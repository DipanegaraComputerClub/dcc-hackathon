var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __moduleCache = /* @__PURE__ */ new WeakMap;
var __toCommonJS = (from) => {
  var entry = __moduleCache.get(from), desc;
  if (entry)
    return entry;
  entry = __defProp({}, "__esModule", { value: true });
  if (from && typeof from === "object" || typeof from === "function")
    __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    }));
  __moduleCache.set(from, entry);
  return entry;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// backend/node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports2, module2) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  var __rewriteRelativeImportExtension;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports3) {
        factory(createExporter(root, createExporter(exports3)));
      });
    } else if (typeof module2 === "object" && typeof module2.exports === "object") {
      factory(createExporter(root, createExporter(module2.exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports3, previous) {
      if (exports3 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports3, "__esModule", { value: true });
        } else {
          exports3.__esModule = true;
        }
      }
      return function(id, v) {
        return exports3[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q2 = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q2.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q2[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q2[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q2.shift(), q2.length)
          resume(q2[0][0], q2[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw2) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw2 });
      } else {
        cooked.raw = raw2;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver2, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver2 !== state || !f : !state.has(receiver2))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver2) : f ? f.value : state.get(receiver2);
    };
    __classPrivateFieldSet = function(receiver2, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver2 !== state || !f : !state.has(receiver2))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver2, value) : f ? f.value = value : state.set(receiver2, value), value;
    };
    __classPrivateFieldIn = function(state, receiver2) {
      if (receiver2 === null || typeof receiver2 !== "object" && typeof receiver2 !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver2 === state : state.has(receiver2);
    };
    __addDisposableResource = function(env, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async });
      } else if (async) {
        env.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env) {
      function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1)
              return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  fail(e);
                  return next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1)
          return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
    __rewriteRelativeImportExtension = function(path, preserveJsx) {
      if (typeof path === "string" && /^\.\.?\//.test(path)) {
        return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
        });
      }
      return path;
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
    exporter("__rewriteRelativeImportExtension", __rewriteRelativeImportExtension);
  });
});

// backend/node_modules/@supabase/functions-js/dist/main/helper.js
var require_helper = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.resolveFetch = undefined;
  var resolveFetch = (customFetch) => {
    if (customFetch) {
      return (...args) => customFetch(...args);
    }
    return (...args) => fetch(...args);
  };
  exports2.resolveFetch = resolveFetch;
});

// backend/node_modules/@supabase/functions-js/dist/main/types.js
var require_types = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.FunctionRegion = exports2.FunctionsHttpError = exports2.FunctionsRelayError = exports2.FunctionsFetchError = exports2.FunctionsError = undefined;

  class FunctionsError extends Error {
    constructor(message, name = "FunctionsError", context) {
      super(message);
      this.name = name;
      this.context = context;
    }
  }
  exports2.FunctionsError = FunctionsError;

  class FunctionsFetchError extends FunctionsError {
    constructor(context) {
      super("Failed to send a request to the Edge Function", "FunctionsFetchError", context);
    }
  }
  exports2.FunctionsFetchError = FunctionsFetchError;

  class FunctionsRelayError extends FunctionsError {
    constructor(context) {
      super("Relay Error invoking the Edge Function", "FunctionsRelayError", context);
    }
  }
  exports2.FunctionsRelayError = FunctionsRelayError;

  class FunctionsHttpError extends FunctionsError {
    constructor(context) {
      super("Edge Function returned a non-2xx status code", "FunctionsHttpError", context);
    }
  }
  exports2.FunctionsHttpError = FunctionsHttpError;
  var FunctionRegion;
  (function(FunctionRegion2) {
    FunctionRegion2["Any"] = "any";
    FunctionRegion2["ApNortheast1"] = "ap-northeast-1";
    FunctionRegion2["ApNortheast2"] = "ap-northeast-2";
    FunctionRegion2["ApSouth1"] = "ap-south-1";
    FunctionRegion2["ApSoutheast1"] = "ap-southeast-1";
    FunctionRegion2["ApSoutheast2"] = "ap-southeast-2";
    FunctionRegion2["CaCentral1"] = "ca-central-1";
    FunctionRegion2["EuCentral1"] = "eu-central-1";
    FunctionRegion2["EuWest1"] = "eu-west-1";
    FunctionRegion2["EuWest2"] = "eu-west-2";
    FunctionRegion2["EuWest3"] = "eu-west-3";
    FunctionRegion2["SaEast1"] = "sa-east-1";
    FunctionRegion2["UsEast1"] = "us-east-1";
    FunctionRegion2["UsWest1"] = "us-west-1";
    FunctionRegion2["UsWest2"] = "us-west-2";
  })(FunctionRegion || (exports2.FunctionRegion = FunctionRegion = {}));
});

// backend/node_modules/@supabase/functions-js/dist/main/FunctionsClient.js
var require_FunctionsClient = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.FunctionsClient = undefined;
  var tslib_1 = require_tslib();
  var helper_1 = require_helper();
  var types_1 = require_types();

  class FunctionsClient {
    constructor(url, { headers = {}, customFetch, region = types_1.FunctionRegion.Any } = {}) {
      this.url = url;
      this.headers = headers;
      this.region = region;
      this.fetch = (0, helper_1.resolveFetch)(customFetch);
    }
    setAuth(token) {
      this.headers.Authorization = `Bearer ${token}`;
    }
    invoke(functionName_1) {
      return tslib_1.__awaiter(this, arguments, undefined, function* (functionName, options = {}) {
        var _a;
        let timeoutId;
        let timeoutController;
        try {
          const { headers, method, body: functionArgs, signal, timeout } = options;
          let _headers = {};
          let { region } = options;
          if (!region) {
            region = this.region;
          }
          const url = new URL(`${this.url}/${functionName}`);
          if (region && region !== "any") {
            _headers["x-region"] = region;
            url.searchParams.set("forceFunctionRegion", region);
          }
          let body;
          if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, "Content-Type") || !headers)) {
            if (typeof Blob !== "undefined" && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {
              _headers["Content-Type"] = "application/octet-stream";
              body = functionArgs;
            } else if (typeof functionArgs === "string") {
              _headers["Content-Type"] = "text/plain";
              body = functionArgs;
            } else if (typeof FormData !== "undefined" && functionArgs instanceof FormData) {
              body = functionArgs;
            } else {
              _headers["Content-Type"] = "application/json";
              body = JSON.stringify(functionArgs);
            }
          } else {
            body = functionArgs;
          }
          let effectiveSignal = signal;
          if (timeout) {
            timeoutController = new AbortController;
            timeoutId = setTimeout(() => timeoutController.abort(), timeout);
            if (signal) {
              effectiveSignal = timeoutController.signal;
              signal.addEventListener("abort", () => timeoutController.abort());
            } else {
              effectiveSignal = timeoutController.signal;
            }
          }
          const response = yield this.fetch(url.toString(), {
            method: method || "POST",
            headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),
            body,
            signal: effectiveSignal
          }).catch((fetchError) => {
            throw new types_1.FunctionsFetchError(fetchError);
          });
          const isRelayError = response.headers.get("x-relay-error");
          if (isRelayError && isRelayError === "true") {
            throw new types_1.FunctionsRelayError(response);
          }
          if (!response.ok) {
            throw new types_1.FunctionsHttpError(response);
          }
          let responseType = ((_a = response.headers.get("Content-Type")) !== null && _a !== undefined ? _a : "text/plain").split(";")[0].trim();
          let data;
          if (responseType === "application/json") {
            data = yield response.json();
          } else if (responseType === "application/octet-stream" || responseType === "application/pdf") {
            data = yield response.blob();
          } else if (responseType === "text/event-stream") {
            data = response;
          } else if (responseType === "multipart/form-data") {
            data = yield response.formData();
          } else {
            data = yield response.text();
          }
          return { data, error: null, response };
        } catch (error) {
          return {
            data: null,
            error,
            response: error instanceof types_1.FunctionsHttpError || error instanceof types_1.FunctionsRelayError ? error.context : undefined
          };
        } finally {
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
        }
      });
    }
  }
  exports2.FunctionsClient = FunctionsClient;
});

// backend/node_modules/@supabase/functions-js/dist/main/index.js
var require_main = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.FunctionRegion = exports2.FunctionsRelayError = exports2.FunctionsHttpError = exports2.FunctionsFetchError = exports2.FunctionsError = exports2.FunctionsClient = undefined;
  var FunctionsClient_1 = require_FunctionsClient();
  Object.defineProperty(exports2, "FunctionsClient", { enumerable: true, get: function() {
    return FunctionsClient_1.FunctionsClient;
  } });
  var types_1 = require_types();
  Object.defineProperty(exports2, "FunctionsError", { enumerable: true, get: function() {
    return types_1.FunctionsError;
  } });
  Object.defineProperty(exports2, "FunctionsFetchError", { enumerable: true, get: function() {
    return types_1.FunctionsFetchError;
  } });
  Object.defineProperty(exports2, "FunctionsHttpError", { enumerable: true, get: function() {
    return types_1.FunctionsHttpError;
  } });
  Object.defineProperty(exports2, "FunctionsRelayError", { enumerable: true, get: function() {
    return types_1.FunctionsRelayError;
  } });
  Object.defineProperty(exports2, "FunctionRegion", { enumerable: true, get: function() {
    return types_1.FunctionRegion;
  } });
});

// backend/node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js
var require_PostgrestError = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });

  class PostgrestError extends Error {
    constructor(context) {
      super(context.message);
      this.name = "PostgrestError";
      this.details = context.details;
      this.hint = context.hint;
      this.code = context.code;
    }
  }
  exports2.default = PostgrestError;
});

// backend/node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js
var require_PostgrestBuilder = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  var PostgrestError_1 = tslib_1.__importDefault(require_PostgrestError());

  class PostgrestBuilder {
    constructor(builder) {
      var _a, _b;
      this.shouldThrowOnError = false;
      this.method = builder.method;
      this.url = builder.url;
      this.headers = new Headers(builder.headers);
      this.schema = builder.schema;
      this.body = builder.body;
      this.shouldThrowOnError = (_a = builder.shouldThrowOnError) !== null && _a !== undefined ? _a : false;
      this.signal = builder.signal;
      this.isMaybeSingle = (_b = builder.isMaybeSingle) !== null && _b !== undefined ? _b : false;
      if (builder.fetch) {
        this.fetch = builder.fetch;
      } else {
        this.fetch = fetch;
      }
    }
    throwOnError() {
      this.shouldThrowOnError = true;
      return this;
    }
    setHeader(name, value) {
      this.headers = new Headers(this.headers);
      this.headers.set(name, value);
      return this;
    }
    then(onfulfilled, onrejected) {
      if (this.schema === undefined) {} else if (["GET", "HEAD"].includes(this.method)) {
        this.headers.set("Accept-Profile", this.schema);
      } else {
        this.headers.set("Content-Profile", this.schema);
      }
      if (this.method !== "GET" && this.method !== "HEAD") {
        this.headers.set("Content-Type", "application/json");
      }
      const _fetch = this.fetch;
      let res = _fetch(this.url.toString(), {
        method: this.method,
        headers: this.headers,
        body: JSON.stringify(this.body),
        signal: this.signal
      }).then(async (res2) => {
        var _a, _b, _c, _d;
        let error = null;
        let data = null;
        let count = null;
        let status = res2.status;
        let statusText = res2.statusText;
        if (res2.ok) {
          if (this.method !== "HEAD") {
            const body = await res2.text();
            if (body === "") {} else if (this.headers.get("Accept") === "text/csv") {
              data = body;
            } else if (this.headers.get("Accept") && ((_a = this.headers.get("Accept")) === null || _a === undefined ? undefined : _a.includes("application/vnd.pgrst.plan+text"))) {
              data = body;
            } else {
              data = JSON.parse(body);
            }
          }
          const countHeader = (_b = this.headers.get("Prefer")) === null || _b === undefined ? undefined : _b.match(/count=(exact|planned|estimated)/);
          const contentRange = (_c = res2.headers.get("content-range")) === null || _c === undefined ? undefined : _c.split("/");
          if (countHeader && contentRange && contentRange.length > 1) {
            count = parseInt(contentRange[1]);
          }
          if (this.isMaybeSingle && this.method === "GET" && Array.isArray(data)) {
            if (data.length > 1) {
              error = {
                code: "PGRST116",
                details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,
                hint: null,
                message: "JSON object requested, multiple (or no) rows returned"
              };
              data = null;
              count = null;
              status = 406;
              statusText = "Not Acceptable";
            } else if (data.length === 1) {
              data = data[0];
            } else {
              data = null;
            }
          }
        } else {
          const body = await res2.text();
          try {
            error = JSON.parse(body);
            if (Array.isArray(error) && res2.status === 404) {
              data = [];
              error = null;
              status = 200;
              statusText = "OK";
            }
          } catch (_e) {
            if (res2.status === 404 && body === "") {
              status = 204;
              statusText = "No Content";
            } else {
              error = {
                message: body
              };
            }
          }
          if (error && this.isMaybeSingle && ((_d = error === null || error === undefined ? undefined : error.details) === null || _d === undefined ? undefined : _d.includes("0 rows"))) {
            error = null;
            status = 200;
            statusText = "OK";
          }
          if (error && this.shouldThrowOnError) {
            throw new PostgrestError_1.default(error);
          }
        }
        const postgrestResponse = {
          error,
          data,
          count,
          status,
          statusText
        };
        return postgrestResponse;
      });
      if (!this.shouldThrowOnError) {
        res = res.catch((fetchError) => {
          var _a, _b, _c, _d, _e, _f;
          let errorDetails = "";
          const cause = fetchError === null || fetchError === undefined ? undefined : fetchError.cause;
          if (cause) {
            const causeMessage = (_a = cause === null || cause === undefined ? undefined : cause.message) !== null && _a !== undefined ? _a : "";
            const causeCode = (_b = cause === null || cause === undefined ? undefined : cause.code) !== null && _b !== undefined ? _b : "";
            errorDetails = `${(_c = fetchError === null || fetchError === undefined ? undefined : fetchError.name) !== null && _c !== undefined ? _c : "FetchError"}: ${fetchError === null || fetchError === undefined ? undefined : fetchError.message}`;
            errorDetails += `

Caused by: ${(_d = cause === null || cause === undefined ? undefined : cause.name) !== null && _d !== undefined ? _d : "Error"}: ${causeMessage}`;
            if (causeCode) {
              errorDetails += ` (${causeCode})`;
            }
            if (cause === null || cause === undefined ? undefined : cause.stack) {
              errorDetails += `
${cause.stack}`;
            }
          } else {
            errorDetails = (_e = fetchError === null || fetchError === undefined ? undefined : fetchError.stack) !== null && _e !== undefined ? _e : "";
          }
          return {
            error: {
              message: `${(_f = fetchError === null || fetchError === undefined ? undefined : fetchError.name) !== null && _f !== undefined ? _f : "FetchError"}: ${fetchError === null || fetchError === undefined ? undefined : fetchError.message}`,
              details: errorDetails,
              hint: "",
              code: ""
            },
            data: null,
            count: null,
            status: 0,
            statusText: ""
          };
        });
      }
      return res.then(onfulfilled, onrejected);
    }
    returns() {
      return this;
    }
    overrideTypes() {
      return this;
    }
  }
  exports2.default = PostgrestBuilder;
});

// backend/node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js
var require_PostgrestTransformBuilder = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  var PostgrestBuilder_1 = tslib_1.__importDefault(require_PostgrestBuilder());

  class PostgrestTransformBuilder extends PostgrestBuilder_1.default {
    select(columns) {
      let quoted = false;
      const cleanedColumns = (columns !== null && columns !== undefined ? columns : "*").split("").map((c) => {
        if (/\s/.test(c) && !quoted) {
          return "";
        }
        if (c === '"') {
          quoted = !quoted;
        }
        return c;
      }).join("");
      this.url.searchParams.set("select", cleanedColumns);
      this.headers.append("Prefer", "return=representation");
      return this;
    }
    order(column, { ascending = true, nullsFirst, foreignTable, referencedTable = foreignTable } = {}) {
      const key = referencedTable ? `${referencedTable}.order` : "order";
      const existingOrder = this.url.searchParams.get(key);
      this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : ""}${column}.${ascending ? "asc" : "desc"}${nullsFirst === undefined ? "" : nullsFirst ? ".nullsfirst" : ".nullslast"}`);
      return this;
    }
    limit(count, { foreignTable, referencedTable = foreignTable } = {}) {
      const key = typeof referencedTable === "undefined" ? "limit" : `${referencedTable}.limit`;
      this.url.searchParams.set(key, `${count}`);
      return this;
    }
    range(from, to, { foreignTable, referencedTable = foreignTable } = {}) {
      const keyOffset = typeof referencedTable === "undefined" ? "offset" : `${referencedTable}.offset`;
      const keyLimit = typeof referencedTable === "undefined" ? "limit" : `${referencedTable}.limit`;
      this.url.searchParams.set(keyOffset, `${from}`);
      this.url.searchParams.set(keyLimit, `${to - from + 1}`);
      return this;
    }
    abortSignal(signal) {
      this.signal = signal;
      return this;
    }
    single() {
      this.headers.set("Accept", "application/vnd.pgrst.object+json");
      return this;
    }
    maybeSingle() {
      if (this.method === "GET") {
        this.headers.set("Accept", "application/json");
      } else {
        this.headers.set("Accept", "application/vnd.pgrst.object+json");
      }
      this.isMaybeSingle = true;
      return this;
    }
    csv() {
      this.headers.set("Accept", "text/csv");
      return this;
    }
    geojson() {
      this.headers.set("Accept", "application/geo+json");
      return this;
    }
    explain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = "text" } = {}) {
      var _a;
      const options = [
        analyze ? "analyze" : null,
        verbose ? "verbose" : null,
        settings ? "settings" : null,
        buffers ? "buffers" : null,
        wal ? "wal" : null
      ].filter(Boolean).join("|");
      const forMediatype = (_a = this.headers.get("Accept")) !== null && _a !== undefined ? _a : "application/json";
      this.headers.set("Accept", `application/vnd.pgrst.plan+${format}; for="${forMediatype}"; options=${options};`);
      if (format === "json") {
        return this;
      } else {
        return this;
      }
    }
    rollback() {
      this.headers.append("Prefer", "tx=rollback");
      return this;
    }
    returns() {
      return this;
    }
    maxAffected(value) {
      this.headers.append("Prefer", "handling=strict");
      this.headers.append("Prefer", `max-affected=${value}`);
      return this;
    }
  }
  exports2.default = PostgrestTransformBuilder;
});

// backend/node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js
var require_PostgrestFilterBuilder = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  var PostgrestTransformBuilder_1 = tslib_1.__importDefault(require_PostgrestTransformBuilder());
  var PostgrestReservedCharsRegexp = new RegExp("[,()]");

  class PostgrestFilterBuilder extends PostgrestTransformBuilder_1.default {
    eq(column, value) {
      this.url.searchParams.append(column, `eq.${value}`);
      return this;
    }
    neq(column, value) {
      this.url.searchParams.append(column, `neq.${value}`);
      return this;
    }
    gt(column, value) {
      this.url.searchParams.append(column, `gt.${value}`);
      return this;
    }
    gte(column, value) {
      this.url.searchParams.append(column, `gte.${value}`);
      return this;
    }
    lt(column, value) {
      this.url.searchParams.append(column, `lt.${value}`);
      return this;
    }
    lte(column, value) {
      this.url.searchParams.append(column, `lte.${value}`);
      return this;
    }
    like(column, pattern) {
      this.url.searchParams.append(column, `like.${pattern}`);
      return this;
    }
    likeAllOf(column, patterns) {
      this.url.searchParams.append(column, `like(all).{${patterns.join(",")}}`);
      return this;
    }
    likeAnyOf(column, patterns) {
      this.url.searchParams.append(column, `like(any).{${patterns.join(",")}}`);
      return this;
    }
    ilike(column, pattern) {
      this.url.searchParams.append(column, `ilike.${pattern}`);
      return this;
    }
    ilikeAllOf(column, patterns) {
      this.url.searchParams.append(column, `ilike(all).{${patterns.join(",")}}`);
      return this;
    }
    ilikeAnyOf(column, patterns) {
      this.url.searchParams.append(column, `ilike(any).{${patterns.join(",")}}`);
      return this;
    }
    regexMatch(column, pattern) {
      this.url.searchParams.append(column, `match.${pattern}`);
      return this;
    }
    regexIMatch(column, pattern) {
      this.url.searchParams.append(column, `imatch.${pattern}`);
      return this;
    }
    is(column, value) {
      this.url.searchParams.append(column, `is.${value}`);
      return this;
    }
    isDistinct(column, value) {
      this.url.searchParams.append(column, `isdistinct.${value}`);
      return this;
    }
    in(column, values) {
      const cleanedValues = Array.from(new Set(values)).map((s) => {
        if (typeof s === "string" && PostgrestReservedCharsRegexp.test(s))
          return `"${s}"`;
        else
          return `${s}`;
      }).join(",");
      this.url.searchParams.append(column, `in.(${cleanedValues})`);
      return this;
    }
    contains(column, value) {
      if (typeof value === "string") {
        this.url.searchParams.append(column, `cs.${value}`);
      } else if (Array.isArray(value)) {
        this.url.searchParams.append(column, `cs.{${value.join(",")}}`);
      } else {
        this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);
      }
      return this;
    }
    containedBy(column, value) {
      if (typeof value === "string") {
        this.url.searchParams.append(column, `cd.${value}`);
      } else if (Array.isArray(value)) {
        this.url.searchParams.append(column, `cd.{${value.join(",")}}`);
      } else {
        this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);
      }
      return this;
    }
    rangeGt(column, range) {
      this.url.searchParams.append(column, `sr.${range}`);
      return this;
    }
    rangeGte(column, range) {
      this.url.searchParams.append(column, `nxl.${range}`);
      return this;
    }
    rangeLt(column, range) {
      this.url.searchParams.append(column, `sl.${range}`);
      return this;
    }
    rangeLte(column, range) {
      this.url.searchParams.append(column, `nxr.${range}`);
      return this;
    }
    rangeAdjacent(column, range) {
      this.url.searchParams.append(column, `adj.${range}`);
      return this;
    }
    overlaps(column, value) {
      if (typeof value === "string") {
        this.url.searchParams.append(column, `ov.${value}`);
      } else {
        this.url.searchParams.append(column, `ov.{${value.join(",")}}`);
      }
      return this;
    }
    textSearch(column, query, { config, type } = {}) {
      let typePart = "";
      if (type === "plain") {
        typePart = "pl";
      } else if (type === "phrase") {
        typePart = "ph";
      } else if (type === "websearch") {
        typePart = "w";
      }
      const configPart = config === undefined ? "" : `(${config})`;
      this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);
      return this;
    }
    match(query) {
      Object.entries(query).forEach(([column, value]) => {
        this.url.searchParams.append(column, `eq.${value}`);
      });
      return this;
    }
    not(column, operator, value) {
      this.url.searchParams.append(column, `not.${operator}.${value}`);
      return this;
    }
    or(filters, { foreignTable, referencedTable = foreignTable } = {}) {
      const key = referencedTable ? `${referencedTable}.or` : "or";
      this.url.searchParams.append(key, `(${filters})`);
      return this;
    }
    filter(column, operator, value) {
      this.url.searchParams.append(column, `${operator}.${value}`);
      return this;
    }
  }
  exports2.default = PostgrestFilterBuilder;
});

// backend/node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js
var require_PostgrestQueryBuilder = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  var PostgrestFilterBuilder_1 = tslib_1.__importDefault(require_PostgrestFilterBuilder());

  class PostgrestQueryBuilder {
    constructor(url, { headers = {}, schema, fetch: fetch2 }) {
      this.url = url;
      this.headers = new Headers(headers);
      this.schema = schema;
      this.fetch = fetch2;
    }
    select(columns, options) {
      const { head = false, count } = options !== null && options !== undefined ? options : {};
      const method = head ? "HEAD" : "GET";
      let quoted = false;
      const cleanedColumns = (columns !== null && columns !== undefined ? columns : "*").split("").map((c) => {
        if (/\s/.test(c) && !quoted) {
          return "";
        }
        if (c === '"') {
          quoted = !quoted;
        }
        return c;
      }).join("");
      this.url.searchParams.set("select", cleanedColumns);
      if (count) {
        this.headers.append("Prefer", `count=${count}`);
      }
      return new PostgrestFilterBuilder_1.default({
        method,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        fetch: this.fetch
      });
    }
    insert(values, { count, defaultToNull = true } = {}) {
      var _a;
      const method = "POST";
      if (count) {
        this.headers.append("Prefer", `count=${count}`);
      }
      if (!defaultToNull) {
        this.headers.append("Prefer", `missing=default`);
      }
      if (Array.isArray(values)) {
        const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);
        if (columns.length > 0) {
          const uniqueColumns = [...new Set(columns)].map((column) => `"${column}"`);
          this.url.searchParams.set("columns", uniqueColumns.join(","));
        }
      }
      return new PostgrestFilterBuilder_1.default({
        method,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        body: values,
        fetch: (_a = this.fetch) !== null && _a !== undefined ? _a : fetch
      });
    }
    upsert(values, { onConflict, ignoreDuplicates = false, count, defaultToNull = true } = {}) {
      var _a;
      const method = "POST";
      this.headers.append("Prefer", `resolution=${ignoreDuplicates ? "ignore" : "merge"}-duplicates`);
      if (onConflict !== undefined)
        this.url.searchParams.set("on_conflict", onConflict);
      if (count) {
        this.headers.append("Prefer", `count=${count}`);
      }
      if (!defaultToNull) {
        this.headers.append("Prefer", "missing=default");
      }
      if (Array.isArray(values)) {
        const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);
        if (columns.length > 0) {
          const uniqueColumns = [...new Set(columns)].map((column) => `"${column}"`);
          this.url.searchParams.set("columns", uniqueColumns.join(","));
        }
      }
      return new PostgrestFilterBuilder_1.default({
        method,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        body: values,
        fetch: (_a = this.fetch) !== null && _a !== undefined ? _a : fetch
      });
    }
    update(values, { count } = {}) {
      var _a;
      const method = "PATCH";
      if (count) {
        this.headers.append("Prefer", `count=${count}`);
      }
      return new PostgrestFilterBuilder_1.default({
        method,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        body: values,
        fetch: (_a = this.fetch) !== null && _a !== undefined ? _a : fetch
      });
    }
    delete({ count } = {}) {
      var _a;
      const method = "DELETE";
      if (count) {
        this.headers.append("Prefer", `count=${count}`);
      }
      return new PostgrestFilterBuilder_1.default({
        method,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        fetch: (_a = this.fetch) !== null && _a !== undefined ? _a : fetch
      });
    }
  }
  exports2.default = PostgrestQueryBuilder;
});

// backend/node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js
var require_PostgrestClient = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  var PostgrestQueryBuilder_1 = tslib_1.__importDefault(require_PostgrestQueryBuilder());
  var PostgrestFilterBuilder_1 = tslib_1.__importDefault(require_PostgrestFilterBuilder());

  class PostgrestClient {
    constructor(url, { headers = {}, schema, fetch: fetch2 } = {}) {
      this.url = url;
      this.headers = new Headers(headers);
      this.schemaName = schema;
      this.fetch = fetch2;
    }
    from(relation) {
      if (!relation || typeof relation !== "string" || relation.trim() === "") {
        throw new Error("Invalid relation name: relation must be a non-empty string.");
      }
      const url = new URL(`${this.url}/${relation}`);
      return new PostgrestQueryBuilder_1.default(url, {
        headers: new Headers(this.headers),
        schema: this.schemaName,
        fetch: this.fetch
      });
    }
    schema(schema) {
      return new PostgrestClient(this.url, {
        headers: this.headers,
        schema,
        fetch: this.fetch
      });
    }
    rpc(fn, args = {}, { head = false, get = false, count } = {}) {
      var _a;
      let method;
      const url = new URL(`${this.url}/rpc/${fn}`);
      let body;
      if (head || get) {
        method = head ? "HEAD" : "GET";
        Object.entries(args).filter(([_, value]) => value !== undefined).map(([name, value]) => [name, Array.isArray(value) ? `{${value.join(",")}}` : `${value}`]).forEach(([name, value]) => {
          url.searchParams.append(name, value);
        });
      } else {
        method = "POST";
        body = args;
      }
      const headers = new Headers(this.headers);
      if (count) {
        headers.set("Prefer", `count=${count}`);
      }
      return new PostgrestFilterBuilder_1.default({
        method,
        url,
        headers,
        schema: this.schemaName,
        body,
        fetch: (_a = this.fetch) !== null && _a !== undefined ? _a : fetch
      });
    }
  }
  exports2.default = PostgrestClient;
});

// backend/node_modules/@supabase/postgrest-js/dist/cjs/index.js
var require_cjs = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.PostgrestError = exports2.PostgrestBuilder = exports2.PostgrestTransformBuilder = exports2.PostgrestFilterBuilder = exports2.PostgrestQueryBuilder = exports2.PostgrestClient = undefined;
  var tslib_1 = require_tslib();
  var PostgrestClient_1 = tslib_1.__importDefault(require_PostgrestClient());
  exports2.PostgrestClient = PostgrestClient_1.default;
  var PostgrestQueryBuilder_1 = tslib_1.__importDefault(require_PostgrestQueryBuilder());
  exports2.PostgrestQueryBuilder = PostgrestQueryBuilder_1.default;
  var PostgrestFilterBuilder_1 = tslib_1.__importDefault(require_PostgrestFilterBuilder());
  exports2.PostgrestFilterBuilder = PostgrestFilterBuilder_1.default;
  var PostgrestTransformBuilder_1 = tslib_1.__importDefault(require_PostgrestTransformBuilder());
  exports2.PostgrestTransformBuilder = PostgrestTransformBuilder_1.default;
  var PostgrestBuilder_1 = tslib_1.__importDefault(require_PostgrestBuilder());
  exports2.PostgrestBuilder = PostgrestBuilder_1.default;
  var PostgrestError_1 = tslib_1.__importDefault(require_PostgrestError());
  exports2.PostgrestError = PostgrestError_1.default;
  exports2.default = {
    PostgrestClient: PostgrestClient_1.default,
    PostgrestQueryBuilder: PostgrestQueryBuilder_1.default,
    PostgrestFilterBuilder: PostgrestFilterBuilder_1.default,
    PostgrestTransformBuilder: PostgrestTransformBuilder_1.default,
    PostgrestBuilder: PostgrestBuilder_1.default,
    PostgrestError: PostgrestError_1.default
  };
});

// backend/node_modules/@supabase/realtime-js/dist/main/lib/websocket-factory.js
var require_websocket_factory = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.WebSocketFactory = undefined;

  class WebSocketFactory {
    constructor() {}
    static detectEnvironment() {
      var _a;
      if (typeof WebSocket !== "undefined") {
        return { type: "native", constructor: WebSocket };
      }
      if (typeof globalThis !== "undefined" && typeof globalThis.WebSocket !== "undefined") {
        return { type: "native", constructor: globalThis.WebSocket };
      }
      if (typeof global !== "undefined" && typeof global.WebSocket !== "undefined") {
        return { type: "native", constructor: global.WebSocket };
      }
      if (typeof globalThis !== "undefined" && typeof globalThis.WebSocketPair !== "undefined" && typeof globalThis.WebSocket === "undefined") {
        return {
          type: "cloudflare",
          error: "Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",
          workaround: "Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime."
        };
      }
      if (typeof globalThis !== "undefined" && globalThis.EdgeRuntime || typeof navigator !== "undefined" && ((_a = navigator.userAgent) === null || _a === undefined ? undefined : _a.includes("Vercel-Edge"))) {
        return {
          type: "unsupported",
          error: "Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",
          workaround: "Use serverless functions or a different deployment target for WebSocket functionality."
        };
      }
      if (typeof process !== "undefined") {
        const processVersions = process["versions"];
        if (processVersions && processVersions["node"]) {
          const versionString = processVersions["node"];
          const nodeVersion = parseInt(versionString.replace(/^v/, "").split(".")[0]);
          if (nodeVersion >= 22) {
            if (typeof globalThis.WebSocket !== "undefined") {
              return { type: "native", constructor: globalThis.WebSocket };
            }
            return {
              type: "unsupported",
              error: `Node.js ${nodeVersion} detected but native WebSocket not found.`,
              workaround: "Provide a WebSocket implementation via the transport option."
            };
          }
          return {
            type: "unsupported",
            error: `Node.js ${nodeVersion} detected without native WebSocket support.`,
            workaround: `For Node.js < 22, install "ws" package and provide it via the transport option:
` + `import ws from "ws"
` + "new RealtimeClient(url, { transport: ws })"
          };
        }
      }
      return {
        type: "unsupported",
        error: "Unknown JavaScript runtime without WebSocket support.",
        workaround: "Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."
      };
    }
    static getWebSocketConstructor() {
      const env = this.detectEnvironment();
      if (env.constructor) {
        return env.constructor;
      }
      let errorMessage = env.error || "WebSocket not supported in this environment.";
      if (env.workaround) {
        errorMessage += `

Suggested solution: ${env.workaround}`;
      }
      throw new Error(errorMessage);
    }
    static createWebSocket(url, protocols) {
      const WS = this.getWebSocketConstructor();
      return new WS(url, protocols);
    }
    static isWebSocketSupported() {
      try {
        const env = this.detectEnvironment();
        return env.type === "native" || env.type === "ws";
      } catch (_a) {
        return false;
      }
    }
  }
  exports2.WebSocketFactory = WebSocketFactory;
  exports2.default = WebSocketFactory;
});

// backend/node_modules/@supabase/realtime-js/dist/main/lib/version.js
var require_version = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.version = undefined;
  exports2.version = "2.86.0";
});

// backend/node_modules/@supabase/realtime-js/dist/main/lib/constants.js
var require_constants = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.CONNECTION_STATE = exports2.TRANSPORTS = exports2.CHANNEL_EVENTS = exports2.CHANNEL_STATES = exports2.SOCKET_STATES = exports2.MAX_PUSH_BUFFER_SIZE = exports2.WS_CLOSE_NORMAL = exports2.DEFAULT_TIMEOUT = exports2.VERSION = exports2.DEFAULT_VSN = exports2.VSN_2_0_0 = exports2.VSN_1_0_0 = exports2.DEFAULT_VERSION = undefined;
  var version_1 = require_version();
  exports2.DEFAULT_VERSION = `realtime-js/${version_1.version}`;
  exports2.VSN_1_0_0 = "1.0.0";
  exports2.VSN_2_0_0 = "2.0.0";
  exports2.DEFAULT_VSN = exports2.VSN_1_0_0;
  exports2.VERSION = version_1.version;
  exports2.DEFAULT_TIMEOUT = 1e4;
  exports2.WS_CLOSE_NORMAL = 1000;
  exports2.MAX_PUSH_BUFFER_SIZE = 100;
  var SOCKET_STATES;
  (function(SOCKET_STATES2) {
    SOCKET_STATES2[SOCKET_STATES2["connecting"] = 0] = "connecting";
    SOCKET_STATES2[SOCKET_STATES2["open"] = 1] = "open";
    SOCKET_STATES2[SOCKET_STATES2["closing"] = 2] = "closing";
    SOCKET_STATES2[SOCKET_STATES2["closed"] = 3] = "closed";
  })(SOCKET_STATES || (exports2.SOCKET_STATES = SOCKET_STATES = {}));
  var CHANNEL_STATES;
  (function(CHANNEL_STATES2) {
    CHANNEL_STATES2["closed"] = "closed";
    CHANNEL_STATES2["errored"] = "errored";
    CHANNEL_STATES2["joined"] = "joined";
    CHANNEL_STATES2["joining"] = "joining";
    CHANNEL_STATES2["leaving"] = "leaving";
  })(CHANNEL_STATES || (exports2.CHANNEL_STATES = CHANNEL_STATES = {}));
  var CHANNEL_EVENTS;
  (function(CHANNEL_EVENTS2) {
    CHANNEL_EVENTS2["close"] = "phx_close";
    CHANNEL_EVENTS2["error"] = "phx_error";
    CHANNEL_EVENTS2["join"] = "phx_join";
    CHANNEL_EVENTS2["reply"] = "phx_reply";
    CHANNEL_EVENTS2["leave"] = "phx_leave";
    CHANNEL_EVENTS2["access_token"] = "access_token";
  })(CHANNEL_EVENTS || (exports2.CHANNEL_EVENTS = CHANNEL_EVENTS = {}));
  var TRANSPORTS;
  (function(TRANSPORTS2) {
    TRANSPORTS2["websocket"] = "websocket";
  })(TRANSPORTS || (exports2.TRANSPORTS = TRANSPORTS = {}));
  var CONNECTION_STATE;
  (function(CONNECTION_STATE2) {
    CONNECTION_STATE2["Connecting"] = "connecting";
    CONNECTION_STATE2["Open"] = "open";
    CONNECTION_STATE2["Closing"] = "closing";
    CONNECTION_STATE2["Closed"] = "closed";
  })(CONNECTION_STATE || (exports2.CONNECTION_STATE = CONNECTION_STATE = {}));
});

// backend/node_modules/@supabase/realtime-js/dist/main/lib/serializer.js
var require_serializer = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });

  class Serializer {
    constructor(allowedMetadataKeys) {
      this.HEADER_LENGTH = 1;
      this.USER_BROADCAST_PUSH_META_LENGTH = 6;
      this.KINDS = { userBroadcastPush: 3, userBroadcast: 4 };
      this.BINARY_ENCODING = 0;
      this.JSON_ENCODING = 1;
      this.BROADCAST_EVENT = "broadcast";
      this.allowedMetadataKeys = [];
      this.allowedMetadataKeys = allowedMetadataKeys !== null && allowedMetadataKeys !== undefined ? allowedMetadataKeys : [];
    }
    encode(msg, callback) {
      if (msg.event === this.BROADCAST_EVENT && !(msg.payload instanceof ArrayBuffer) && typeof msg.payload.event === "string") {
        return callback(this._binaryEncodeUserBroadcastPush(msg));
      }
      let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];
      return callback(JSON.stringify(payload));
    }
    _binaryEncodeUserBroadcastPush(message) {
      var _a;
      if (this._isArrayBuffer((_a = message.payload) === null || _a === undefined ? undefined : _a.payload)) {
        return this._encodeBinaryUserBroadcastPush(message);
      } else {
        return this._encodeJsonUserBroadcastPush(message);
      }
    }
    _encodeBinaryUserBroadcastPush(message) {
      var _a, _b;
      const userPayload = (_b = (_a = message.payload) === null || _a === undefined ? undefined : _a.payload) !== null && _b !== undefined ? _b : new ArrayBuffer(0);
      return this._encodeUserBroadcastPush(message, this.BINARY_ENCODING, userPayload);
    }
    _encodeJsonUserBroadcastPush(message) {
      var _a, _b;
      const userPayload = (_b = (_a = message.payload) === null || _a === undefined ? undefined : _a.payload) !== null && _b !== undefined ? _b : {};
      const encoder = new TextEncoder;
      const encodedUserPayload = encoder.encode(JSON.stringify(userPayload)).buffer;
      return this._encodeUserBroadcastPush(message, this.JSON_ENCODING, encodedUserPayload);
    }
    _encodeUserBroadcastPush(message, encodingType, encodedPayload) {
      var _a, _b;
      const topic = message.topic;
      const ref = (_a = message.ref) !== null && _a !== undefined ? _a : "";
      const joinRef = (_b = message.join_ref) !== null && _b !== undefined ? _b : "";
      const userEvent = message.payload.event;
      const rest = this.allowedMetadataKeys ? this._pick(message.payload, this.allowedMetadataKeys) : {};
      const metadata = Object.keys(rest).length === 0 ? "" : JSON.stringify(rest);
      if (joinRef.length > 255) {
        throw new Error(`joinRef length ${joinRef.length} exceeds maximum of 255`);
      }
      if (ref.length > 255) {
        throw new Error(`ref length ${ref.length} exceeds maximum of 255`);
      }
      if (topic.length > 255) {
        throw new Error(`topic length ${topic.length} exceeds maximum of 255`);
      }
      if (userEvent.length > 255) {
        throw new Error(`userEvent length ${userEvent.length} exceeds maximum of 255`);
      }
      if (metadata.length > 255) {
        throw new Error(`metadata length ${metadata.length} exceeds maximum of 255`);
      }
      const metaLength = this.USER_BROADCAST_PUSH_META_LENGTH + joinRef.length + ref.length + topic.length + userEvent.length + metadata.length;
      const header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);
      let view = new DataView(header);
      let offset = 0;
      view.setUint8(offset++, this.KINDS.userBroadcastPush);
      view.setUint8(offset++, joinRef.length);
      view.setUint8(offset++, ref.length);
      view.setUint8(offset++, topic.length);
      view.setUint8(offset++, userEvent.length);
      view.setUint8(offset++, metadata.length);
      view.setUint8(offset++, encodingType);
      Array.from(joinRef, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(userEvent, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(metadata, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      var combined = new Uint8Array(header.byteLength + encodedPayload.byteLength);
      combined.set(new Uint8Array(header), 0);
      combined.set(new Uint8Array(encodedPayload), header.byteLength);
      return combined.buffer;
    }
    decode(rawPayload, callback) {
      if (this._isArrayBuffer(rawPayload)) {
        let result = this._binaryDecode(rawPayload);
        return callback(result);
      }
      if (typeof rawPayload === "string") {
        const jsonPayload = JSON.parse(rawPayload);
        const [join_ref, ref, topic, event, payload] = jsonPayload;
        return callback({ join_ref, ref, topic, event, payload });
      }
      return callback({});
    }
    _binaryDecode(buffer) {
      const view = new DataView(buffer);
      const kind = view.getUint8(0);
      const decoder = new TextDecoder;
      switch (kind) {
        case this.KINDS.userBroadcast:
          return this._decodeUserBroadcast(buffer, view, decoder);
      }
    }
    _decodeUserBroadcast(buffer, view, decoder) {
      const topicSize = view.getUint8(1);
      const userEventSize = view.getUint8(2);
      const metadataSize = view.getUint8(3);
      const payloadEncoding = view.getUint8(4);
      let offset = this.HEADER_LENGTH + 4;
      const topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      const userEvent = decoder.decode(buffer.slice(offset, offset + userEventSize));
      offset = offset + userEventSize;
      const metadata = decoder.decode(buffer.slice(offset, offset + metadataSize));
      offset = offset + metadataSize;
      const payload = buffer.slice(offset, buffer.byteLength);
      const parsedPayload = payloadEncoding === this.JSON_ENCODING ? JSON.parse(decoder.decode(payload)) : payload;
      const data = {
        type: this.BROADCAST_EVENT,
        event: userEvent,
        payload: parsedPayload
      };
      if (metadataSize > 0) {
        data["meta"] = JSON.parse(metadata);
      }
      return { join_ref: null, ref: null, topic, event: this.BROADCAST_EVENT, payload: data };
    }
    _isArrayBuffer(buffer) {
      var _a;
      return buffer instanceof ArrayBuffer || ((_a = buffer === null || buffer === undefined ? undefined : buffer.constructor) === null || _a === undefined ? undefined : _a.name) === "ArrayBuffer";
    }
    _pick(obj2, keys) {
      if (!obj2 || typeof obj2 !== "object") {
        return {};
      }
      return Object.fromEntries(Object.entries(obj2).filter(([key]) => keys.includes(key)));
    }
  }
  exports2.default = Serializer;
});

// backend/node_modules/@supabase/realtime-js/dist/main/lib/timer.js
var require_timer = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });

  class Timer {
    constructor(callback, timerCalc) {
      this.callback = callback;
      this.timerCalc = timerCalc;
      this.timer = undefined;
      this.tries = 0;
      this.callback = callback;
      this.timerCalc = timerCalc;
    }
    reset() {
      this.tries = 0;
      clearTimeout(this.timer);
      this.timer = undefined;
    }
    scheduleTimeout() {
      clearTimeout(this.timer);
      this.timer = setTimeout(() => {
        this.tries = this.tries + 1;
        this.callback();
      }, this.timerCalc(this.tries + 1));
    }
  }
  exports2.default = Timer;
});

// backend/node_modules/@supabase/realtime-js/dist/main/lib/transformers.js
var require_transformers = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.httpEndpointURL = exports2.toTimestampString = exports2.toArray = exports2.toJson = exports2.toNumber = exports2.toBoolean = exports2.convertCell = exports2.convertColumn = exports2.convertChangeData = exports2.PostgresTypes = undefined;
  var PostgresTypes;
  (function(PostgresTypes2) {
    PostgresTypes2["abstime"] = "abstime";
    PostgresTypes2["bool"] = "bool";
    PostgresTypes2["date"] = "date";
    PostgresTypes2["daterange"] = "daterange";
    PostgresTypes2["float4"] = "float4";
    PostgresTypes2["float8"] = "float8";
    PostgresTypes2["int2"] = "int2";
    PostgresTypes2["int4"] = "int4";
    PostgresTypes2["int4range"] = "int4range";
    PostgresTypes2["int8"] = "int8";
    PostgresTypes2["int8range"] = "int8range";
    PostgresTypes2["json"] = "json";
    PostgresTypes2["jsonb"] = "jsonb";
    PostgresTypes2["money"] = "money";
    PostgresTypes2["numeric"] = "numeric";
    PostgresTypes2["oid"] = "oid";
    PostgresTypes2["reltime"] = "reltime";
    PostgresTypes2["text"] = "text";
    PostgresTypes2["time"] = "time";
    PostgresTypes2["timestamp"] = "timestamp";
    PostgresTypes2["timestamptz"] = "timestamptz";
    PostgresTypes2["timetz"] = "timetz";
    PostgresTypes2["tsrange"] = "tsrange";
    PostgresTypes2["tstzrange"] = "tstzrange";
  })(PostgresTypes || (exports2.PostgresTypes = PostgresTypes = {}));
  var convertChangeData = (columns, record, options = {}) => {
    var _a;
    const skipTypes = (_a = options.skipTypes) !== null && _a !== undefined ? _a : [];
    if (!record) {
      return {};
    }
    return Object.keys(record).reduce((acc, rec_key) => {
      acc[rec_key] = (0, exports2.convertColumn)(rec_key, columns, record, skipTypes);
      return acc;
    }, {});
  };
  exports2.convertChangeData = convertChangeData;
  var convertColumn = (columnName, columns, record, skipTypes) => {
    const column = columns.find((x) => x.name === columnName);
    const colType = column === null || column === undefined ? undefined : column.type;
    const value = record[columnName];
    if (colType && !skipTypes.includes(colType)) {
      return (0, exports2.convertCell)(colType, value);
    }
    return noop(value);
  };
  exports2.convertColumn = convertColumn;
  var convertCell = (type, value) => {
    if (type.charAt(0) === "_") {
      const dataType = type.slice(1, type.length);
      return (0, exports2.toArray)(value, dataType);
    }
    switch (type) {
      case PostgresTypes.bool:
        return (0, exports2.toBoolean)(value);
      case PostgresTypes.float4:
      case PostgresTypes.float8:
      case PostgresTypes.int2:
      case PostgresTypes.int4:
      case PostgresTypes.int8:
      case PostgresTypes.numeric:
      case PostgresTypes.oid:
        return (0, exports2.toNumber)(value);
      case PostgresTypes.json:
      case PostgresTypes.jsonb:
        return (0, exports2.toJson)(value);
      case PostgresTypes.timestamp:
        return (0, exports2.toTimestampString)(value);
      case PostgresTypes.abstime:
      case PostgresTypes.date:
      case PostgresTypes.daterange:
      case PostgresTypes.int4range:
      case PostgresTypes.int8range:
      case PostgresTypes.money:
      case PostgresTypes.reltime:
      case PostgresTypes.text:
      case PostgresTypes.time:
      case PostgresTypes.timestamptz:
      case PostgresTypes.timetz:
      case PostgresTypes.tsrange:
      case PostgresTypes.tstzrange:
        return noop(value);
      default:
        return noop(value);
    }
  };
  exports2.convertCell = convertCell;
  var noop = (value) => {
    return value;
  };
  var toBoolean = (value) => {
    switch (value) {
      case "t":
        return true;
      case "f":
        return false;
      default:
        return value;
    }
  };
  exports2.toBoolean = toBoolean;
  var toNumber = (value) => {
    if (typeof value === "string") {
      const parsedValue = parseFloat(value);
      if (!Number.isNaN(parsedValue)) {
        return parsedValue;
      }
    }
    return value;
  };
  exports2.toNumber = toNumber;
  var toJson = (value) => {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch (error) {
        console.log(`JSON parse error: ${error}`);
        return value;
      }
    }
    return value;
  };
  exports2.toJson = toJson;
  var toArray = (value, type) => {
    if (typeof value !== "string") {
      return value;
    }
    const lastIdx = value.length - 1;
    const closeBrace = value[lastIdx];
    const openBrace = value[0];
    if (openBrace === "{" && closeBrace === "}") {
      let arr;
      const valTrim = value.slice(1, lastIdx);
      try {
        arr = JSON.parse("[" + valTrim + "]");
      } catch (_) {
        arr = valTrim ? valTrim.split(",") : [];
      }
      return arr.map((val) => (0, exports2.convertCell)(type, val));
    }
    return value;
  };
  exports2.toArray = toArray;
  var toTimestampString = (value) => {
    if (typeof value === "string") {
      return value.replace(" ", "T");
    }
    return value;
  };
  exports2.toTimestampString = toTimestampString;
  var httpEndpointURL = (socketUrl) => {
    const wsUrl = new URL(socketUrl);
    wsUrl.protocol = wsUrl.protocol.replace(/^ws/i, "http");
    wsUrl.pathname = wsUrl.pathname.replace(/\/+$/, "").replace(/\/socket\/websocket$/i, "").replace(/\/socket$/i, "").replace(/\/websocket$/i, "");
    if (wsUrl.pathname === "" || wsUrl.pathname === "/") {
      wsUrl.pathname = "/api/broadcast";
    } else {
      wsUrl.pathname = wsUrl.pathname + "/api/broadcast";
    }
    return wsUrl.href;
  };
  exports2.httpEndpointURL = httpEndpointURL;
});

// backend/node_modules/@supabase/realtime-js/dist/main/lib/push.js
var require_push = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var constants_1 = require_constants();

  class Push {
    constructor(channel, event, payload = {}, timeout = constants_1.DEFAULT_TIMEOUT) {
      this.channel = channel;
      this.event = event;
      this.payload = payload;
      this.timeout = timeout;
      this.sent = false;
      this.timeoutTimer = undefined;
      this.ref = "";
      this.receivedResp = null;
      this.recHooks = [];
      this.refEvent = null;
    }
    resend(timeout) {
      this.timeout = timeout;
      this._cancelRefEvent();
      this.ref = "";
      this.refEvent = null;
      this.receivedResp = null;
      this.sent = false;
      this.send();
    }
    send() {
      if (this._hasReceived("timeout")) {
        return;
      }
      this.startTimeout();
      this.sent = true;
      this.channel.socket.push({
        topic: this.channel.topic,
        event: this.event,
        payload: this.payload,
        ref: this.ref,
        join_ref: this.channel._joinRef()
      });
    }
    updatePayload(payload) {
      this.payload = Object.assign(Object.assign({}, this.payload), payload);
    }
    receive(status, callback) {
      var _a;
      if (this._hasReceived(status)) {
        callback((_a = this.receivedResp) === null || _a === undefined ? undefined : _a.response);
      }
      this.recHooks.push({ status, callback });
      return this;
    }
    startTimeout() {
      if (this.timeoutTimer) {
        return;
      }
      this.ref = this.channel.socket._makeRef();
      this.refEvent = this.channel._replyEventName(this.ref);
      const callback = (payload) => {
        this._cancelRefEvent();
        this._cancelTimeout();
        this.receivedResp = payload;
        this._matchReceive(payload);
      };
      this.channel._on(this.refEvent, {}, callback);
      this.timeoutTimer = setTimeout(() => {
        this.trigger("timeout", {});
      }, this.timeout);
    }
    trigger(status, response) {
      if (this.refEvent)
        this.channel._trigger(this.refEvent, { status, response });
    }
    destroy() {
      this._cancelRefEvent();
      this._cancelTimeout();
    }
    _cancelRefEvent() {
      if (!this.refEvent) {
        return;
      }
      this.channel._off(this.refEvent, {});
    }
    _cancelTimeout() {
      clearTimeout(this.timeoutTimer);
      this.timeoutTimer = undefined;
    }
    _matchReceive({ status, response }) {
      this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));
    }
    _hasReceived(status) {
      return this.receivedResp && this.receivedResp.status === status;
    }
  }
  exports2.default = Push;
});

// backend/node_modules/@supabase/realtime-js/dist/main/RealtimePresence.js
var require_RealtimePresence = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.REALTIME_PRESENCE_LISTEN_EVENTS = undefined;
  var REALTIME_PRESENCE_LISTEN_EVENTS;
  (function(REALTIME_PRESENCE_LISTEN_EVENTS2) {
    REALTIME_PRESENCE_LISTEN_EVENTS2["SYNC"] = "sync";
    REALTIME_PRESENCE_LISTEN_EVENTS2["JOIN"] = "join";
    REALTIME_PRESENCE_LISTEN_EVENTS2["LEAVE"] = "leave";
  })(REALTIME_PRESENCE_LISTEN_EVENTS || (exports2.REALTIME_PRESENCE_LISTEN_EVENTS = REALTIME_PRESENCE_LISTEN_EVENTS = {}));

  class RealtimePresence {
    constructor(channel, opts) {
      this.channel = channel;
      this.state = {};
      this.pendingDiffs = [];
      this.joinRef = null;
      this.enabled = false;
      this.caller = {
        onJoin: () => {},
        onLeave: () => {},
        onSync: () => {}
      };
      const events = (opts === null || opts === undefined ? undefined : opts.events) || {
        state: "presence_state",
        diff: "presence_diff"
      };
      this.channel._on(events.state, {}, (newState) => {
        const { onJoin, onLeave, onSync } = this.caller;
        this.joinRef = this.channel._joinRef();
        this.state = RealtimePresence.syncState(this.state, newState, onJoin, onLeave);
        this.pendingDiffs.forEach((diff) => {
          this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
        });
        this.pendingDiffs = [];
        onSync();
      });
      this.channel._on(events.diff, {}, (diff) => {
        const { onJoin, onLeave, onSync } = this.caller;
        if (this.inPendingSyncState()) {
          this.pendingDiffs.push(diff);
        } else {
          this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
          onSync();
        }
      });
      this.onJoin((key, currentPresences, newPresences) => {
        this.channel._trigger("presence", {
          event: "join",
          key,
          currentPresences,
          newPresences
        });
      });
      this.onLeave((key, currentPresences, leftPresences) => {
        this.channel._trigger("presence", {
          event: "leave",
          key,
          currentPresences,
          leftPresences
        });
      });
      this.onSync(() => {
        this.channel._trigger("presence", { event: "sync" });
      });
    }
    static syncState(currentState, newState, onJoin, onLeave) {
      const state = this.cloneDeep(currentState);
      const transformedState = this.transformState(newState);
      const joins = {};
      const leaves = {};
      this.map(state, (key, presences) => {
        if (!transformedState[key]) {
          leaves[key] = presences;
        }
      });
      this.map(transformedState, (key, newPresences) => {
        const currentPresences = state[key];
        if (currentPresences) {
          const newPresenceRefs = newPresences.map((m) => m.presence_ref);
          const curPresenceRefs = currentPresences.map((m) => m.presence_ref);
          const joinedPresences = newPresences.filter((m) => curPresenceRefs.indexOf(m.presence_ref) < 0);
          const leftPresences = currentPresences.filter((m) => newPresenceRefs.indexOf(m.presence_ref) < 0);
          if (joinedPresences.length > 0) {
            joins[key] = joinedPresences;
          }
          if (leftPresences.length > 0) {
            leaves[key] = leftPresences;
          }
        } else {
          joins[key] = newPresences;
        }
      });
      return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);
    }
    static syncDiff(state, diff, onJoin, onLeave) {
      const { joins, leaves } = {
        joins: this.transformState(diff.joins),
        leaves: this.transformState(diff.leaves)
      };
      if (!onJoin) {
        onJoin = () => {};
      }
      if (!onLeave) {
        onLeave = () => {};
      }
      this.map(joins, (key, newPresences) => {
        var _a;
        const currentPresences = (_a = state[key]) !== null && _a !== undefined ? _a : [];
        state[key] = this.cloneDeep(newPresences);
        if (currentPresences.length > 0) {
          const joinedPresenceRefs = state[key].map((m) => m.presence_ref);
          const curPresences = currentPresences.filter((m) => joinedPresenceRefs.indexOf(m.presence_ref) < 0);
          state[key].unshift(...curPresences);
        }
        onJoin(key, currentPresences, newPresences);
      });
      this.map(leaves, (key, leftPresences) => {
        let currentPresences = state[key];
        if (!currentPresences)
          return;
        const presenceRefsToRemove = leftPresences.map((m) => m.presence_ref);
        currentPresences = currentPresences.filter((m) => presenceRefsToRemove.indexOf(m.presence_ref) < 0);
        state[key] = currentPresences;
        onLeave(key, currentPresences, leftPresences);
        if (currentPresences.length === 0)
          delete state[key];
      });
      return state;
    }
    static map(obj2, func) {
      return Object.getOwnPropertyNames(obj2).map((key) => func(key, obj2[key]));
    }
    static transformState(state) {
      state = this.cloneDeep(state);
      return Object.getOwnPropertyNames(state).reduce((newState, key) => {
        const presences = state[key];
        if ("metas" in presences) {
          newState[key] = presences.metas.map((presence) => {
            presence["presence_ref"] = presence["phx_ref"];
            delete presence["phx_ref"];
            delete presence["phx_ref_prev"];
            return presence;
          });
        } else {
          newState[key] = presences;
        }
        return newState;
      }, {});
    }
    static cloneDeep(obj2) {
      return JSON.parse(JSON.stringify(obj2));
    }
    onJoin(callback) {
      this.caller.onJoin = callback;
    }
    onLeave(callback) {
      this.caller.onLeave = callback;
    }
    onSync(callback) {
      this.caller.onSync = callback;
    }
    inPendingSyncState() {
      return !this.joinRef || this.joinRef !== this.channel._joinRef();
    }
  }
  exports2.default = RealtimePresence;
});

// backend/node_modules/@supabase/realtime-js/dist/main/RealtimeChannel.js
var require_RealtimeChannel = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.REALTIME_CHANNEL_STATES = exports2.REALTIME_SUBSCRIBE_STATES = exports2.REALTIME_LISTEN_TYPES = exports2.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = undefined;
  var tslib_1 = require_tslib();
  var constants_1 = require_constants();
  var push_1 = tslib_1.__importDefault(require_push());
  var timer_1 = tslib_1.__importDefault(require_timer());
  var RealtimePresence_1 = tslib_1.__importDefault(require_RealtimePresence());
  var Transformers = tslib_1.__importStar(require_transformers());
  var transformers_1 = require_transformers();
  var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;
  (function(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2) {
    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["ALL"] = "*";
    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["INSERT"] = "INSERT";
    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["UPDATE"] = "UPDATE";
    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT2["DELETE"] = "DELETE";
  })(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (exports2.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));
  var REALTIME_LISTEN_TYPES;
  (function(REALTIME_LISTEN_TYPES2) {
    REALTIME_LISTEN_TYPES2["BROADCAST"] = "broadcast";
    REALTIME_LISTEN_TYPES2["PRESENCE"] = "presence";
    REALTIME_LISTEN_TYPES2["POSTGRES_CHANGES"] = "postgres_changes";
    REALTIME_LISTEN_TYPES2["SYSTEM"] = "system";
  })(REALTIME_LISTEN_TYPES || (exports2.REALTIME_LISTEN_TYPES = REALTIME_LISTEN_TYPES = {}));
  var REALTIME_SUBSCRIBE_STATES;
  (function(REALTIME_SUBSCRIBE_STATES2) {
    REALTIME_SUBSCRIBE_STATES2["SUBSCRIBED"] = "SUBSCRIBED";
    REALTIME_SUBSCRIBE_STATES2["TIMED_OUT"] = "TIMED_OUT";
    REALTIME_SUBSCRIBE_STATES2["CLOSED"] = "CLOSED";
    REALTIME_SUBSCRIBE_STATES2["CHANNEL_ERROR"] = "CHANNEL_ERROR";
  })(REALTIME_SUBSCRIBE_STATES || (exports2.REALTIME_SUBSCRIBE_STATES = REALTIME_SUBSCRIBE_STATES = {}));
  exports2.REALTIME_CHANNEL_STATES = constants_1.CHANNEL_STATES;

  class RealtimeChannel {
    constructor(topic, params = { config: {} }, socket) {
      var _a, _b;
      this.topic = topic;
      this.params = params;
      this.socket = socket;
      this.bindings = {};
      this.state = constants_1.CHANNEL_STATES.closed;
      this.joinedOnce = false;
      this.pushBuffer = [];
      this.subTopic = topic.replace(/^realtime:/i, "");
      this.params.config = Object.assign({
        broadcast: { ack: false, self: false },
        presence: { key: "", enabled: false },
        private: false
      }, params.config);
      this.timeout = this.socket.timeout;
      this.joinPush = new push_1.default(this, constants_1.CHANNEL_EVENTS.join, this.params, this.timeout);
      this.rejoinTimer = new timer_1.default(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);
      this.joinPush.receive("ok", () => {
        this.state = constants_1.CHANNEL_STATES.joined;
        this.rejoinTimer.reset();
        this.pushBuffer.forEach((pushEvent) => pushEvent.send());
        this.pushBuffer = [];
      });
      this._onClose(() => {
        this.rejoinTimer.reset();
        this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`);
        this.state = constants_1.CHANNEL_STATES.closed;
        this.socket._remove(this);
      });
      this._onError((reason) => {
        if (this._isLeaving() || this._isClosed()) {
          return;
        }
        this.socket.log("channel", `error ${this.topic}`, reason);
        this.state = constants_1.CHANNEL_STATES.errored;
        this.rejoinTimer.scheduleTimeout();
      });
      this.joinPush.receive("timeout", () => {
        if (!this._isJoining()) {
          return;
        }
        this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout);
        this.state = constants_1.CHANNEL_STATES.errored;
        this.rejoinTimer.scheduleTimeout();
      });
      this.joinPush.receive("error", (reason) => {
        if (this._isLeaving() || this._isClosed()) {
          return;
        }
        this.socket.log("channel", `error ${this.topic}`, reason);
        this.state = constants_1.CHANNEL_STATES.errored;
        this.rejoinTimer.scheduleTimeout();
      });
      this._on(constants_1.CHANNEL_EVENTS.reply, {}, (payload, ref) => {
        this._trigger(this._replyEventName(ref), payload);
      });
      this.presence = new RealtimePresence_1.default(this);
      this.broadcastEndpointURL = (0, transformers_1.httpEndpointURL)(this.socket.endPoint);
      this.private = this.params.config.private || false;
      if (!this.private && ((_b = (_a = this.params.config) === null || _a === undefined ? undefined : _a.broadcast) === null || _b === undefined ? undefined : _b.replay)) {
        throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`;
      }
    }
    subscribe(callback, timeout = this.timeout) {
      var _a, _b, _c;
      if (!this.socket.isConnected()) {
        this.socket.connect();
      }
      if (this.state == constants_1.CHANNEL_STATES.closed) {
        const { config: { broadcast, presence, private: isPrivate } } = this.params;
        const postgres_changes = (_b = (_a = this.bindings.postgres_changes) === null || _a === undefined ? undefined : _a.map((r) => r.filter)) !== null && _b !== undefined ? _b : [];
        const presence_enabled = !!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE] && this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length > 0 || ((_c = this.params.config.presence) === null || _c === undefined ? undefined : _c.enabled) === true;
        const accessTokenPayload = {};
        const config = {
          broadcast,
          presence: Object.assign(Object.assign({}, presence), { enabled: presence_enabled }),
          postgres_changes,
          private: isPrivate
        };
        if (this.socket.accessTokenValue) {
          accessTokenPayload.access_token = this.socket.accessTokenValue;
        }
        this._onError((e) => callback === null || callback === undefined ? undefined : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));
        this._onClose(() => callback === null || callback === undefined ? undefined : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));
        this.updateJoinPayload(Object.assign({ config }, accessTokenPayload));
        this.joinedOnce = true;
        this._rejoin(timeout);
        this.joinPush.receive("ok", async ({ postgres_changes: postgres_changes2 }) => {
          var _a2;
          this.socket.setAuth();
          if (postgres_changes2 === undefined) {
            callback === null || callback === undefined || callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
            return;
          } else {
            const clientPostgresBindings = this.bindings.postgres_changes;
            const bindingsLen = (_a2 = clientPostgresBindings === null || clientPostgresBindings === undefined ? undefined : clientPostgresBindings.length) !== null && _a2 !== undefined ? _a2 : 0;
            const newPostgresBindings = [];
            for (let i = 0;i < bindingsLen; i++) {
              const clientPostgresBinding = clientPostgresBindings[i];
              const { filter: { event, schema, table, filter } } = clientPostgresBinding;
              const serverPostgresFilter = postgres_changes2 && postgres_changes2[i];
              if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) {
                newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), { id: serverPostgresFilter.id }));
              } else {
                this.unsubscribe();
                this.state = constants_1.CHANNEL_STATES.errored;
                callback === null || callback === undefined || callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error("mismatch between server and client bindings for postgres changes"));
                return;
              }
            }
            this.bindings.postgres_changes = newPostgresBindings;
            callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
            return;
          }
        }).receive("error", (error) => {
          this.state = constants_1.CHANNEL_STATES.errored;
          callback === null || callback === undefined || callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(", ") || "error")));
          return;
        }).receive("timeout", () => {
          callback === null || callback === undefined || callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);
          return;
        });
      }
      return this;
    }
    presenceState() {
      return this.presence.state;
    }
    async track(payload, opts = {}) {
      return await this.send({
        type: "presence",
        event: "track",
        payload
      }, opts.timeout || this.timeout);
    }
    async untrack(opts = {}) {
      return await this.send({
        type: "presence",
        event: "untrack"
      }, opts);
    }
    on(type, filter, callback) {
      if (this.state === constants_1.CHANNEL_STATES.joined && type === REALTIME_LISTEN_TYPES.PRESENCE) {
        this.socket.log("channel", `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`);
        this.unsubscribe().then(() => this.subscribe());
      }
      return this._on(type, filter, callback);
    }
    async httpSend(event, payload, opts = {}) {
      var _a;
      const authorization = this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : "";
      if (payload === undefined || payload === null) {
        return Promise.reject("Payload is required for httpSend()");
      }
      const options = {
        method: "POST",
        headers: {
          Authorization: authorization,
          apikey: this.socket.apiKey ? this.socket.apiKey : "",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          messages: [
            {
              topic: this.subTopic,
              event,
              payload,
              private: this.private
            }
          ]
        })
      };
      const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== undefined ? _a : this.timeout);
      if (response.status === 202) {
        return { success: true };
      }
      let errorMessage = response.statusText;
      try {
        const errorBody = await response.json();
        errorMessage = errorBody.error || errorBody.message || errorMessage;
      } catch (_b) {}
      return Promise.reject(new Error(errorMessage));
    }
    async send(args, opts = {}) {
      var _a, _b;
      if (!this._canPush() && args.type === "broadcast") {
        console.warn("Realtime send() is automatically falling back to REST API. " + "This behavior will be deprecated in the future. " + "Please use httpSend() explicitly for REST delivery.");
        const { event, payload: endpoint_payload } = args;
        const authorization = this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : "";
        const options = {
          method: "POST",
          headers: {
            Authorization: authorization,
            apikey: this.socket.apiKey ? this.socket.apiKey : "",
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            messages: [
              {
                topic: this.subTopic,
                event,
                payload: endpoint_payload,
                private: this.private
              }
            ]
          })
        };
        try {
          const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== undefined ? _a : this.timeout);
          await ((_b = response.body) === null || _b === undefined ? undefined : _b.cancel());
          return response.ok ? "ok" : "error";
        } catch (error) {
          if (error.name === "AbortError") {
            return "timed out";
          } else {
            return "error";
          }
        }
      } else {
        return new Promise((resolve) => {
          var _a2, _b2, _c;
          const push = this._push(args.type, args, opts.timeout || this.timeout);
          if (args.type === "broadcast" && !((_c = (_b2 = (_a2 = this.params) === null || _a2 === undefined ? undefined : _a2.config) === null || _b2 === undefined ? undefined : _b2.broadcast) === null || _c === undefined ? undefined : _c.ack)) {
            resolve("ok");
          }
          push.receive("ok", () => resolve("ok"));
          push.receive("error", () => resolve("error"));
          push.receive("timeout", () => resolve("timed out"));
        });
      }
    }
    updateJoinPayload(payload) {
      this.joinPush.updatePayload(payload);
    }
    unsubscribe(timeout = this.timeout) {
      this.state = constants_1.CHANNEL_STATES.leaving;
      const onClose = () => {
        this.socket.log("channel", `leave ${this.topic}`);
        this._trigger(constants_1.CHANNEL_EVENTS.close, "leave", this._joinRef());
      };
      this.joinPush.destroy();
      let leavePush = null;
      return new Promise((resolve) => {
        leavePush = new push_1.default(this, constants_1.CHANNEL_EVENTS.leave, {}, timeout);
        leavePush.receive("ok", () => {
          onClose();
          resolve("ok");
        }).receive("timeout", () => {
          onClose();
          resolve("timed out");
        }).receive("error", () => {
          resolve("error");
        });
        leavePush.send();
        if (!this._canPush()) {
          leavePush.trigger("ok", {});
        }
      }).finally(() => {
        leavePush === null || leavePush === undefined || leavePush.destroy();
      });
    }
    teardown() {
      this.pushBuffer.forEach((push) => push.destroy());
      this.pushBuffer = [];
      this.rejoinTimer.reset();
      this.joinPush.destroy();
      this.state = constants_1.CHANNEL_STATES.closed;
      this.bindings = {};
    }
    async _fetchWithTimeout(url, options, timeout) {
      const controller = new AbortController;
      const id = setTimeout(() => controller.abort(), timeout);
      const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), { signal: controller.signal }));
      clearTimeout(id);
      return response;
    }
    _push(event, payload, timeout = this.timeout) {
      if (!this.joinedOnce) {
        throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
      }
      let pushEvent = new push_1.default(this, event, payload, timeout);
      if (this._canPush()) {
        pushEvent.send();
      } else {
        this._addToPushBuffer(pushEvent);
      }
      return pushEvent;
    }
    _addToPushBuffer(pushEvent) {
      pushEvent.startTimeout();
      this.pushBuffer.push(pushEvent);
      if (this.pushBuffer.length > constants_1.MAX_PUSH_BUFFER_SIZE) {
        const removedPush = this.pushBuffer.shift();
        if (removedPush) {
          removedPush.destroy();
          this.socket.log("channel", `discarded push due to buffer overflow: ${removedPush.event}`, removedPush.payload);
        }
      }
    }
    _onMessage(_event, payload, _ref) {
      return payload;
    }
    _isMember(topic) {
      return this.topic === topic;
    }
    _joinRef() {
      return this.joinPush.ref;
    }
    _trigger(type, payload, ref) {
      var _a, _b;
      const typeLower = type.toLocaleLowerCase();
      const { close, error, leave, join } = constants_1.CHANNEL_EVENTS;
      const events = [close, error, leave, join];
      if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {
        return;
      }
      let handledPayload = this._onMessage(typeLower, payload, ref);
      if (payload && !handledPayload) {
        throw "channel onMessage callbacks must return the payload, modified or unmodified";
      }
      if (["insert", "update", "delete"].includes(typeLower)) {
        (_a = this.bindings.postgres_changes) === null || _a === undefined || _a.filter((bind) => {
          var _a2, _b2, _c;
          return ((_a2 = bind.filter) === null || _a2 === undefined ? undefined : _a2.event) === "*" || ((_c = (_b2 = bind.filter) === null || _b2 === undefined ? undefined : _b2.event) === null || _c === undefined ? undefined : _c.toLocaleLowerCase()) === typeLower;
        }).map((bind) => bind.callback(handledPayload, ref));
      } else {
        (_b = this.bindings[typeLower]) === null || _b === undefined || _b.filter((bind) => {
          var _a2, _b2, _c, _d, _e, _f;
          if (["broadcast", "presence", "postgres_changes"].includes(typeLower)) {
            if ("id" in bind) {
              const bindId = bind.id;
              const bindEvent = (_a2 = bind.filter) === null || _a2 === undefined ? undefined : _a2.event;
              return bindId && ((_b2 = payload.ids) === null || _b2 === undefined ? undefined : _b2.includes(bindId)) && (bindEvent === "*" || (bindEvent === null || bindEvent === undefined ? undefined : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === undefined ? undefined : _c.type.toLocaleLowerCase()));
            } else {
              const bindEvent = (_e = (_d = bind === null || bind === undefined ? undefined : bind.filter) === null || _d === undefined ? undefined : _d.event) === null || _e === undefined ? undefined : _e.toLocaleLowerCase();
              return bindEvent === "*" || bindEvent === ((_f = payload === null || payload === undefined ? undefined : payload.event) === null || _f === undefined ? undefined : _f.toLocaleLowerCase());
            }
          } else {
            return bind.type.toLocaleLowerCase() === typeLower;
          }
        }).map((bind) => {
          if (typeof handledPayload === "object" && "ids" in handledPayload) {
            const postgresChanges = handledPayload.data;
            const { schema, table, commit_timestamp, type: type2, errors } = postgresChanges;
            const enrichedPayload = {
              schema,
              table,
              commit_timestamp,
              eventType: type2,
              new: {},
              old: {},
              errors
            };
            handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));
          }
          bind.callback(handledPayload, ref);
        });
      }
    }
    _isClosed() {
      return this.state === constants_1.CHANNEL_STATES.closed;
    }
    _isJoined() {
      return this.state === constants_1.CHANNEL_STATES.joined;
    }
    _isJoining() {
      return this.state === constants_1.CHANNEL_STATES.joining;
    }
    _isLeaving() {
      return this.state === constants_1.CHANNEL_STATES.leaving;
    }
    _replyEventName(ref) {
      return `chan_reply_${ref}`;
    }
    _on(type, filter, callback) {
      const typeLower = type.toLocaleLowerCase();
      const binding = {
        type: typeLower,
        filter,
        callback
      };
      if (this.bindings[typeLower]) {
        this.bindings[typeLower].push(binding);
      } else {
        this.bindings[typeLower] = [binding];
      }
      return this;
    }
    _off(type, filter) {
      const typeLower = type.toLocaleLowerCase();
      if (this.bindings[typeLower]) {
        this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {
          var _a;
          return !(((_a = bind.type) === null || _a === undefined ? undefined : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));
        });
      }
      return this;
    }
    static isEqual(obj1, obj2) {
      if (Object.keys(obj1).length !== Object.keys(obj2).length) {
        return false;
      }
      for (const k in obj1) {
        if (obj1[k] !== obj2[k]) {
          return false;
        }
      }
      return true;
    }
    _rejoinUntilConnected() {
      this.rejoinTimer.scheduleTimeout();
      if (this.socket.isConnected()) {
        this._rejoin();
      }
    }
    _onClose(callback) {
      this._on(constants_1.CHANNEL_EVENTS.close, {}, callback);
    }
    _onError(callback) {
      this._on(constants_1.CHANNEL_EVENTS.error, {}, (reason) => callback(reason));
    }
    _canPush() {
      return this.socket.isConnected() && this._isJoined();
    }
    _rejoin(timeout = this.timeout) {
      if (this._isLeaving()) {
        return;
      }
      this.socket._leaveOpenTopic(this.topic);
      this.state = constants_1.CHANNEL_STATES.joining;
      this.joinPush.resend(timeout);
    }
    _getPayloadRecords(payload) {
      const records = {
        new: {},
        old: {}
      };
      if (payload.type === "INSERT" || payload.type === "UPDATE") {
        records.new = Transformers.convertChangeData(payload.columns, payload.record);
      }
      if (payload.type === "UPDATE" || payload.type === "DELETE") {
        records.old = Transformers.convertChangeData(payload.columns, payload.old_record);
      }
      return records;
    }
  }
  exports2.default = RealtimeChannel;
});

// backend/node_modules/@supabase/realtime-js/dist/main/RealtimeClient.js
var require_RealtimeClient = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  var websocket_factory_1 = tslib_1.__importDefault(require_websocket_factory());
  var constants_1 = require_constants();
  var serializer_1 = tslib_1.__importDefault(require_serializer());
  var timer_1 = tslib_1.__importDefault(require_timer());
  var transformers_1 = require_transformers();
  var RealtimeChannel_1 = tslib_1.__importDefault(require_RealtimeChannel());
  var noop = () => {};
  var CONNECTION_TIMEOUTS = {
    HEARTBEAT_INTERVAL: 25000,
    RECONNECT_DELAY: 10,
    HEARTBEAT_TIMEOUT_FALLBACK: 100
  };
  var RECONNECT_INTERVALS = [1000, 2000, 5000, 1e4];
  var DEFAULT_RECONNECT_FALLBACK = 1e4;
  var WORKER_SCRIPT = `
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;

  class RealtimeClient {
    constructor(endPoint, options) {
      var _a;
      this.accessTokenValue = null;
      this.apiKey = null;
      this.channels = new Array;
      this.endPoint = "";
      this.httpEndpoint = "";
      this.headers = {};
      this.params = {};
      this.timeout = constants_1.DEFAULT_TIMEOUT;
      this.transport = null;
      this.heartbeatIntervalMs = CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;
      this.heartbeatTimer = undefined;
      this.pendingHeartbeatRef = null;
      this.heartbeatCallback = noop;
      this.ref = 0;
      this.reconnectTimer = null;
      this.vsn = constants_1.DEFAULT_VSN;
      this.logger = noop;
      this.conn = null;
      this.sendBuffer = [];
      this.serializer = new serializer_1.default;
      this.stateChangeCallbacks = {
        open: [],
        close: [],
        error: [],
        message: []
      };
      this.accessToken = null;
      this._connectionState = "disconnected";
      this._wasManualDisconnect = false;
      this._authPromise = null;
      this._resolveFetch = (customFetch) => {
        if (customFetch) {
          return (...args) => customFetch(...args);
        }
        return (...args) => fetch(...args);
      };
      if (!((_a = options === null || options === undefined ? undefined : options.params) === null || _a === undefined ? undefined : _a.apikey)) {
        throw new Error("API key is required to connect to Realtime");
      }
      this.apiKey = options.params.apikey;
      this.endPoint = `${endPoint}/${constants_1.TRANSPORTS.websocket}`;
      this.httpEndpoint = (0, transformers_1.httpEndpointURL)(endPoint);
      this._initializeOptions(options);
      this._setupReconnectionTimer();
      this.fetch = this._resolveFetch(options === null || options === undefined ? undefined : options.fetch);
    }
    connect() {
      if (this.isConnecting() || this.isDisconnecting() || this.conn !== null && this.isConnected()) {
        return;
      }
      this._setConnectionState("connecting");
      if (this.accessToken && !this._authPromise) {
        this._setAuthSafely("connect");
      }
      if (this.transport) {
        this.conn = new this.transport(this.endpointURL());
      } else {
        try {
          this.conn = websocket_factory_1.default.createWebSocket(this.endpointURL());
        } catch (error) {
          this._setConnectionState("disconnected");
          const errorMessage = error.message;
          if (errorMessage.includes("Node.js")) {
            throw new Error(`${errorMessage}

` + `To use Realtime in Node.js, you need to provide a WebSocket implementation:

` + `Option 1: Use Node.js 22+ which has native WebSocket support
` + `Option 2: Install and provide the "ws" package:

` + `  npm install ws

` + `  import ws from "ws"
` + `  const client = new RealtimeClient(url, {
` + `    ...options,
` + `    transport: ws
` + "  })");
          }
          throw new Error(`WebSocket not available: ${errorMessage}`);
        }
      }
      this._setupConnectionHandlers();
    }
    endpointURL() {
      return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: this.vsn }));
    }
    disconnect(code, reason) {
      if (this.isDisconnecting()) {
        return;
      }
      this._setConnectionState("disconnecting", true);
      if (this.conn) {
        const fallbackTimer = setTimeout(() => {
          this._setConnectionState("disconnected");
        }, 100);
        this.conn.onclose = () => {
          clearTimeout(fallbackTimer);
          this._setConnectionState("disconnected");
        };
        if (typeof this.conn.close === "function") {
          if (code) {
            this.conn.close(code, reason !== null && reason !== undefined ? reason : "");
          } else {
            this.conn.close();
          }
        }
        this._teardownConnection();
      } else {
        this._setConnectionState("disconnected");
      }
    }
    getChannels() {
      return this.channels;
    }
    async removeChannel(channel) {
      const status = await channel.unsubscribe();
      if (this.channels.length === 0) {
        this.disconnect();
      }
      return status;
    }
    async removeAllChannels() {
      const values_1 = await Promise.all(this.channels.map((channel) => channel.unsubscribe()));
      this.channels = [];
      this.disconnect();
      return values_1;
    }
    log(kind, msg, data) {
      this.logger(kind, msg, data);
    }
    connectionState() {
      switch (this.conn && this.conn.readyState) {
        case constants_1.SOCKET_STATES.connecting:
          return constants_1.CONNECTION_STATE.Connecting;
        case constants_1.SOCKET_STATES.open:
          return constants_1.CONNECTION_STATE.Open;
        case constants_1.SOCKET_STATES.closing:
          return constants_1.CONNECTION_STATE.Closing;
        default:
          return constants_1.CONNECTION_STATE.Closed;
      }
    }
    isConnected() {
      return this.connectionState() === constants_1.CONNECTION_STATE.Open;
    }
    isConnecting() {
      return this._connectionState === "connecting";
    }
    isDisconnecting() {
      return this._connectionState === "disconnecting";
    }
    channel(topic, params = { config: {} }) {
      const realtimeTopic = `realtime:${topic}`;
      const exists = this.getChannels().find((c) => c.topic === realtimeTopic);
      if (!exists) {
        const chan = new RealtimeChannel_1.default(`realtime:${topic}`, params, this);
        this.channels.push(chan);
        return chan;
      } else {
        return exists;
      }
    }
    push(data) {
      const { topic, event, payload, ref } = data;
      const callback = () => {
        this.encode(data, (result) => {
          var _a;
          (_a = this.conn) === null || _a === undefined || _a.send(result);
        });
      };
      this.log("push", `${topic} ${event} (${ref})`, payload);
      if (this.isConnected()) {
        callback();
      } else {
        this.sendBuffer.push(callback);
      }
    }
    async setAuth(token = null) {
      this._authPromise = this._performAuth(token);
      try {
        await this._authPromise;
      } finally {
        this._authPromise = null;
      }
    }
    async sendHeartbeat() {
      var _a;
      if (!this.isConnected()) {
        try {
          this.heartbeatCallback("disconnected");
        } catch (e) {
          this.log("error", "error in heartbeat callback", e);
        }
        return;
      }
      if (this.pendingHeartbeatRef) {
        this.pendingHeartbeatRef = null;
        this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
        try {
          this.heartbeatCallback("timeout");
        } catch (e) {
          this.log("error", "error in heartbeat callback", e);
        }
        this._wasManualDisconnect = false;
        (_a = this.conn) === null || _a === undefined || _a.close(constants_1.WS_CLOSE_NORMAL, "heartbeat timeout");
        setTimeout(() => {
          var _a2;
          if (!this.isConnected()) {
            (_a2 = this.reconnectTimer) === null || _a2 === undefined || _a2.scheduleTimeout();
          }
        }, CONNECTION_TIMEOUTS.HEARTBEAT_TIMEOUT_FALLBACK);
        return;
      }
      this.pendingHeartbeatRef = this._makeRef();
      this.push({
        topic: "phoenix",
        event: "heartbeat",
        payload: {},
        ref: this.pendingHeartbeatRef
      });
      try {
        this.heartbeatCallback("sent");
      } catch (e) {
        this.log("error", "error in heartbeat callback", e);
      }
      this._setAuthSafely("heartbeat");
    }
    onHeartbeat(callback) {
      this.heartbeatCallback = callback;
    }
    flushSendBuffer() {
      if (this.isConnected() && this.sendBuffer.length > 0) {
        this.sendBuffer.forEach((callback) => callback());
        this.sendBuffer = [];
      }
    }
    _makeRef() {
      let newRef = this.ref + 1;
      if (newRef === this.ref) {
        this.ref = 0;
      } else {
        this.ref = newRef;
      }
      return this.ref.toString();
    }
    _leaveOpenTopic(topic) {
      let dupChannel = this.channels.find((c) => c.topic === topic && (c._isJoined() || c._isJoining()));
      if (dupChannel) {
        this.log("transport", `leaving duplicate topic "${topic}"`);
        dupChannel.unsubscribe();
      }
    }
    _remove(channel) {
      this.channels = this.channels.filter((c) => c.topic !== channel.topic);
    }
    _onConnMessage(rawMessage) {
      this.decode(rawMessage.data, (msg) => {
        if (msg.topic === "phoenix" && msg.event === "phx_reply") {
          try {
            this.heartbeatCallback(msg.payload.status === "ok" ? "ok" : "error");
          } catch (e) {
            this.log("error", "error in heartbeat callback", e);
          }
        }
        if (msg.ref && msg.ref === this.pendingHeartbeatRef) {
          this.pendingHeartbeatRef = null;
        }
        const { topic, event, payload, ref } = msg;
        const refString = ref ? `(${ref})` : "";
        const status = payload.status || "";
        this.log("receive", `${status} ${topic} ${event} ${refString}`.trim(), payload);
        this.channels.filter((channel) => channel._isMember(topic)).forEach((channel) => channel._trigger(event, payload, ref));
        this._triggerStateCallbacks("message", msg);
      });
    }
    _clearTimer(timer) {
      var _a;
      if (timer === "heartbeat" && this.heartbeatTimer) {
        clearInterval(this.heartbeatTimer);
        this.heartbeatTimer = undefined;
      } else if (timer === "reconnect") {
        (_a = this.reconnectTimer) === null || _a === undefined || _a.reset();
      }
    }
    _clearAllTimers() {
      this._clearTimer("heartbeat");
      this._clearTimer("reconnect");
    }
    _setupConnectionHandlers() {
      if (!this.conn)
        return;
      if ("binaryType" in this.conn) {
        this.conn.binaryType = "arraybuffer";
      }
      this.conn.onopen = () => this._onConnOpen();
      this.conn.onerror = (error) => this._onConnError(error);
      this.conn.onmessage = (event) => this._onConnMessage(event);
      this.conn.onclose = (event) => this._onConnClose(event);
    }
    _teardownConnection() {
      if (this.conn) {
        if (this.conn.readyState === constants_1.SOCKET_STATES.open || this.conn.readyState === constants_1.SOCKET_STATES.connecting) {
          try {
            this.conn.close();
          } catch (e) {
            this.log("error", "Error closing connection", e);
          }
        }
        this.conn.onopen = null;
        this.conn.onerror = null;
        this.conn.onmessage = null;
        this.conn.onclose = null;
        this.conn = null;
      }
      this._clearAllTimers();
      this.channels.forEach((channel) => channel.teardown());
    }
    _onConnOpen() {
      this._setConnectionState("connected");
      this.log("transport", `connected to ${this.endpointURL()}`);
      const authPromise = this._authPromise || (this.accessToken && !this.accessTokenValue ? this.setAuth() : Promise.resolve());
      authPromise.then(() => {
        this.flushSendBuffer();
      }).catch((e) => {
        this.log("error", "error waiting for auth on connect", e);
        this.flushSendBuffer();
      });
      this._clearTimer("reconnect");
      if (!this.worker) {
        this._startHeartbeat();
      } else {
        if (!this.workerRef) {
          this._startWorkerHeartbeat();
        }
      }
      this._triggerStateCallbacks("open");
    }
    _startHeartbeat() {
      this.heartbeatTimer && clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
    }
    _startWorkerHeartbeat() {
      if (this.workerUrl) {
        this.log("worker", `starting worker for from ${this.workerUrl}`);
      } else {
        this.log("worker", `starting default worker`);
      }
      const objectUrl = this._workerObjectUrl(this.workerUrl);
      this.workerRef = new Worker(objectUrl);
      this.workerRef.onerror = (error) => {
        this.log("worker", "worker error", error.message);
        this.workerRef.terminate();
      };
      this.workerRef.onmessage = (event) => {
        if (event.data.event === "keepAlive") {
          this.sendHeartbeat();
        }
      };
      this.workerRef.postMessage({
        event: "start",
        interval: this.heartbeatIntervalMs
      });
    }
    _onConnClose(event) {
      var _a;
      this._setConnectionState("disconnected");
      this.log("transport", "close", event);
      this._triggerChanError();
      this._clearTimer("heartbeat");
      if (!this._wasManualDisconnect) {
        (_a = this.reconnectTimer) === null || _a === undefined || _a.scheduleTimeout();
      }
      this._triggerStateCallbacks("close", event);
    }
    _onConnError(error) {
      this._setConnectionState("disconnected");
      this.log("transport", `${error}`);
      this._triggerChanError();
      this._triggerStateCallbacks("error", error);
    }
    _triggerChanError() {
      this.channels.forEach((channel) => channel._trigger(constants_1.CHANNEL_EVENTS.error));
    }
    _appendParams(url, params) {
      if (Object.keys(params).length === 0) {
        return url;
      }
      const prefix = url.match(/\?/) ? "&" : "?";
      const query = new URLSearchParams(params);
      return `${url}${prefix}${query}`;
    }
    _workerObjectUrl(url) {
      let result_url;
      if (url) {
        result_url = url;
      } else {
        const blob = new Blob([WORKER_SCRIPT], { type: "application/javascript" });
        result_url = URL.createObjectURL(blob);
      }
      return result_url;
    }
    _setConnectionState(state, manual = false) {
      this._connectionState = state;
      if (state === "connecting") {
        this._wasManualDisconnect = false;
      } else if (state === "disconnecting") {
        this._wasManualDisconnect = manual;
      }
    }
    async _performAuth(token = null) {
      let tokenToSend;
      if (token) {
        tokenToSend = token;
      } else if (this.accessToken) {
        tokenToSend = await this.accessToken();
      } else {
        tokenToSend = this.accessTokenValue;
      }
      if (this.accessTokenValue != tokenToSend) {
        this.accessTokenValue = tokenToSend;
        this.channels.forEach((channel) => {
          const payload = {
            access_token: tokenToSend,
            version: constants_1.DEFAULT_VERSION
          };
          tokenToSend && channel.updateJoinPayload(payload);
          if (channel.joinedOnce && channel._isJoined()) {
            channel._push(constants_1.CHANNEL_EVENTS.access_token, {
              access_token: tokenToSend
            });
          }
        });
      }
    }
    async _waitForAuthIfNeeded() {
      if (this._authPromise) {
        await this._authPromise;
      }
    }
    _setAuthSafely(context = "general") {
      this.setAuth().catch((e) => {
        this.log("error", `error setting auth in ${context}`, e);
      });
    }
    _triggerStateCallbacks(event, data) {
      try {
        this.stateChangeCallbacks[event].forEach((callback) => {
          try {
            callback(data);
          } catch (e) {
            this.log("error", `error in ${event} callback`, e);
          }
        });
      } catch (e) {
        this.log("error", `error triggering ${event} callbacks`, e);
      }
    }
    _setupReconnectionTimer() {
      this.reconnectTimer = new timer_1.default(async () => {
        setTimeout(async () => {
          await this._waitForAuthIfNeeded();
          if (!this.isConnected()) {
            this.connect();
          }
        }, CONNECTION_TIMEOUTS.RECONNECT_DELAY);
      }, this.reconnectAfterMs);
    }
    _initializeOptions(options) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      this.transport = (_a = options === null || options === undefined ? undefined : options.transport) !== null && _a !== undefined ? _a : null;
      this.timeout = (_b = options === null || options === undefined ? undefined : options.timeout) !== null && _b !== undefined ? _b : constants_1.DEFAULT_TIMEOUT;
      this.heartbeatIntervalMs = (_c = options === null || options === undefined ? undefined : options.heartbeatIntervalMs) !== null && _c !== undefined ? _c : CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;
      this.worker = (_d = options === null || options === undefined ? undefined : options.worker) !== null && _d !== undefined ? _d : false;
      this.accessToken = (_e = options === null || options === undefined ? undefined : options.accessToken) !== null && _e !== undefined ? _e : null;
      this.heartbeatCallback = (_f = options === null || options === undefined ? undefined : options.heartbeatCallback) !== null && _f !== undefined ? _f : noop;
      this.vsn = (_g = options === null || options === undefined ? undefined : options.vsn) !== null && _g !== undefined ? _g : constants_1.DEFAULT_VSN;
      if (options === null || options === undefined ? undefined : options.params)
        this.params = options.params;
      if (options === null || options === undefined ? undefined : options.logger)
        this.logger = options.logger;
      if ((options === null || options === undefined ? undefined : options.logLevel) || (options === null || options === undefined ? undefined : options.log_level)) {
        this.logLevel = options.logLevel || options.log_level;
        this.params = Object.assign(Object.assign({}, this.params), { log_level: this.logLevel });
      }
      this.reconnectAfterMs = (_h = options === null || options === undefined ? undefined : options.reconnectAfterMs) !== null && _h !== undefined ? _h : (tries) => {
        return RECONNECT_INTERVALS[tries - 1] || DEFAULT_RECONNECT_FALLBACK;
      };
      switch (this.vsn) {
        case constants_1.VSN_1_0_0:
          this.encode = (_j = options === null || options === undefined ? undefined : options.encode) !== null && _j !== undefined ? _j : (payload, callback) => {
            return callback(JSON.stringify(payload));
          };
          this.decode = (_k = options === null || options === undefined ? undefined : options.decode) !== null && _k !== undefined ? _k : (payload, callback) => {
            return callback(JSON.parse(payload));
          };
          break;
        case constants_1.VSN_2_0_0:
          this.encode = (_l = options === null || options === undefined ? undefined : options.encode) !== null && _l !== undefined ? _l : this.serializer.encode.bind(this.serializer);
          this.decode = (_m = options === null || options === undefined ? undefined : options.decode) !== null && _m !== undefined ? _m : this.serializer.decode.bind(this.serializer);
          break;
        default:
          throw new Error(`Unsupported serializer version: ${this.vsn}`);
      }
      if (this.worker) {
        if (typeof window !== "undefined" && !window.Worker) {
          throw new Error("Web Worker is not supported");
        }
        this.workerUrl = options === null || options === undefined ? undefined : options.workerUrl;
      }
    }
  }
  exports2.default = RealtimeClient;
});

// backend/node_modules/@supabase/realtime-js/dist/main/index.js
var require_main2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.WebSocketFactory = exports2.REALTIME_CHANNEL_STATES = exports2.REALTIME_SUBSCRIBE_STATES = exports2.REALTIME_PRESENCE_LISTEN_EVENTS = exports2.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = exports2.REALTIME_LISTEN_TYPES = exports2.RealtimeClient = exports2.RealtimeChannel = exports2.RealtimePresence = undefined;
  var tslib_1 = require_tslib();
  var RealtimeClient_1 = tslib_1.__importDefault(require_RealtimeClient());
  exports2.RealtimeClient = RealtimeClient_1.default;
  var RealtimeChannel_1 = tslib_1.__importStar(require_RealtimeChannel());
  exports2.RealtimeChannel = RealtimeChannel_1.default;
  Object.defineProperty(exports2, "REALTIME_LISTEN_TYPES", { enumerable: true, get: function() {
    return RealtimeChannel_1.REALTIME_LISTEN_TYPES;
  } });
  Object.defineProperty(exports2, "REALTIME_POSTGRES_CHANGES_LISTEN_EVENT", { enumerable: true, get: function() {
    return RealtimeChannel_1.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;
  } });
  Object.defineProperty(exports2, "REALTIME_SUBSCRIBE_STATES", { enumerable: true, get: function() {
    return RealtimeChannel_1.REALTIME_SUBSCRIBE_STATES;
  } });
  Object.defineProperty(exports2, "REALTIME_CHANNEL_STATES", { enumerable: true, get: function() {
    return RealtimeChannel_1.REALTIME_CHANNEL_STATES;
  } });
  var RealtimePresence_1 = tslib_1.__importStar(require_RealtimePresence());
  exports2.RealtimePresence = RealtimePresence_1.default;
  Object.defineProperty(exports2, "REALTIME_PRESENCE_LISTEN_EVENTS", { enumerable: true, get: function() {
    return RealtimePresence_1.REALTIME_PRESENCE_LISTEN_EVENTS;
  } });
  var websocket_factory_1 = tslib_1.__importDefault(require_websocket_factory());
  exports2.WebSocketFactory = websocket_factory_1.default;
});

// backend/node_modules/@supabase/storage-js/dist/main/lib/errors.js
var require_errors = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.StorageUnknownError = exports2.StorageApiError = exports2.StorageError = undefined;
  exports2.isStorageError = isStorageError;

  class StorageError extends Error {
    constructor(message) {
      super(message);
      this.__isStorageError = true;
      this.name = "StorageError";
    }
  }
  exports2.StorageError = StorageError;
  function isStorageError(error) {
    return typeof error === "object" && error !== null && "__isStorageError" in error;
  }

  class StorageApiError extends StorageError {
    constructor(message, status, statusCode) {
      super(message);
      this.name = "StorageApiError";
      this.status = status;
      this.statusCode = statusCode;
    }
    toJSON() {
      return {
        name: this.name,
        message: this.message,
        status: this.status,
        statusCode: this.statusCode
      };
    }
  }
  exports2.StorageApiError = StorageApiError;

  class StorageUnknownError extends StorageError {
    constructor(message, originalError) {
      super(message);
      this.name = "StorageUnknownError";
      this.originalError = originalError;
    }
  }
  exports2.StorageUnknownError = StorageUnknownError;
});

// backend/node_modules/@supabase/storage-js/dist/main/lib/helpers.js
var require_helpers = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.isValidBucketName = exports2.isPlainObject = exports2.recursiveToCamel = exports2.resolveResponse = exports2.resolveFetch = undefined;
  var resolveFetch = (customFetch) => {
    if (customFetch) {
      return (...args) => customFetch(...args);
    }
    return (...args) => fetch(...args);
  };
  exports2.resolveFetch = resolveFetch;
  var resolveResponse = () => {
    return Response;
  };
  exports2.resolveResponse = resolveResponse;
  var recursiveToCamel = (item) => {
    if (Array.isArray(item)) {
      return item.map((el) => (0, exports2.recursiveToCamel)(el));
    } else if (typeof item === "function" || item !== Object(item)) {
      return item;
    }
    const result = {};
    Object.entries(item).forEach(([key, value]) => {
      const newKey = key.replace(/([-_][a-z])/gi, (c) => c.toUpperCase().replace(/[-_]/g, ""));
      result[newKey] = (0, exports2.recursiveToCamel)(value);
    });
    return result;
  };
  exports2.recursiveToCamel = recursiveToCamel;
  var isPlainObject = (value) => {
    if (typeof value !== "object" || value === null) {
      return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
  };
  exports2.isPlainObject = isPlainObject;
  var isValidBucketName = (bucketName) => {
    if (!bucketName || typeof bucketName !== "string") {
      return false;
    }
    if (bucketName.length === 0 || bucketName.length > 100) {
      return false;
    }
    if (bucketName.trim() !== bucketName) {
      return false;
    }
    if (bucketName.includes("/") || bucketName.includes("\\")) {
      return false;
    }
    const bucketNameRegex = /^[\w!.\*'() &$@=;:+,?-]+$/;
    return bucketNameRegex.test(bucketName);
  };
  exports2.isValidBucketName = isValidBucketName;
});

// backend/node_modules/@supabase/storage-js/dist/main/lib/fetch.js
var require_fetch = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.get = get;
  exports2.post = post;
  exports2.put = put;
  exports2.head = head;
  exports2.remove = remove;
  var tslib_1 = require_tslib();
  var errors_1 = require_errors();
  var helpers_1 = require_helpers();
  var _getErrorMessage = (err) => {
    var _a;
    return err.msg || err.message || err.error_description || (typeof err.error === "string" ? err.error : (_a = err.error) === null || _a === undefined ? undefined : _a.message) || JSON.stringify(err);
  };
  var handleError = (error, reject, options) => tslib_1.__awaiter(undefined, undefined, undefined, function* () {
    const Res = yield (0, helpers_1.resolveResponse)();
    if (error instanceof Res && !(options === null || options === undefined ? undefined : options.noResolveJson)) {
      error.json().then((err) => {
        const status = error.status || 500;
        const statusCode = (err === null || err === undefined ? undefined : err.statusCode) || status + "";
        reject(new errors_1.StorageApiError(_getErrorMessage(err), status, statusCode));
      }).catch((err) => {
        reject(new errors_1.StorageUnknownError(_getErrorMessage(err), err));
      });
    } else {
      reject(new errors_1.StorageUnknownError(_getErrorMessage(error), error));
    }
  });
  var _getRequestParams = (method, options, parameters, body) => {
    const params = { method, headers: (options === null || options === undefined ? undefined : options.headers) || {} };
    if (method === "GET" || !body) {
      return params;
    }
    if ((0, helpers_1.isPlainObject)(body)) {
      params.headers = Object.assign({ "Content-Type": "application/json" }, options === null || options === undefined ? undefined : options.headers);
      params.body = JSON.stringify(body);
    } else {
      params.body = body;
    }
    if (options === null || options === undefined ? undefined : options.duplex) {
      params.duplex = options.duplex;
    }
    return Object.assign(Object.assign({}, params), parameters);
  };
  function _handleRequest(fetcher, method, url, options, parameters, body) {
    return tslib_1.__awaiter(this, undefined, undefined, function* () {
      return new Promise((resolve, reject) => {
        fetcher(url, _getRequestParams(method, options, parameters, body)).then((result) => {
          if (!result.ok)
            throw result;
          if (options === null || options === undefined ? undefined : options.noResolveJson)
            return result;
          return result.json();
        }).then((data) => resolve(data)).catch((error) => handleError(error, reject, options));
      });
    });
  }
  function get(fetcher, url, options, parameters) {
    return tslib_1.__awaiter(this, undefined, undefined, function* () {
      return _handleRequest(fetcher, "GET", url, options, parameters);
    });
  }
  function post(fetcher, url, body, options, parameters) {
    return tslib_1.__awaiter(this, undefined, undefined, function* () {
      return _handleRequest(fetcher, "POST", url, options, parameters, body);
    });
  }
  function put(fetcher, url, body, options, parameters) {
    return tslib_1.__awaiter(this, undefined, undefined, function* () {
      return _handleRequest(fetcher, "PUT", url, options, parameters, body);
    });
  }
  function head(fetcher, url, options, parameters) {
    return tslib_1.__awaiter(this, undefined, undefined, function* () {
      return _handleRequest(fetcher, "HEAD", url, Object.assign(Object.assign({}, options), { noResolveJson: true }), parameters);
    });
  }
  function remove(fetcher, url, body, options, parameters) {
    return tslib_1.__awaiter(this, undefined, undefined, function* () {
      return _handleRequest(fetcher, "DELETE", url, options, parameters, body);
    });
  }
});

// backend/node_modules/@supabase/storage-js/dist/main/packages/StreamDownloadBuilder.js
var require_StreamDownloadBuilder = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  var errors_1 = require_errors();

  class StreamDownloadBuilder {
    constructor(downloadFn, shouldThrowOnError) {
      this.downloadFn = downloadFn;
      this.shouldThrowOnError = shouldThrowOnError;
    }
    then(onfulfilled, onrejected) {
      return this.execute().then(onfulfilled, onrejected);
    }
    execute() {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          const result = yield this.downloadFn();
          return {
            data: result.body,
            error: null
          };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
  }
  exports2.default = StreamDownloadBuilder;
});

// backend/node_modules/@supabase/storage-js/dist/main/packages/BlobDownloadBuilder.js
var require_BlobDownloadBuilder = __commonJS((exports2) => {
  var _a;
  Object.defineProperty(exports2, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  var errors_1 = require_errors();
  var StreamDownloadBuilder_1 = tslib_1.__importDefault(require_StreamDownloadBuilder());

  class BlobDownloadBuilder {
    constructor(downloadFn, shouldThrowOnError) {
      this.downloadFn = downloadFn;
      this.shouldThrowOnError = shouldThrowOnError;
      this[_a] = "BlobDownloadBuilder";
      this.promise = null;
    }
    asStream() {
      return new StreamDownloadBuilder_1.default(this.downloadFn, this.shouldThrowOnError);
    }
    then(onfulfilled, onrejected) {
      return this.getPromise().then(onfulfilled, onrejected);
    }
    catch(onrejected) {
      return this.getPromise().catch(onrejected);
    }
    finally(onfinally) {
      return this.getPromise().finally(onfinally);
    }
    getPromise() {
      if (!this.promise) {
        this.promise = this.execute();
      }
      return this.promise;
    }
    execute() {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          const result = yield this.downloadFn();
          return {
            data: yield result.blob(),
            error: null
          };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
  }
  _a = Symbol.toStringTag;
  exports2.default = BlobDownloadBuilder;
});

// backend/node_modules/@supabase/storage-js/dist/main/packages/StorageFileApi.js
var require_StorageFileApi = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  var errors_1 = require_errors();
  var fetch_1 = require_fetch();
  var helpers_1 = require_helpers();
  var BlobDownloadBuilder_1 = tslib_1.__importDefault(require_BlobDownloadBuilder());
  var DEFAULT_SEARCH_OPTIONS = {
    limit: 100,
    offset: 0,
    sortBy: {
      column: "name",
      order: "asc"
    }
  };
  var DEFAULT_FILE_OPTIONS = {
    cacheControl: "3600",
    contentType: "text/plain;charset=UTF-8",
    upsert: false
  };

  class StorageFileApi {
    constructor(url, headers = {}, bucketId, fetch2) {
      this.shouldThrowOnError = false;
      this.url = url;
      this.headers = headers;
      this.bucketId = bucketId;
      this.fetch = (0, helpers_1.resolveFetch)(fetch2);
    }
    throwOnError() {
      this.shouldThrowOnError = true;
      return this;
    }
    uploadOrUpdate(method, path, fileBody, fileOptions) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          let body;
          const options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);
          let headers = Object.assign(Object.assign({}, this.headers), method === "POST" && { "x-upsert": String(options.upsert) });
          const metadata = options.metadata;
          if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
            body = new FormData;
            body.append("cacheControl", options.cacheControl);
            if (metadata) {
              body.append("metadata", this.encodeMetadata(metadata));
            }
            body.append("", fileBody);
          } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
            body = fileBody;
            if (!body.has("cacheControl")) {
              body.append("cacheControl", options.cacheControl);
            }
            if (metadata && !body.has("metadata")) {
              body.append("metadata", this.encodeMetadata(metadata));
            }
          } else {
            body = fileBody;
            headers["cache-control"] = `max-age=${options.cacheControl}`;
            headers["content-type"] = options.contentType;
            if (metadata) {
              headers["x-metadata"] = this.toBase64(this.encodeMetadata(metadata));
            }
            const isStream = typeof ReadableStream !== "undefined" && body instanceof ReadableStream || body && typeof body === "object" && "pipe" in body && typeof body.pipe === "function";
            if (isStream && !options.duplex) {
              options.duplex = "half";
            }
          }
          if (fileOptions === null || fileOptions === undefined ? undefined : fileOptions.headers) {
            headers = Object.assign(Object.assign({}, headers), fileOptions.headers);
          }
          const cleanPath = this._removeEmptyFolders(path);
          const _path = this._getFinalPath(cleanPath);
          const data = yield (method == "PUT" ? fetch_1.put : fetch_1.post)(this.fetch, `${this.url}/object/${_path}`, body, Object.assign({ headers }, (options === null || options === undefined ? undefined : options.duplex) ? { duplex: options.duplex } : {}));
          return {
            data: { path: cleanPath, id: data.Id, fullPath: data.Key },
            error: null
          };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    upload(path, fileBody, fileOptions) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        return this.uploadOrUpdate("POST", path, fileBody, fileOptions);
      });
    }
    uploadToSignedUrl(path, token, fileBody, fileOptions) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        const cleanPath = this._removeEmptyFolders(path);
        const _path = this._getFinalPath(cleanPath);
        const url = new URL(this.url + `/object/upload/sign/${_path}`);
        url.searchParams.set("token", token);
        try {
          let body;
          const options = Object.assign({ upsert: DEFAULT_FILE_OPTIONS.upsert }, fileOptions);
          const headers = Object.assign(Object.assign({}, this.headers), { "x-upsert": String(options.upsert) });
          if (typeof Blob !== "undefined" && fileBody instanceof Blob) {
            body = new FormData;
            body.append("cacheControl", options.cacheControl);
            body.append("", fileBody);
          } else if (typeof FormData !== "undefined" && fileBody instanceof FormData) {
            body = fileBody;
            body.append("cacheControl", options.cacheControl);
          } else {
            body = fileBody;
            headers["cache-control"] = `max-age=${options.cacheControl}`;
            headers["content-type"] = options.contentType;
          }
          const data = yield (0, fetch_1.put)(this.fetch, url.toString(), body, { headers });
          return {
            data: { path: cleanPath, fullPath: data.Key },
            error: null
          };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    createSignedUploadUrl(path, options) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          let _path = this._getFinalPath(path);
          const headers = Object.assign({}, this.headers);
          if (options === null || options === undefined ? undefined : options.upsert) {
            headers["x-upsert"] = "true";
          }
          const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/object/upload/sign/${_path}`, {}, { headers });
          const url = new URL(this.url + data.url);
          const token = url.searchParams.get("token");
          if (!token) {
            throw new errors_1.StorageError("No token returned by API");
          }
          return { data: { signedUrl: url.toString(), path, token }, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    update(path, fileBody, fileOptions) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        return this.uploadOrUpdate("PUT", path, fileBody, fileOptions);
      });
    }
    move(fromPath, toPath, options) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/object/move`, {
            bucketId: this.bucketId,
            sourceKey: fromPath,
            destinationKey: toPath,
            destinationBucket: options === null || options === undefined ? undefined : options.destinationBucket
          }, { headers: this.headers });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    copy(fromPath, toPath, options) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/object/copy`, {
            bucketId: this.bucketId,
            sourceKey: fromPath,
            destinationKey: toPath,
            destinationBucket: options === null || options === undefined ? undefined : options.destinationBucket
          }, { headers: this.headers });
          return { data: { path: data.Key }, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    createSignedUrl(path, expiresIn, options) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          let _path = this._getFinalPath(path);
          let data = yield (0, fetch_1.post)(this.fetch, `${this.url}/object/sign/${_path}`, Object.assign({ expiresIn }, (options === null || options === undefined ? undefined : options.transform) ? { transform: options.transform } : {}), { headers: this.headers });
          const downloadQueryParam = (options === null || options === undefined ? undefined : options.download) ? `&download=${options.download === true ? "" : options.download}` : "";
          const signedUrl = encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`);
          data = { signedUrl };
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    createSignedUrls(paths, expiresIn, options) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/object/sign/${this.bucketId}`, { expiresIn, paths }, { headers: this.headers });
          const downloadQueryParam = (options === null || options === undefined ? undefined : options.download) ? `&download=${options.download === true ? "" : options.download}` : "";
          return {
            data: data.map((datum) => Object.assign(Object.assign({}, datum), { signedUrl: datum.signedURL ? encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`) : null })),
            error: null
          };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    download(path, options) {
      const wantsTransformation = typeof (options === null || options === undefined ? undefined : options.transform) !== "undefined";
      const renderPath = wantsTransformation ? "render/image/authenticated" : "object";
      const transformationQuery = this.transformOptsToQueryString((options === null || options === undefined ? undefined : options.transform) || {});
      const queryString = transformationQuery ? `?${transformationQuery}` : "";
      const _path = this._getFinalPath(path);
      const downloadFn = () => (0, fetch_1.get)(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {
        headers: this.headers,
        noResolveJson: true
      });
      return new BlobDownloadBuilder_1.default(downloadFn, this.shouldThrowOnError);
    }
    info(path) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        const _path = this._getFinalPath(path);
        try {
          const data = yield (0, fetch_1.get)(this.fetch, `${this.url}/object/info/${_path}`, {
            headers: this.headers
          });
          return { data: (0, helpers_1.recursiveToCamel)(data), error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    exists(path) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        const _path = this._getFinalPath(path);
        try {
          yield (0, fetch_1.head)(this.fetch, `${this.url}/object/${_path}`, {
            headers: this.headers
          });
          return { data: true, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageError)(error) && error instanceof errors_1.StorageUnknownError) {
            const originalError = error.originalError;
            if ([400, 404].includes(originalError === null || originalError === undefined ? undefined : originalError.status)) {
              return { data: false, error };
            }
          }
          throw error;
        }
      });
    }
    getPublicUrl(path, options) {
      const _path = this._getFinalPath(path);
      const _queryString = [];
      const downloadQueryParam = (options === null || options === undefined ? undefined : options.download) ? `download=${options.download === true ? "" : options.download}` : "";
      if (downloadQueryParam !== "") {
        _queryString.push(downloadQueryParam);
      }
      const wantsTransformation = typeof (options === null || options === undefined ? undefined : options.transform) !== "undefined";
      const renderPath = wantsTransformation ? "render/image" : "object";
      const transformationQuery = this.transformOptsToQueryString((options === null || options === undefined ? undefined : options.transform) || {});
      if (transformationQuery !== "") {
        _queryString.push(transformationQuery);
      }
      let queryString = _queryString.join("&");
      if (queryString !== "") {
        queryString = `?${queryString}`;
      }
      return {
        data: { publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`) }
      };
    }
    remove(paths) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          const data = yield (0, fetch_1.remove)(this.fetch, `${this.url}/object/${this.bucketId}`, { prefixes: paths }, { headers: this.headers });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    list(path, options, parameters) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          const body = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), { prefix: path || "" });
          const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/object/list/${this.bucketId}`, body, { headers: this.headers }, parameters);
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    listV2(options, parameters) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          const body = Object.assign({}, options);
          const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/object/list-v2/${this.bucketId}`, body, { headers: this.headers }, parameters);
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    encodeMetadata(metadata) {
      return JSON.stringify(metadata);
    }
    toBase64(data) {
      if (typeof Buffer !== "undefined") {
        return Buffer.from(data).toString("base64");
      }
      return btoa(data);
    }
    _getFinalPath(path) {
      return `${this.bucketId}/${path.replace(/^\/+/, "")}`;
    }
    _removeEmptyFolders(path) {
      return path.replace(/^\/|\/$/g, "").replace(/\/+/g, "/");
    }
    transformOptsToQueryString(transform) {
      const params = [];
      if (transform.width) {
        params.push(`width=${transform.width}`);
      }
      if (transform.height) {
        params.push(`height=${transform.height}`);
      }
      if (transform.resize) {
        params.push(`resize=${transform.resize}`);
      }
      if (transform.format) {
        params.push(`format=${transform.format}`);
      }
      if (transform.quality) {
        params.push(`quality=${transform.quality}`);
      }
      return params.join("&");
    }
  }
  exports2.default = StorageFileApi;
});

// backend/node_modules/@supabase/storage-js/dist/main/lib/version.js
var require_version2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.version = undefined;
  exports2.version = "2.86.0";
});

// backend/node_modules/@supabase/storage-js/dist/main/lib/constants.js
var require_constants2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.DEFAULT_HEADERS = undefined;
  var version_1 = require_version2();
  exports2.DEFAULT_HEADERS = {
    "X-Client-Info": `storage-js/${version_1.version}`
  };
});

// backend/node_modules/@supabase/storage-js/dist/main/packages/StorageBucketApi.js
var require_StorageBucketApi = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  var constants_1 = require_constants2();
  var errors_1 = require_errors();
  var fetch_1 = require_fetch();
  var helpers_1 = require_helpers();

  class StorageBucketApi {
    constructor(url, headers = {}, fetch2, opts) {
      this.shouldThrowOnError = false;
      const baseUrl = new URL(url);
      if (opts === null || opts === undefined ? undefined : opts.useNewHostname) {
        const isSupabaseHost = /supabase\.(co|in|red)$/.test(baseUrl.hostname);
        if (isSupabaseHost && !baseUrl.hostname.includes("storage.supabase.")) {
          baseUrl.hostname = baseUrl.hostname.replace("supabase.", "storage.supabase.");
        }
      }
      this.url = baseUrl.href.replace(/\/$/, "");
      this.headers = Object.assign(Object.assign({}, constants_1.DEFAULT_HEADERS), headers);
      this.fetch = (0, helpers_1.resolveFetch)(fetch2);
    }
    throwOnError() {
      this.shouldThrowOnError = true;
      return this;
    }
    listBuckets(options) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          const queryString = this.listBucketOptionsToQueryString(options);
          const data = yield (0, fetch_1.get)(this.fetch, `${this.url}/bucket${queryString}`, {
            headers: this.headers
          });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    getBucket(id) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          const data = yield (0, fetch_1.get)(this.fetch, `${this.url}/bucket/${id}`, { headers: this.headers });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    createBucket(id_1) {
      return tslib_1.__awaiter(this, arguments, undefined, function* (id, options = {
        public: false
      }) {
        try {
          const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/bucket`, {
            id,
            name: id,
            type: options.type,
            public: options.public,
            file_size_limit: options.fileSizeLimit,
            allowed_mime_types: options.allowedMimeTypes
          }, { headers: this.headers });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    updateBucket(id, options) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          const data = yield (0, fetch_1.put)(this.fetch, `${this.url}/bucket/${id}`, {
            id,
            name: id,
            public: options.public,
            file_size_limit: options.fileSizeLimit,
            allowed_mime_types: options.allowedMimeTypes
          }, { headers: this.headers });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    emptyBucket(id) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/bucket/${id}/empty`, {}, { headers: this.headers });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    deleteBucket(id) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          const data = yield (0, fetch_1.remove)(this.fetch, `${this.url}/bucket/${id}`, {}, { headers: this.headers });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    listBucketOptionsToQueryString(options) {
      const params = {};
      if (options) {
        if ("limit" in options) {
          params.limit = String(options.limit);
        }
        if ("offset" in options) {
          params.offset = String(options.offset);
        }
        if (options.search) {
          params.search = options.search;
        }
        if (options.sortColumn) {
          params.sortColumn = options.sortColumn;
        }
        if (options.sortOrder) {
          params.sortOrder = options.sortOrder;
        }
      }
      return Object.keys(params).length > 0 ? "?" + new URLSearchParams(params).toString() : "";
    }
  }
  exports2.default = StorageBucketApi;
});

// backend/node_modules/iceberg-js/dist/index.cjs
var require_dist = __commonJS((exports2) => {
  var IcebergError = class extends Error {
    constructor(message, opts) {
      super(message);
      this.name = "IcebergError";
      this.status = opts.status;
      this.icebergType = opts.icebergType;
      this.icebergCode = opts.icebergCode;
      this.details = opts.details;
      this.isCommitStateUnknown = opts.icebergType === "CommitStateUnknownException" || [500, 502, 504].includes(opts.status) && opts.icebergType?.includes("CommitState") === true;
    }
    isNotFound() {
      return this.status === 404;
    }
    isConflict() {
      return this.status === 409;
    }
    isAuthenticationTimeout() {
      return this.status === 419;
    }
  };
  function buildUrl(baseUrl, path, query) {
    const url = new URL(path, baseUrl);
    if (query) {
      for (const [key, value] of Object.entries(query)) {
        if (value !== undefined) {
          url.searchParams.set(key, value);
        }
      }
    }
    return url.toString();
  }
  async function buildAuthHeaders(auth) {
    if (!auth || auth.type === "none") {
      return {};
    }
    if (auth.type === "bearer") {
      return { Authorization: `Bearer ${auth.token}` };
    }
    if (auth.type === "header") {
      return { [auth.name]: auth.value };
    }
    if (auth.type === "custom") {
      return await auth.getHeaders();
    }
    return {};
  }
  function createFetchClient(options) {
    const fetchFn = options.fetchImpl ?? globalThis.fetch;
    return {
      async request({
        method,
        path,
        query,
        body,
        headers
      }) {
        const url = buildUrl(options.baseUrl, path, query);
        const authHeaders = await buildAuthHeaders(options.auth);
        const res = await fetchFn(url, {
          method,
          headers: {
            ...body ? { "Content-Type": "application/json" } : {},
            ...authHeaders,
            ...headers
          },
          body: body ? JSON.stringify(body) : undefined
        });
        const text = await res.text();
        const isJson = (res.headers.get("content-type") || "").includes("application/json");
        const data = isJson && text ? JSON.parse(text) : text;
        if (!res.ok) {
          const errBody = isJson ? data : undefined;
          const errorDetail = errBody?.error;
          throw new IcebergError(errorDetail?.message ?? `Request failed with status ${res.status}`, {
            status: res.status,
            icebergType: errorDetail?.type,
            icebergCode: errorDetail?.code,
            details: errBody
          });
        }
        return { status: res.status, headers: res.headers, data };
      }
    };
  }
  function namespaceToPath(namespace) {
    return namespace.join("\x1F");
  }
  var NamespaceOperations = class {
    constructor(client, prefix = "") {
      this.client = client;
      this.prefix = prefix;
    }
    async listNamespaces(parent) {
      const query = parent ? { parent: namespaceToPath(parent.namespace) } : undefined;
      const response = await this.client.request({
        method: "GET",
        path: `${this.prefix}/namespaces`,
        query
      });
      return response.data.namespaces.map((ns) => ({ namespace: ns }));
    }
    async createNamespace(id, metadata) {
      const request = {
        namespace: id.namespace,
        properties: metadata?.properties
      };
      const response = await this.client.request({
        method: "POST",
        path: `${this.prefix}/namespaces`,
        body: request
      });
      return response.data;
    }
    async dropNamespace(id) {
      await this.client.request({
        method: "DELETE",
        path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`
      });
    }
    async loadNamespaceMetadata(id) {
      const response = await this.client.request({
        method: "GET",
        path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`
      });
      return {
        properties: response.data.properties
      };
    }
    async namespaceExists(id) {
      try {
        await this.client.request({
          method: "HEAD",
          path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`
        });
        return true;
      } catch (error) {
        if (error instanceof IcebergError && error.status === 404) {
          return false;
        }
        throw error;
      }
    }
    async createNamespaceIfNotExists(id, metadata) {
      try {
        return await this.createNamespace(id, metadata);
      } catch (error) {
        if (error instanceof IcebergError && error.status === 409) {
          return;
        }
        throw error;
      }
    }
  };
  function namespaceToPath2(namespace) {
    return namespace.join("\x1F");
  }
  var TableOperations = class {
    constructor(client, prefix = "", accessDelegation) {
      this.client = client;
      this.prefix = prefix;
      this.accessDelegation = accessDelegation;
    }
    async listTables(namespace) {
      const response = await this.client.request({
        method: "GET",
        path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`
      });
      return response.data.identifiers;
    }
    async createTable(namespace, request) {
      const headers = {};
      if (this.accessDelegation) {
        headers["X-Iceberg-Access-Delegation"] = this.accessDelegation;
      }
      const response = await this.client.request({
        method: "POST",
        path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`,
        body: request,
        headers
      });
      return response.data.metadata;
    }
    async updateTable(id, request) {
      const response = await this.client.request({
        method: "POST",
        path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,
        body: request
      });
      return {
        "metadata-location": response.data["metadata-location"],
        metadata: response.data.metadata
      };
    }
    async dropTable(id, options) {
      await this.client.request({
        method: "DELETE",
        path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,
        query: { purgeRequested: String(options?.purge ?? false) }
      });
    }
    async loadTable(id) {
      const headers = {};
      if (this.accessDelegation) {
        headers["X-Iceberg-Access-Delegation"] = this.accessDelegation;
      }
      const response = await this.client.request({
        method: "GET",
        path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,
        headers
      });
      return response.data.metadata;
    }
    async tableExists(id) {
      const headers = {};
      if (this.accessDelegation) {
        headers["X-Iceberg-Access-Delegation"] = this.accessDelegation;
      }
      try {
        await this.client.request({
          method: "HEAD",
          path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,
          headers
        });
        return true;
      } catch (error) {
        if (error instanceof IcebergError && error.status === 404) {
          return false;
        }
        throw error;
      }
    }
    async createTableIfNotExists(namespace, request) {
      try {
        return await this.createTable(namespace, request);
      } catch (error) {
        if (error instanceof IcebergError && error.status === 409) {
          return await this.loadTable({ namespace: namespace.namespace, name: request.name });
        }
        throw error;
      }
    }
  };
  var IcebergRestCatalog = class {
    constructor(options) {
      let prefix = "v1";
      if (options.catalogName) {
        prefix += `/${options.catalogName}`;
      }
      const baseUrl = options.baseUrl.endsWith("/") ? options.baseUrl : `${options.baseUrl}/`;
      this.client = createFetchClient({
        baseUrl,
        auth: options.auth,
        fetchImpl: options.fetch
      });
      this.accessDelegation = options.accessDelegation?.join(",");
      this.namespaceOps = new NamespaceOperations(this.client, prefix);
      this.tableOps = new TableOperations(this.client, prefix, this.accessDelegation);
    }
    async listNamespaces(parent) {
      return this.namespaceOps.listNamespaces(parent);
    }
    async createNamespace(id, metadata) {
      return this.namespaceOps.createNamespace(id, metadata);
    }
    async dropNamespace(id) {
      await this.namespaceOps.dropNamespace(id);
    }
    async loadNamespaceMetadata(id) {
      return this.namespaceOps.loadNamespaceMetadata(id);
    }
    async listTables(namespace) {
      return this.tableOps.listTables(namespace);
    }
    async createTable(namespace, request) {
      return this.tableOps.createTable(namespace, request);
    }
    async updateTable(id, request) {
      return this.tableOps.updateTable(id, request);
    }
    async dropTable(id, options) {
      await this.tableOps.dropTable(id, options);
    }
    async loadTable(id) {
      return this.tableOps.loadTable(id);
    }
    async namespaceExists(id) {
      return this.namespaceOps.namespaceExists(id);
    }
    async tableExists(id) {
      return this.tableOps.tableExists(id);
    }
    async createNamespaceIfNotExists(id, metadata) {
      return this.namespaceOps.createNamespaceIfNotExists(id, metadata);
    }
    async createTableIfNotExists(namespace, request) {
      return this.tableOps.createTableIfNotExists(namespace, request);
    }
  };
  function getCurrentSchema(metadata) {
    return metadata.schemas.find((s) => s["schema-id"] === metadata["current-schema-id"]);
  }
  exports2.IcebergError = IcebergError;
  exports2.IcebergRestCatalog = IcebergRestCatalog;
  exports2.getCurrentSchema = getCurrentSchema;
});

// backend/node_modules/@supabase/storage-js/dist/main/packages/StorageAnalyticsClient.js
var require_StorageAnalyticsClient = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  var iceberg_js_1 = require_dist();
  var constants_1 = require_constants2();
  var errors_1 = require_errors();
  var fetch_1 = require_fetch();
  var helpers_1 = require_helpers();

  class StorageAnalyticsClient {
    constructor(url, headers = {}, fetch2) {
      this.shouldThrowOnError = false;
      this.url = url.replace(/\/$/, "");
      this.headers = Object.assign(Object.assign({}, constants_1.DEFAULT_HEADERS), headers);
      this.fetch = (0, helpers_1.resolveFetch)(fetch2);
    }
    throwOnError() {
      this.shouldThrowOnError = true;
      return this;
    }
    createBucket(name) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/bucket`, { name }, { headers: this.headers });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    listBuckets(options) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          const queryParams = new URLSearchParams;
          if ((options === null || options === undefined ? undefined : options.limit) !== undefined)
            queryParams.set("limit", options.limit.toString());
          if ((options === null || options === undefined ? undefined : options.offset) !== undefined)
            queryParams.set("offset", options.offset.toString());
          if (options === null || options === undefined ? undefined : options.sortColumn)
            queryParams.set("sortColumn", options.sortColumn);
          if (options === null || options === undefined ? undefined : options.sortOrder)
            queryParams.set("sortOrder", options.sortOrder);
          if (options === null || options === undefined ? undefined : options.search)
            queryParams.set("search", options.search);
          const queryString = queryParams.toString();
          const url = queryString ? `${this.url}/bucket?${queryString}` : `${this.url}/bucket`;
          const data = yield (0, fetch_1.get)(this.fetch, url, { headers: this.headers });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    deleteBucket(bucketName) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          const data = yield (0, fetch_1.remove)(this.fetch, `${this.url}/bucket/${bucketName}`, {}, { headers: this.headers });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    from(bucketName) {
      if (!(0, helpers_1.isValidBucketName)(bucketName)) {
        throw new errors_1.StorageError("Invalid bucket name: File, folder, and bucket names must follow AWS object key naming guidelines " + "and should avoid the use of any other characters.");
      }
      return new iceberg_js_1.IcebergRestCatalog({
        baseUrl: this.url,
        catalogName: bucketName,
        auth: {
          type: "custom",
          getHeaders: () => tslib_1.__awaiter(this, undefined, undefined, function* () {
            return this.headers;
          })
        },
        fetch: this.fetch
      });
    }
  }
  exports2.default = StorageAnalyticsClient;
});

// backend/node_modules/@supabase/storage-js/dist/main/lib/vectors/constants.js
var require_constants3 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.DEFAULT_HEADERS = undefined;
  var version_1 = require_version2();
  exports2.DEFAULT_HEADERS = {
    "X-Client-Info": `storage-js/${version_1.version}`,
    "Content-Type": "application/json"
  };
});

// backend/node_modules/@supabase/storage-js/dist/main/lib/vectors/errors.js
var require_errors2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.StorageVectorsErrorCode = exports2.StorageVectorsUnknownError = exports2.StorageVectorsApiError = exports2.StorageVectorsError = undefined;
  exports2.isStorageVectorsError = isStorageVectorsError;

  class StorageVectorsError extends Error {
    constructor(message) {
      super(message);
      this.__isStorageVectorsError = true;
      this.name = "StorageVectorsError";
    }
  }
  exports2.StorageVectorsError = StorageVectorsError;
  function isStorageVectorsError(error) {
    return typeof error === "object" && error !== null && "__isStorageVectorsError" in error;
  }

  class StorageVectorsApiError extends StorageVectorsError {
    constructor(message, status, statusCode) {
      super(message);
      this.name = "StorageVectorsApiError";
      this.status = status;
      this.statusCode = statusCode;
    }
    toJSON() {
      return {
        name: this.name,
        message: this.message,
        status: this.status,
        statusCode: this.statusCode
      };
    }
  }
  exports2.StorageVectorsApiError = StorageVectorsApiError;

  class StorageVectorsUnknownError extends StorageVectorsError {
    constructor(message, originalError) {
      super(message);
      this.name = "StorageVectorsUnknownError";
      this.originalError = originalError;
    }
  }
  exports2.StorageVectorsUnknownError = StorageVectorsUnknownError;
  var StorageVectorsErrorCode;
  (function(StorageVectorsErrorCode2) {
    StorageVectorsErrorCode2["InternalError"] = "InternalError";
    StorageVectorsErrorCode2["S3VectorConflictException"] = "S3VectorConflictException";
    StorageVectorsErrorCode2["S3VectorNotFoundException"] = "S3VectorNotFoundException";
    StorageVectorsErrorCode2["S3VectorBucketNotEmpty"] = "S3VectorBucketNotEmpty";
    StorageVectorsErrorCode2["S3VectorMaxBucketsExceeded"] = "S3VectorMaxBucketsExceeded";
    StorageVectorsErrorCode2["S3VectorMaxIndexesExceeded"] = "S3VectorMaxIndexesExceeded";
  })(StorageVectorsErrorCode || (exports2.StorageVectorsErrorCode = StorageVectorsErrorCode = {}));
});

// backend/node_modules/@supabase/storage-js/dist/main/lib/vectors/helpers.js
var require_helpers2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.validateVectorDimension = exports2.normalizeToFloat32 = exports2.isPlainObject = exports2.resolveResponse = exports2.resolveFetch = undefined;
  var resolveFetch = (customFetch) => {
    if (customFetch) {
      return (...args) => customFetch(...args);
    }
    return (...args) => fetch(...args);
  };
  exports2.resolveFetch = resolveFetch;
  var resolveResponse = () => {
    return Response;
  };
  exports2.resolveResponse = resolveResponse;
  var isPlainObject = (value) => {
    if (typeof value !== "object" || value === null) {
      return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
  };
  exports2.isPlainObject = isPlainObject;
  var normalizeToFloat32 = (values) => {
    return Array.from(new Float32Array(values));
  };
  exports2.normalizeToFloat32 = normalizeToFloat32;
  var validateVectorDimension = (vector, expectedDimension) => {
    if (expectedDimension !== undefined && vector.float32.length !== expectedDimension) {
      throw new Error(`Vector dimension mismatch: expected ${expectedDimension}, got ${vector.float32.length}`);
    }
  };
  exports2.validateVectorDimension = validateVectorDimension;
});

// backend/node_modules/@supabase/storage-js/dist/main/lib/vectors/fetch.js
var require_fetch2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.get = get;
  exports2.post = post;
  exports2.put = put;
  exports2.remove = remove;
  var tslib_1 = require_tslib();
  var errors_1 = require_errors2();
  var helpers_1 = require_helpers2();
  var _getErrorMessage = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
  var handleError = (error, reject, options) => tslib_1.__awaiter(undefined, undefined, undefined, function* () {
    const isResponseLike = error && typeof error === "object" && "status" in error && "ok" in error && typeof error.status === "number";
    if (isResponseLike && !(options === null || options === undefined ? undefined : options.noResolveJson)) {
      const status = error.status || 500;
      const responseError = error;
      if (typeof responseError.json === "function") {
        responseError.json().then((err) => {
          const statusCode = (err === null || err === undefined ? undefined : err.statusCode) || (err === null || err === undefined ? undefined : err.code) || status + "";
          reject(new errors_1.StorageVectorsApiError(_getErrorMessage(err), status, statusCode));
        }).catch(() => {
          const statusCode = status + "";
          const message = responseError.statusText || `HTTP ${status} error`;
          reject(new errors_1.StorageVectorsApiError(message, status, statusCode));
        });
      } else {
        const statusCode = status + "";
        const message = responseError.statusText || `HTTP ${status} error`;
        reject(new errors_1.StorageVectorsApiError(message, status, statusCode));
      }
    } else {
      reject(new errors_1.StorageVectorsUnknownError(_getErrorMessage(error), error));
    }
  });
  var _getRequestParams = (method, options, parameters, body) => {
    const params = { method, headers: (options === null || options === undefined ? undefined : options.headers) || {} };
    if (method === "GET" || !body) {
      return params;
    }
    if ((0, helpers_1.isPlainObject)(body)) {
      params.headers = Object.assign({ "Content-Type": "application/json" }, options === null || options === undefined ? undefined : options.headers);
      params.body = JSON.stringify(body);
    } else {
      params.body = body;
    }
    return Object.assign(Object.assign({}, params), parameters);
  };
  function _handleRequest(fetcher, method, url, options, parameters, body) {
    return tslib_1.__awaiter(this, undefined, undefined, function* () {
      return new Promise((resolve, reject) => {
        fetcher(url, _getRequestParams(method, options, parameters, body)).then((result) => {
          if (!result.ok)
            throw result;
          if (options === null || options === undefined ? undefined : options.noResolveJson)
            return result;
          const contentType = result.headers.get("content-type");
          if (!contentType || !contentType.includes("application/json")) {
            return {};
          }
          return result.json();
        }).then((data) => resolve(data)).catch((error) => handleError(error, reject, options));
      });
    });
  }
  function get(fetcher, url, options, parameters) {
    return tslib_1.__awaiter(this, undefined, undefined, function* () {
      return _handleRequest(fetcher, "GET", url, options, parameters);
    });
  }
  function post(fetcher, url, body, options, parameters) {
    return tslib_1.__awaiter(this, undefined, undefined, function* () {
      return _handleRequest(fetcher, "POST", url, options, parameters, body);
    });
  }
  function put(fetcher, url, body, options, parameters) {
    return tslib_1.__awaiter(this, undefined, undefined, function* () {
      return _handleRequest(fetcher, "PUT", url, options, parameters, body);
    });
  }
  function remove(fetcher, url, body, options, parameters) {
    return tslib_1.__awaiter(this, undefined, undefined, function* () {
      return _handleRequest(fetcher, "DELETE", url, options, parameters, body);
    });
  }
});

// backend/node_modules/@supabase/storage-js/dist/main/lib/vectors/VectorIndexApi.js
var require_VectorIndexApi = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  var constants_1 = require_constants3();
  var errors_1 = require_errors2();
  var fetch_1 = require_fetch2();
  var helpers_1 = require_helpers2();

  class VectorIndexApi {
    constructor(url, headers = {}, fetch2) {
      this.shouldThrowOnError = false;
      this.url = url.replace(/\/$/, "");
      this.headers = Object.assign(Object.assign({}, constants_1.DEFAULT_HEADERS), headers);
      this.fetch = (0, helpers_1.resolveFetch)(fetch2);
    }
    throwOnError() {
      this.shouldThrowOnError = true;
      return this;
    }
    createIndex(options) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/CreateIndex`, options, {
            headers: this.headers
          });
          return { data: data || {}, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageVectorsError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    getIndex(vectorBucketName, indexName) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/GetIndex`, { vectorBucketName, indexName }, { headers: this.headers });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageVectorsError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    listIndexes(options) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/ListIndexes`, options, {
            headers: this.headers
          });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageVectorsError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    deleteIndex(vectorBucketName, indexName) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/DeleteIndex`, { vectorBucketName, indexName }, { headers: this.headers });
          return { data: data || {}, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageVectorsError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
  }
  exports2.default = VectorIndexApi;
});

// backend/node_modules/@supabase/storage-js/dist/main/lib/vectors/VectorDataApi.js
var require_VectorDataApi = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  var constants_1 = require_constants3();
  var errors_1 = require_errors2();
  var fetch_1 = require_fetch2();
  var helpers_1 = require_helpers2();

  class VectorDataApi {
    constructor(url, headers = {}, fetch2) {
      this.shouldThrowOnError = false;
      this.url = url.replace(/\/$/, "");
      this.headers = Object.assign(Object.assign({}, constants_1.DEFAULT_HEADERS), headers);
      this.fetch = (0, helpers_1.resolveFetch)(fetch2);
    }
    throwOnError() {
      this.shouldThrowOnError = true;
      return this;
    }
    putVectors(options) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          if (options.vectors.length < 1 || options.vectors.length > 500) {
            throw new Error("Vector batch size must be between 1 and 500 items");
          }
          const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/PutVectors`, options, {
            headers: this.headers
          });
          return { data: data || {}, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageVectorsError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    getVectors(options) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/GetVectors`, options, {
            headers: this.headers
          });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageVectorsError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    listVectors(options) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          if (options.segmentCount !== undefined) {
            if (options.segmentCount < 1 || options.segmentCount > 16) {
              throw new Error("segmentCount must be between 1 and 16");
            }
            if (options.segmentIndex !== undefined) {
              if (options.segmentIndex < 0 || options.segmentIndex >= options.segmentCount) {
                throw new Error(`segmentIndex must be between 0 and ${options.segmentCount - 1}`);
              }
            }
          }
          const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/ListVectors`, options, {
            headers: this.headers
          });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageVectorsError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    queryVectors(options) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/QueryVectors`, options, {
            headers: this.headers
          });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageVectorsError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    deleteVectors(options) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          if (options.keys.length < 1 || options.keys.length > 500) {
            throw new Error("Keys batch size must be between 1 and 500 items");
          }
          const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/DeleteVectors`, options, {
            headers: this.headers
          });
          return { data: data || {}, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageVectorsError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
  }
  exports2.default = VectorDataApi;
});

// backend/node_modules/@supabase/storage-js/dist/main/lib/vectors/VectorBucketApi.js
var require_VectorBucketApi = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  var constants_1 = require_constants3();
  var errors_1 = require_errors2();
  var fetch_1 = require_fetch2();
  var helpers_1 = require_helpers2();

  class VectorBucketApi {
    constructor(url, headers = {}, fetch2) {
      this.shouldThrowOnError = false;
      this.url = url.replace(/\/$/, "");
      this.headers = Object.assign(Object.assign({}, constants_1.DEFAULT_HEADERS), headers);
      this.fetch = (0, helpers_1.resolveFetch)(fetch2);
    }
    throwOnError() {
      this.shouldThrowOnError = true;
      return this;
    }
    createBucket(vectorBucketName) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/CreateVectorBucket`, { vectorBucketName }, { headers: this.headers });
          return { data: data || {}, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageVectorsError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    getBucket(vectorBucketName) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/GetVectorBucket`, { vectorBucketName }, { headers: this.headers });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageVectorsError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    listBuckets() {
      return tslib_1.__awaiter(this, arguments, undefined, function* (options = {}) {
        try {
          const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/ListVectorBuckets`, options, {
            headers: this.headers
          });
          return { data, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageVectorsError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
    deleteBucket(vectorBucketName) {
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        try {
          const data = yield (0, fetch_1.post)(this.fetch, `${this.url}/DeleteVectorBucket`, { vectorBucketName }, { headers: this.headers });
          return { data: data || {}, error: null };
        } catch (error) {
          if (this.shouldThrowOnError) {
            throw error;
          }
          if ((0, errors_1.isStorageVectorsError)(error)) {
            return { data: null, error };
          }
          throw error;
        }
      });
    }
  }
  exports2.default = VectorBucketApi;
});

// backend/node_modules/@supabase/storage-js/dist/main/lib/vectors/StorageVectorsClient.js
var require_StorageVectorsClient = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.VectorIndexScope = exports2.VectorBucketScope = exports2.StorageVectorsClient = undefined;
  var tslib_1 = require_tslib();
  var VectorIndexApi_1 = tslib_1.__importDefault(require_VectorIndexApi());
  var VectorDataApi_1 = tslib_1.__importDefault(require_VectorDataApi());
  var VectorBucketApi_1 = tslib_1.__importDefault(require_VectorBucketApi());

  class StorageVectorsClient extends VectorBucketApi_1.default {
    constructor(url, options = {}) {
      super(url, options.headers || {}, options.fetch);
    }
    from(vectorBucketName) {
      return new VectorBucketScope(this.url, this.headers, vectorBucketName, this.fetch);
    }
    createBucket(vectorBucketName) {
      const _super = Object.create(null, {
        createBucket: { get: () => super.createBucket }
      });
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        return _super.createBucket.call(this, vectorBucketName);
      });
    }
    getBucket(vectorBucketName) {
      const _super = Object.create(null, {
        getBucket: { get: () => super.getBucket }
      });
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        return _super.getBucket.call(this, vectorBucketName);
      });
    }
    listBuckets() {
      const _super = Object.create(null, {
        listBuckets: { get: () => super.listBuckets }
      });
      return tslib_1.__awaiter(this, arguments, undefined, function* (options = {}) {
        return _super.listBuckets.call(this, options);
      });
    }
    deleteBucket(vectorBucketName) {
      const _super = Object.create(null, {
        deleteBucket: { get: () => super.deleteBucket }
      });
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        return _super.deleteBucket.call(this, vectorBucketName);
      });
    }
  }
  exports2.StorageVectorsClient = StorageVectorsClient;

  class VectorBucketScope extends VectorIndexApi_1.default {
    constructor(url, headers, vectorBucketName, fetch2) {
      super(url, headers, fetch2);
      this.vectorBucketName = vectorBucketName;
    }
    createIndex(options) {
      const _super = Object.create(null, {
        createIndex: { get: () => super.createIndex }
      });
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        return _super.createIndex.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName }));
      });
    }
    listIndexes() {
      const _super = Object.create(null, {
        listIndexes: { get: () => super.listIndexes }
      });
      return tslib_1.__awaiter(this, arguments, undefined, function* (options = {}) {
        return _super.listIndexes.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName }));
      });
    }
    getIndex(indexName) {
      const _super = Object.create(null, {
        getIndex: { get: () => super.getIndex }
      });
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        return _super.getIndex.call(this, this.vectorBucketName, indexName);
      });
    }
    deleteIndex(indexName) {
      const _super = Object.create(null, {
        deleteIndex: { get: () => super.deleteIndex }
      });
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        return _super.deleteIndex.call(this, this.vectorBucketName, indexName);
      });
    }
    index(indexName) {
      return new VectorIndexScope(this.url, this.headers, this.vectorBucketName, indexName, this.fetch);
    }
  }
  exports2.VectorBucketScope = VectorBucketScope;

  class VectorIndexScope extends VectorDataApi_1.default {
    constructor(url, headers, vectorBucketName, indexName, fetch2) {
      super(url, headers, fetch2);
      this.vectorBucketName = vectorBucketName;
      this.indexName = indexName;
    }
    putVectors(options) {
      const _super = Object.create(null, {
        putVectors: { get: () => super.putVectors }
      });
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        return _super.putVectors.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
      });
    }
    getVectors(options) {
      const _super = Object.create(null, {
        getVectors: { get: () => super.getVectors }
      });
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        return _super.getVectors.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
      });
    }
    listVectors() {
      const _super = Object.create(null, {
        listVectors: { get: () => super.listVectors }
      });
      return tslib_1.__awaiter(this, arguments, undefined, function* (options = {}) {
        return _super.listVectors.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
      });
    }
    queryVectors(options) {
      const _super = Object.create(null, {
        queryVectors: { get: () => super.queryVectors }
      });
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        return _super.queryVectors.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
      });
    }
    deleteVectors(options) {
      const _super = Object.create(null, {
        deleteVectors: { get: () => super.deleteVectors }
      });
      return tslib_1.__awaiter(this, undefined, undefined, function* () {
        return _super.deleteVectors.call(this, Object.assign(Object.assign({}, options), { vectorBucketName: this.vectorBucketName, indexName: this.indexName }));
      });
    }
  }
  exports2.VectorIndexScope = VectorIndexScope;
});

// backend/node_modules/@supabase/storage-js/dist/main/lib/vectors/index.js
var require_vectors = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.validateVectorDimension = exports2.normalizeToFloat32 = exports2.isPlainObject = exports2.resolveResponse = exports2.resolveFetch = exports2.isStorageVectorsError = exports2.StorageVectorsErrorCode = exports2.StorageVectorsUnknownError = exports2.StorageVectorsApiError = exports2.StorageVectorsError = exports2.VectorDataApi = exports2.VectorIndexApi = exports2.VectorBucketApi = exports2.VectorIndexScope = exports2.VectorBucketScope = exports2.StorageVectorsClient = undefined;
  var tslib_1 = require_tslib();
  var StorageVectorsClient_1 = require_StorageVectorsClient();
  Object.defineProperty(exports2, "StorageVectorsClient", { enumerable: true, get: function() {
    return StorageVectorsClient_1.StorageVectorsClient;
  } });
  Object.defineProperty(exports2, "VectorBucketScope", { enumerable: true, get: function() {
    return StorageVectorsClient_1.VectorBucketScope;
  } });
  Object.defineProperty(exports2, "VectorIndexScope", { enumerable: true, get: function() {
    return StorageVectorsClient_1.VectorIndexScope;
  } });
  var VectorBucketApi_1 = require_VectorBucketApi();
  Object.defineProperty(exports2, "VectorBucketApi", { enumerable: true, get: function() {
    return tslib_1.__importDefault(VectorBucketApi_1).default;
  } });
  var VectorIndexApi_1 = require_VectorIndexApi();
  Object.defineProperty(exports2, "VectorIndexApi", { enumerable: true, get: function() {
    return tslib_1.__importDefault(VectorIndexApi_1).default;
  } });
  var VectorDataApi_1 = require_VectorDataApi();
  Object.defineProperty(exports2, "VectorDataApi", { enumerable: true, get: function() {
    return tslib_1.__importDefault(VectorDataApi_1).default;
  } });
  var errors_1 = require_errors2();
  Object.defineProperty(exports2, "StorageVectorsError", { enumerable: true, get: function() {
    return errors_1.StorageVectorsError;
  } });
  Object.defineProperty(exports2, "StorageVectorsApiError", { enumerable: true, get: function() {
    return errors_1.StorageVectorsApiError;
  } });
  Object.defineProperty(exports2, "StorageVectorsUnknownError", { enumerable: true, get: function() {
    return errors_1.StorageVectorsUnknownError;
  } });
  Object.defineProperty(exports2, "StorageVectorsErrorCode", { enumerable: true, get: function() {
    return errors_1.StorageVectorsErrorCode;
  } });
  Object.defineProperty(exports2, "isStorageVectorsError", { enumerable: true, get: function() {
    return errors_1.isStorageVectorsError;
  } });
  var helpers_1 = require_helpers2();
  Object.defineProperty(exports2, "resolveFetch", { enumerable: true, get: function() {
    return helpers_1.resolveFetch;
  } });
  Object.defineProperty(exports2, "resolveResponse", { enumerable: true, get: function() {
    return helpers_1.resolveResponse;
  } });
  Object.defineProperty(exports2, "isPlainObject", { enumerable: true, get: function() {
    return helpers_1.isPlainObject;
  } });
  Object.defineProperty(exports2, "normalizeToFloat32", { enumerable: true, get: function() {
    return helpers_1.normalizeToFloat32;
  } });
  Object.defineProperty(exports2, "validateVectorDimension", { enumerable: true, get: function() {
    return helpers_1.validateVectorDimension;
  } });
});

// backend/node_modules/@supabase/storage-js/dist/main/StorageClient.js
var require_StorageClient = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.StorageClient = undefined;
  var tslib_1 = require_tslib();
  var StorageFileApi_1 = tslib_1.__importDefault(require_StorageFileApi());
  var StorageBucketApi_1 = tslib_1.__importDefault(require_StorageBucketApi());
  var StorageAnalyticsClient_1 = tslib_1.__importDefault(require_StorageAnalyticsClient());
  var vectors_1 = require_vectors();

  class StorageClient extends StorageBucketApi_1.default {
    constructor(url, headers = {}, fetch2, opts) {
      super(url, headers, fetch2, opts);
    }
    from(id) {
      return new StorageFileApi_1.default(this.url, this.headers, id, this.fetch);
    }
    get vectors() {
      return new vectors_1.StorageVectorsClient(this.url + "/vector", {
        headers: this.headers,
        fetch: this.fetch
      });
    }
    get analytics() {
      return new StorageAnalyticsClient_1.default(this.url + "/iceberg", this.headers, this.fetch);
    }
  }
  exports2.StorageClient = StorageClient;
});

// backend/node_modules/@supabase/storage-js/dist/main/lib/types.js
var require_types2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
});

// backend/node_modules/@supabase/storage-js/dist/main/index.js
var require_main3 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.StorageAnalyticsClient = exports2.StorageClient = undefined;
  var tslib_1 = require_tslib();
  var StorageClient_1 = require_StorageClient();
  Object.defineProperty(exports2, "StorageClient", { enumerable: true, get: function() {
    return StorageClient_1.StorageClient;
  } });
  var StorageAnalyticsClient_1 = require_StorageAnalyticsClient();
  Object.defineProperty(exports2, "StorageAnalyticsClient", { enumerable: true, get: function() {
    return tslib_1.__importDefault(StorageAnalyticsClient_1).default;
  } });
  tslib_1.__exportStar(require_types2(), exports2);
  tslib_1.__exportStar(require_errors(), exports2);
  tslib_1.__exportStar(require_vectors(), exports2);
});

// backend/node_modules/@supabase/supabase-js/dist/main/lib/version.js
var require_version3 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.version = undefined;
  exports2.version = "2.86.0";
});

// backend/node_modules/@supabase/supabase-js/dist/main/lib/constants.js
var require_constants4 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.DEFAULT_REALTIME_OPTIONS = exports2.DEFAULT_AUTH_OPTIONS = exports2.DEFAULT_DB_OPTIONS = exports2.DEFAULT_GLOBAL_OPTIONS = exports2.DEFAULT_HEADERS = undefined;
  var version_1 = require_version3();
  var JS_ENV = "";
  if (typeof Deno !== "undefined") {
    JS_ENV = "deno";
  } else if (typeof document !== "undefined") {
    JS_ENV = "web";
  } else if (typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    JS_ENV = "react-native";
  } else {
    JS_ENV = "node";
  }
  exports2.DEFAULT_HEADERS = { "X-Client-Info": `supabase-js-${JS_ENV}/${version_1.version}` };
  exports2.DEFAULT_GLOBAL_OPTIONS = {
    headers: exports2.DEFAULT_HEADERS
  };
  exports2.DEFAULT_DB_OPTIONS = {
    schema: "public"
  };
  exports2.DEFAULT_AUTH_OPTIONS = {
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true,
    flowType: "implicit"
  };
  exports2.DEFAULT_REALTIME_OPTIONS = {};
});

// backend/node_modules/@supabase/supabase-js/dist/main/lib/fetch.js
var require_fetch3 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.fetchWithAuth = exports2.resolveHeadersConstructor = exports2.resolveFetch = undefined;
  var resolveFetch = (customFetch) => {
    if (customFetch) {
      return (...args) => customFetch(...args);
    }
    return (...args) => fetch(...args);
  };
  exports2.resolveFetch = resolveFetch;
  var resolveHeadersConstructor = () => {
    return Headers;
  };
  exports2.resolveHeadersConstructor = resolveHeadersConstructor;
  var fetchWithAuth = (supabaseKey, getAccessToken, customFetch) => {
    const fetch2 = (0, exports2.resolveFetch)(customFetch);
    const HeadersConstructor = (0, exports2.resolveHeadersConstructor)();
    return async (input, init) => {
      var _a;
      const accessToken = (_a = await getAccessToken()) !== null && _a !== undefined ? _a : supabaseKey;
      let headers = new HeadersConstructor(init === null || init === undefined ? undefined : init.headers);
      if (!headers.has("apikey")) {
        headers.set("apikey", supabaseKey);
      }
      if (!headers.has("Authorization")) {
        headers.set("Authorization", `Bearer ${accessToken}`);
      }
      return fetch2(input, Object.assign(Object.assign({}, init), { headers }));
    };
  };
  exports2.fetchWithAuth = fetchWithAuth;
});

// backend/node_modules/@supabase/supabase-js/dist/main/lib/helpers.js
var require_helpers3 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.isBrowser = undefined;
  exports2.uuid = uuid;
  exports2.ensureTrailingSlash = ensureTrailingSlash;
  exports2.applySettingDefaults = applySettingDefaults;
  exports2.validateSupabaseUrl = validateSupabaseUrl;
  function uuid() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      var r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }
  function ensureTrailingSlash(url) {
    return url.endsWith("/") ? url : url + "/";
  }
  var isBrowser = () => typeof window !== "undefined";
  exports2.isBrowser = isBrowser;
  function applySettingDefaults(options, defaults) {
    var _a, _b;
    const { db: dbOptions, auth: authOptions, realtime: realtimeOptions, global: globalOptions } = options;
    const { db: DEFAULT_DB_OPTIONS, auth: DEFAULT_AUTH_OPTIONS, realtime: DEFAULT_REALTIME_OPTIONS, global: DEFAULT_GLOBAL_OPTIONS } = defaults;
    const result = {
      db: Object.assign(Object.assign({}, DEFAULT_DB_OPTIONS), dbOptions),
      auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), authOptions),
      realtime: Object.assign(Object.assign({}, DEFAULT_REALTIME_OPTIONS), realtimeOptions),
      storage: {},
      global: Object.assign(Object.assign(Object.assign({}, DEFAULT_GLOBAL_OPTIONS), globalOptions), { headers: Object.assign(Object.assign({}, (_a = DEFAULT_GLOBAL_OPTIONS === null || DEFAULT_GLOBAL_OPTIONS === undefined ? undefined : DEFAULT_GLOBAL_OPTIONS.headers) !== null && _a !== undefined ? _a : {}), (_b = globalOptions === null || globalOptions === undefined ? undefined : globalOptions.headers) !== null && _b !== undefined ? _b : {}) }),
      accessToken: async () => ""
    };
    if (options.accessToken) {
      result.accessToken = options.accessToken;
    } else {
      delete result.accessToken;
    }
    return result;
  }
  function validateSupabaseUrl(supabaseUrl) {
    const trimmedUrl = supabaseUrl === null || supabaseUrl === undefined ? undefined : supabaseUrl.trim();
    if (!trimmedUrl) {
      throw new Error("supabaseUrl is required.");
    }
    if (!trimmedUrl.match(/^https?:\/\//i)) {
      throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");
    }
    try {
      return new URL(ensureTrailingSlash(trimmedUrl));
    } catch (_a) {
      throw Error("Invalid supabaseUrl: Provided URL is malformed.");
    }
  }
});

// backend/node_modules/@supabase/auth-js/dist/main/lib/version.js
var require_version4 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.version = undefined;
  exports2.version = "2.86.0";
});

// backend/node_modules/@supabase/auth-js/dist/main/lib/constants.js
var require_constants5 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.JWKS_TTL = exports2.BASE64URL_REGEX = exports2.API_VERSIONS = exports2.API_VERSION_HEADER_NAME = exports2.NETWORK_FAILURE = exports2.DEFAULT_HEADERS = exports2.AUDIENCE = exports2.STORAGE_KEY = exports2.GOTRUE_URL = exports2.EXPIRY_MARGIN_MS = exports2.AUTO_REFRESH_TICK_THRESHOLD = exports2.AUTO_REFRESH_TICK_DURATION_MS = undefined;
  var version_1 = require_version4();
  exports2.AUTO_REFRESH_TICK_DURATION_MS = 30 * 1000;
  exports2.AUTO_REFRESH_TICK_THRESHOLD = 3;
  exports2.EXPIRY_MARGIN_MS = exports2.AUTO_REFRESH_TICK_THRESHOLD * exports2.AUTO_REFRESH_TICK_DURATION_MS;
  exports2.GOTRUE_URL = "http://localhost:9999";
  exports2.STORAGE_KEY = "supabase.auth.token";
  exports2.AUDIENCE = "";
  exports2.DEFAULT_HEADERS = { "X-Client-Info": `gotrue-js/${version_1.version}` };
  exports2.NETWORK_FAILURE = {
    MAX_RETRIES: 10,
    RETRY_INTERVAL: 2
  };
  exports2.API_VERSION_HEADER_NAME = "X-Supabase-Api-Version";
  exports2.API_VERSIONS = {
    "2024-01-01": {
      timestamp: Date.parse("2024-01-01T00:00:00.0Z"),
      name: "2024-01-01"
    }
  };
  exports2.BASE64URL_REGEX = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i;
  exports2.JWKS_TTL = 10 * 60 * 1000;
});

// backend/node_modules/@supabase/auth-js/dist/main/lib/errors.js
var require_errors3 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.AuthInvalidJwtError = exports2.AuthWeakPasswordError = exports2.AuthRetryableFetchError = exports2.AuthPKCEGrantCodeExchangeError = exports2.AuthImplicitGrantRedirectError = exports2.AuthInvalidCredentialsError = exports2.AuthInvalidTokenResponseError = exports2.AuthSessionMissingError = exports2.CustomAuthError = exports2.AuthUnknownError = exports2.AuthApiError = exports2.AuthError = undefined;
  exports2.isAuthError = isAuthError;
  exports2.isAuthApiError = isAuthApiError;
  exports2.isAuthSessionMissingError = isAuthSessionMissingError;
  exports2.isAuthImplicitGrantRedirectError = isAuthImplicitGrantRedirectError;
  exports2.isAuthRetryableFetchError = isAuthRetryableFetchError;
  exports2.isAuthWeakPasswordError = isAuthWeakPasswordError;

  class AuthError extends Error {
    constructor(message, status, code) {
      super(message);
      this.__isAuthError = true;
      this.name = "AuthError";
      this.status = status;
      this.code = code;
    }
  }
  exports2.AuthError = AuthError;
  function isAuthError(error) {
    return typeof error === "object" && error !== null && "__isAuthError" in error;
  }

  class AuthApiError extends AuthError {
    constructor(message, status, code) {
      super(message, status, code);
      this.name = "AuthApiError";
      this.status = status;
      this.code = code;
    }
  }
  exports2.AuthApiError = AuthApiError;
  function isAuthApiError(error) {
    return isAuthError(error) && error.name === "AuthApiError";
  }

  class AuthUnknownError extends AuthError {
    constructor(message, originalError) {
      super(message);
      this.name = "AuthUnknownError";
      this.originalError = originalError;
    }
  }
  exports2.AuthUnknownError = AuthUnknownError;

  class CustomAuthError extends AuthError {
    constructor(message, name, status, code) {
      super(message, status, code);
      this.name = name;
      this.status = status;
    }
  }
  exports2.CustomAuthError = CustomAuthError;

  class AuthSessionMissingError extends CustomAuthError {
    constructor() {
      super("Auth session missing!", "AuthSessionMissingError", 400, undefined);
    }
  }
  exports2.AuthSessionMissingError = AuthSessionMissingError;
  function isAuthSessionMissingError(error) {
    return isAuthError(error) && error.name === "AuthSessionMissingError";
  }

  class AuthInvalidTokenResponseError extends CustomAuthError {
    constructor() {
      super("Auth session or user missing", "AuthInvalidTokenResponseError", 500, undefined);
    }
  }
  exports2.AuthInvalidTokenResponseError = AuthInvalidTokenResponseError;

  class AuthInvalidCredentialsError extends CustomAuthError {
    constructor(message) {
      super(message, "AuthInvalidCredentialsError", 400, undefined);
    }
  }
  exports2.AuthInvalidCredentialsError = AuthInvalidCredentialsError;

  class AuthImplicitGrantRedirectError extends CustomAuthError {
    constructor(message, details = null) {
      super(message, "AuthImplicitGrantRedirectError", 500, undefined);
      this.details = null;
      this.details = details;
    }
    toJSON() {
      return {
        name: this.name,
        message: this.message,
        status: this.status,
        details: this.details
      };
    }
  }
  exports2.AuthImplicitGrantRedirectError = AuthImplicitGrantRedirectError;
  function isAuthImplicitGrantRedirectError(error) {
    return isAuthError(error) && error.name === "AuthImplicitGrantRedirectError";
  }

  class AuthPKCEGrantCodeExchangeError extends CustomAuthError {
    constructor(message, details = null) {
      super(message, "AuthPKCEGrantCodeExchangeError", 500, undefined);
      this.details = null;
      this.details = details;
    }
    toJSON() {
      return {
        name: this.name,
        message: this.message,
        status: this.status,
        details: this.details
      };
    }
  }
  exports2.AuthPKCEGrantCodeExchangeError = AuthPKCEGrantCodeExchangeError;

  class AuthRetryableFetchError extends CustomAuthError {
    constructor(message, status) {
      super(message, "AuthRetryableFetchError", status, undefined);
    }
  }
  exports2.AuthRetryableFetchError = AuthRetryableFetchError;
  function isAuthRetryableFetchError(error) {
    return isAuthError(error) && error.name === "AuthRetryableFetchError";
  }

  class AuthWeakPasswordError extends CustomAuthError {
    constructor(message, status, reasons) {
      super(message, "AuthWeakPasswordError", status, "weak_password");
      this.reasons = reasons;
    }
  }
  exports2.AuthWeakPasswordError = AuthWeakPasswordError;
  function isAuthWeakPasswordError(error) {
    return isAuthError(error) && error.name === "AuthWeakPasswordError";
  }

  class AuthInvalidJwtError extends CustomAuthError {
    constructor(message) {
      super(message, "AuthInvalidJwtError", 400, "invalid_jwt");
    }
  }
  exports2.AuthInvalidJwtError = AuthInvalidJwtError;
});

// backend/node_modules/@supabase/auth-js/dist/main/lib/base64url.js
var require_base64url = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.byteToBase64URL = byteToBase64URL;
  exports2.byteFromBase64URL = byteFromBase64URL;
  exports2.stringToBase64URL = stringToBase64URL;
  exports2.stringFromBase64URL = stringFromBase64URL;
  exports2.codepointToUTF8 = codepointToUTF8;
  exports2.stringToUTF8 = stringToUTF8;
  exports2.stringFromUTF8 = stringFromUTF8;
  exports2.base64UrlToUint8Array = base64UrlToUint8Array;
  exports2.stringToUint8Array = stringToUint8Array;
  exports2.bytesToBase64URL = bytesToBase64URL;
  var TO_BASE64URL = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split("");
  var IGNORE_BASE64URL = ` 	
\r=`.split("");
  var FROM_BASE64URL = (() => {
    const charMap = new Array(128);
    for (let i = 0;i < charMap.length; i += 1) {
      charMap[i] = -1;
    }
    for (let i = 0;i < IGNORE_BASE64URL.length; i += 1) {
      charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;
    }
    for (let i = 0;i < TO_BASE64URL.length; i += 1) {
      charMap[TO_BASE64URL[i].charCodeAt(0)] = i;
    }
    return charMap;
  })();
  function byteToBase64URL(byte, state, emit) {
    if (byte !== null) {
      state.queue = state.queue << 8 | byte;
      state.queuedBits += 8;
      while (state.queuedBits >= 6) {
        const pos = state.queue >> state.queuedBits - 6 & 63;
        emit(TO_BASE64URL[pos]);
        state.queuedBits -= 6;
      }
    } else if (state.queuedBits > 0) {
      state.queue = state.queue << 6 - state.queuedBits;
      state.queuedBits = 6;
      while (state.queuedBits >= 6) {
        const pos = state.queue >> state.queuedBits - 6 & 63;
        emit(TO_BASE64URL[pos]);
        state.queuedBits -= 6;
      }
    }
  }
  function byteFromBase64URL(charCode, state, emit) {
    const bits = FROM_BASE64URL[charCode];
    if (bits > -1) {
      state.queue = state.queue << 6 | bits;
      state.queuedBits += 6;
      while (state.queuedBits >= 8) {
        emit(state.queue >> state.queuedBits - 8 & 255);
        state.queuedBits -= 8;
      }
    } else if (bits === -2) {
      return;
    } else {
      throw new Error(`Invalid Base64-URL character "${String.fromCharCode(charCode)}"`);
    }
  }
  function stringToBase64URL(str) {
    const base64 = [];
    const emitter = (char) => {
      base64.push(char);
    };
    const state = { queue: 0, queuedBits: 0 };
    stringToUTF8(str, (byte) => {
      byteToBase64URL(byte, state, emitter);
    });
    byteToBase64URL(null, state, emitter);
    return base64.join("");
  }
  function stringFromBase64URL(str) {
    const conv = [];
    const utf8Emit = (codepoint) => {
      conv.push(String.fromCodePoint(codepoint));
    };
    const utf8State = {
      utf8seq: 0,
      codepoint: 0
    };
    const b64State = { queue: 0, queuedBits: 0 };
    const byteEmit = (byte) => {
      stringFromUTF8(byte, utf8State, utf8Emit);
    };
    for (let i = 0;i < str.length; i += 1) {
      byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit);
    }
    return conv.join("");
  }
  function codepointToUTF8(codepoint, emit) {
    if (codepoint <= 127) {
      emit(codepoint);
      return;
    } else if (codepoint <= 2047) {
      emit(192 | codepoint >> 6);
      emit(128 | codepoint & 63);
      return;
    } else if (codepoint <= 65535) {
      emit(224 | codepoint >> 12);
      emit(128 | codepoint >> 6 & 63);
      emit(128 | codepoint & 63);
      return;
    } else if (codepoint <= 1114111) {
      emit(240 | codepoint >> 18);
      emit(128 | codepoint >> 12 & 63);
      emit(128 | codepoint >> 6 & 63);
      emit(128 | codepoint & 63);
      return;
    }
    throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);
  }
  function stringToUTF8(str, emit) {
    for (let i = 0;i < str.length; i += 1) {
      let codepoint = str.charCodeAt(i);
      if (codepoint > 55295 && codepoint <= 56319) {
        const highSurrogate = (codepoint - 55296) * 1024 & 65535;
        const lowSurrogate = str.charCodeAt(i + 1) - 56320 & 65535;
        codepoint = (lowSurrogate | highSurrogate) + 65536;
        i += 1;
      }
      codepointToUTF8(codepoint, emit);
    }
  }
  function stringFromUTF8(byte, state, emit) {
    if (state.utf8seq === 0) {
      if (byte <= 127) {
        emit(byte);
        return;
      }
      for (let leadingBit = 1;leadingBit < 6; leadingBit += 1) {
        if ((byte >> 7 - leadingBit & 1) === 0) {
          state.utf8seq = leadingBit;
          break;
        }
      }
      if (state.utf8seq === 2) {
        state.codepoint = byte & 31;
      } else if (state.utf8seq === 3) {
        state.codepoint = byte & 15;
      } else if (state.utf8seq === 4) {
        state.codepoint = byte & 7;
      } else {
        throw new Error("Invalid UTF-8 sequence");
      }
      state.utf8seq -= 1;
    } else if (state.utf8seq > 0) {
      if (byte <= 127) {
        throw new Error("Invalid UTF-8 sequence");
      }
      state.codepoint = state.codepoint << 6 | byte & 63;
      state.utf8seq -= 1;
      if (state.utf8seq === 0) {
        emit(state.codepoint);
      }
    }
  }
  function base64UrlToUint8Array(str) {
    const result = [];
    const state = { queue: 0, queuedBits: 0 };
    const onByte = (byte) => {
      result.push(byte);
    };
    for (let i = 0;i < str.length; i += 1) {
      byteFromBase64URL(str.charCodeAt(i), state, onByte);
    }
    return new Uint8Array(result);
  }
  function stringToUint8Array(str) {
    const result = [];
    stringToUTF8(str, (byte) => result.push(byte));
    return new Uint8Array(result);
  }
  function bytesToBase64URL(bytes) {
    const result = [];
    const state = { queue: 0, queuedBits: 0 };
    const onChar = (char) => {
      result.push(char);
    };
    bytes.forEach((byte) => byteToBase64URL(byte, state, onChar));
    byteToBase64URL(null, state, onChar);
    return result.join("");
  }
});

// backend/node_modules/@supabase/auth-js/dist/main/lib/helpers.js
var require_helpers4 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Deferred = exports2.removeItemAsync = exports2.getItemAsync = exports2.setItemAsync = exports2.looksLikeFetchResponse = exports2.resolveFetch = exports2.supportsLocalStorage = exports2.isBrowser = undefined;
  exports2.expiresAt = expiresAt;
  exports2.generateCallbackId = generateCallbackId;
  exports2.parseParametersFromURL = parseParametersFromURL;
  exports2.decodeJWT = decodeJWT;
  exports2.sleep = sleep;
  exports2.retryable = retryable;
  exports2.generatePKCEVerifier = generatePKCEVerifier;
  exports2.generatePKCEChallenge = generatePKCEChallenge;
  exports2.getCodeChallengeAndMethod = getCodeChallengeAndMethod;
  exports2.parseResponseAPIVersion = parseResponseAPIVersion;
  exports2.validateExp = validateExp;
  exports2.getAlgorithm = getAlgorithm;
  exports2.validateUUID = validateUUID;
  exports2.userNotAvailableProxy = userNotAvailableProxy;
  exports2.insecureUserWarningProxy = insecureUserWarningProxy;
  exports2.deepClone = deepClone;
  var constants_1 = require_constants5();
  var errors_1 = require_errors3();
  var base64url_1 = require_base64url();
  function expiresAt(expiresIn) {
    const timeNow = Math.round(Date.now() / 1000);
    return timeNow + expiresIn;
  }
  function generateCallbackId() {
    return Symbol("auth-callback");
  }
  var isBrowser = () => typeof window !== "undefined" && typeof document !== "undefined";
  exports2.isBrowser = isBrowser;
  var localStorageWriteTests = {
    tested: false,
    writable: false
  };
  var supportsLocalStorage = () => {
    if (!(0, exports2.isBrowser)()) {
      return false;
    }
    try {
      if (typeof globalThis.localStorage !== "object") {
        return false;
      }
    } catch (e) {
      return false;
    }
    if (localStorageWriteTests.tested) {
      return localStorageWriteTests.writable;
    }
    const randomKey = `lswt-${Math.random()}${Math.random()}`;
    try {
      globalThis.localStorage.setItem(randomKey, randomKey);
      globalThis.localStorage.removeItem(randomKey);
      localStorageWriteTests.tested = true;
      localStorageWriteTests.writable = true;
    } catch (e) {
      localStorageWriteTests.tested = true;
      localStorageWriteTests.writable = false;
    }
    return localStorageWriteTests.writable;
  };
  exports2.supportsLocalStorage = supportsLocalStorage;
  function parseParametersFromURL(href) {
    const result = {};
    const url = new URL(href);
    if (url.hash && url.hash[0] === "#") {
      try {
        const hashSearchParams = new URLSearchParams(url.hash.substring(1));
        hashSearchParams.forEach((value, key) => {
          result[key] = value;
        });
      } catch (e) {}
    }
    url.searchParams.forEach((value, key) => {
      result[key] = value;
    });
    return result;
  }
  var resolveFetch = (customFetch) => {
    if (customFetch) {
      return (...args) => customFetch(...args);
    }
    return (...args) => fetch(...args);
  };
  exports2.resolveFetch = resolveFetch;
  var looksLikeFetchResponse = (maybeResponse) => {
    return typeof maybeResponse === "object" && maybeResponse !== null && "status" in maybeResponse && "ok" in maybeResponse && "json" in maybeResponse && typeof maybeResponse.json === "function";
  };
  exports2.looksLikeFetchResponse = looksLikeFetchResponse;
  var setItemAsync = async (storage, key, data) => {
    await storage.setItem(key, JSON.stringify(data));
  };
  exports2.setItemAsync = setItemAsync;
  var getItemAsync = async (storage, key) => {
    const value = await storage.getItem(key);
    if (!value) {
      return null;
    }
    try {
      return JSON.parse(value);
    } catch (_a) {
      return value;
    }
  };
  exports2.getItemAsync = getItemAsync;
  var removeItemAsync = async (storage, key) => {
    await storage.removeItem(key);
  };
  exports2.removeItemAsync = removeItemAsync;

  class Deferred {
    constructor() {
      this.promise = new Deferred.promiseConstructor((res, rej) => {
        this.resolve = res;
        this.reject = rej;
      });
    }
  }
  exports2.Deferred = Deferred;
  Deferred.promiseConstructor = Promise;
  function decodeJWT(token) {
    const parts = token.split(".");
    if (parts.length !== 3) {
      throw new errors_1.AuthInvalidJwtError("Invalid JWT structure");
    }
    for (let i = 0;i < parts.length; i++) {
      if (!constants_1.BASE64URL_REGEX.test(parts[i])) {
        throw new errors_1.AuthInvalidJwtError("JWT not in base64url format");
      }
    }
    const data = {
      header: JSON.parse((0, base64url_1.stringFromBase64URL)(parts[0])),
      payload: JSON.parse((0, base64url_1.stringFromBase64URL)(parts[1])),
      signature: (0, base64url_1.base64UrlToUint8Array)(parts[2]),
      raw: {
        header: parts[0],
        payload: parts[1]
      }
    };
    return data;
  }
  async function sleep(time) {
    return await new Promise((accept) => {
      setTimeout(() => accept(null), time);
    });
  }
  function retryable(fn, isRetryable) {
    const promise = new Promise((accept, reject) => {
      (async () => {
        for (let attempt = 0;attempt < Infinity; attempt++) {
          try {
            const result = await fn(attempt);
            if (!isRetryable(attempt, null, result)) {
              accept(result);
              return;
            }
          } catch (e) {
            if (!isRetryable(attempt, e)) {
              reject(e);
              return;
            }
          }
        }
      })();
    });
    return promise;
  }
  function dec2hex(dec) {
    return ("0" + dec.toString(16)).substr(-2);
  }
  function generatePKCEVerifier() {
    const verifierLength = 56;
    const array = new Uint32Array(verifierLength);
    if (typeof crypto === "undefined") {
      const charSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
      const charSetLen = charSet.length;
      let verifier = "";
      for (let i = 0;i < verifierLength; i++) {
        verifier += charSet.charAt(Math.floor(Math.random() * charSetLen));
      }
      return verifier;
    }
    crypto.getRandomValues(array);
    return Array.from(array, dec2hex).join("");
  }
  async function sha256(randomString) {
    const encoder = new TextEncoder;
    const encodedData = encoder.encode(randomString);
    const hash = await crypto.subtle.digest("SHA-256", encodedData);
    const bytes = new Uint8Array(hash);
    return Array.from(bytes).map((c) => String.fromCharCode(c)).join("");
  }
  async function generatePKCEChallenge(verifier) {
    const hasCryptoSupport = typeof crypto !== "undefined" && typeof crypto.subtle !== "undefined" && typeof TextEncoder !== "undefined";
    if (!hasCryptoSupport) {
      console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.");
      return verifier;
    }
    const hashed = await sha256(verifier);
    return btoa(hashed).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  }
  async function getCodeChallengeAndMethod(storage, storageKey, isPasswordRecovery = false) {
    const codeVerifier = generatePKCEVerifier();
    let storedCodeVerifier = codeVerifier;
    if (isPasswordRecovery) {
      storedCodeVerifier += "/PASSWORD_RECOVERY";
    }
    await (0, exports2.setItemAsync)(storage, `${storageKey}-code-verifier`, storedCodeVerifier);
    const codeChallenge = await generatePKCEChallenge(codeVerifier);
    const codeChallengeMethod = codeVerifier === codeChallenge ? "plain" : "s256";
    return [codeChallenge, codeChallengeMethod];
  }
  var API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
  function parseResponseAPIVersion(response) {
    const apiVersion = response.headers.get(constants_1.API_VERSION_HEADER_NAME);
    if (!apiVersion) {
      return null;
    }
    if (!apiVersion.match(API_VERSION_REGEX)) {
      return null;
    }
    try {
      const date = new Date(`${apiVersion}T00:00:00.0Z`);
      return date;
    } catch (e) {
      return null;
    }
  }
  function validateExp(exp) {
    if (!exp) {
      throw new Error("Missing exp claim");
    }
    const timeNow = Math.floor(Date.now() / 1000);
    if (exp <= timeNow) {
      throw new Error("JWT has expired");
    }
  }
  function getAlgorithm(alg) {
    switch (alg) {
      case "RS256":
        return {
          name: "RSASSA-PKCS1-v1_5",
          hash: { name: "SHA-256" }
        };
      case "ES256":
        return {
          name: "ECDSA",
          namedCurve: "P-256",
          hash: { name: "SHA-256" }
        };
      default:
        throw new Error("Invalid alg claim");
    }
  }
  var UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
  function validateUUID(str) {
    if (!UUID_REGEX.test(str)) {
      throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not");
    }
  }
  function userNotAvailableProxy() {
    const proxyTarget = {};
    return new Proxy(proxyTarget, {
      get: (target, prop) => {
        if (prop === "__isUserNotAvailableProxy") {
          return true;
        }
        if (typeof prop === "symbol") {
          const sProp = prop.toString();
          if (sProp === "Symbol(Symbol.toPrimitive)" || sProp === "Symbol(Symbol.toStringTag)" || sProp === "Symbol(util.inspect.custom)") {
            return;
          }
        }
        throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${prop}" property of the session object is not supported. Please use getUser() instead.`);
      },
      set: (_target, prop) => {
        throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${prop}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);
      },
      deleteProperty: (_target, prop) => {
        throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${prop}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);
      }
    });
  }
  function insecureUserWarningProxy(user, suppressWarningRef) {
    return new Proxy(user, {
      get: (target, prop, receiver2) => {
        if (prop === "__isInsecureUserWarningProxy") {
          return true;
        }
        if (typeof prop === "symbol") {
          const sProp = prop.toString();
          if (sProp === "Symbol(Symbol.toPrimitive)" || sProp === "Symbol(Symbol.toStringTag)" || sProp === "Symbol(util.inspect.custom)" || sProp === "Symbol(nodejs.util.inspect.custom)") {
            return Reflect.get(target, prop, receiver2);
          }
        }
        if (!suppressWarningRef.value && typeof prop === "string") {
          console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server.");
          suppressWarningRef.value = true;
        }
        return Reflect.get(target, prop, receiver2);
      }
    });
  }
  function deepClone(obj2) {
    return JSON.parse(JSON.stringify(obj2));
  }
});

// backend/node_modules/@supabase/auth-js/dist/main/lib/fetch.js
var require_fetch4 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.handleError = handleError;
  exports2._request = _request;
  exports2._sessionResponse = _sessionResponse;
  exports2._sessionResponsePassword = _sessionResponsePassword;
  exports2._userResponse = _userResponse;
  exports2._ssoResponse = _ssoResponse;
  exports2._generateLinkResponse = _generateLinkResponse;
  exports2._noResolveJsonResponse = _noResolveJsonResponse;
  var tslib_1 = require_tslib();
  var constants_1 = require_constants5();
  var helpers_1 = require_helpers4();
  var errors_1 = require_errors3();
  var _getErrorMessage = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
  var NETWORK_ERROR_CODES = [502, 503, 504];
  async function handleError(error) {
    var _a;
    if (!(0, helpers_1.looksLikeFetchResponse)(error)) {
      throw new errors_1.AuthRetryableFetchError(_getErrorMessage(error), 0);
    }
    if (NETWORK_ERROR_CODES.includes(error.status)) {
      throw new errors_1.AuthRetryableFetchError(_getErrorMessage(error), error.status);
    }
    let data;
    try {
      data = await error.json();
    } catch (e) {
      throw new errors_1.AuthUnknownError(_getErrorMessage(e), e);
    }
    let errorCode = undefined;
    const responseAPIVersion = (0, helpers_1.parseResponseAPIVersion)(error);
    if (responseAPIVersion && responseAPIVersion.getTime() >= constants_1.API_VERSIONS["2024-01-01"].timestamp && typeof data === "object" && data && typeof data.code === "string") {
      errorCode = data.code;
    } else if (typeof data === "object" && data && typeof data.error_code === "string") {
      errorCode = data.error_code;
    }
    if (!errorCode) {
      if (typeof data === "object" && data && typeof data.weak_password === "object" && data.weak_password && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.reasons.reduce((a, i) => a && typeof i === "string", true)) {
        throw new errors_1.AuthWeakPasswordError(_getErrorMessage(data), error.status, data.weak_password.reasons);
      }
    } else if (errorCode === "weak_password") {
      throw new errors_1.AuthWeakPasswordError(_getErrorMessage(data), error.status, ((_a = data.weak_password) === null || _a === undefined ? undefined : _a.reasons) || []);
    } else if (errorCode === "session_not_found") {
      throw new errors_1.AuthSessionMissingError;
    }
    throw new errors_1.AuthApiError(_getErrorMessage(data), error.status || 500, errorCode);
  }
  var _getRequestParams = (method, options, parameters, body) => {
    const params = { method, headers: (options === null || options === undefined ? undefined : options.headers) || {} };
    if (method === "GET") {
      return params;
    }
    params.headers = Object.assign({ "Content-Type": "application/json;charset=UTF-8" }, options === null || options === undefined ? undefined : options.headers);
    params.body = JSON.stringify(body);
    return Object.assign(Object.assign({}, params), parameters);
  };
  async function _request(fetcher, method, url, options) {
    var _a;
    const headers = Object.assign({}, options === null || options === undefined ? undefined : options.headers);
    if (!headers[constants_1.API_VERSION_HEADER_NAME]) {
      headers[constants_1.API_VERSION_HEADER_NAME] = constants_1.API_VERSIONS["2024-01-01"].name;
    }
    if (options === null || options === undefined ? undefined : options.jwt) {
      headers["Authorization"] = `Bearer ${options.jwt}`;
    }
    const qs = (_a = options === null || options === undefined ? undefined : options.query) !== null && _a !== undefined ? _a : {};
    if (options === null || options === undefined ? undefined : options.redirectTo) {
      qs["redirect_to"] = options.redirectTo;
    }
    const queryString = Object.keys(qs).length ? "?" + new URLSearchParams(qs).toString() : "";
    const data = await _handleRequest(fetcher, method, url + queryString, {
      headers,
      noResolveJson: options === null || options === undefined ? undefined : options.noResolveJson
    }, {}, options === null || options === undefined ? undefined : options.body);
    return (options === null || options === undefined ? undefined : options.xform) ? options === null || options === undefined ? undefined : options.xform(data) : { data: Object.assign({}, data), error: null };
  }
  async function _handleRequest(fetcher, method, url, options, parameters, body) {
    const requestParams = _getRequestParams(method, options, parameters, body);
    let result;
    try {
      result = await fetcher(url, Object.assign({}, requestParams));
    } catch (e) {
      console.error(e);
      throw new errors_1.AuthRetryableFetchError(_getErrorMessage(e), 0);
    }
    if (!result.ok) {
      await handleError(result);
    }
    if (options === null || options === undefined ? undefined : options.noResolveJson) {
      return result;
    }
    try {
      return await result.json();
    } catch (e) {
      await handleError(e);
    }
  }
  function _sessionResponse(data) {
    var _a;
    let session = null;
    if (hasSession(data)) {
      session = Object.assign({}, data);
      if (!data.expires_at) {
        session.expires_at = (0, helpers_1.expiresAt)(data.expires_in);
      }
    }
    const user = (_a = data.user) !== null && _a !== undefined ? _a : data;
    return { data: { session, user }, error: null };
  }
  function _sessionResponsePassword(data) {
    const response = _sessionResponse(data);
    if (!response.error && data.weak_password && typeof data.weak_password === "object" && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.message && typeof data.weak_password.message === "string" && data.weak_password.reasons.reduce((a, i) => a && typeof i === "string", true)) {
      response.data.weak_password = data.weak_password;
    }
    return response;
  }
  function _userResponse(data) {
    var _a;
    const user = (_a = data.user) !== null && _a !== undefined ? _a : data;
    return { data: { user }, error: null };
  }
  function _ssoResponse(data) {
    return { data, error: null };
  }
  function _generateLinkResponse(data) {
    const { action_link, email_otp, hashed_token, redirect_to, verification_type } = data, rest = tslib_1.__rest(data, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]);
    const properties = {
      action_link,
      email_otp,
      hashed_token,
      redirect_to,
      verification_type
    };
    const user = Object.assign({}, rest);
    return {
      data: {
        properties,
        user
      },
      error: null
    };
  }
  function _noResolveJsonResponse(data) {
    return data;
  }
  function hasSession(data) {
    return data.access_token && data.refresh_token && data.expires_in;
  }
});

// backend/node_modules/@supabase/auth-js/dist/main/lib/types.js
var require_types3 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.SIGN_OUT_SCOPES = undefined;
  exports2.SIGN_OUT_SCOPES = ["global", "local", "others"];
});

// backend/node_modules/@supabase/auth-js/dist/main/GoTrueAdminApi.js
var require_GoTrueAdminApi = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  var fetch_1 = require_fetch4();
  var helpers_1 = require_helpers4();
  var types_1 = require_types3();
  var errors_1 = require_errors3();

  class GoTrueAdminApi {
    constructor({ url = "", headers = {}, fetch: fetch2 }) {
      this.url = url;
      this.headers = headers;
      this.fetch = (0, helpers_1.resolveFetch)(fetch2);
      this.mfa = {
        listFactors: this._listFactors.bind(this),
        deleteFactor: this._deleteFactor.bind(this)
      };
      this.oauth = {
        listClients: this._listOAuthClients.bind(this),
        createClient: this._createOAuthClient.bind(this),
        getClient: this._getOAuthClient.bind(this),
        updateClient: this._updateOAuthClient.bind(this),
        deleteClient: this._deleteOAuthClient.bind(this),
        regenerateClientSecret: this._regenerateOAuthClientSecret.bind(this)
      };
    }
    async signOut(jwt, scope = types_1.SIGN_OUT_SCOPES[0]) {
      if (types_1.SIGN_OUT_SCOPES.indexOf(scope) < 0) {
        throw new Error(`@supabase/auth-js: Parameter scope must be one of ${types_1.SIGN_OUT_SCOPES.join(", ")}`);
      }
      try {
        await (0, fetch_1._request)(this.fetch, "POST", `${this.url}/logout?scope=${scope}`, {
          headers: this.headers,
          jwt,
          noResolveJson: true
        });
        return { data: null, error: null };
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return { data: null, error };
        }
        throw error;
      }
    }
    async inviteUserByEmail(email, options = {}) {
      try {
        return await (0, fetch_1._request)(this.fetch, "POST", `${this.url}/invite`, {
          body: { email, data: options.data },
          headers: this.headers,
          redirectTo: options.redirectTo,
          xform: fetch_1._userResponse
        });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return { data: { user: null }, error };
        }
        throw error;
      }
    }
    async generateLink(params) {
      try {
        const { options } = params, rest = tslib_1.__rest(params, ["options"]);
        const body = Object.assign(Object.assign({}, rest), options);
        if ("newEmail" in rest) {
          body.new_email = rest === null || rest === undefined ? undefined : rest.newEmail;
          delete body["newEmail"];
        }
        return await (0, fetch_1._request)(this.fetch, "POST", `${this.url}/admin/generate_link`, {
          body,
          headers: this.headers,
          xform: fetch_1._generateLinkResponse,
          redirectTo: options === null || options === undefined ? undefined : options.redirectTo
        });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return {
            data: {
              properties: null,
              user: null
            },
            error
          };
        }
        throw error;
      }
    }
    async createUser(attributes) {
      try {
        return await (0, fetch_1._request)(this.fetch, "POST", `${this.url}/admin/users`, {
          body: attributes,
          headers: this.headers,
          xform: fetch_1._userResponse
        });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return { data: { user: null }, error };
        }
        throw error;
      }
    }
    async listUsers(params) {
      var _a, _b, _c, _d, _e, _f, _g;
      try {
        const pagination = { nextPage: null, lastPage: 0, total: 0 };
        const response = await (0, fetch_1._request)(this.fetch, "GET", `${this.url}/admin/users`, {
          headers: this.headers,
          noResolveJson: true,
          query: {
            page: (_b = (_a = params === null || params === undefined ? undefined : params.page) === null || _a === undefined ? undefined : _a.toString()) !== null && _b !== undefined ? _b : "",
            per_page: (_d = (_c = params === null || params === undefined ? undefined : params.perPage) === null || _c === undefined ? undefined : _c.toString()) !== null && _d !== undefined ? _d : ""
          },
          xform: fetch_1._noResolveJsonResponse
        });
        if (response.error)
          throw response.error;
        const users = await response.json();
        const total = (_e = response.headers.get("x-total-count")) !== null && _e !== undefined ? _e : 0;
        const links = (_g = (_f = response.headers.get("link")) === null || _f === undefined ? undefined : _f.split(",")) !== null && _g !== undefined ? _g : [];
        if (links.length > 0) {
          links.forEach((link) => {
            const page = parseInt(link.split(";")[0].split("=")[1].substring(0, 1));
            const rel = JSON.parse(link.split(";")[1].split("=")[1]);
            pagination[`${rel}Page`] = page;
          });
          pagination.total = parseInt(total);
        }
        return { data: Object.assign(Object.assign({}, users), pagination), error: null };
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return { data: { users: [] }, error };
        }
        throw error;
      }
    }
    async getUserById(uid) {
      (0, helpers_1.validateUUID)(uid);
      try {
        return await (0, fetch_1._request)(this.fetch, "GET", `${this.url}/admin/users/${uid}`, {
          headers: this.headers,
          xform: fetch_1._userResponse
        });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return { data: { user: null }, error };
        }
        throw error;
      }
    }
    async updateUserById(uid, attributes) {
      (0, helpers_1.validateUUID)(uid);
      try {
        return await (0, fetch_1._request)(this.fetch, "PUT", `${this.url}/admin/users/${uid}`, {
          body: attributes,
          headers: this.headers,
          xform: fetch_1._userResponse
        });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return { data: { user: null }, error };
        }
        throw error;
      }
    }
    async deleteUser(id, shouldSoftDelete = false) {
      (0, helpers_1.validateUUID)(id);
      try {
        return await (0, fetch_1._request)(this.fetch, "DELETE", `${this.url}/admin/users/${id}`, {
          headers: this.headers,
          body: {
            should_soft_delete: shouldSoftDelete
          },
          xform: fetch_1._userResponse
        });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return { data: { user: null }, error };
        }
        throw error;
      }
    }
    async _listFactors(params) {
      (0, helpers_1.validateUUID)(params.userId);
      try {
        const { data, error } = await (0, fetch_1._request)(this.fetch, "GET", `${this.url}/admin/users/${params.userId}/factors`, {
          headers: this.headers,
          xform: (factors) => {
            return { data: { factors }, error: null };
          }
        });
        return { data, error };
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return { data: null, error };
        }
        throw error;
      }
    }
    async _deleteFactor(params) {
      (0, helpers_1.validateUUID)(params.userId);
      (0, helpers_1.validateUUID)(params.id);
      try {
        const data = await (0, fetch_1._request)(this.fetch, "DELETE", `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {
          headers: this.headers
        });
        return { data, error: null };
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return { data: null, error };
        }
        throw error;
      }
    }
    async _listOAuthClients(params) {
      var _a, _b, _c, _d, _e, _f, _g;
      try {
        const pagination = { nextPage: null, lastPage: 0, total: 0 };
        const response = await (0, fetch_1._request)(this.fetch, "GET", `${this.url}/admin/oauth/clients`, {
          headers: this.headers,
          noResolveJson: true,
          query: {
            page: (_b = (_a = params === null || params === undefined ? undefined : params.page) === null || _a === undefined ? undefined : _a.toString()) !== null && _b !== undefined ? _b : "",
            per_page: (_d = (_c = params === null || params === undefined ? undefined : params.perPage) === null || _c === undefined ? undefined : _c.toString()) !== null && _d !== undefined ? _d : ""
          },
          xform: fetch_1._noResolveJsonResponse
        });
        if (response.error)
          throw response.error;
        const clients = await response.json();
        const total = (_e = response.headers.get("x-total-count")) !== null && _e !== undefined ? _e : 0;
        const links = (_g = (_f = response.headers.get("link")) === null || _f === undefined ? undefined : _f.split(",")) !== null && _g !== undefined ? _g : [];
        if (links.length > 0) {
          links.forEach((link) => {
            const page = parseInt(link.split(";")[0].split("=")[1].substring(0, 1));
            const rel = JSON.parse(link.split(";")[1].split("=")[1]);
            pagination[`${rel}Page`] = page;
          });
          pagination.total = parseInt(total);
        }
        return { data: Object.assign(Object.assign({}, clients), pagination), error: null };
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return { data: { clients: [] }, error };
        }
        throw error;
      }
    }
    async _createOAuthClient(params) {
      try {
        return await (0, fetch_1._request)(this.fetch, "POST", `${this.url}/admin/oauth/clients`, {
          body: params,
          headers: this.headers,
          xform: (client) => {
            return { data: client, error: null };
          }
        });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return { data: null, error };
        }
        throw error;
      }
    }
    async _getOAuthClient(clientId) {
      try {
        return await (0, fetch_1._request)(this.fetch, "GET", `${this.url}/admin/oauth/clients/${clientId}`, {
          headers: this.headers,
          xform: (client) => {
            return { data: client, error: null };
          }
        });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return { data: null, error };
        }
        throw error;
      }
    }
    async _updateOAuthClient(clientId, params) {
      try {
        return await (0, fetch_1._request)(this.fetch, "PUT", `${this.url}/admin/oauth/clients/${clientId}`, {
          body: params,
          headers: this.headers,
          xform: (client) => {
            return { data: client, error: null };
          }
        });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return { data: null, error };
        }
        throw error;
      }
    }
    async _deleteOAuthClient(clientId) {
      try {
        await (0, fetch_1._request)(this.fetch, "DELETE", `${this.url}/admin/oauth/clients/${clientId}`, {
          headers: this.headers,
          noResolveJson: true
        });
        return { data: null, error: null };
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return { data: null, error };
        }
        throw error;
      }
    }
    async _regenerateOAuthClientSecret(clientId) {
      try {
        return await (0, fetch_1._request)(this.fetch, "POST", `${this.url}/admin/oauth/clients/${clientId}/regenerate_secret`, {
          headers: this.headers,
          xform: (client) => {
            return { data: client, error: null };
          }
        });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return { data: null, error };
        }
        throw error;
      }
    }
  }
  exports2.default = GoTrueAdminApi;
});

// backend/node_modules/@supabase/auth-js/dist/main/lib/local-storage.js
var require_local_storage = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.memoryLocalStorageAdapter = memoryLocalStorageAdapter;
  function memoryLocalStorageAdapter(store = {}) {
    return {
      getItem: (key) => {
        return store[key] || null;
      },
      setItem: (key, value) => {
        store[key] = value;
      },
      removeItem: (key) => {
        delete store[key];
      }
    };
  }
});

// backend/node_modules/@supabase/auth-js/dist/main/lib/locks.js
var require_locks = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ProcessLockAcquireTimeoutError = exports2.NavigatorLockAcquireTimeoutError = exports2.LockAcquireTimeoutError = exports2.internals = undefined;
  exports2.navigatorLock = navigatorLock;
  exports2.processLock = processLock;
  var helpers_1 = require_helpers4();
  exports2.internals = {
    debug: !!(globalThis && (0, helpers_1.supportsLocalStorage)() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true")
  };

  class LockAcquireTimeoutError extends Error {
    constructor(message) {
      super(message);
      this.isAcquireTimeout = true;
    }
  }
  exports2.LockAcquireTimeoutError = LockAcquireTimeoutError;

  class NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {
  }
  exports2.NavigatorLockAcquireTimeoutError = NavigatorLockAcquireTimeoutError;

  class ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {
  }
  exports2.ProcessLockAcquireTimeoutError = ProcessLockAcquireTimeoutError;
  async function navigatorLock(name, acquireTimeout, fn) {
    if (exports2.internals.debug) {
      console.log("@supabase/gotrue-js: navigatorLock: acquire lock", name, acquireTimeout);
    }
    const abortController = new globalThis.AbortController;
    if (acquireTimeout > 0) {
      setTimeout(() => {
        abortController.abort();
        if (exports2.internals.debug) {
          console.log("@supabase/gotrue-js: navigatorLock acquire timed out", name);
        }
      }, acquireTimeout);
    }
    return await Promise.resolve().then(() => globalThis.navigator.locks.request(name, acquireTimeout === 0 ? {
      mode: "exclusive",
      ifAvailable: true
    } : {
      mode: "exclusive",
      signal: abortController.signal
    }, async (lock) => {
      if (lock) {
        if (exports2.internals.debug) {
          console.log("@supabase/gotrue-js: navigatorLock: acquired", name, lock.name);
        }
        try {
          return await fn();
        } finally {
          if (exports2.internals.debug) {
            console.log("@supabase/gotrue-js: navigatorLock: released", name, lock.name);
          }
        }
      } else {
        if (acquireTimeout === 0) {
          if (exports2.internals.debug) {
            console.log("@supabase/gotrue-js: navigatorLock: not immediately available", name);
          }
          throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock "${name}" immediately failed`);
        } else {
          if (exports2.internals.debug) {
            try {
              const result = await globalThis.navigator.locks.query();
              console.log("@supabase/gotrue-js: Navigator LockManager state", JSON.stringify(result, null, "  "));
            } catch (e) {
              console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state", e);
            }
          }
          console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request");
          return await fn();
        }
      }
    }));
  }
  var PROCESS_LOCKS = {};
  async function processLock(name, acquireTimeout, fn) {
    var _a;
    const previousOperation = (_a = PROCESS_LOCKS[name]) !== null && _a !== undefined ? _a : Promise.resolve();
    const currentOperation = Promise.race([
      previousOperation.catch(() => {
        return null;
      }),
      acquireTimeout >= 0 ? new Promise((_, reject) => {
        setTimeout(() => {
          reject(new ProcessLockAcquireTimeoutError(`Acquring process lock with name "${name}" timed out`));
        }, acquireTimeout);
      }) : null
    ].filter((x) => x)).catch((e) => {
      if (e && e.isAcquireTimeout) {
        throw e;
      }
      return null;
    }).then(async () => {
      return await fn();
    });
    PROCESS_LOCKS[name] = currentOperation.catch(async (e) => {
      if (e && e.isAcquireTimeout) {
        await previousOperation;
        return null;
      }
      throw e;
    });
    return await currentOperation;
  }
});

// backend/node_modules/@supabase/auth-js/dist/main/lib/polyfills.js
var require_polyfills = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.polyfillGlobalThis = polyfillGlobalThis;
  function polyfillGlobalThis() {
    if (typeof globalThis === "object")
      return;
    try {
      Object.defineProperty(Object.prototype, "__magic__", {
        get: function() {
          return this;
        },
        configurable: true
      });
      __magic__.globalThis = __magic__;
      delete Object.prototype.__magic__;
    } catch (e) {
      if (typeof self !== "undefined") {
        self.globalThis = self;
      }
    }
  }
});

// backend/node_modules/@supabase/auth-js/dist/main/lib/web3/ethereum.js
var require_ethereum = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.getAddress = getAddress;
  exports2.fromHex = fromHex;
  exports2.toHex = toHex;
  exports2.createSiweMessage = createSiweMessage;
  function getAddress(address) {
    if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
      throw new Error(`@supabase/auth-js: Address "${address}" is invalid.`);
    }
    return address.toLowerCase();
  }
  function fromHex(hex) {
    return parseInt(hex, 16);
  }
  function toHex(value) {
    const bytes = new TextEncoder().encode(value);
    const hex = Array.from(bytes, (byte) => byte.toString(16).padStart(2, "0")).join("");
    return "0x" + hex;
  }
  function createSiweMessage(parameters) {
    var _a;
    const { chainId, domain, expirationTime, issuedAt = new Date, nonce, notBefore, requestId, resources, scheme, uri, version } = parameters;
    {
      if (!Number.isInteger(chainId))
        throw new Error(`@supabase/auth-js: Invalid SIWE message field "chainId". Chain ID must be a EIP-155 chain ID. Provided value: ${chainId}`);
      if (!domain)
        throw new Error(`@supabase/auth-js: Invalid SIWE message field "domain". Domain must be provided.`);
      if (nonce && nonce.length < 8)
        throw new Error(`@supabase/auth-js: Invalid SIWE message field "nonce". Nonce must be at least 8 characters. Provided value: ${nonce}`);
      if (!uri)
        throw new Error(`@supabase/auth-js: Invalid SIWE message field "uri". URI must be provided.`);
      if (version !== "1")
        throw new Error(`@supabase/auth-js: Invalid SIWE message field "version". Version must be '1'. Provided value: ${version}`);
      if ((_a = parameters.statement) === null || _a === undefined ? undefined : _a.includes(`
`))
        throw new Error(`@supabase/auth-js: Invalid SIWE message field "statement". Statement must not include '\\n'. Provided value: ${parameters.statement}`);
    }
    const address = getAddress(parameters.address);
    const origin = scheme ? `${scheme}://${domain}` : domain;
    const statement = parameters.statement ? `${parameters.statement}
` : "";
    const prefix = `${origin} wants you to sign in with your Ethereum account:
${address}

${statement}`;
    let suffix = `URI: ${uri}
Version: ${version}
Chain ID: ${chainId}${nonce ? `
Nonce: ${nonce}` : ""}
Issued At: ${issuedAt.toISOString()}`;
    if (expirationTime)
      suffix += `
Expiration Time: ${expirationTime.toISOString()}`;
    if (notBefore)
      suffix += `
Not Before: ${notBefore.toISOString()}`;
    if (requestId)
      suffix += `
Request ID: ${requestId}`;
    if (resources) {
      let content = `
Resources:`;
      for (const resource of resources) {
        if (!resource || typeof resource !== "string")
          throw new Error(`@supabase/auth-js: Invalid SIWE message field "resources". Every resource must be a valid string. Provided value: ${resource}`);
        content += `
- ${resource}`;
      }
      suffix += content;
    }
    return `${prefix}
${suffix}`;
  }
});

// backend/node_modules/@supabase/auth-js/dist/main/lib/webauthn.errors.js
var require_webauthn_errors = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.WebAuthnUnknownError = exports2.WebAuthnError = undefined;
  exports2.isWebAuthnError = isWebAuthnError;
  exports2.identifyRegistrationError = identifyRegistrationError;
  exports2.identifyAuthenticationError = identifyAuthenticationError;
  var webauthn_1 = require_webauthn();

  class WebAuthnError extends Error {
    constructor({ message, code, cause, name }) {
      var _a;
      super(message, { cause });
      this.__isWebAuthnError = true;
      this.name = (_a = name !== null && name !== undefined ? name : cause instanceof Error ? cause.name : undefined) !== null && _a !== undefined ? _a : "Unknown Error";
      this.code = code;
    }
  }
  exports2.WebAuthnError = WebAuthnError;

  class WebAuthnUnknownError extends WebAuthnError {
    constructor(message, originalError) {
      super({
        code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
        cause: originalError,
        message
      });
      this.name = "WebAuthnUnknownError";
      this.originalError = originalError;
    }
  }
  exports2.WebAuthnUnknownError = WebAuthnUnknownError;
  function isWebAuthnError(error) {
    return typeof error === "object" && error !== null && "__isWebAuthnError" in error;
  }
  function identifyRegistrationError({ error, options }) {
    var _a, _b, _c;
    const { publicKey } = options;
    if (!publicKey) {
      throw Error("options was missing required publicKey property");
    }
    if (error.name === "AbortError") {
      if (options.signal instanceof AbortSignal) {
        return new WebAuthnError({
          message: "Registration ceremony was sent an abort signal",
          code: "ERROR_CEREMONY_ABORTED",
          cause: error
        });
      }
    } else if (error.name === "ConstraintError") {
      if (((_a = publicKey.authenticatorSelection) === null || _a === undefined ? undefined : _a.requireResidentKey) === true) {
        return new WebAuthnError({
          message: "Discoverable credentials were required but no available authenticator supported it",
          code: "ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",
          cause: error
        });
      } else if (options.mediation === "conditional" && ((_b = publicKey.authenticatorSelection) === null || _b === undefined ? undefined : _b.userVerification) === "required") {
        return new WebAuthnError({
          message: "User verification was required during automatic registration but it could not be performed",
          code: "ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",
          cause: error
        });
      } else if (((_c = publicKey.authenticatorSelection) === null || _c === undefined ? undefined : _c.userVerification) === "required") {
        return new WebAuthnError({
          message: "User verification was required but no available authenticator supported it",
          code: "ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",
          cause: error
        });
      }
    } else if (error.name === "InvalidStateError") {
      return new WebAuthnError({
        message: "The authenticator was previously registered",
        code: "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",
        cause: error
      });
    } else if (error.name === "NotAllowedError") {
      return new WebAuthnError({
        message: error.message,
        code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
        cause: error
      });
    } else if (error.name === "NotSupportedError") {
      const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param) => param.type === "public-key");
      if (validPubKeyCredParams.length === 0) {
        return new WebAuthnError({
          message: 'No entry in pubKeyCredParams was of type "public-key"',
          code: "ERROR_MALFORMED_PUBKEYCREDPARAMS",
          cause: error
        });
      }
      return new WebAuthnError({
        message: "No available authenticator supported any of the specified pubKeyCredParams algorithms",
        code: "ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",
        cause: error
      });
    } else if (error.name === "SecurityError") {
      const effectiveDomain = window.location.hostname;
      if (!(0, webauthn_1.isValidDomain)(effectiveDomain)) {
        return new WebAuthnError({
          message: `${window.location.hostname} is an invalid domain`,
          code: "ERROR_INVALID_DOMAIN",
          cause: error
        });
      } else if (publicKey.rp.id !== effectiveDomain) {
        return new WebAuthnError({
          message: `The RP ID "${publicKey.rp.id}" is invalid for this domain`,
          code: "ERROR_INVALID_RP_ID",
          cause: error
        });
      }
    } else if (error.name === "TypeError") {
      if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {
        return new WebAuthnError({
          message: "User ID was not between 1 and 64 characters",
          code: "ERROR_INVALID_USER_ID_LENGTH",
          cause: error
        });
      }
    } else if (error.name === "UnknownError") {
      return new WebAuthnError({
        message: "The authenticator was unable to process the specified options, or could not create a new credential",
        code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
        cause: error
      });
    }
    return new WebAuthnError({
      message: "a Non-Webauthn related error has occurred",
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: error
    });
  }
  function identifyAuthenticationError({ error, options }) {
    const { publicKey } = options;
    if (!publicKey) {
      throw Error("options was missing required publicKey property");
    }
    if (error.name === "AbortError") {
      if (options.signal instanceof AbortSignal) {
        return new WebAuthnError({
          message: "Authentication ceremony was sent an abort signal",
          code: "ERROR_CEREMONY_ABORTED",
          cause: error
        });
      }
    } else if (error.name === "NotAllowedError") {
      return new WebAuthnError({
        message: error.message,
        code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
        cause: error
      });
    } else if (error.name === "SecurityError") {
      const effectiveDomain = window.location.hostname;
      if (!(0, webauthn_1.isValidDomain)(effectiveDomain)) {
        return new WebAuthnError({
          message: `${window.location.hostname} is an invalid domain`,
          code: "ERROR_INVALID_DOMAIN",
          cause: error
        });
      } else if (publicKey.rpId !== effectiveDomain) {
        return new WebAuthnError({
          message: `The RP ID "${publicKey.rpId}" is invalid for this domain`,
          code: "ERROR_INVALID_RP_ID",
          cause: error
        });
      }
    } else if (error.name === "UnknownError") {
      return new WebAuthnError({
        message: "The authenticator was unable to process the specified options, or could not create a new assertion signature",
        code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
        cause: error
      });
    }
    return new WebAuthnError({
      message: "a Non-Webauthn related error has occurred",
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: error
    });
  }
});

// backend/node_modules/@supabase/auth-js/dist/main/lib/webauthn.js
var require_webauthn = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.WebAuthnApi = exports2.DEFAULT_REQUEST_OPTIONS = exports2.DEFAULT_CREATION_OPTIONS = exports2.webAuthnAbortService = exports2.WebAuthnAbortService = exports2.identifyAuthenticationError = exports2.identifyRegistrationError = exports2.isWebAuthnError = exports2.WebAuthnError = undefined;
  exports2.deserializeCredentialCreationOptions = deserializeCredentialCreationOptions;
  exports2.deserializeCredentialRequestOptions = deserializeCredentialRequestOptions;
  exports2.serializeCredentialCreationResponse = serializeCredentialCreationResponse;
  exports2.serializeCredentialRequestResponse = serializeCredentialRequestResponse;
  exports2.isValidDomain = isValidDomain;
  exports2.createCredential = createCredential;
  exports2.getCredential = getCredential;
  exports2.mergeCredentialCreationOptions = mergeCredentialCreationOptions;
  exports2.mergeCredentialRequestOptions = mergeCredentialRequestOptions;
  var tslib_1 = require_tslib();
  var base64url_1 = require_base64url();
  var errors_1 = require_errors3();
  var helpers_1 = require_helpers4();
  var webauthn_errors_1 = require_webauthn_errors();
  Object.defineProperty(exports2, "identifyAuthenticationError", { enumerable: true, get: function() {
    return webauthn_errors_1.identifyAuthenticationError;
  } });
  Object.defineProperty(exports2, "identifyRegistrationError", { enumerable: true, get: function() {
    return webauthn_errors_1.identifyRegistrationError;
  } });
  Object.defineProperty(exports2, "isWebAuthnError", { enumerable: true, get: function() {
    return webauthn_errors_1.isWebAuthnError;
  } });
  Object.defineProperty(exports2, "WebAuthnError", { enumerable: true, get: function() {
    return webauthn_errors_1.WebAuthnError;
  } });

  class WebAuthnAbortService {
    createNewAbortSignal() {
      if (this.controller) {
        const abortError = new Error("Cancelling existing WebAuthn API call for new one");
        abortError.name = "AbortError";
        this.controller.abort(abortError);
      }
      const newController = new AbortController;
      this.controller = newController;
      return newController.signal;
    }
    cancelCeremony() {
      if (this.controller) {
        const abortError = new Error("Manually cancelling existing WebAuthn API call");
        abortError.name = "AbortError";
        this.controller.abort(abortError);
        this.controller = undefined;
      }
    }
  }
  exports2.WebAuthnAbortService = WebAuthnAbortService;
  exports2.webAuthnAbortService = new WebAuthnAbortService;
  function deserializeCredentialCreationOptions(options) {
    if (!options) {
      throw new Error("Credential creation options are required");
    }
    if (typeof PublicKeyCredential !== "undefined" && "parseCreationOptionsFromJSON" in PublicKeyCredential && typeof PublicKeyCredential.parseCreationOptionsFromJSON === "function") {
      return PublicKeyCredential.parseCreationOptionsFromJSON(options);
    }
    const { challenge: challengeStr, user: userOpts, excludeCredentials } = options, restOptions = tslib_1.__rest(options, ["challenge", "user", "excludeCredentials"]);
    const challenge = (0, base64url_1.base64UrlToUint8Array)(challengeStr).buffer;
    const user = Object.assign(Object.assign({}, userOpts), { id: (0, base64url_1.base64UrlToUint8Array)(userOpts.id).buffer });
    const result = Object.assign(Object.assign({}, restOptions), {
      challenge,
      user
    });
    if (excludeCredentials && excludeCredentials.length > 0) {
      result.excludeCredentials = new Array(excludeCredentials.length);
      for (let i = 0;i < excludeCredentials.length; i++) {
        const cred = excludeCredentials[i];
        result.excludeCredentials[i] = Object.assign(Object.assign({}, cred), {
          id: (0, base64url_1.base64UrlToUint8Array)(cred.id).buffer,
          type: cred.type || "public-key",
          transports: cred.transports
        });
      }
    }
    return result;
  }
  function deserializeCredentialRequestOptions(options) {
    if (!options) {
      throw new Error("Credential request options are required");
    }
    if (typeof PublicKeyCredential !== "undefined" && "parseRequestOptionsFromJSON" in PublicKeyCredential && typeof PublicKeyCredential.parseRequestOptionsFromJSON === "function") {
      return PublicKeyCredential.parseRequestOptionsFromJSON(options);
    }
    const { challenge: challengeStr, allowCredentials } = options, restOptions = tslib_1.__rest(options, ["challenge", "allowCredentials"]);
    const challenge = (0, base64url_1.base64UrlToUint8Array)(challengeStr).buffer;
    const result = Object.assign(Object.assign({}, restOptions), { challenge });
    if (allowCredentials && allowCredentials.length > 0) {
      result.allowCredentials = new Array(allowCredentials.length);
      for (let i = 0;i < allowCredentials.length; i++) {
        const cred = allowCredentials[i];
        result.allowCredentials[i] = Object.assign(Object.assign({}, cred), {
          id: (0, base64url_1.base64UrlToUint8Array)(cred.id).buffer,
          type: cred.type || "public-key",
          transports: cred.transports
        });
      }
    }
    return result;
  }
  function serializeCredentialCreationResponse(credential) {
    var _a;
    if ("toJSON" in credential && typeof credential.toJSON === "function") {
      return credential.toJSON();
    }
    const credentialWithAttachment = credential;
    return {
      id: credential.id,
      rawId: credential.id,
      response: {
        attestationObject: (0, base64url_1.bytesToBase64URL)(new Uint8Array(credential.response.attestationObject)),
        clientDataJSON: (0, base64url_1.bytesToBase64URL)(new Uint8Array(credential.response.clientDataJSON))
      },
      type: "public-key",
      clientExtensionResults: credential.getClientExtensionResults(),
      authenticatorAttachment: (_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== undefined ? _a : undefined
    };
  }
  function serializeCredentialRequestResponse(credential) {
    var _a;
    if ("toJSON" in credential && typeof credential.toJSON === "function") {
      return credential.toJSON();
    }
    const credentialWithAttachment = credential;
    const clientExtensionResults = credential.getClientExtensionResults();
    const assertionResponse = credential.response;
    return {
      id: credential.id,
      rawId: credential.id,
      response: {
        authenticatorData: (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.authenticatorData)),
        clientDataJSON: (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.clientDataJSON)),
        signature: (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.signature)),
        userHandle: assertionResponse.userHandle ? (0, base64url_1.bytesToBase64URL)(new Uint8Array(assertionResponse.userHandle)) : undefined
      },
      type: "public-key",
      clientExtensionResults,
      authenticatorAttachment: (_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== undefined ? _a : undefined
    };
  }
  function isValidDomain(hostname) {
    return hostname === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(hostname);
  }
  function browserSupportsWebAuthn() {
    var _a, _b;
    return !!((0, helpers_1.isBrowser)() && ("PublicKeyCredential" in window) && window.PublicKeyCredential && ("credentials" in navigator) && typeof ((_a = navigator === null || navigator === undefined ? undefined : navigator.credentials) === null || _a === undefined ? undefined : _a.create) === "function" && typeof ((_b = navigator === null || navigator === undefined ? undefined : navigator.credentials) === null || _b === undefined ? undefined : _b.get) === "function");
  }
  async function createCredential(options) {
    try {
      const response = await navigator.credentials.create(options);
      if (!response) {
        return {
          data: null,
          error: new webauthn_errors_1.WebAuthnUnknownError("Empty credential response", response)
        };
      }
      if (!(response instanceof PublicKeyCredential)) {
        return {
          data: null,
          error: new webauthn_errors_1.WebAuthnUnknownError("Browser returned unexpected credential type", response)
        };
      }
      return { data: response, error: null };
    } catch (err) {
      return {
        data: null,
        error: (0, webauthn_errors_1.identifyRegistrationError)({
          error: err,
          options
        })
      };
    }
  }
  async function getCredential(options) {
    try {
      const response = await navigator.credentials.get(options);
      if (!response) {
        return {
          data: null,
          error: new webauthn_errors_1.WebAuthnUnknownError("Empty credential response", response)
        };
      }
      if (!(response instanceof PublicKeyCredential)) {
        return {
          data: null,
          error: new webauthn_errors_1.WebAuthnUnknownError("Browser returned unexpected credential type", response)
        };
      }
      return { data: response, error: null };
    } catch (err) {
      return {
        data: null,
        error: (0, webauthn_errors_1.identifyAuthenticationError)({
          error: err,
          options
        })
      };
    }
  }
  exports2.DEFAULT_CREATION_OPTIONS = {
    hints: ["security-key"],
    authenticatorSelection: {
      authenticatorAttachment: "cross-platform",
      requireResidentKey: false,
      userVerification: "preferred",
      residentKey: "discouraged"
    },
    attestation: "direct"
  };
  exports2.DEFAULT_REQUEST_OPTIONS = {
    userVerification: "preferred",
    hints: ["security-key"],
    attestation: "direct"
  };
  function deepMerge(...sources) {
    const isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    const isArrayBufferLike = (val) => val instanceof ArrayBuffer || ArrayBuffer.isView(val);
    const result = {};
    for (const source of sources) {
      if (!source)
        continue;
      for (const key in source) {
        const value = source[key];
        if (value === undefined)
          continue;
        if (Array.isArray(value)) {
          result[key] = value;
        } else if (isArrayBufferLike(value)) {
          result[key] = value;
        } else if (isObject(value)) {
          const existing = result[key];
          if (isObject(existing)) {
            result[key] = deepMerge(existing, value);
          } else {
            result[key] = deepMerge(value);
          }
        } else {
          result[key] = value;
        }
      }
    }
    return result;
  }
  function mergeCredentialCreationOptions(baseOptions, overrides) {
    return deepMerge(exports2.DEFAULT_CREATION_OPTIONS, baseOptions, overrides || {});
  }
  function mergeCredentialRequestOptions(baseOptions, overrides) {
    return deepMerge(exports2.DEFAULT_REQUEST_OPTIONS, baseOptions, overrides || {});
  }

  class WebAuthnApi {
    constructor(client) {
      this.client = client;
      this.enroll = this._enroll.bind(this);
      this.challenge = this._challenge.bind(this);
      this.verify = this._verify.bind(this);
      this.authenticate = this._authenticate.bind(this);
      this.register = this._register.bind(this);
    }
    async _enroll(params) {
      return this.client.mfa.enroll(Object.assign(Object.assign({}, params), { factorType: "webauthn" }));
    }
    async _challenge({ factorId, webauthn, friendlyName, signal }, overrides) {
      try {
        const { data: challengeResponse, error: challengeError } = await this.client.mfa.challenge({
          factorId,
          webauthn
        });
        if (!challengeResponse) {
          return { data: null, error: challengeError };
        }
        const abortSignal = signal !== null && signal !== undefined ? signal : exports2.webAuthnAbortService.createNewAbortSignal();
        if (challengeResponse.webauthn.type === "create") {
          const { user } = challengeResponse.webauthn.credential_options.publicKey;
          if (!user.name) {
            user.name = `${user.id}:${friendlyName}`;
          }
          if (!user.displayName) {
            user.displayName = user.name;
          }
        }
        switch (challengeResponse.webauthn.type) {
          case "create": {
            const options = mergeCredentialCreationOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === undefined ? undefined : overrides.create);
            const { data, error } = await createCredential({
              publicKey: options,
              signal: abortSignal
            });
            if (data) {
              return {
                data: {
                  factorId,
                  challengeId: challengeResponse.id,
                  webauthn: {
                    type: challengeResponse.webauthn.type,
                    credential_response: data
                  }
                },
                error: null
              };
            }
            return { data: null, error };
          }
          case "request": {
            const options = mergeCredentialRequestOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === undefined ? undefined : overrides.request);
            const { data, error } = await getCredential(Object.assign(Object.assign({}, challengeResponse.webauthn.credential_options), { publicKey: options, signal: abortSignal }));
            if (data) {
              return {
                data: {
                  factorId,
                  challengeId: challengeResponse.id,
                  webauthn: {
                    type: challengeResponse.webauthn.type,
                    credential_response: data
                  }
                },
                error: null
              };
            }
            return { data: null, error };
          }
        }
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return { data: null, error };
        }
        return {
          data: null,
          error: new errors_1.AuthUnknownError("Unexpected error in challenge", error)
        };
      }
    }
    async _verify({ challengeId, factorId, webauthn }) {
      return this.client.mfa.verify({
        factorId,
        challengeId,
        webauthn
      });
    }
    async _authenticate({ factorId, webauthn: { rpId = typeof window !== "undefined" ? window.location.hostname : undefined, rpOrigins = typeof window !== "undefined" ? [window.location.origin] : undefined, signal } = {} }, overrides) {
      if (!rpId) {
        return {
          data: null,
          error: new errors_1.AuthError("rpId is required for WebAuthn authentication")
        };
      }
      try {
        if (!browserSupportsWebAuthn()) {
          return {
            data: null,
            error: new errors_1.AuthUnknownError("Browser does not support WebAuthn", null)
          };
        }
        const { data: challengeResponse, error: challengeError } = await this.challenge({
          factorId,
          webauthn: { rpId, rpOrigins },
          signal
        }, { request: overrides });
        if (!challengeResponse) {
          return { data: null, error: challengeError };
        }
        const { webauthn } = challengeResponse;
        return this._verify({
          factorId,
          challengeId: challengeResponse.challengeId,
          webauthn: {
            type: webauthn.type,
            rpId,
            rpOrigins,
            credential_response: webauthn.credential_response
          }
        });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return { data: null, error };
        }
        return {
          data: null,
          error: new errors_1.AuthUnknownError("Unexpected error in authenticate", error)
        };
      }
    }
    async _register({ friendlyName, webauthn: { rpId = typeof window !== "undefined" ? window.location.hostname : undefined, rpOrigins = typeof window !== "undefined" ? [window.location.origin] : undefined, signal } = {} }, overrides) {
      if (!rpId) {
        return {
          data: null,
          error: new errors_1.AuthError("rpId is required for WebAuthn registration")
        };
      }
      try {
        if (!browserSupportsWebAuthn()) {
          return {
            data: null,
            error: new errors_1.AuthUnknownError("Browser does not support WebAuthn", null)
          };
        }
        const { data: factor, error: enrollError } = await this._enroll({
          friendlyName
        });
        if (!factor) {
          await this.client.mfa.listFactors().then((factors) => {
            var _a;
            return (_a = factors.data) === null || _a === undefined ? undefined : _a.all.find((v) => v.factor_type === "webauthn" && v.friendly_name === friendlyName && v.status !== "unverified");
          }).then((factor2) => factor2 ? this.client.mfa.unenroll({ factorId: factor2 === null || factor2 === undefined ? undefined : factor2.id }) : undefined);
          return { data: null, error: enrollError };
        }
        const { data: challengeResponse, error: challengeError } = await this._challenge({
          factorId: factor.id,
          friendlyName: factor.friendly_name,
          webauthn: { rpId, rpOrigins },
          signal
        }, {
          create: overrides
        });
        if (!challengeResponse) {
          return { data: null, error: challengeError };
        }
        return this._verify({
          factorId: factor.id,
          challengeId: challengeResponse.challengeId,
          webauthn: {
            rpId,
            rpOrigins,
            type: challengeResponse.webauthn.type,
            credential_response: challengeResponse.webauthn.credential_response
          }
        });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return { data: null, error };
        }
        return {
          data: null,
          error: new errors_1.AuthUnknownError("Unexpected error in register", error)
        };
      }
    }
  }
  exports2.WebAuthnApi = WebAuthnApi;
});

// backend/node_modules/@supabase/auth-js/dist/main/GoTrueClient.js
var require_GoTrueClient = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  var GoTrueAdminApi_1 = tslib_1.__importDefault(require_GoTrueAdminApi());
  var constants_1 = require_constants5();
  var errors_1 = require_errors3();
  var fetch_1 = require_fetch4();
  var helpers_1 = require_helpers4();
  var local_storage_1 = require_local_storage();
  var locks_1 = require_locks();
  var polyfills_1 = require_polyfills();
  var version_1 = require_version4();
  var base64url_1 = require_base64url();
  var ethereum_1 = require_ethereum();
  var webauthn_1 = require_webauthn();
  (0, polyfills_1.polyfillGlobalThis)();
  var DEFAULT_OPTIONS = {
    url: constants_1.GOTRUE_URL,
    storageKey: constants_1.STORAGE_KEY,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true,
    headers: constants_1.DEFAULT_HEADERS,
    flowType: "implicit",
    debug: false,
    hasCustomAuthorizationHeader: false,
    throwOnError: false
  };
  async function lockNoOp(name, acquireTimeout, fn) {
    return await fn();
  }
  var GLOBAL_JWKS = {};

  class GoTrueClient {
    get jwks() {
      var _a, _b;
      return (_b = (_a = GLOBAL_JWKS[this.storageKey]) === null || _a === undefined ? undefined : _a.jwks) !== null && _b !== undefined ? _b : { keys: [] };
    }
    set jwks(value) {
      GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), { jwks: value });
    }
    get jwks_cached_at() {
      var _a, _b;
      return (_b = (_a = GLOBAL_JWKS[this.storageKey]) === null || _a === undefined ? undefined : _a.cachedAt) !== null && _b !== undefined ? _b : Number.MIN_SAFE_INTEGER;
    }
    set jwks_cached_at(value) {
      GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), { cachedAt: value });
    }
    constructor(options) {
      var _a, _b, _c;
      this.userStorage = null;
      this.memoryStorage = null;
      this.stateChangeEmitters = new Map;
      this.autoRefreshTicker = null;
      this.visibilityChangedCallback = null;
      this.refreshingDeferred = null;
      this.initializePromise = null;
      this.detectSessionInUrl = true;
      this.hasCustomAuthorizationHeader = false;
      this.suppressGetSessionWarning = false;
      this.lockAcquired = false;
      this.pendingInLock = [];
      this.broadcastChannel = null;
      this.logger = console.log;
      const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
      this.storageKey = settings.storageKey;
      this.instanceID = (_a = GoTrueClient.nextInstanceID[this.storageKey]) !== null && _a !== undefined ? _a : 0;
      GoTrueClient.nextInstanceID[this.storageKey] = this.instanceID + 1;
      this.logDebugMessages = !!settings.debug;
      if (typeof settings.debug === "function") {
        this.logger = settings.debug;
      }
      if (this.instanceID > 0 && (0, helpers_1.isBrowser)()) {
        const message = `${this._logPrefix()} Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.`;
        console.warn(message);
        if (this.logDebugMessages) {
          console.trace(message);
        }
      }
      this.persistSession = settings.persistSession;
      this.autoRefreshToken = settings.autoRefreshToken;
      this.admin = new GoTrueAdminApi_1.default({
        url: settings.url,
        headers: settings.headers,
        fetch: settings.fetch
      });
      this.url = settings.url;
      this.headers = settings.headers;
      this.fetch = (0, helpers_1.resolveFetch)(settings.fetch);
      this.lock = settings.lock || lockNoOp;
      this.detectSessionInUrl = settings.detectSessionInUrl;
      this.flowType = settings.flowType;
      this.hasCustomAuthorizationHeader = settings.hasCustomAuthorizationHeader;
      this.throwOnError = settings.throwOnError;
      if (settings.lock) {
        this.lock = settings.lock;
      } else if ((0, helpers_1.isBrowser)() && ((_b = globalThis === null || globalThis === undefined ? undefined : globalThis.navigator) === null || _b === undefined ? undefined : _b.locks)) {
        this.lock = locks_1.navigatorLock;
      } else {
        this.lock = lockNoOp;
      }
      if (!this.jwks) {
        this.jwks = { keys: [] };
        this.jwks_cached_at = Number.MIN_SAFE_INTEGER;
      }
      this.mfa = {
        verify: this._verify.bind(this),
        enroll: this._enroll.bind(this),
        unenroll: this._unenroll.bind(this),
        challenge: this._challenge.bind(this),
        listFactors: this._listFactors.bind(this),
        challengeAndVerify: this._challengeAndVerify.bind(this),
        getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),
        webauthn: new webauthn_1.WebAuthnApi(this)
      };
      this.oauth = {
        getAuthorizationDetails: this._getAuthorizationDetails.bind(this),
        approveAuthorization: this._approveAuthorization.bind(this),
        denyAuthorization: this._denyAuthorization.bind(this),
        listGrants: this._listOAuthGrants.bind(this),
        revokeGrant: this._revokeOAuthGrant.bind(this)
      };
      if (this.persistSession) {
        if (settings.storage) {
          this.storage = settings.storage;
        } else {
          if ((0, helpers_1.supportsLocalStorage)()) {
            this.storage = globalThis.localStorage;
          } else {
            this.memoryStorage = {};
            this.storage = (0, local_storage_1.memoryLocalStorageAdapter)(this.memoryStorage);
          }
        }
        if (settings.userStorage) {
          this.userStorage = settings.userStorage;
        }
      } else {
        this.memoryStorage = {};
        this.storage = (0, local_storage_1.memoryLocalStorageAdapter)(this.memoryStorage);
      }
      if ((0, helpers_1.isBrowser)() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
        try {
          this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);
        } catch (e) {
          console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", e);
        }
        (_c = this.broadcastChannel) === null || _c === undefined || _c.addEventListener("message", async (event) => {
          this._debug("received broadcast notification from other tab or client", event);
          await this._notifyAllSubscribers(event.data.event, event.data.session, false);
        });
      }
      this.initialize();
    }
    isThrowOnErrorEnabled() {
      return this.throwOnError;
    }
    _returnResult(result) {
      if (this.throwOnError && result && result.error) {
        throw result.error;
      }
      return result;
    }
    _logPrefix() {
      return "GoTrueClient@" + `${this.storageKey}:${this.instanceID} (${version_1.version}) ${new Date().toISOString()}`;
    }
    _debug(...args) {
      if (this.logDebugMessages) {
        this.logger(this._logPrefix(), ...args);
      }
      return this;
    }
    async initialize() {
      if (this.initializePromise) {
        return await this.initializePromise;
      }
      this.initializePromise = (async () => {
        return await this._acquireLock(-1, async () => {
          return await this._initialize();
        });
      })();
      return await this.initializePromise;
    }
    async _initialize() {
      var _a;
      try {
        let params = {};
        let callbackUrlType = "none";
        if ((0, helpers_1.isBrowser)()) {
          params = (0, helpers_1.parseParametersFromURL)(window.location.href);
          if (this._isImplicitGrantCallback(params)) {
            callbackUrlType = "implicit";
          } else if (await this._isPKCECallback(params)) {
            callbackUrlType = "pkce";
          }
        }
        if ((0, helpers_1.isBrowser)() && this.detectSessionInUrl && callbackUrlType !== "none") {
          const { data, error } = await this._getSessionFromURL(params, callbackUrlType);
          if (error) {
            this._debug("#_initialize()", "error detecting session from URL", error);
            if ((0, errors_1.isAuthImplicitGrantRedirectError)(error)) {
              const errorCode = (_a = error.details) === null || _a === undefined ? undefined : _a.code;
              if (errorCode === "identity_already_exists" || errorCode === "identity_not_found" || errorCode === "single_identity_not_deletable") {
                return { error };
              }
            }
            await this._removeSession();
            return { error };
          }
          const { session, redirectType } = data;
          this._debug("#_initialize()", "detected session in URL", session, "redirect type", redirectType);
          await this._saveSession(session);
          setTimeout(async () => {
            if (redirectType === "recovery") {
              await this._notifyAllSubscribers("PASSWORD_RECOVERY", session);
            } else {
              await this._notifyAllSubscribers("SIGNED_IN", session);
            }
          }, 0);
          return { error: null };
        }
        await this._recoverAndRefresh();
        return { error: null };
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ error });
        }
        return this._returnResult({
          error: new errors_1.AuthUnknownError("Unexpected error during initialization", error)
        });
      } finally {
        await this._handleVisibilityChange();
        this._debug("#_initialize()", "end");
      }
    }
    async signInAnonymously(credentials) {
      var _a, _b, _c;
      try {
        const res = await (0, fetch_1._request)(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          body: {
            data: (_b = (_a = credentials === null || credentials === undefined ? undefined : credentials.options) === null || _a === undefined ? undefined : _a.data) !== null && _b !== undefined ? _b : {},
            gotrue_meta_security: { captcha_token: (_c = credentials === null || credentials === undefined ? undefined : credentials.options) === null || _c === undefined ? undefined : _c.captchaToken }
          },
          xform: fetch_1._sessionResponse
        });
        const { data, error } = res;
        if (error || !data) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        const session = data.session;
        const user = data.user;
        if (data.session) {
          await this._saveSession(data.session);
          await this._notifyAllSubscribers("SIGNED_IN", session);
        }
        return this._returnResult({ data: { user, session }, error: null });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        throw error;
      }
    }
    async signUp(credentials) {
      var _a, _b, _c;
      try {
        let res;
        if ("email" in credentials) {
          const { email, password, options } = credentials;
          let codeChallenge = null;
          let codeChallengeMethod = null;
          if (this.flowType === "pkce") {
            [codeChallenge, codeChallengeMethod] = await (0, helpers_1.getCodeChallengeAndMethod)(this.storage, this.storageKey);
          }
          res = await (0, fetch_1._request)(this.fetch, "POST", `${this.url}/signup`, {
            headers: this.headers,
            redirectTo: options === null || options === undefined ? undefined : options.emailRedirectTo,
            body: {
              email,
              password,
              data: (_a = options === null || options === undefined ? undefined : options.data) !== null && _a !== undefined ? _a : {},
              gotrue_meta_security: { captcha_token: options === null || options === undefined ? undefined : options.captchaToken },
              code_challenge: codeChallenge,
              code_challenge_method: codeChallengeMethod
            },
            xform: fetch_1._sessionResponse
          });
        } else if ("phone" in credentials) {
          const { phone, password, options } = credentials;
          res = await (0, fetch_1._request)(this.fetch, "POST", `${this.url}/signup`, {
            headers: this.headers,
            body: {
              phone,
              password,
              data: (_b = options === null || options === undefined ? undefined : options.data) !== null && _b !== undefined ? _b : {},
              channel: (_c = options === null || options === undefined ? undefined : options.channel) !== null && _c !== undefined ? _c : "sms",
              gotrue_meta_security: { captcha_token: options === null || options === undefined ? undefined : options.captchaToken }
            },
            xform: fetch_1._sessionResponse
          });
        } else {
          throw new errors_1.AuthInvalidCredentialsError("You must provide either an email or phone number and a password");
        }
        const { data, error } = res;
        if (error || !data) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        const session = data.session;
        const user = data.user;
        if (data.session) {
          await this._saveSession(data.session);
          await this._notifyAllSubscribers("SIGNED_IN", session);
        }
        return this._returnResult({ data: { user, session }, error: null });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        throw error;
      }
    }
    async signInWithPassword(credentials) {
      try {
        let res;
        if ("email" in credentials) {
          const { email, password, options } = credentials;
          res = await (0, fetch_1._request)(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
            headers: this.headers,
            body: {
              email,
              password,
              gotrue_meta_security: { captcha_token: options === null || options === undefined ? undefined : options.captchaToken }
            },
            xform: fetch_1._sessionResponsePassword
          });
        } else if ("phone" in credentials) {
          const { phone, password, options } = credentials;
          res = await (0, fetch_1._request)(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
            headers: this.headers,
            body: {
              phone,
              password,
              gotrue_meta_security: { captcha_token: options === null || options === undefined ? undefined : options.captchaToken }
            },
            xform: fetch_1._sessionResponsePassword
          });
        } else {
          throw new errors_1.AuthInvalidCredentialsError("You must provide either an email or phone number and a password");
        }
        const { data, error } = res;
        if (error) {
          return this._returnResult({ data: { user: null, session: null }, error });
        } else if (!data || !data.session || !data.user) {
          const invalidTokenError = new errors_1.AuthInvalidTokenResponseError;
          return this._returnResult({ data: { user: null, session: null }, error: invalidTokenError });
        }
        if (data.session) {
          await this._saveSession(data.session);
          await this._notifyAllSubscribers("SIGNED_IN", data.session);
        }
        return this._returnResult({
          data: Object.assign({ user: data.user, session: data.session }, data.weak_password ? { weakPassword: data.weak_password } : null),
          error
        });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        throw error;
      }
    }
    async signInWithOAuth(credentials) {
      var _a, _b, _c, _d;
      return await this._handleProviderSignIn(credentials.provider, {
        redirectTo: (_a = credentials.options) === null || _a === undefined ? undefined : _a.redirectTo,
        scopes: (_b = credentials.options) === null || _b === undefined ? undefined : _b.scopes,
        queryParams: (_c = credentials.options) === null || _c === undefined ? undefined : _c.queryParams,
        skipBrowserRedirect: (_d = credentials.options) === null || _d === undefined ? undefined : _d.skipBrowserRedirect
      });
    }
    async exchangeCodeForSession(authCode) {
      await this.initializePromise;
      return this._acquireLock(-1, async () => {
        return this._exchangeCodeForSession(authCode);
      });
    }
    async signInWithWeb3(credentials) {
      const { chain } = credentials;
      switch (chain) {
        case "ethereum":
          return await this.signInWithEthereum(credentials);
        case "solana":
          return await this.signInWithSolana(credentials);
        default:
          throw new Error(`@supabase/auth-js: Unsupported chain "${chain}"`);
      }
    }
    async signInWithEthereum(credentials) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
      let message;
      let signature;
      if ("message" in credentials) {
        message = credentials.message;
        signature = credentials.signature;
      } else {
        const { chain, wallet, statement, options } = credentials;
        let resolvedWallet;
        if (!(0, helpers_1.isBrowser)()) {
          if (typeof wallet !== "object" || !(options === null || options === undefined ? undefined : options.url)) {
            throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
          }
          resolvedWallet = wallet;
        } else if (typeof wallet === "object") {
          resolvedWallet = wallet;
        } else {
          const windowAny = window;
          if ("ethereum" in windowAny && typeof windowAny.ethereum === "object" && "request" in windowAny.ethereum && typeof windowAny.ethereum.request === "function") {
            resolvedWallet = windowAny.ethereum;
          } else {
            throw new Error(`@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.`);
          }
        }
        const url = new URL((_a = options === null || options === undefined ? undefined : options.url) !== null && _a !== undefined ? _a : window.location.href);
        const accounts = await resolvedWallet.request({
          method: "eth_requestAccounts"
        }).then((accs) => accs).catch(() => {
          throw new Error(`@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid`);
        });
        if (!accounts || accounts.length === 0) {
          throw new Error(`@supabase/auth-js: No accounts available. Please ensure the wallet is connected.`);
        }
        const address = (0, ethereum_1.getAddress)(accounts[0]);
        let chainId = (_b = options === null || options === undefined ? undefined : options.signInWithEthereum) === null || _b === undefined ? undefined : _b.chainId;
        if (!chainId) {
          const chainIdHex = await resolvedWallet.request({
            method: "eth_chainId"
          });
          chainId = (0, ethereum_1.fromHex)(chainIdHex);
        }
        const siweMessage = {
          domain: url.host,
          address,
          statement,
          uri: url.href,
          version: "1",
          chainId,
          nonce: (_c = options === null || options === undefined ? undefined : options.signInWithEthereum) === null || _c === undefined ? undefined : _c.nonce,
          issuedAt: (_e = (_d = options === null || options === undefined ? undefined : options.signInWithEthereum) === null || _d === undefined ? undefined : _d.issuedAt) !== null && _e !== undefined ? _e : new Date,
          expirationTime: (_f = options === null || options === undefined ? undefined : options.signInWithEthereum) === null || _f === undefined ? undefined : _f.expirationTime,
          notBefore: (_g = options === null || options === undefined ? undefined : options.signInWithEthereum) === null || _g === undefined ? undefined : _g.notBefore,
          requestId: (_h = options === null || options === undefined ? undefined : options.signInWithEthereum) === null || _h === undefined ? undefined : _h.requestId,
          resources: (_j = options === null || options === undefined ? undefined : options.signInWithEthereum) === null || _j === undefined ? undefined : _j.resources
        };
        message = (0, ethereum_1.createSiweMessage)(siweMessage);
        signature = await resolvedWallet.request({
          method: "personal_sign",
          params: [(0, ethereum_1.toHex)(message), address]
        });
      }
      try {
        const { data, error } = await (0, fetch_1._request)(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
          headers: this.headers,
          body: Object.assign({
            chain: "ethereum",
            message,
            signature
          }, ((_k = credentials.options) === null || _k === undefined ? undefined : _k.captchaToken) ? { gotrue_meta_security: { captcha_token: (_l = credentials.options) === null || _l === undefined ? undefined : _l.captchaToken } } : null),
          xform: fetch_1._sessionResponse
        });
        if (error) {
          throw error;
        }
        if (!data || !data.session || !data.user) {
          const invalidTokenError = new errors_1.AuthInvalidTokenResponseError;
          return this._returnResult({ data: { user: null, session: null }, error: invalidTokenError });
        }
        if (data.session) {
          await this._saveSession(data.session);
          await this._notifyAllSubscribers("SIGNED_IN", data.session);
        }
        return this._returnResult({ data: Object.assign({}, data), error });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        throw error;
      }
    }
    async signInWithSolana(credentials) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      let message;
      let signature;
      if ("message" in credentials) {
        message = credentials.message;
        signature = credentials.signature;
      } else {
        const { chain, wallet, statement, options } = credentials;
        let resolvedWallet;
        if (!(0, helpers_1.isBrowser)()) {
          if (typeof wallet !== "object" || !(options === null || options === undefined ? undefined : options.url)) {
            throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
          }
          resolvedWallet = wallet;
        } else if (typeof wallet === "object") {
          resolvedWallet = wallet;
        } else {
          const windowAny = window;
          if ("solana" in windowAny && typeof windowAny.solana === "object" && (("signIn" in windowAny.solana) && typeof windowAny.solana.signIn === "function" || ("signMessage" in windowAny.solana) && typeof windowAny.solana.signMessage === "function")) {
            resolvedWallet = windowAny.solana;
          } else {
            throw new Error(`@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.`);
          }
        }
        const url = new URL((_a = options === null || options === undefined ? undefined : options.url) !== null && _a !== undefined ? _a : window.location.href);
        if ("signIn" in resolvedWallet && resolvedWallet.signIn) {
          const output = await resolvedWallet.signIn(Object.assign(Object.assign(Object.assign({ issuedAt: new Date().toISOString() }, options === null || options === undefined ? undefined : options.signInWithSolana), {
            version: "1",
            domain: url.host,
            uri: url.href
          }), statement ? { statement } : null));
          let outputToProcess;
          if (Array.isArray(output) && output[0] && typeof output[0] === "object") {
            outputToProcess = output[0];
          } else if (output && typeof output === "object" && "signedMessage" in output && "signature" in output) {
            outputToProcess = output;
          } else {
            throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");
          }
          if ("signedMessage" in outputToProcess && "signature" in outputToProcess && (typeof outputToProcess.signedMessage === "string" || outputToProcess.signedMessage instanceof Uint8Array) && outputToProcess.signature instanceof Uint8Array) {
            message = typeof outputToProcess.signedMessage === "string" ? outputToProcess.signedMessage : new TextDecoder().decode(outputToProcess.signedMessage);
            signature = outputToProcess.signature;
          } else {
            throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields");
          }
        } else {
          if (!("signMessage" in resolvedWallet) || typeof resolvedWallet.signMessage !== "function" || !("publicKey" in resolvedWallet) || typeof resolvedWallet !== "object" || !resolvedWallet.publicKey || !("toBase58" in resolvedWallet.publicKey) || typeof resolvedWallet.publicKey.toBase58 !== "function") {
            throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");
          }
          message = [
            `${url.host} wants you to sign in with your Solana account:`,
            resolvedWallet.publicKey.toBase58(),
            ...statement ? ["", statement, ""] : [""],
            "Version: 1",
            `URI: ${url.href}`,
            `Issued At: ${(_c = (_b = options === null || options === undefined ? undefined : options.signInWithSolana) === null || _b === undefined ? undefined : _b.issuedAt) !== null && _c !== undefined ? _c : new Date().toISOString()}`,
            ...((_d = options === null || options === undefined ? undefined : options.signInWithSolana) === null || _d === undefined ? undefined : _d.notBefore) ? [`Not Before: ${options.signInWithSolana.notBefore}`] : [],
            ...((_e = options === null || options === undefined ? undefined : options.signInWithSolana) === null || _e === undefined ? undefined : _e.expirationTime) ? [`Expiration Time: ${options.signInWithSolana.expirationTime}`] : [],
            ...((_f = options === null || options === undefined ? undefined : options.signInWithSolana) === null || _f === undefined ? undefined : _f.chainId) ? [`Chain ID: ${options.signInWithSolana.chainId}`] : [],
            ...((_g = options === null || options === undefined ? undefined : options.signInWithSolana) === null || _g === undefined ? undefined : _g.nonce) ? [`Nonce: ${options.signInWithSolana.nonce}`] : [],
            ...((_h = options === null || options === undefined ? undefined : options.signInWithSolana) === null || _h === undefined ? undefined : _h.requestId) ? [`Request ID: ${options.signInWithSolana.requestId}`] : [],
            ...((_k = (_j = options === null || options === undefined ? undefined : options.signInWithSolana) === null || _j === undefined ? undefined : _j.resources) === null || _k === undefined ? undefined : _k.length) ? [
              "Resources",
              ...options.signInWithSolana.resources.map((resource) => `- ${resource}`)
            ] : []
          ].join(`
`);
          const maybeSignature = await resolvedWallet.signMessage(new TextEncoder().encode(message), "utf8");
          if (!maybeSignature || !(maybeSignature instanceof Uint8Array)) {
            throw new Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value");
          }
          signature = maybeSignature;
        }
      }
      try {
        const { data, error } = await (0, fetch_1._request)(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
          headers: this.headers,
          body: Object.assign({ chain: "solana", message, signature: (0, base64url_1.bytesToBase64URL)(signature) }, ((_l = credentials.options) === null || _l === undefined ? undefined : _l.captchaToken) ? { gotrue_meta_security: { captcha_token: (_m = credentials.options) === null || _m === undefined ? undefined : _m.captchaToken } } : null),
          xform: fetch_1._sessionResponse
        });
        if (error) {
          throw error;
        }
        if (!data || !data.session || !data.user) {
          const invalidTokenError = new errors_1.AuthInvalidTokenResponseError;
          return this._returnResult({ data: { user: null, session: null }, error: invalidTokenError });
        }
        if (data.session) {
          await this._saveSession(data.session);
          await this._notifyAllSubscribers("SIGNED_IN", data.session);
        }
        return this._returnResult({ data: Object.assign({}, data), error });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        throw error;
      }
    }
    async _exchangeCodeForSession(authCode) {
      const storageItem = await (0, helpers_1.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
      const [codeVerifier, redirectType] = (storageItem !== null && storageItem !== undefined ? storageItem : "").split("/");
      try {
        const { data, error } = await (0, fetch_1._request)(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, {
          headers: this.headers,
          body: {
            auth_code: authCode,
            code_verifier: codeVerifier
          },
          xform: fetch_1._sessionResponse
        });
        await (0, helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
        if (error) {
          throw error;
        }
        if (!data || !data.session || !data.user) {
          const invalidTokenError = new errors_1.AuthInvalidTokenResponseError;
          return this._returnResult({
            data: { user: null, session: null, redirectType: null },
            error: invalidTokenError
          });
        }
        if (data.session) {
          await this._saveSession(data.session);
          await this._notifyAllSubscribers("SIGNED_IN", data.session);
        }
        return this._returnResult({ data: Object.assign(Object.assign({}, data), { redirectType: redirectType !== null && redirectType !== undefined ? redirectType : null }), error });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({
            data: { user: null, session: null, redirectType: null },
            error
          });
        }
        throw error;
      }
    }
    async signInWithIdToken(credentials) {
      try {
        const { options, provider, token, access_token, nonce } = credentials;
        const res = await (0, fetch_1._request)(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
          headers: this.headers,
          body: {
            provider,
            id_token: token,
            access_token,
            nonce,
            gotrue_meta_security: { captcha_token: options === null || options === undefined ? undefined : options.captchaToken }
          },
          xform: fetch_1._sessionResponse
        });
        const { data, error } = res;
        if (error) {
          return this._returnResult({ data: { user: null, session: null }, error });
        } else if (!data || !data.session || !data.user) {
          const invalidTokenError = new errors_1.AuthInvalidTokenResponseError;
          return this._returnResult({ data: { user: null, session: null }, error: invalidTokenError });
        }
        if (data.session) {
          await this._saveSession(data.session);
          await this._notifyAllSubscribers("SIGNED_IN", data.session);
        }
        return this._returnResult({ data, error });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        throw error;
      }
    }
    async signInWithOtp(credentials) {
      var _a, _b, _c, _d, _e;
      try {
        if ("email" in credentials) {
          const { email, options } = credentials;
          let codeChallenge = null;
          let codeChallengeMethod = null;
          if (this.flowType === "pkce") {
            [codeChallenge, codeChallengeMethod] = await (0, helpers_1.getCodeChallengeAndMethod)(this.storage, this.storageKey);
          }
          const { error } = await (0, fetch_1._request)(this.fetch, "POST", `${this.url}/otp`, {
            headers: this.headers,
            body: {
              email,
              data: (_a = options === null || options === undefined ? undefined : options.data) !== null && _a !== undefined ? _a : {},
              create_user: (_b = options === null || options === undefined ? undefined : options.shouldCreateUser) !== null && _b !== undefined ? _b : true,
              gotrue_meta_security: { captcha_token: options === null || options === undefined ? undefined : options.captchaToken },
              code_challenge: codeChallenge,
              code_challenge_method: codeChallengeMethod
            },
            redirectTo: options === null || options === undefined ? undefined : options.emailRedirectTo
          });
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        if ("phone" in credentials) {
          const { phone, options } = credentials;
          const { data, error } = await (0, fetch_1._request)(this.fetch, "POST", `${this.url}/otp`, {
            headers: this.headers,
            body: {
              phone,
              data: (_c = options === null || options === undefined ? undefined : options.data) !== null && _c !== undefined ? _c : {},
              create_user: (_d = options === null || options === undefined ? undefined : options.shouldCreateUser) !== null && _d !== undefined ? _d : true,
              gotrue_meta_security: { captcha_token: options === null || options === undefined ? undefined : options.captchaToken },
              channel: (_e = options === null || options === undefined ? undefined : options.channel) !== null && _e !== undefined ? _e : "sms"
            }
          });
          return this._returnResult({
            data: { user: null, session: null, messageId: data === null || data === undefined ? undefined : data.message_id },
            error
          });
        }
        throw new errors_1.AuthInvalidCredentialsError("You must provide either an email or phone number.");
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        throw error;
      }
    }
    async verifyOtp(params) {
      var _a, _b;
      try {
        let redirectTo = undefined;
        let captchaToken = undefined;
        if ("options" in params) {
          redirectTo = (_a = params.options) === null || _a === undefined ? undefined : _a.redirectTo;
          captchaToken = (_b = params.options) === null || _b === undefined ? undefined : _b.captchaToken;
        }
        const { data, error } = await (0, fetch_1._request)(this.fetch, "POST", `${this.url}/verify`, {
          headers: this.headers,
          body: Object.assign(Object.assign({}, params), { gotrue_meta_security: { captcha_token: captchaToken } }),
          redirectTo,
          xform: fetch_1._sessionResponse
        });
        if (error) {
          throw error;
        }
        if (!data) {
          const tokenVerificationError = new Error("An error occurred on token verification.");
          throw tokenVerificationError;
        }
        const session = data.session;
        const user = data.user;
        if (session === null || session === undefined ? undefined : session.access_token) {
          await this._saveSession(session);
          await this._notifyAllSubscribers(params.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN", session);
        }
        return this._returnResult({ data: { user, session }, error: null });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        throw error;
      }
    }
    async signInWithSSO(params) {
      var _a, _b, _c, _d, _e;
      try {
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === "pkce") {
          [codeChallenge, codeChallengeMethod] = await (0, helpers_1.getCodeChallengeAndMethod)(this.storage, this.storageKey);
        }
        const result = await (0, fetch_1._request)(this.fetch, "POST", `${this.url}/sso`, {
          body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId" in params ? { provider_id: params.providerId } : null), "domain" in params ? { domain: params.domain } : null), { redirect_to: (_b = (_a = params.options) === null || _a === undefined ? undefined : _a.redirectTo) !== null && _b !== undefined ? _b : undefined }), ((_c = params === null || params === undefined ? undefined : params.options) === null || _c === undefined ? undefined : _c.captchaToken) ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } } : null), { skip_http_redirect: true, code_challenge: codeChallenge, code_challenge_method: codeChallengeMethod }),
          headers: this.headers,
          xform: fetch_1._ssoResponse
        });
        if (((_d = result.data) === null || _d === undefined ? undefined : _d.url) && (0, helpers_1.isBrowser)() && !((_e = params.options) === null || _e === undefined ? undefined : _e.skipBrowserRedirect)) {
          window.location.assign(result.data.url);
        }
        return this._returnResult(result);
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: null, error });
        }
        throw error;
      }
    }
    async reauthenticate() {
      await this.initializePromise;
      return await this._acquireLock(-1, async () => {
        return await this._reauthenticate();
      });
    }
    async _reauthenticate() {
      try {
        return await this._useSession(async (result) => {
          const { data: { session }, error: sessionError } = result;
          if (sessionError)
            throw sessionError;
          if (!session)
            throw new errors_1.AuthSessionMissingError;
          const { error } = await (0, fetch_1._request)(this.fetch, "GET", `${this.url}/reauthenticate`, {
            headers: this.headers,
            jwt: session.access_token
          });
          return this._returnResult({ data: { user: null, session: null }, error });
        });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        throw error;
      }
    }
    async resend(credentials) {
      try {
        const endpoint = `${this.url}/resend`;
        if ("email" in credentials) {
          const { email, type, options } = credentials;
          const { error } = await (0, fetch_1._request)(this.fetch, "POST", endpoint, {
            headers: this.headers,
            body: {
              email,
              type,
              gotrue_meta_security: { captcha_token: options === null || options === undefined ? undefined : options.captchaToken }
            },
            redirectTo: options === null || options === undefined ? undefined : options.emailRedirectTo
          });
          return this._returnResult({ data: { user: null, session: null }, error });
        } else if ("phone" in credentials) {
          const { phone, type, options } = credentials;
          const { data, error } = await (0, fetch_1._request)(this.fetch, "POST", endpoint, {
            headers: this.headers,
            body: {
              phone,
              type,
              gotrue_meta_security: { captcha_token: options === null || options === undefined ? undefined : options.captchaToken }
            }
          });
          return this._returnResult({
            data: { user: null, session: null, messageId: data === null || data === undefined ? undefined : data.message_id },
            error
          });
        }
        throw new errors_1.AuthInvalidCredentialsError("You must provide either an email or phone number and a type");
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        throw error;
      }
    }
    async getSession() {
      await this.initializePromise;
      const result = await this._acquireLock(-1, async () => {
        return this._useSession(async (result2) => {
          return result2;
        });
      });
      return result;
    }
    async _acquireLock(acquireTimeout, fn) {
      this._debug("#_acquireLock", "begin", acquireTimeout);
      try {
        if (this.lockAcquired) {
          const last = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve();
          const result = (async () => {
            await last;
            return await fn();
          })();
          this.pendingInLock.push((async () => {
            try {
              await result;
            } catch (e) {}
          })());
          return result;
        }
        return await this.lock(`lock:${this.storageKey}`, acquireTimeout, async () => {
          this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey);
          try {
            this.lockAcquired = true;
            const result = fn();
            this.pendingInLock.push((async () => {
              try {
                await result;
              } catch (e) {}
            })());
            await result;
            while (this.pendingInLock.length) {
              const waitOn = [...this.pendingInLock];
              await Promise.all(waitOn);
              this.pendingInLock.splice(0, waitOn.length);
            }
            return await result;
          } finally {
            this._debug("#_acquireLock", "lock released for storage key", this.storageKey);
            this.lockAcquired = false;
          }
        });
      } finally {
        this._debug("#_acquireLock", "end");
      }
    }
    async _useSession(fn) {
      this._debug("#_useSession", "begin");
      try {
        const result = await this.__loadSession();
        return await fn(result);
      } finally {
        this._debug("#_useSession", "end");
      }
    }
    async __loadSession() {
      this._debug("#__loadSession()", "begin");
      if (!this.lockAcquired) {
        this._debug("#__loadSession()", "used outside of an acquired lock!", new Error().stack);
      }
      try {
        let currentSession = null;
        const maybeSession = await (0, helpers_1.getItemAsync)(this.storage, this.storageKey);
        this._debug("#getSession()", "session from storage", maybeSession);
        if (maybeSession !== null) {
          if (this._isValidSession(maybeSession)) {
            currentSession = maybeSession;
          } else {
            this._debug("#getSession()", "session from storage is not valid");
            await this._removeSession();
          }
        }
        if (!currentSession) {
          return { data: { session: null }, error: null };
        }
        const hasExpired = currentSession.expires_at ? currentSession.expires_at * 1000 - Date.now() < constants_1.EXPIRY_MARGIN_MS : false;
        this._debug("#__loadSession()", `session has${hasExpired ? "" : " not"} expired`, "expires_at", currentSession.expires_at);
        if (!hasExpired) {
          if (this.userStorage) {
            const maybeUser = await (0, helpers_1.getItemAsync)(this.userStorage, this.storageKey + "-user");
            if (maybeUser === null || maybeUser === undefined ? undefined : maybeUser.user) {
              currentSession.user = maybeUser.user;
            } else {
              currentSession.user = (0, helpers_1.userNotAvailableProxy)();
            }
          }
          if (this.storage.isServer && currentSession.user && !currentSession.user.__isUserNotAvailableProxy) {
            const suppressWarningRef = { value: this.suppressGetSessionWarning };
            currentSession.user = (0, helpers_1.insecureUserWarningProxy)(currentSession.user, suppressWarningRef);
            if (suppressWarningRef.value) {
              this.suppressGetSessionWarning = true;
            }
          }
          return { data: { session: currentSession }, error: null };
        }
        const { data: session, error } = await this._callRefreshToken(currentSession.refresh_token);
        if (error) {
          return this._returnResult({ data: { session: null }, error });
        }
        return this._returnResult({ data: { session }, error: null });
      } finally {
        this._debug("#__loadSession()", "end");
      }
    }
    async getUser(jwt) {
      if (jwt) {
        return await this._getUser(jwt);
      }
      await this.initializePromise;
      const result = await this._acquireLock(-1, async () => {
        return await this._getUser();
      });
      return result;
    }
    async _getUser(jwt) {
      try {
        if (jwt) {
          return await (0, fetch_1._request)(this.fetch, "GET", `${this.url}/user`, {
            headers: this.headers,
            jwt,
            xform: fetch_1._userResponse
          });
        }
        return await this._useSession(async (result) => {
          var _a, _b, _c;
          const { data, error } = result;
          if (error) {
            throw error;
          }
          if (!((_a = data.session) === null || _a === undefined ? undefined : _a.access_token) && !this.hasCustomAuthorizationHeader) {
            return { data: { user: null }, error: new errors_1.AuthSessionMissingError };
          }
          return await (0, fetch_1._request)(this.fetch, "GET", `${this.url}/user`, {
            headers: this.headers,
            jwt: (_c = (_b = data.session) === null || _b === undefined ? undefined : _b.access_token) !== null && _c !== undefined ? _c : undefined,
            xform: fetch_1._userResponse
          });
        });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          if ((0, errors_1.isAuthSessionMissingError)(error)) {
            await this._removeSession();
            await (0, helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
          }
          return this._returnResult({ data: { user: null }, error });
        }
        throw error;
      }
    }
    async updateUser(attributes, options = {}) {
      await this.initializePromise;
      return await this._acquireLock(-1, async () => {
        return await this._updateUser(attributes, options);
      });
    }
    async _updateUser(attributes, options = {}) {
      try {
        return await this._useSession(async (result) => {
          const { data: sessionData, error: sessionError } = result;
          if (sessionError) {
            throw sessionError;
          }
          if (!sessionData.session) {
            throw new errors_1.AuthSessionMissingError;
          }
          const session = sessionData.session;
          let codeChallenge = null;
          let codeChallengeMethod = null;
          if (this.flowType === "pkce" && attributes.email != null) {
            [codeChallenge, codeChallengeMethod] = await (0, helpers_1.getCodeChallengeAndMethod)(this.storage, this.storageKey);
          }
          const { data, error: userError } = await (0, fetch_1._request)(this.fetch, "PUT", `${this.url}/user`, {
            headers: this.headers,
            redirectTo: options === null || options === undefined ? undefined : options.emailRedirectTo,
            body: Object.assign(Object.assign({}, attributes), { code_challenge: codeChallenge, code_challenge_method: codeChallengeMethod }),
            jwt: session.access_token,
            xform: fetch_1._userResponse
          });
          if (userError) {
            throw userError;
          }
          session.user = data.user;
          await this._saveSession(session);
          await this._notifyAllSubscribers("USER_UPDATED", session);
          return this._returnResult({ data: { user: session.user }, error: null });
        });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: { user: null }, error });
        }
        throw error;
      }
    }
    async setSession(currentSession) {
      await this.initializePromise;
      return await this._acquireLock(-1, async () => {
        return await this._setSession(currentSession);
      });
    }
    async _setSession(currentSession) {
      try {
        if (!currentSession.access_token || !currentSession.refresh_token) {
          throw new errors_1.AuthSessionMissingError;
        }
        const timeNow = Date.now() / 1000;
        let expiresAt = timeNow;
        let hasExpired = true;
        let session = null;
        const { payload } = (0, helpers_1.decodeJWT)(currentSession.access_token);
        if (payload.exp) {
          expiresAt = payload.exp;
          hasExpired = expiresAt <= timeNow;
        }
        if (hasExpired) {
          const { data: refreshedSession, error } = await this._callRefreshToken(currentSession.refresh_token);
          if (error) {
            return this._returnResult({ data: { user: null, session: null }, error });
          }
          if (!refreshedSession) {
            return { data: { user: null, session: null }, error: null };
          }
          session = refreshedSession;
        } else {
          const { data, error } = await this._getUser(currentSession.access_token);
          if (error) {
            throw error;
          }
          session = {
            access_token: currentSession.access_token,
            refresh_token: currentSession.refresh_token,
            user: data.user,
            token_type: "bearer",
            expires_in: expiresAt - timeNow,
            expires_at: expiresAt
          };
          await this._saveSession(session);
          await this._notifyAllSubscribers("SIGNED_IN", session);
        }
        return this._returnResult({ data: { user: session.user, session }, error: null });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: { session: null, user: null }, error });
        }
        throw error;
      }
    }
    async refreshSession(currentSession) {
      await this.initializePromise;
      return await this._acquireLock(-1, async () => {
        return await this._refreshSession(currentSession);
      });
    }
    async _refreshSession(currentSession) {
      try {
        return await this._useSession(async (result) => {
          var _a;
          if (!currentSession) {
            const { data, error: error2 } = result;
            if (error2) {
              throw error2;
            }
            currentSession = (_a = data.session) !== null && _a !== undefined ? _a : undefined;
          }
          if (!(currentSession === null || currentSession === undefined ? undefined : currentSession.refresh_token)) {
            throw new errors_1.AuthSessionMissingError;
          }
          const { data: session, error } = await this._callRefreshToken(currentSession.refresh_token);
          if (error) {
            return this._returnResult({ data: { user: null, session: null }, error });
          }
          if (!session) {
            return this._returnResult({ data: { user: null, session: null }, error: null });
          }
          return this._returnResult({ data: { user: session.user, session }, error: null });
        });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: { user: null, session: null }, error });
        }
        throw error;
      }
    }
    async _getSessionFromURL(params, callbackUrlType) {
      try {
        if (!(0, helpers_1.isBrowser)())
          throw new errors_1.AuthImplicitGrantRedirectError("No browser detected.");
        if (params.error || params.error_description || params.error_code) {
          throw new errors_1.AuthImplicitGrantRedirectError(params.error_description || "Error in URL with unspecified error_description", {
            error: params.error || "unspecified_error",
            code: params.error_code || "unspecified_code"
          });
        }
        switch (callbackUrlType) {
          case "implicit":
            if (this.flowType === "pkce") {
              throw new errors_1.AuthPKCEGrantCodeExchangeError("Not a valid PKCE flow url.");
            }
            break;
          case "pkce":
            if (this.flowType === "implicit") {
              throw new errors_1.AuthImplicitGrantRedirectError("Not a valid implicit grant flow url.");
            }
            break;
          default:
        }
        if (callbackUrlType === "pkce") {
          this._debug("#_initialize()", "begin", "is PKCE flow", true);
          if (!params.code)
            throw new errors_1.AuthPKCEGrantCodeExchangeError("No code detected.");
          const { data: data2, error: error2 } = await this._exchangeCodeForSession(params.code);
          if (error2)
            throw error2;
          const url = new URL(window.location.href);
          url.searchParams.delete("code");
          window.history.replaceState(window.history.state, "", url.toString());
          return { data: { session: data2.session, redirectType: null }, error: null };
        }
        const { provider_token, provider_refresh_token, access_token, refresh_token, expires_in, expires_at, token_type } = params;
        if (!access_token || !expires_in || !refresh_token || !token_type) {
          throw new errors_1.AuthImplicitGrantRedirectError("No session defined in URL");
        }
        const timeNow = Math.round(Date.now() / 1000);
        const expiresIn = parseInt(expires_in);
        let expiresAt = timeNow + expiresIn;
        if (expires_at) {
          expiresAt = parseInt(expires_at);
        }
        const actuallyExpiresIn = expiresAt - timeNow;
        if (actuallyExpiresIn * 1000 <= constants_1.AUTO_REFRESH_TICK_DURATION_MS) {
          console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${actuallyExpiresIn}s, should have been closer to ${expiresIn}s`);
        }
        const issuedAt = expiresAt - expiresIn;
        if (timeNow - issuedAt >= 120) {
          console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", issuedAt, expiresAt, timeNow);
        } else if (timeNow - issuedAt < 0) {
          console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew", issuedAt, expiresAt, timeNow);
        }
        const { data, error } = await this._getUser(access_token);
        if (error)
          throw error;
        const session = {
          provider_token,
          provider_refresh_token,
          access_token,
          expires_in: expiresIn,
          expires_at: expiresAt,
          refresh_token,
          token_type,
          user: data.user
        };
        window.location.hash = "";
        this._debug("#_getSessionFromURL()", "clearing window.location.hash");
        return this._returnResult({ data: { session, redirectType: params.type }, error: null });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: { session: null, redirectType: null }, error });
        }
        throw error;
      }
    }
    _isImplicitGrantCallback(params) {
      return Boolean(params.access_token || params.error_description);
    }
    async _isPKCECallback(params) {
      const currentStorageContent = await (0, helpers_1.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
      return !!(params.code && currentStorageContent);
    }
    async signOut(options = { scope: "global" }) {
      await this.initializePromise;
      return await this._acquireLock(-1, async () => {
        return await this._signOut(options);
      });
    }
    async _signOut({ scope } = { scope: "global" }) {
      return await this._useSession(async (result) => {
        var _a;
        const { data, error: sessionError } = result;
        if (sessionError) {
          return this._returnResult({ error: sessionError });
        }
        const accessToken = (_a = data.session) === null || _a === undefined ? undefined : _a.access_token;
        if (accessToken) {
          const { error } = await this.admin.signOut(accessToken, scope);
          if (error) {
            if (!((0, errors_1.isAuthApiError)(error) && (error.status === 404 || error.status === 401 || error.status === 403))) {
              return this._returnResult({ error });
            }
          }
        }
        if (scope !== "others") {
          await this._removeSession();
          await (0, helpers_1.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
        }
        return this._returnResult({ error: null });
      });
    }
    onAuthStateChange(callback) {
      const id = (0, helpers_1.generateCallbackId)();
      const subscription = {
        id,
        callback,
        unsubscribe: () => {
          this._debug("#unsubscribe()", "state change callback with id removed", id);
          this.stateChangeEmitters.delete(id);
        }
      };
      this._debug("#onAuthStateChange()", "registered callback with id", id);
      this.stateChangeEmitters.set(id, subscription);
      (async () => {
        await this.initializePromise;
        await this._acquireLock(-1, async () => {
          this._emitInitialSession(id);
        });
      })();
      return { data: { subscription } };
    }
    async _emitInitialSession(id) {
      return await this._useSession(async (result) => {
        var _a, _b;
        try {
          const { data: { session }, error } = result;
          if (error)
            throw error;
          await ((_a = this.stateChangeEmitters.get(id)) === null || _a === undefined ? undefined : _a.callback("INITIAL_SESSION", session));
          this._debug("INITIAL_SESSION", "callback id", id, "session", session);
        } catch (err) {
          await ((_b = this.stateChangeEmitters.get(id)) === null || _b === undefined ? undefined : _b.callback("INITIAL_SESSION", null));
          this._debug("INITIAL_SESSION", "callback id", id, "error", err);
          console.error(err);
        }
      });
    }
    async resetPasswordForEmail(email, options = {}) {
      let codeChallenge = null;
      let codeChallengeMethod = null;
      if (this.flowType === "pkce") {
        [codeChallenge, codeChallengeMethod] = await (0, helpers_1.getCodeChallengeAndMethod)(this.storage, this.storageKey, true);
      }
      try {
        return await (0, fetch_1._request)(this.fetch, "POST", `${this.url}/recover`, {
          body: {
            email,
            code_challenge: codeChallenge,
            code_challenge_method: codeChallengeMethod,
            gotrue_meta_security: { captcha_token: options.captchaToken }
          },
          headers: this.headers,
          redirectTo: options.redirectTo
        });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: null, error });
        }
        throw error;
      }
    }
    async getUserIdentities() {
      var _a;
      try {
        const { data, error } = await this.getUser();
        if (error)
          throw error;
        return this._returnResult({ data: { identities: (_a = data.user.identities) !== null && _a !== undefined ? _a : [] }, error: null });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: null, error });
        }
        throw error;
      }
    }
    async linkIdentity(credentials) {
      if ("token" in credentials) {
        return this.linkIdentityIdToken(credentials);
      }
      return this.linkIdentityOAuth(credentials);
    }
    async linkIdentityOAuth(credentials) {
      var _a;
      try {
        const { data, error } = await this._useSession(async (result) => {
          var _a2, _b, _c, _d, _e;
          const { data: data2, error: error2 } = result;
          if (error2)
            throw error2;
          const url = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, credentials.provider, {
            redirectTo: (_a2 = credentials.options) === null || _a2 === undefined ? undefined : _a2.redirectTo,
            scopes: (_b = credentials.options) === null || _b === undefined ? undefined : _b.scopes,
            queryParams: (_c = credentials.options) === null || _c === undefined ? undefined : _c.queryParams,
            skipBrowserRedirect: true
          });
          return await (0, fetch_1._request)(this.fetch, "GET", url, {
            headers: this.headers,
            jwt: (_e = (_d = data2.session) === null || _d === undefined ? undefined : _d.access_token) !== null && _e !== undefined ? _e : undefined
          });
        });
        if (error)
          throw error;
        if ((0, helpers_1.isBrowser)() && !((_a = credentials.options) === null || _a === undefined ? undefined : _a.skipBrowserRedirect)) {
          window.location.assign(data === null || data === undefined ? undefined : data.url);
        }
        return this._returnResult({
          data: { provider: credentials.provider, url: data === null || data === undefined ? undefined : data.url },
          error: null
        });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: { provider: credentials.provider, url: null }, error });
        }
        throw error;
      }
    }
    async linkIdentityIdToken(credentials) {
      return await this._useSession(async (result) => {
        var _a;
        try {
          const { error: sessionError, data: { session } } = result;
          if (sessionError)
            throw sessionError;
          const { options, provider, token, access_token, nonce } = credentials;
          const res = await (0, fetch_1._request)(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
            headers: this.headers,
            jwt: (_a = session === null || session === undefined ? undefined : session.access_token) !== null && _a !== undefined ? _a : undefined,
            body: {
              provider,
              id_token: token,
              access_token,
              nonce,
              link_identity: true,
              gotrue_meta_security: { captcha_token: options === null || options === undefined ? undefined : options.captchaToken }
            },
            xform: fetch_1._sessionResponse
          });
          const { data, error } = res;
          if (error) {
            return this._returnResult({ data: { user: null, session: null }, error });
          } else if (!data || !data.session || !data.user) {
            return this._returnResult({
              data: { user: null, session: null },
              error: new errors_1.AuthInvalidTokenResponseError
            });
          }
          if (data.session) {
            await this._saveSession(data.session);
            await this._notifyAllSubscribers("USER_UPDATED", data.session);
          }
          return this._returnResult({ data, error });
        } catch (error) {
          if ((0, errors_1.isAuthError)(error)) {
            return this._returnResult({ data: { user: null, session: null }, error });
          }
          throw error;
        }
      });
    }
    async unlinkIdentity(identity) {
      try {
        return await this._useSession(async (result) => {
          var _a, _b;
          const { data, error } = result;
          if (error) {
            throw error;
          }
          return await (0, fetch_1._request)(this.fetch, "DELETE", `${this.url}/user/identities/${identity.identity_id}`, {
            headers: this.headers,
            jwt: (_b = (_a = data.session) === null || _a === undefined ? undefined : _a.access_token) !== null && _b !== undefined ? _b : undefined
          });
        });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: null, error });
        }
        throw error;
      }
    }
    async _refreshAccessToken(refreshToken) {
      const debugName = `#_refreshAccessToken(${refreshToken.substring(0, 5)}...)`;
      this._debug(debugName, "begin");
      try {
        const startedAt = Date.now();
        return await (0, helpers_1.retryable)(async (attempt) => {
          if (attempt > 0) {
            await (0, helpers_1.sleep)(200 * Math.pow(2, attempt - 1));
          }
          this._debug(debugName, "refreshing attempt", attempt);
          return await (0, fetch_1._request)(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, {
            body: { refresh_token: refreshToken },
            headers: this.headers,
            xform: fetch_1._sessionResponse
          });
        }, (attempt, error) => {
          const nextBackOffInterval = 200 * Math.pow(2, attempt);
          return error && (0, errors_1.isAuthRetryableFetchError)(error) && Date.now() + nextBackOffInterval - startedAt < constants_1.AUTO_REFRESH_TICK_DURATION_MS;
        });
      } catch (error) {
        this._debug(debugName, "error", error);
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: { session: null, user: null }, error });
        }
        throw error;
      } finally {
        this._debug(debugName, "end");
      }
    }
    _isValidSession(maybeSession) {
      const isValidSession = typeof maybeSession === "object" && maybeSession !== null && "access_token" in maybeSession && "refresh_token" in maybeSession && "expires_at" in maybeSession;
      return isValidSession;
    }
    async _handleProviderSignIn(provider, options) {
      const url = await this._getUrlForProvider(`${this.url}/authorize`, provider, {
        redirectTo: options.redirectTo,
        scopes: options.scopes,
        queryParams: options.queryParams
      });
      this._debug("#_handleProviderSignIn()", "provider", provider, "options", options, "url", url);
      if ((0, helpers_1.isBrowser)() && !options.skipBrowserRedirect) {
        window.location.assign(url);
      }
      return { data: { provider, url }, error: null };
    }
    async _recoverAndRefresh() {
      var _a, _b;
      const debugName = "#_recoverAndRefresh()";
      this._debug(debugName, "begin");
      try {
        const currentSession = await (0, helpers_1.getItemAsync)(this.storage, this.storageKey);
        if (currentSession && this.userStorage) {
          let maybeUser = await (0, helpers_1.getItemAsync)(this.userStorage, this.storageKey + "-user");
          if (!this.storage.isServer && Object.is(this.storage, this.userStorage) && !maybeUser) {
            maybeUser = { user: currentSession.user };
            await (0, helpers_1.setItemAsync)(this.userStorage, this.storageKey + "-user", maybeUser);
          }
          currentSession.user = (_a = maybeUser === null || maybeUser === undefined ? undefined : maybeUser.user) !== null && _a !== undefined ? _a : (0, helpers_1.userNotAvailableProxy)();
        } else if (currentSession && !currentSession.user) {
          if (!currentSession.user) {
            const separateUser = await (0, helpers_1.getItemAsync)(this.storage, this.storageKey + "-user");
            if (separateUser && (separateUser === null || separateUser === undefined ? undefined : separateUser.user)) {
              currentSession.user = separateUser.user;
              await (0, helpers_1.removeItemAsync)(this.storage, this.storageKey + "-user");
              await (0, helpers_1.setItemAsync)(this.storage, this.storageKey, currentSession);
            } else {
              currentSession.user = (0, helpers_1.userNotAvailableProxy)();
            }
          }
        }
        this._debug(debugName, "session from storage", currentSession);
        if (!this._isValidSession(currentSession)) {
          this._debug(debugName, "session is not valid");
          if (currentSession !== null) {
            await this._removeSession();
          }
          return;
        }
        const expiresWithMargin = ((_b = currentSession.expires_at) !== null && _b !== undefined ? _b : Infinity) * 1000 - Date.now() < constants_1.EXPIRY_MARGIN_MS;
        this._debug(debugName, `session has${expiresWithMargin ? "" : " not"} expired with margin of ${constants_1.EXPIRY_MARGIN_MS}s`);
        if (expiresWithMargin) {
          if (this.autoRefreshToken && currentSession.refresh_token) {
            const { error } = await this._callRefreshToken(currentSession.refresh_token);
            if (error) {
              console.error(error);
              if (!(0, errors_1.isAuthRetryableFetchError)(error)) {
                this._debug(debugName, "refresh failed with a non-retryable error, removing the session", error);
                await this._removeSession();
              }
            }
          }
        } else if (currentSession.user && currentSession.user.__isUserNotAvailableProxy === true) {
          try {
            const { data, error: userError } = await this._getUser(currentSession.access_token);
            if (!userError && (data === null || data === undefined ? undefined : data.user)) {
              currentSession.user = data.user;
              await this._saveSession(currentSession);
              await this._notifyAllSubscribers("SIGNED_IN", currentSession);
            } else {
              this._debug(debugName, "could not get user data, skipping SIGNED_IN notification");
            }
          } catch (getUserError) {
            console.error("Error getting user data:", getUserError);
            this._debug(debugName, "error getting user data, skipping SIGNED_IN notification", getUserError);
          }
        } else {
          await this._notifyAllSubscribers("SIGNED_IN", currentSession);
        }
      } catch (err) {
        this._debug(debugName, "error", err);
        console.error(err);
        return;
      } finally {
        this._debug(debugName, "end");
      }
    }
    async _callRefreshToken(refreshToken) {
      var _a, _b;
      if (!refreshToken) {
        throw new errors_1.AuthSessionMissingError;
      }
      if (this.refreshingDeferred) {
        return this.refreshingDeferred.promise;
      }
      const debugName = `#_callRefreshToken(${refreshToken.substring(0, 5)}...)`;
      this._debug(debugName, "begin");
      try {
        this.refreshingDeferred = new helpers_1.Deferred;
        const { data, error } = await this._refreshAccessToken(refreshToken);
        if (error)
          throw error;
        if (!data.session)
          throw new errors_1.AuthSessionMissingError;
        await this._saveSession(data.session);
        await this._notifyAllSubscribers("TOKEN_REFRESHED", data.session);
        const result = { data: data.session, error: null };
        this.refreshingDeferred.resolve(result);
        return result;
      } catch (error) {
        this._debug(debugName, "error", error);
        if ((0, errors_1.isAuthError)(error)) {
          const result = { data: null, error };
          if (!(0, errors_1.isAuthRetryableFetchError)(error)) {
            await this._removeSession();
          }
          (_a = this.refreshingDeferred) === null || _a === undefined || _a.resolve(result);
          return result;
        }
        (_b = this.refreshingDeferred) === null || _b === undefined || _b.reject(error);
        throw error;
      } finally {
        this.refreshingDeferred = null;
        this._debug(debugName, "end");
      }
    }
    async _notifyAllSubscribers(event, session, broadcast = true) {
      const debugName = `#_notifyAllSubscribers(${event})`;
      this._debug(debugName, "begin", session, `broadcast = ${broadcast}`);
      try {
        if (this.broadcastChannel && broadcast) {
          this.broadcastChannel.postMessage({ event, session });
        }
        const errors = [];
        const promises = Array.from(this.stateChangeEmitters.values()).map(async (x) => {
          try {
            await x.callback(event, session);
          } catch (e) {
            errors.push(e);
          }
        });
        await Promise.all(promises);
        if (errors.length > 0) {
          for (let i = 0;i < errors.length; i += 1) {
            console.error(errors[i]);
          }
          throw errors[0];
        }
      } finally {
        this._debug(debugName, "end");
      }
    }
    async _saveSession(session) {
      this._debug("#_saveSession()", session);
      this.suppressGetSessionWarning = true;
      const sessionToProcess = Object.assign({}, session);
      const userIsProxy = sessionToProcess.user && sessionToProcess.user.__isUserNotAvailableProxy === true;
      if (this.userStorage) {
        if (!userIsProxy && sessionToProcess.user) {
          await (0, helpers_1.setItemAsync)(this.userStorage, this.storageKey + "-user", {
            user: sessionToProcess.user
          });
        } else if (userIsProxy) {}
        const mainSessionData = Object.assign({}, sessionToProcess);
        delete mainSessionData.user;
        const clonedMainSessionData = (0, helpers_1.deepClone)(mainSessionData);
        await (0, helpers_1.setItemAsync)(this.storage, this.storageKey, clonedMainSessionData);
      } else {
        const clonedSession = (0, helpers_1.deepClone)(sessionToProcess);
        await (0, helpers_1.setItemAsync)(this.storage, this.storageKey, clonedSession);
      }
    }
    async _removeSession() {
      this._debug("#_removeSession()");
      await (0, helpers_1.removeItemAsync)(this.storage, this.storageKey);
      await (0, helpers_1.removeItemAsync)(this.storage, this.storageKey + "-code-verifier");
      await (0, helpers_1.removeItemAsync)(this.storage, this.storageKey + "-user");
      if (this.userStorage) {
        await (0, helpers_1.removeItemAsync)(this.userStorage, this.storageKey + "-user");
      }
      await this._notifyAllSubscribers("SIGNED_OUT", null);
    }
    _removeVisibilityChangedCallback() {
      this._debug("#_removeVisibilityChangedCallback()");
      const callback = this.visibilityChangedCallback;
      this.visibilityChangedCallback = null;
      try {
        if (callback && (0, helpers_1.isBrowser)() && (window === null || window === undefined ? undefined : window.removeEventListener)) {
          window.removeEventListener("visibilitychange", callback);
        }
      } catch (e) {
        console.error("removing visibilitychange callback failed", e);
      }
    }
    async _startAutoRefresh() {
      await this._stopAutoRefresh();
      this._debug("#_startAutoRefresh()");
      const ticker = setInterval(() => this._autoRefreshTokenTick(), constants_1.AUTO_REFRESH_TICK_DURATION_MS);
      this.autoRefreshTicker = ticker;
      if (ticker && typeof ticker === "object" && typeof ticker.unref === "function") {
        ticker.unref();
      } else if (typeof Deno !== "undefined" && typeof Deno.unrefTimer === "function") {
        Deno.unrefTimer(ticker);
      }
      setTimeout(async () => {
        await this.initializePromise;
        await this._autoRefreshTokenTick();
      }, 0);
    }
    async _stopAutoRefresh() {
      this._debug("#_stopAutoRefresh()");
      const ticker = this.autoRefreshTicker;
      this.autoRefreshTicker = null;
      if (ticker) {
        clearInterval(ticker);
      }
    }
    async startAutoRefresh() {
      this._removeVisibilityChangedCallback();
      await this._startAutoRefresh();
    }
    async stopAutoRefresh() {
      this._removeVisibilityChangedCallback();
      await this._stopAutoRefresh();
    }
    async _autoRefreshTokenTick() {
      this._debug("#_autoRefreshTokenTick()", "begin");
      try {
        await this._acquireLock(0, async () => {
          try {
            const now = Date.now();
            try {
              return await this._useSession(async (result) => {
                const { data: { session } } = result;
                if (!session || !session.refresh_token || !session.expires_at) {
                  this._debug("#_autoRefreshTokenTick()", "no session");
                  return;
                }
                const expiresInTicks = Math.floor((session.expires_at * 1000 - now) / constants_1.AUTO_REFRESH_TICK_DURATION_MS);
                this._debug("#_autoRefreshTokenTick()", `access token expires in ${expiresInTicks} ticks, a tick lasts ${constants_1.AUTO_REFRESH_TICK_DURATION_MS}ms, refresh threshold is ${constants_1.AUTO_REFRESH_TICK_THRESHOLD} ticks`);
                if (expiresInTicks <= constants_1.AUTO_REFRESH_TICK_THRESHOLD) {
                  await this._callRefreshToken(session.refresh_token);
                }
              });
            } catch (e) {
              console.error("Auto refresh tick failed with error. This is likely a transient error.", e);
            }
          } finally {
            this._debug("#_autoRefreshTokenTick()", "end");
          }
        });
      } catch (e) {
        if (e.isAcquireTimeout || e instanceof locks_1.LockAcquireTimeoutError) {
          this._debug("auto refresh token tick lock not available");
        } else {
          throw e;
        }
      }
    }
    async _handleVisibilityChange() {
      this._debug("#_handleVisibilityChange()");
      if (!(0, helpers_1.isBrowser)() || !(window === null || window === undefined ? undefined : window.addEventListener)) {
        if (this.autoRefreshToken) {
          this.startAutoRefresh();
        }
        return false;
      }
      try {
        this.visibilityChangedCallback = async () => await this._onVisibilityChanged(false);
        window === null || window === undefined || window.addEventListener("visibilitychange", this.visibilityChangedCallback);
        await this._onVisibilityChanged(true);
      } catch (error) {
        console.error("_handleVisibilityChange", error);
      }
    }
    async _onVisibilityChanged(calledFromInitialize) {
      const methodName = `#_onVisibilityChanged(${calledFromInitialize})`;
      this._debug(methodName, "visibilityState", document.visibilityState);
      if (document.visibilityState === "visible") {
        if (this.autoRefreshToken) {
          this._startAutoRefresh();
        }
        if (!calledFromInitialize) {
          await this.initializePromise;
          await this._acquireLock(-1, async () => {
            if (document.visibilityState !== "visible") {
              this._debug(methodName, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");
              return;
            }
            await this._recoverAndRefresh();
          });
        }
      } else if (document.visibilityState === "hidden") {
        if (this.autoRefreshToken) {
          this._stopAutoRefresh();
        }
      }
    }
    async _getUrlForProvider(url, provider, options) {
      const urlParams = [`provider=${encodeURIComponent(provider)}`];
      if (options === null || options === undefined ? undefined : options.redirectTo) {
        urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);
      }
      if (options === null || options === undefined ? undefined : options.scopes) {
        urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);
      }
      if (this.flowType === "pkce") {
        const [codeChallenge, codeChallengeMethod] = await (0, helpers_1.getCodeChallengeAndMethod)(this.storage, this.storageKey);
        const flowParams = new URLSearchParams({
          code_challenge: `${encodeURIComponent(codeChallenge)}`,
          code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`
        });
        urlParams.push(flowParams.toString());
      }
      if (options === null || options === undefined ? undefined : options.queryParams) {
        const query = new URLSearchParams(options.queryParams);
        urlParams.push(query.toString());
      }
      if (options === null || options === undefined ? undefined : options.skipBrowserRedirect) {
        urlParams.push(`skip_http_redirect=${options.skipBrowserRedirect}`);
      }
      return `${url}?${urlParams.join("&")}`;
    }
    async _unenroll(params) {
      try {
        return await this._useSession(async (result) => {
          var _a;
          const { data: sessionData, error: sessionError } = result;
          if (sessionError) {
            return this._returnResult({ data: null, error: sessionError });
          }
          return await (0, fetch_1._request)(this.fetch, "DELETE", `${this.url}/factors/${params.factorId}`, {
            headers: this.headers,
            jwt: (_a = sessionData === null || sessionData === undefined ? undefined : sessionData.session) === null || _a === undefined ? undefined : _a.access_token
          });
        });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: null, error });
        }
        throw error;
      }
    }
    async _enroll(params) {
      try {
        return await this._useSession(async (result) => {
          var _a, _b;
          const { data: sessionData, error: sessionError } = result;
          if (sessionError) {
            return this._returnResult({ data: null, error: sessionError });
          }
          const body = Object.assign({ friendly_name: params.friendlyName, factor_type: params.factorType }, params.factorType === "phone" ? { phone: params.phone } : params.factorType === "totp" ? { issuer: params.issuer } : {});
          const { data, error } = await (0, fetch_1._request)(this.fetch, "POST", `${this.url}/factors`, {
            body,
            headers: this.headers,
            jwt: (_a = sessionData === null || sessionData === undefined ? undefined : sessionData.session) === null || _a === undefined ? undefined : _a.access_token
          });
          if (error) {
            return this._returnResult({ data: null, error });
          }
          if (params.factorType === "totp" && data.type === "totp" && ((_b = data === null || data === undefined ? undefined : data.totp) === null || _b === undefined ? undefined : _b.qr_code)) {
            data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;
          }
          return this._returnResult({ data, error: null });
        });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: null, error });
        }
        throw error;
      }
    }
    async _verify(params) {
      return this._acquireLock(-1, async () => {
        try {
          return await this._useSession(async (result) => {
            var _a;
            const { data: sessionData, error: sessionError } = result;
            if (sessionError) {
              return this._returnResult({ data: null, error: sessionError });
            }
            const body = Object.assign({ challenge_id: params.challengeId }, "webauthn" in params ? {
              webauthn: Object.assign(Object.assign({}, params.webauthn), { credential_response: params.webauthn.type === "create" ? (0, webauthn_1.serializeCredentialCreationResponse)(params.webauthn.credential_response) : (0, webauthn_1.serializeCredentialRequestResponse)(params.webauthn.credential_response) })
            } : { code: params.code });
            const { data, error } = await (0, fetch_1._request)(this.fetch, "POST", `${this.url}/factors/${params.factorId}/verify`, {
              body,
              headers: this.headers,
              jwt: (_a = sessionData === null || sessionData === undefined ? undefined : sessionData.session) === null || _a === undefined ? undefined : _a.access_token
            });
            if (error) {
              return this._returnResult({ data: null, error });
            }
            await this._saveSession(Object.assign({ expires_at: Math.round(Date.now() / 1000) + data.expires_in }, data));
            await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", data);
            return this._returnResult({ data, error });
          });
        } catch (error) {
          if ((0, errors_1.isAuthError)(error)) {
            return this._returnResult({ data: null, error });
          }
          throw error;
        }
      });
    }
    async _challenge(params) {
      return this._acquireLock(-1, async () => {
        try {
          return await this._useSession(async (result) => {
            var _a;
            const { data: sessionData, error: sessionError } = result;
            if (sessionError) {
              return this._returnResult({ data: null, error: sessionError });
            }
            const response = await (0, fetch_1._request)(this.fetch, "POST", `${this.url}/factors/${params.factorId}/challenge`, {
              body: params,
              headers: this.headers,
              jwt: (_a = sessionData === null || sessionData === undefined ? undefined : sessionData.session) === null || _a === undefined ? undefined : _a.access_token
            });
            if (response.error) {
              return response;
            }
            const { data } = response;
            if (data.type !== "webauthn") {
              return { data, error: null };
            }
            switch (data.webauthn.type) {
              case "create":
                return {
                  data: Object.assign(Object.assign({}, data), { webauthn: Object.assign(Object.assign({}, data.webauthn), { credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), { publicKey: (0, webauthn_1.deserializeCredentialCreationOptions)(data.webauthn.credential_options.publicKey) }) }) }),
                  error: null
                };
              case "request":
                return {
                  data: Object.assign(Object.assign({}, data), { webauthn: Object.assign(Object.assign({}, data.webauthn), { credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), { publicKey: (0, webauthn_1.deserializeCredentialRequestOptions)(data.webauthn.credential_options.publicKey) }) }) }),
                  error: null
                };
            }
          });
        } catch (error) {
          if ((0, errors_1.isAuthError)(error)) {
            return this._returnResult({ data: null, error });
          }
          throw error;
        }
      });
    }
    async _challengeAndVerify(params) {
      const { data: challengeData, error: challengeError } = await this._challenge({
        factorId: params.factorId
      });
      if (challengeError) {
        return this._returnResult({ data: null, error: challengeError });
      }
      return await this._verify({
        factorId: params.factorId,
        challengeId: challengeData.id,
        code: params.code
      });
    }
    async _listFactors() {
      var _a;
      const { data: { user }, error: userError } = await this.getUser();
      if (userError) {
        return { data: null, error: userError };
      }
      const data = {
        all: [],
        phone: [],
        totp: [],
        webauthn: []
      };
      for (const factor of (_a = user === null || user === undefined ? undefined : user.factors) !== null && _a !== undefined ? _a : []) {
        data.all.push(factor);
        if (factor.status === "verified") {
          data[factor.factor_type].push(factor);
        }
      }
      return {
        data,
        error: null
      };
    }
    async _getAuthenticatorAssuranceLevel() {
      var _a, _b;
      const { data: { session }, error: sessionError } = await this.getSession();
      if (sessionError) {
        return this._returnResult({ data: null, error: sessionError });
      }
      if (!session) {
        return {
          data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },
          error: null
        };
      }
      const { payload } = (0, helpers_1.decodeJWT)(session.access_token);
      let currentLevel = null;
      if (payload.aal) {
        currentLevel = payload.aal;
      }
      let nextLevel = currentLevel;
      const verifiedFactors = (_b = (_a = session.user.factors) === null || _a === undefined ? undefined : _a.filter((factor) => factor.status === "verified")) !== null && _b !== undefined ? _b : [];
      if (verifiedFactors.length > 0) {
        nextLevel = "aal2";
      }
      const currentAuthenticationMethods = payload.amr || [];
      return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null };
    }
    async _getAuthorizationDetails(authorizationId) {
      try {
        return await this._useSession(async (result) => {
          const { data: { session }, error: sessionError } = result;
          if (sessionError) {
            return this._returnResult({ data: null, error: sessionError });
          }
          if (!session) {
            return this._returnResult({ data: null, error: new errors_1.AuthSessionMissingError });
          }
          return await (0, fetch_1._request)(this.fetch, "GET", `${this.url}/oauth/authorizations/${authorizationId}`, {
            headers: this.headers,
            jwt: session.access_token,
            xform: (data) => ({ data, error: null })
          });
        });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: null, error });
        }
        throw error;
      }
    }
    async _approveAuthorization(authorizationId, options) {
      try {
        return await this._useSession(async (result) => {
          const { data: { session }, error: sessionError } = result;
          if (sessionError) {
            return this._returnResult({ data: null, error: sessionError });
          }
          if (!session) {
            return this._returnResult({ data: null, error: new errors_1.AuthSessionMissingError });
          }
          const response = await (0, fetch_1._request)(this.fetch, "POST", `${this.url}/oauth/authorizations/${authorizationId}/consent`, {
            headers: this.headers,
            jwt: session.access_token,
            body: { action: "approve" },
            xform: (data) => ({ data, error: null })
          });
          if (response.data && response.data.redirect_url) {
            if ((0, helpers_1.isBrowser)() && !(options === null || options === undefined ? undefined : options.skipBrowserRedirect)) {
              window.location.assign(response.data.redirect_url);
            }
          }
          return response;
        });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: null, error });
        }
        throw error;
      }
    }
    async _denyAuthorization(authorizationId, options) {
      try {
        return await this._useSession(async (result) => {
          const { data: { session }, error: sessionError } = result;
          if (sessionError) {
            return this._returnResult({ data: null, error: sessionError });
          }
          if (!session) {
            return this._returnResult({ data: null, error: new errors_1.AuthSessionMissingError });
          }
          const response = await (0, fetch_1._request)(this.fetch, "POST", `${this.url}/oauth/authorizations/${authorizationId}/consent`, {
            headers: this.headers,
            jwt: session.access_token,
            body: { action: "deny" },
            xform: (data) => ({ data, error: null })
          });
          if (response.data && response.data.redirect_url) {
            if ((0, helpers_1.isBrowser)() && !(options === null || options === undefined ? undefined : options.skipBrowserRedirect)) {
              window.location.assign(response.data.redirect_url);
            }
          }
          return response;
        });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: null, error });
        }
        throw error;
      }
    }
    async _listOAuthGrants() {
      try {
        return await this._useSession(async (result) => {
          const { data: { session }, error: sessionError } = result;
          if (sessionError) {
            return this._returnResult({ data: null, error: sessionError });
          }
          if (!session) {
            return this._returnResult({ data: null, error: new errors_1.AuthSessionMissingError });
          }
          return await (0, fetch_1._request)(this.fetch, "GET", `${this.url}/user/oauth/grants`, {
            headers: this.headers,
            jwt: session.access_token,
            xform: (data) => ({ data, error: null })
          });
        });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: null, error });
        }
        throw error;
      }
    }
    async _revokeOAuthGrant(options) {
      try {
        return await this._useSession(async (result) => {
          const { data: { session }, error: sessionError } = result;
          if (sessionError) {
            return this._returnResult({ data: null, error: sessionError });
          }
          if (!session) {
            return this._returnResult({ data: null, error: new errors_1.AuthSessionMissingError });
          }
          await (0, fetch_1._request)(this.fetch, "DELETE", `${this.url}/user/oauth/grants`, {
            headers: this.headers,
            jwt: session.access_token,
            query: { client_id: options.clientId },
            noResolveJson: true
          });
          return { data: {}, error: null };
        });
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: null, error });
        }
        throw error;
      }
    }
    async fetchJwk(kid, jwks = { keys: [] }) {
      let jwk = jwks.keys.find((key) => key.kid === kid);
      if (jwk) {
        return jwk;
      }
      const now = Date.now();
      jwk = this.jwks.keys.find((key) => key.kid === kid);
      if (jwk && this.jwks_cached_at + constants_1.JWKS_TTL > now) {
        return jwk;
      }
      const { data, error } = await (0, fetch_1._request)(this.fetch, "GET", `${this.url}/.well-known/jwks.json`, {
        headers: this.headers
      });
      if (error) {
        throw error;
      }
      if (!data.keys || data.keys.length === 0) {
        return null;
      }
      this.jwks = data;
      this.jwks_cached_at = now;
      jwk = data.keys.find((key) => key.kid === kid);
      if (!jwk) {
        return null;
      }
      return jwk;
    }
    async getClaims(jwt, options = {}) {
      try {
        let token = jwt;
        if (!token) {
          const { data, error } = await this.getSession();
          if (error || !data.session) {
            return this._returnResult({ data: null, error });
          }
          token = data.session.access_token;
        }
        const { header, payload, signature, raw: { header: rawHeader, payload: rawPayload } } = (0, helpers_1.decodeJWT)(token);
        if (!(options === null || options === undefined ? undefined : options.allowExpired)) {
          (0, helpers_1.validateExp)(payload.exp);
        }
        const signingKey = !header.alg || header.alg.startsWith("HS") || !header.kid || !(("crypto" in globalThis) && ("subtle" in globalThis.crypto)) ? null : await this.fetchJwk(header.kid, (options === null || options === undefined ? undefined : options.keys) ? { keys: options.keys } : options === null || options === undefined ? undefined : options.jwks);
        if (!signingKey) {
          const { error } = await this.getUser(token);
          if (error) {
            throw error;
          }
          return {
            data: {
              claims: payload,
              header,
              signature
            },
            error: null
          };
        }
        const algorithm = (0, helpers_1.getAlgorithm)(header.alg);
        const publicKey = await crypto.subtle.importKey("jwk", signingKey, algorithm, true, [
          "verify"
        ]);
        const isValid = await crypto.subtle.verify(algorithm, publicKey, signature, (0, base64url_1.stringToUint8Array)(`${rawHeader}.${rawPayload}`));
        if (!isValid) {
          throw new errors_1.AuthInvalidJwtError("Invalid JWT signature");
        }
        return {
          data: {
            claims: payload,
            header,
            signature
          },
          error: null
        };
      } catch (error) {
        if ((0, errors_1.isAuthError)(error)) {
          return this._returnResult({ data: null, error });
        }
        throw error;
      }
    }
  }
  GoTrueClient.nextInstanceID = {};
  exports2.default = GoTrueClient;
});

// backend/node_modules/@supabase/auth-js/dist/main/AuthAdminApi.js
var require_AuthAdminApi = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  var GoTrueAdminApi_1 = tslib_1.__importDefault(require_GoTrueAdminApi());
  var AuthAdminApi = GoTrueAdminApi_1.default;
  exports2.default = AuthAdminApi;
});

// backend/node_modules/@supabase/auth-js/dist/main/AuthClient.js
var require_AuthClient = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var tslib_1 = require_tslib();
  var GoTrueClient_1 = tslib_1.__importDefault(require_GoTrueClient());
  var AuthClient = GoTrueClient_1.default;
  exports2.default = AuthClient;
});

// backend/node_modules/@supabase/auth-js/dist/main/index.js
var require_main4 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.processLock = exports2.lockInternals = exports2.NavigatorLockAcquireTimeoutError = exports2.navigatorLock = exports2.AuthClient = exports2.AuthAdminApi = exports2.GoTrueClient = exports2.GoTrueAdminApi = undefined;
  var tslib_1 = require_tslib();
  var GoTrueAdminApi_1 = tslib_1.__importDefault(require_GoTrueAdminApi());
  exports2.GoTrueAdminApi = GoTrueAdminApi_1.default;
  var GoTrueClient_1 = tslib_1.__importDefault(require_GoTrueClient());
  exports2.GoTrueClient = GoTrueClient_1.default;
  var AuthAdminApi_1 = tslib_1.__importDefault(require_AuthAdminApi());
  exports2.AuthAdminApi = AuthAdminApi_1.default;
  var AuthClient_1 = tslib_1.__importDefault(require_AuthClient());
  exports2.AuthClient = AuthClient_1.default;
  tslib_1.__exportStar(require_types3(), exports2);
  tslib_1.__exportStar(require_errors3(), exports2);
  var locks_1 = require_locks();
  Object.defineProperty(exports2, "navigatorLock", { enumerable: true, get: function() {
    return locks_1.navigatorLock;
  } });
  Object.defineProperty(exports2, "NavigatorLockAcquireTimeoutError", { enumerable: true, get: function() {
    return locks_1.NavigatorLockAcquireTimeoutError;
  } });
  Object.defineProperty(exports2, "lockInternals", { enumerable: true, get: function() {
    return locks_1.internals;
  } });
  Object.defineProperty(exports2, "processLock", { enumerable: true, get: function() {
    return locks_1.processLock;
  } });
});

// backend/node_modules/@supabase/supabase-js/dist/main/lib/SupabaseAuthClient.js
var require_SupabaseAuthClient = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.SupabaseAuthClient = undefined;
  var auth_js_1 = require_main4();

  class SupabaseAuthClient extends auth_js_1.AuthClient {
    constructor(options) {
      super(options);
    }
  }
  exports2.SupabaseAuthClient = SupabaseAuthClient;
});

// backend/node_modules/@supabase/supabase-js/dist/main/SupabaseClient.js
var require_SupabaseClient = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var functions_js_1 = require_main();
  var postgrest_js_1 = require_cjs();
  var realtime_js_1 = require_main2();
  var storage_js_1 = require_main3();
  var constants_1 = require_constants4();
  var fetch_1 = require_fetch3();
  var helpers_1 = require_helpers3();
  var SupabaseAuthClient_1 = require_SupabaseAuthClient();

  class SupabaseClient {
    constructor(supabaseUrl, supabaseKey, options) {
      var _a, _b, _c;
      this.supabaseUrl = supabaseUrl;
      this.supabaseKey = supabaseKey;
      const baseUrl = (0, helpers_1.validateSupabaseUrl)(supabaseUrl);
      if (!supabaseKey)
        throw new Error("supabaseKey is required.");
      this.realtimeUrl = new URL("realtime/v1", baseUrl);
      this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace("http", "ws");
      this.authUrl = new URL("auth/v1", baseUrl);
      this.storageUrl = new URL("storage/v1", baseUrl);
      this.functionsUrl = new URL("functions/v1", baseUrl);
      const defaultStorageKey = `sb-${baseUrl.hostname.split(".")[0]}-auth-token`;
      const DEFAULTS = {
        db: constants_1.DEFAULT_DB_OPTIONS,
        realtime: constants_1.DEFAULT_REALTIME_OPTIONS,
        auth: Object.assign(Object.assign({}, constants_1.DEFAULT_AUTH_OPTIONS), { storageKey: defaultStorageKey }),
        global: constants_1.DEFAULT_GLOBAL_OPTIONS
      };
      const settings = (0, helpers_1.applySettingDefaults)(options !== null && options !== undefined ? options : {}, DEFAULTS);
      this.storageKey = (_a = settings.auth.storageKey) !== null && _a !== undefined ? _a : "";
      this.headers = (_b = settings.global.headers) !== null && _b !== undefined ? _b : {};
      if (!settings.accessToken) {
        this.auth = this._initSupabaseAuthClient((_c = settings.auth) !== null && _c !== undefined ? _c : {}, this.headers, settings.global.fetch);
      } else {
        this.accessToken = settings.accessToken;
        this.auth = new Proxy({}, {
          get: (_, prop) => {
            throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`);
          }
        });
      }
      this.fetch = (0, fetch_1.fetchWithAuth)(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);
      this.realtime = this._initRealtimeClient(Object.assign({ headers: this.headers, accessToken: this._getAccessToken.bind(this) }, settings.realtime));
      if (this.accessToken) {
        this.accessToken().then((token) => this.realtime.setAuth(token)).catch((e) => console.warn("Failed to set initial Realtime auth token:", e));
      }
      this.rest = new postgrest_js_1.PostgrestClient(new URL("rest/v1", baseUrl).href, {
        headers: this.headers,
        schema: settings.db.schema,
        fetch: this.fetch
      });
      this.storage = new storage_js_1.StorageClient(this.storageUrl.href, this.headers, this.fetch, options === null || options === undefined ? undefined : options.storage);
      if (!settings.accessToken) {
        this._listenForAuthEvents();
      }
    }
    get functions() {
      return new functions_js_1.FunctionsClient(this.functionsUrl.href, {
        headers: this.headers,
        customFetch: this.fetch
      });
    }
    from(relation) {
      return this.rest.from(relation);
    }
    schema(schema) {
      return this.rest.schema(schema);
    }
    rpc(fn, args = {}, options = {
      head: false,
      get: false,
      count: undefined
    }) {
      return this.rest.rpc(fn, args, options);
    }
    channel(name, opts = { config: {} }) {
      return this.realtime.channel(name, opts);
    }
    getChannels() {
      return this.realtime.getChannels();
    }
    removeChannel(channel) {
      return this.realtime.removeChannel(channel);
    }
    removeAllChannels() {
      return this.realtime.removeAllChannels();
    }
    async _getAccessToken() {
      var _a, _b;
      if (this.accessToken) {
        return await this.accessToken();
      }
      const { data } = await this.auth.getSession();
      return (_b = (_a = data.session) === null || _a === undefined ? undefined : _a.access_token) !== null && _b !== undefined ? _b : this.supabaseKey;
    }
    _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, storage, userStorage, storageKey, flowType, lock, debug, throwOnError }, headers, fetch2) {
      const authHeaders = {
        Authorization: `Bearer ${this.supabaseKey}`,
        apikey: `${this.supabaseKey}`
      };
      return new SupabaseAuthClient_1.SupabaseAuthClient({
        url: this.authUrl.href,
        headers: Object.assign(Object.assign({}, authHeaders), headers),
        storageKey,
        autoRefreshToken,
        persistSession,
        detectSessionInUrl,
        storage,
        userStorage,
        flowType,
        lock,
        debug,
        throwOnError,
        fetch: fetch2,
        hasCustomAuthorizationHeader: Object.keys(this.headers).some((key) => key.toLowerCase() === "authorization")
      });
    }
    _initRealtimeClient(options) {
      return new realtime_js_1.RealtimeClient(this.realtimeUrl.href, Object.assign(Object.assign({}, options), { params: Object.assign({ apikey: this.supabaseKey }, options === null || options === undefined ? undefined : options.params) }));
    }
    _listenForAuthEvents() {
      const data = this.auth.onAuthStateChange((event, session) => {
        this._handleTokenChanged(event, "CLIENT", session === null || session === undefined ? undefined : session.access_token);
      });
      return data;
    }
    _handleTokenChanged(event, source, token) {
      if ((event === "TOKEN_REFRESHED" || event === "SIGNED_IN") && this.changedAccessToken !== token) {
        this.changedAccessToken = token;
        this.realtime.setAuth(token);
      } else if (event === "SIGNED_OUT") {
        this.realtime.setAuth();
        if (source == "STORAGE")
          this.auth.signOut();
        this.changedAccessToken = undefined;
      }
    }
  }
  exports2.default = SupabaseClient;
});

// backend/node_modules/@supabase/supabase-js/dist/main/index.js
var require_main5 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.createClient = exports2.SupabaseClient = exports2.FunctionRegion = exports2.FunctionsError = exports2.FunctionsRelayError = exports2.FunctionsFetchError = exports2.FunctionsHttpError = exports2.PostgrestError = undefined;
  var SupabaseClient_1 = __importDefault(require_SupabaseClient());
  __exportStar(require_main4(), exports2);
  var postgrest_js_1 = require_cjs();
  Object.defineProperty(exports2, "PostgrestError", { enumerable: true, get: function() {
    return postgrest_js_1.PostgrestError;
  } });
  var functions_js_1 = require_main();
  Object.defineProperty(exports2, "FunctionsHttpError", { enumerable: true, get: function() {
    return functions_js_1.FunctionsHttpError;
  } });
  Object.defineProperty(exports2, "FunctionsFetchError", { enumerable: true, get: function() {
    return functions_js_1.FunctionsFetchError;
  } });
  Object.defineProperty(exports2, "FunctionsRelayError", { enumerable: true, get: function() {
    return functions_js_1.FunctionsRelayError;
  } });
  Object.defineProperty(exports2, "FunctionsError", { enumerable: true, get: function() {
    return functions_js_1.FunctionsError;
  } });
  Object.defineProperty(exports2, "FunctionRegion", { enumerable: true, get: function() {
    return functions_js_1.FunctionRegion;
  } });
  __exportStar(require_main2(), exports2);
  var SupabaseClient_2 = require_SupabaseClient();
  Object.defineProperty(exports2, "SupabaseClient", { enumerable: true, get: function() {
    return __importDefault(SupabaseClient_2).default;
  } });
  var createClient = (supabaseUrl, supabaseKey, options) => {
    return new SupabaseClient_1.default(supabaseUrl, supabaseKey, options);
  };
  exports2.createClient = createClient;
  function shouldShowDeprecationWarning() {
    if (typeof window !== "undefined") {
      return false;
    }
    if (typeof process === "undefined") {
      return false;
    }
    const processVersion = process["version"];
    if (processVersion === undefined || processVersion === null) {
      return false;
    }
    const versionMatch = processVersion.match(/^v(\d+)\./);
    if (!versionMatch) {
      return false;
    }
    const majorVersion = parseInt(versionMatch[1], 10);
    return majorVersion <= 18;
  }
  if (shouldShowDeprecationWarning()) {
    console.warn(`  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. ` + `Please upgrade to Node.js 20 or later. ` + `For more information, visit: https://github.com/orgs/supabase/discussions/37217`);
  }
});

// backend/node_modules/sharp/lib/is.js
var require_is = __commonJS((exports2, module2) => {
  /*!
    Copyright 2013 Lovell Fuller and others.
    SPDX-License-Identifier: Apache-2.0
  */
  var defined = (val) => typeof val !== "undefined" && val !== null;
  var object = (val) => typeof val === "object";
  var plainObject = (val) => Object.prototype.toString.call(val) === "[object Object]";
  var fn = (val) => typeof val === "function";
  var bool = (val) => typeof val === "boolean";
  var buffer = (val) => val instanceof Buffer;
  var typedArray = (val) => {
    if (defined(val)) {
      switch (val.constructor) {
        case Uint8Array:
        case Uint8ClampedArray:
        case Int8Array:
        case Uint16Array:
        case Int16Array:
        case Uint32Array:
        case Int32Array:
        case Float32Array:
        case Float64Array:
          return true;
      }
    }
    return false;
  };
  var arrayBuffer = (val) => val instanceof ArrayBuffer;
  var string = (val) => typeof val === "string" && val.length > 0;
  var number = (val) => typeof val === "number" && !Number.isNaN(val);
  var integer = (val) => Number.isInteger(val);
  var inRange = (val, min, max) => val >= min && val <= max;
  var inArray = (val, list) => list.includes(val);
  var invalidParameterError = (name, expected, actual) => new Error(`Expected ${expected} for ${name} but received ${actual} of type ${typeof actual}`);
  var nativeError = (native, context) => {
    context.message = native.message;
    return context;
  };
  module2.exports = {
    defined,
    object,
    plainObject,
    fn,
    bool,
    buffer,
    typedArray,
    arrayBuffer,
    string,
    number,
    integer,
    inRange,
    inArray,
    invalidParameterError,
    nativeError
  };
});

// backend/node_modules/detect-libc/lib/process.js
var require_process = __commonJS((exports2, module2) => {
  var isLinux = () => process.platform === "linux";
  var report = null;
  var getReport = () => {
    if (!report) {
      if (isLinux() && process.report) {
        const orig = process.report.excludeNetwork;
        process.report.excludeNetwork = true;
        report = process.report.getReport();
        process.report.excludeNetwork = orig;
      } else {
        report = {};
      }
    }
    return report;
  };
  module2.exports = { isLinux, getReport };
});

// backend/node_modules/detect-libc/lib/filesystem.js
var require_filesystem = __commonJS((exports2, module2) => {
  var fs = require("fs");
  var LDD_PATH = "/usr/bin/ldd";
  var SELF_PATH = "/proc/self/exe";
  var MAX_LENGTH = 2048;
  var readFileSync = (path2) => {
    const fd = fs.openSync(path2, "r");
    const buffer = Buffer.alloc(MAX_LENGTH);
    const bytesRead = fs.readSync(fd, buffer, 0, MAX_LENGTH, 0);
    fs.close(fd, () => {});
    return buffer.subarray(0, bytesRead);
  };
  var readFile = (path2) => new Promise((resolve, reject) => {
    fs.open(path2, "r", (err, fd) => {
      if (err) {
        reject(err);
      } else {
        const buffer = Buffer.alloc(MAX_LENGTH);
        fs.read(fd, buffer, 0, MAX_LENGTH, 0, (_, bytesRead) => {
          resolve(buffer.subarray(0, bytesRead));
          fs.close(fd, () => {});
        });
      }
    });
  });
  module2.exports = {
    LDD_PATH,
    SELF_PATH,
    readFileSync,
    readFile
  };
});

// backend/node_modules/detect-libc/lib/elf.js
var require_elf = __commonJS((exports2, module2) => {
  var interpreterPath = (elf) => {
    if (elf.length < 64) {
      return null;
    }
    if (elf.readUInt32BE(0) !== 2135247942) {
      return null;
    }
    if (elf.readUInt8(4) !== 2) {
      return null;
    }
    if (elf.readUInt8(5) !== 1) {
      return null;
    }
    const offset = elf.readUInt32LE(32);
    const size = elf.readUInt16LE(54);
    const count = elf.readUInt16LE(56);
    for (let i = 0;i < count; i++) {
      const headerOffset = offset + i * size;
      const type = elf.readUInt32LE(headerOffset);
      if (type === 3) {
        const fileOffset = elf.readUInt32LE(headerOffset + 8);
        const fileSize = elf.readUInt32LE(headerOffset + 32);
        return elf.subarray(fileOffset, fileOffset + fileSize).toString().replace(/\0.*$/g, "");
      }
    }
    return null;
  };
  module2.exports = {
    interpreterPath
  };
});

// backend/node_modules/detect-libc/lib/detect-libc.js
var require_detect_libc = __commonJS((exports2, module2) => {
  var childProcess = require("child_process");
  var { isLinux, getReport } = require_process();
  var { LDD_PATH, SELF_PATH, readFile, readFileSync } = require_filesystem();
  var { interpreterPath } = require_elf();
  var cachedFamilyInterpreter;
  var cachedFamilyFilesystem;
  var cachedVersionFilesystem;
  var command = "getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true";
  var commandOut = "";
  var safeCommand = () => {
    if (!commandOut) {
      return new Promise((resolve) => {
        childProcess.exec(command, (err, out) => {
          commandOut = err ? " " : out;
          resolve(commandOut);
        });
      });
    }
    return commandOut;
  };
  var safeCommandSync = () => {
    if (!commandOut) {
      try {
        commandOut = childProcess.execSync(command, { encoding: "utf8" });
      } catch (_err) {
        commandOut = " ";
      }
    }
    return commandOut;
  };
  var GLIBC = "glibc";
  var RE_GLIBC_VERSION = /LIBC[a-z0-9 \-).]*?(\d+\.\d+)/i;
  var MUSL = "musl";
  var isFileMusl = (f) => f.includes("libc.musl-") || f.includes("ld-musl-");
  var familyFromReport = () => {
    const report = getReport();
    if (report.header && report.header.glibcVersionRuntime) {
      return GLIBC;
    }
    if (Array.isArray(report.sharedObjects)) {
      if (report.sharedObjects.some(isFileMusl)) {
        return MUSL;
      }
    }
    return null;
  };
  var familyFromCommand = (out) => {
    const [getconf, ldd1] = out.split(/[\r\n]+/);
    if (getconf && getconf.includes(GLIBC)) {
      return GLIBC;
    }
    if (ldd1 && ldd1.includes(MUSL)) {
      return MUSL;
    }
    return null;
  };
  var familyFromInterpreterPath = (path2) => {
    if (path2) {
      if (path2.includes("/ld-musl-")) {
        return MUSL;
      } else if (path2.includes("/ld-linux-")) {
        return GLIBC;
      }
    }
    return null;
  };
  var getFamilyFromLddContent = (content) => {
    content = content.toString();
    if (content.includes("musl")) {
      return MUSL;
    }
    if (content.includes("GNU C Library")) {
      return GLIBC;
    }
    return null;
  };
  var familyFromFilesystem = async () => {
    if (cachedFamilyFilesystem !== undefined) {
      return cachedFamilyFilesystem;
    }
    cachedFamilyFilesystem = null;
    try {
      const lddContent = await readFile(LDD_PATH);
      cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);
    } catch (e) {}
    return cachedFamilyFilesystem;
  };
  var familyFromFilesystemSync = () => {
    if (cachedFamilyFilesystem !== undefined) {
      return cachedFamilyFilesystem;
    }
    cachedFamilyFilesystem = null;
    try {
      const lddContent = readFileSync(LDD_PATH);
      cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);
    } catch (e) {}
    return cachedFamilyFilesystem;
  };
  var familyFromInterpreter = async () => {
    if (cachedFamilyInterpreter !== undefined) {
      return cachedFamilyInterpreter;
    }
    cachedFamilyInterpreter = null;
    try {
      const selfContent = await readFile(SELF_PATH);
      const path2 = interpreterPath(selfContent);
      cachedFamilyInterpreter = familyFromInterpreterPath(path2);
    } catch (e) {}
    return cachedFamilyInterpreter;
  };
  var familyFromInterpreterSync = () => {
    if (cachedFamilyInterpreter !== undefined) {
      return cachedFamilyInterpreter;
    }
    cachedFamilyInterpreter = null;
    try {
      const selfContent = readFileSync(SELF_PATH);
      const path2 = interpreterPath(selfContent);
      cachedFamilyInterpreter = familyFromInterpreterPath(path2);
    } catch (e) {}
    return cachedFamilyInterpreter;
  };
  var family = async () => {
    let family2 = null;
    if (isLinux()) {
      family2 = await familyFromInterpreter();
      if (!family2) {
        family2 = await familyFromFilesystem();
        if (!family2) {
          family2 = familyFromReport();
        }
        if (!family2) {
          const out = await safeCommand();
          family2 = familyFromCommand(out);
        }
      }
    }
    return family2;
  };
  var familySync = () => {
    let family2 = null;
    if (isLinux()) {
      family2 = familyFromInterpreterSync();
      if (!family2) {
        family2 = familyFromFilesystemSync();
        if (!family2) {
          family2 = familyFromReport();
        }
        if (!family2) {
          const out = safeCommandSync();
          family2 = familyFromCommand(out);
        }
      }
    }
    return family2;
  };
  var isNonGlibcLinux = async () => isLinux() && await family() !== GLIBC;
  var isNonGlibcLinuxSync = () => isLinux() && familySync() !== GLIBC;
  var versionFromFilesystem = async () => {
    if (cachedVersionFilesystem !== undefined) {
      return cachedVersionFilesystem;
    }
    cachedVersionFilesystem = null;
    try {
      const lddContent = await readFile(LDD_PATH);
      const versionMatch = lddContent.match(RE_GLIBC_VERSION);
      if (versionMatch) {
        cachedVersionFilesystem = versionMatch[1];
      }
    } catch (e) {}
    return cachedVersionFilesystem;
  };
  var versionFromFilesystemSync = () => {
    if (cachedVersionFilesystem !== undefined) {
      return cachedVersionFilesystem;
    }
    cachedVersionFilesystem = null;
    try {
      const lddContent = readFileSync(LDD_PATH);
      const versionMatch = lddContent.match(RE_GLIBC_VERSION);
      if (versionMatch) {
        cachedVersionFilesystem = versionMatch[1];
      }
    } catch (e) {}
    return cachedVersionFilesystem;
  };
  var versionFromReport = () => {
    const report = getReport();
    if (report.header && report.header.glibcVersionRuntime) {
      return report.header.glibcVersionRuntime;
    }
    return null;
  };
  var versionSuffix = (s) => s.trim().split(/\s+/)[1];
  var versionFromCommand = (out) => {
    const [getconf, ldd1, ldd2] = out.split(/[\r\n]+/);
    if (getconf && getconf.includes(GLIBC)) {
      return versionSuffix(getconf);
    }
    if (ldd1 && ldd2 && ldd1.includes(MUSL)) {
      return versionSuffix(ldd2);
    }
    return null;
  };
  var version = async () => {
    let version2 = null;
    if (isLinux()) {
      version2 = await versionFromFilesystem();
      if (!version2) {
        version2 = versionFromReport();
      }
      if (!version2) {
        const out = await safeCommand();
        version2 = versionFromCommand(out);
      }
    }
    return version2;
  };
  var versionSync = () => {
    let version2 = null;
    if (isLinux()) {
      version2 = versionFromFilesystemSync();
      if (!version2) {
        version2 = versionFromReport();
      }
      if (!version2) {
        const out = safeCommandSync();
        version2 = versionFromCommand(out);
      }
    }
    return version2;
  };
  module2.exports = {
    GLIBC,
    MUSL,
    family,
    familySync,
    isNonGlibcLinux,
    isNonGlibcLinuxSync,
    version,
    versionSync
  };
});

// backend/node_modules/semver/internal/debug.js
var require_debug = __commonJS((exports2, module2) => {
  var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {};
  module2.exports = debug;
});

// backend/node_modules/semver/internal/constants.js
var require_constants6 = __commonJS((exports2, module2) => {
  var SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  var RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  module2.exports = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
});

// backend/node_modules/semver/internal/re.js
var require_re = __commonJS((exports2, module2) => {
  var {
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_LENGTH
  } = require_constants6();
  var debug = require_debug();
  exports2 = module2.exports = {};
  var re = exports2.re = [];
  var safeRe = exports2.safeRe = [];
  var src = exports2.src = [];
  var safeSrc = exports2.safeSrc = [];
  var t = exports2.t = {};
  var R = 0;
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
  ];
  var makeSafeRegex = (value) => {
    for (const [token, max] of safeRegexReplacements) {
      value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value;
  };
  var createToken = (name, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index = R++;
    debug(name, index, value);
    t[name] = index;
    src[index] = value;
    safeSrc[index] = safe;
    re[index] = new RegExp(value, isGlobal ? "g" : undefined);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : undefined);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
  createToken("FULL", `^${src[t.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
  createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("COERCEPLAIN", `${"(^|[^\\d])" + "(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
  createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
  createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?` + `(?:${src[t.BUILD]})?` + `(?:$|[^\\d])`);
  createToken("COERCERTL", src[t.COERCE], true);
  createToken("COERCERTLFULL", src[t.COERCEFULL], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
  exports2.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
  exports2.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
  exports2.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});

// backend/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS((exports2, module2) => {
  var looseOption = Object.freeze({ loose: true });
  var emptyOpts = Object.freeze({});
  var parseOptions = (options) => {
    if (!options) {
      return emptyOpts;
    }
    if (typeof options !== "object") {
      return looseOption;
    }
    return options;
  };
  module2.exports = parseOptions;
});

// backend/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS((exports2, module2) => {
  var numeric = /^[0-9]+$/;
  var compareIdentifiers = (a, b) => {
    if (typeof a === "number" && typeof b === "number") {
      return a === b ? 0 : a < b ? -1 : 1;
    }
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
  module2.exports = {
    compareIdentifiers,
    rcompareIdentifiers
  };
});

// backend/node_modules/semver/classes/semver.js
var require_semver = __commonJS((exports2, module2) => {
  var debug = require_debug();
  var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants6();
  var { safeRe: re, t } = require_re();
  var parseOptions = require_parse_options();
  var { compareIdentifiers } = require_identifiers();

  class SemVer {
    constructor(version, options) {
      options = parseOptions(options);
      if (version instanceof SemVer) {
        if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
      }
      debug("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
      if (!m) {
        throw new TypeError(`Invalid Version: ${version}`);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map((id) => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.major < other.major) {
        return -1;
      }
      if (this.major > other.major) {
        return 1;
      }
      if (this.minor < other.minor) {
        return -1;
      }
      if (this.minor > other.minor) {
        return 1;
      }
      if (this.patch < other.patch) {
        return -1;
      }
      if (this.patch > other.patch) {
        return 1;
      }
      return 0;
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a = this.prerelease[i];
        const b = other.prerelease[i];
        debug("prerelease compare", i, a, b);
        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i = 0;
      do {
        const a = this.build[i];
        const b = other.build[i];
        debug("build compare", i, a, b);
        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }
    inc(release, identifier, identifierBase) {
      if (release.startsWith("pre")) {
        if (!identifier && identifierBase === false) {
          throw new Error("invalid increment argument: identifier is empty");
        }
        if (identifier) {
          const match2 = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
          if (!match2 || match2[1] !== identifier) {
            throw new Error(`invalid identifier: ${identifier}`);
          }
        }
      }
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier, identifierBase);
          this.inc("pre", identifier, identifierBase);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier, identifierBase);
          }
          this.inc("pre", identifier, identifierBase);
          break;
        case "release":
          if (this.prerelease.length === 0) {
            throw new Error(`version ${this.raw} is not a prerelease`);
          }
          this.prerelease.length = 0;
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre": {
          const base = Number(identifierBase) ? 1 : 0;
          if (this.prerelease.length === 0) {
            this.prerelease = [base];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              if (identifier === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base);
            }
          }
          if (identifier) {
            let prerelease = [identifier, base];
            if (identifierBase === false) {
              prerelease = [identifier];
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease;
              }
            } else {
              this.prerelease = prerelease;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  }
  module2.exports = SemVer;
});

// backend/node_modules/semver/functions/parse.js
var require_parse = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var parse = (version, options, throwErrors = false) => {
    if (version instanceof SemVer) {
      return version;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      if (!throwErrors) {
        return null;
      }
      throw er;
    }
  };
  module2.exports = parse;
});

// backend/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var parse = require_parse();
  var { safeRe: re, t } = require_re();
  var coerce = (version, options) => {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version === "number") {
      version = String(version);
    }
    if (typeof version !== "string") {
      return null;
    }
    options = options || {};
    let match2 = null;
    if (!options.rtl) {
      match2 = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
    } else {
      const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
      let next;
      while ((next = coerceRtlRegex.exec(version)) && (!match2 || match2.index + match2[0].length !== version.length)) {
        if (!match2 || next.index + next[0].length !== match2.index + match2[0].length) {
          match2 = next;
        }
        coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
      }
      coerceRtlRegex.lastIndex = -1;
    }
    if (match2 === null) {
      return null;
    }
    const major = match2[2];
    const minor = match2[3] || "0";
    const patch = match2[4] || "0";
    const prerelease = options.includePrerelease && match2[5] ? `-${match2[5]}` : "";
    const build = options.includePrerelease && match2[6] ? `+${match2[6]}` : "";
    return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
  };
  module2.exports = coerce;
});

// backend/node_modules/semver/functions/compare.js
var require_compare = __commonJS((exports2, module2) => {
  var SemVer = require_semver();
  var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
  module2.exports = compare;
});

// backend/node_modules/semver/functions/gte.js
var require_gte = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var gte = (a, b, loose) => compare(a, b, loose) >= 0;
  module2.exports = gte;
});

// backend/node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS((exports2, module2) => {
  class LRUCache {
    constructor() {
      this.max = 1000;
      this.map = new Map;
    }
    get(key) {
      const value = this.map.get(key);
      if (value === undefined) {
        return;
      } else {
        this.map.delete(key);
        this.map.set(key, value);
        return value;
      }
    }
    delete(key) {
      return this.map.delete(key);
    }
    set(key, value) {
      const deleted = this.delete(key);
      if (!deleted && value !== undefined) {
        if (this.map.size >= this.max) {
          const firstKey = this.map.keys().next().value;
          this.delete(firstKey);
        }
        this.map.set(key, value);
      }
      return this;
    }
  }
  module2.exports = LRUCache;
});

// backend/node_modules/semver/functions/eq.js
var require_eq = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var eq = (a, b, loose) => compare(a, b, loose) === 0;
  module2.exports = eq;
});

// backend/node_modules/semver/functions/neq.js
var require_neq = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var neq = (a, b, loose) => compare(a, b, loose) !== 0;
  module2.exports = neq;
});

// backend/node_modules/semver/functions/gt.js
var require_gt = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var gt = (a, b, loose) => compare(a, b, loose) > 0;
  module2.exports = gt;
});

// backend/node_modules/semver/functions/lt.js
var require_lt = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var lt = (a, b, loose) => compare(a, b, loose) < 0;
  module2.exports = lt;
});

// backend/node_modules/semver/functions/lte.js
var require_lte = __commonJS((exports2, module2) => {
  var compare = require_compare();
  var lte = (a, b, loose) => compare(a, b, loose) <= 0;
  module2.exports = lte;
});

// backend/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS((exports2, module2) => {
  var eq = require_eq();
  var neq = require_neq();
  var gt = require_gt();
  var gte = require_gte();
  var lt = require_lt();
  var lte = require_lte();
  var cmp = (a, op, b, loose) => {
    switch (op) {
      case "===":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a === b;
      case "!==":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  module2.exports = cmp;
});

// backend/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS((exports2, module2) => {
  var ANY = Symbol("SemVer ANY");

  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== undefined ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options).test(comp.semver);
      }
      options = parseOptions(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  module2.exports = Comparator;
  var parseOptions = require_parse_options();
  var { safeRe: re, t } = require_re();
  var cmp = require_cmp();
  var debug = require_debug();
  var SemVer = require_semver();
  var Range = require_range();
});

// backend/node_modules/semver/classes/range.js
var require_range = __commonJS((exports2, module2) => {
  var SPACE_CHARACTERS = /\s+/g;

  class Range {
    constructor(range, options) {
      options = parseOptions(options);
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        this.raw = range.value;
        this.set = [[range]];
        this.formatted = undefined;
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.formatted = undefined;
    }
    get range() {
      if (this.formatted === undefined) {
        this.formatted = "";
        for (let i = 0;i < this.set.length; i++) {
          if (i > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i];
          for (let k = 0;k < comps.length; k++) {
            if (k > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug("hyphen replace", range);
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range);
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
      debug("tilde trim", range);
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);
      debug("caret trim", range);
      let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug("loose invalid filter", comp, this.options);
          return !!comp.match(re[t.COMPARATORLOOSE]);
        });
      }
      debug("range list", rangeList);
      const rangeMap = new Map;
      const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    test(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0;i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  module2.exports = Range;
  var LRU = require_lrucache();
  var cache = new LRU;
  var parseOptions = require_parse_options();
  var Comparator = require_comparator();
  var debug = require_debug();
  var SemVer = require_semver();
  var {
    safeRe: re,
    t,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = require_re();
  var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants6();
  var isNullSet = (c) => c.value === "<0.0.0-0";
  var isAny = (c) => c.value === "";
  var isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var parseComparator = (comp, options) => {
    comp = comp.replace(re[t.BUILD], "");
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  };
  var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  var replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
  };
  var replaceTilde = (comp, options) => {
    const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug("tilde return", ret);
      return ret;
    });
  };
  var replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
  };
  var replaceCaret = (comp, options) => {
    debug("caret", comp, options);
    const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug("caret return", ret);
      return ret;
    });
  };
  var replaceXRanges = (comp, options) => {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
  };
  var replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug("xRange return", ret);
      return ret;
    });
  };
  var replaceStars = (comp, options) => {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re[t.STAR], "");
  };
  var replaceGTE0 = (comp, options) => {
    debug("replaceGTE0", comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
  };
  var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  var testSet = (set, version, options) => {
    for (let i = 0;i < set.length; i++) {
      if (!set[i].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (let i = 0;i < set.length; i++) {
        debug(set[i].semver);
        if (set[i].semver === Comparator.ANY) {
          continue;
        }
        if (set[i].semver.prerelease.length > 0) {
          const allowed = set[i].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
});

// backend/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS((exports2, module2) => {
  var Range = require_range();
  var satisfies = (version, range, options) => {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  };
  module2.exports = satisfies;
});

// backend/node_modules/sharp/package.json
var require_package = __commonJS((exports2, module2) => {
  module2.exports = {
    name: "sharp",
    description: "High performance Node.js image processing, the fastest module to resize JPEG, PNG, WebP, GIF, AVIF and TIFF images",
    version: "0.34.5",
    author: "Lovell Fuller <npm@lovell.info>",
    homepage: "https://sharp.pixelplumbing.com",
    contributors: [
      "Pierre Inglebert <pierre.inglebert@gmail.com>",
      "Jonathan Ong <jonathanrichardong@gmail.com>",
      "Chanon Sajjamanochai <chanon.s@gmail.com>",
      "Juliano Julio <julianojulio@gmail.com>",
      "Daniel Gasienica <daniel@gasienica.ch>",
      "Julian Walker <julian@fiftythree.com>",
      "Amit Pitaru <pitaru.amit@gmail.com>",
      "Brandon Aaron <hello.brandon@aaron.sh>",
      "Andreas Lind <andreas@one.com>",
      "Maurus Cuelenaere <mcuelenaere@gmail.com>",
      "Linus Unnebck <linus@folkdatorn.se>",
      "Victor Mateevitsi <mvictoras@gmail.com>",
      "Alaric Holloway <alaric.holloway@gmail.com>",
      "Bernhard K. Weisshuhn <bkw@codingforce.com>",
      "Chris Riley <criley@primedia.com>",
      "David Carley <dacarley@gmail.com>",
      "John Tobin <john@limelightmobileinc.com>",
      "Kenton Gray <kentongray@gmail.com>",
      "Felix Bnemann <Felix.Buenemann@gmail.com>",
      "Samy Al Zahrani <samyalzahrany@gmail.com>",
      "Chintan Thakkar <lemnisk8@gmail.com>",
      "F. Orlando Galashan <frulo@gmx.de>",
      "Kleis Auke Wolthuizen <info@kleisauke.nl>",
      "Matt Hirsch <mhirsch@media.mit.edu>",
      "Matthias Thoemmes <thoemmes@gmail.com>",
      "Patrick Paskaris <patrick@paskaris.gr>",
      "Jrmy Lal <kapouer@melix.org>",
      "Rahul Nanwani <r.nanwani@gmail.com>",
      "Alice Monday <alice0meta@gmail.com>",
      "Kristo Jorgenson <kristo.jorgenson@gmail.com>",
      "YvesBos <yves_bos@outlook.com>",
      "Guy Maliar <guy@tailorbrands.com>",
      "Nicolas Coden <nicolas@ncoden.fr>",
      "Matt Parrish <matt.r.parrish@gmail.com>",
      "Marcel Bretschneider <marcel.bretschneider@gmail.com>",
      "Matthew McEachen <matthew+github@mceachen.org>",
      "Jarda Kotovec <jarda.kotesovec@gmail.com>",
      "Kenric D'Souza <kenric.dsouza@gmail.com>",
      "Oleh Aleinyk <oleg.aleynik@gmail.com>",
      "Marcel Bretschneider <marcel.bretschneider@gmail.com>",
      "Andrea Bianco <andrea.bianco@unibas.ch>",
      "Rik Heywood <rik@rik.org>",
      "Thomas Parisot <hi@oncletom.io>",
      "Nathan Graves <nathanrgraves+github@gmail.com>",
      "Tom Lokhorst <tom@lokhorst.eu>",
      "Espen Hovlandsdal <espen@hovlandsdal.com>",
      "Sylvain Dumont <sylvain.dumont35@gmail.com>",
      "Alun Davies <alun.owain.davies@googlemail.com>",
      "Aidan Hoolachan <ajhoolachan21@gmail.com>",
      "Axel Eirola <axel.eirola@iki.fi>",
      "Freezy <freezy@xbmc.org>",
      "Daiz <taneli.vatanen@gmail.com>",
      "Julian Aubourg <j@ubourg.net>",
      "Keith Belovay <keith@picthrive.com>",
      "Michael B. Klein <mbklein@gmail.com>",
      "Jordan Prudhomme <jordan@raboland.fr>",
      "Ilya Ovdin <iovdin@gmail.com>",
      "Andargor <andargor@yahoo.com>",
      "Paul Neave <paul.neave@gmail.com>",
      "Brendan Kennedy <brenwken@gmail.com>",
      "Brychan Bennett-Odlum <git@brychan.io>",
      "Edward Silverton <e.silverton@gmail.com>",
      "Roman Malieiev <aromaleev@gmail.com>",
      "Tomas Szabo <tomas.szabo@deftomat.com>",
      "Robert O'Rourke <robert@o-rourke.org>",
      "Guillermo Alfonso Varela Choucio <guillevch@gmail.com>",
      "Christian Flintrup <chr@gigahost.dk>",
      "Manan Jadhav <manan@motionden.com>",
      "Leon Radley <leon@radley.se>",
      "alza54 <alza54@thiocod.in>",
      "Jacob Smith <jacob@frende.me>",
      "Michael Nutt <michael@nutt.im>",
      "Brad Parham <baparham@gmail.com>",
      "Taneli Vatanen <taneli.vatanen@gmail.com>",
      "Joris Dugu <zaruike10@gmail.com>",
      "Chris Banks <christopher.bradley.banks@gmail.com>",
      "Ompal Singh <ompal.hitm09@gmail.com>",
      "Brodan <christopher.hranj@gmail.com>",
      "Ankur Parihar <ankur.github@gmail.com>",
      "Brahim Ait elhaj <brahima@gmail.com>",
      "Mart Jansink <m.jansink@gmail.com>",
      "Lachlan Newman <lachnewman007@gmail.com>",
      "Dennis Beatty <dennis@dcbeatty.com>",
      "Ingvar Stepanyan <me@rreverser.com>",
      "Don Denton <don@happycollision.com>"
    ],
    scripts: {
      build: "node install/build.js",
      install: "node install/check.js || npm run build",
      clean: "rm -rf src/build/ .nyc_output/ coverage/ test/fixtures/output.*",
      test: "npm run lint && npm run test-unit",
      lint: "npm run lint-cpp && npm run lint-js && npm run lint-types",
      "lint-cpp": "cpplint --quiet src/*.h src/*.cc",
      "lint-js": "biome lint",
      "lint-types": "tsd --files ./test/types/sharp.test-d.ts",
      "test-leak": "./test/leak/leak.sh",
      "test-unit": "node --experimental-test-coverage test/unit.mjs",
      "package-from-local-build": "node npm/from-local-build.js",
      "package-release-notes": "node npm/release-notes.js",
      "docs-build": "node docs/build.mjs",
      "docs-serve": "cd docs && npm start",
      "docs-publish": "cd docs && npm run build && npx firebase-tools deploy --project pixelplumbing --only hosting:pixelplumbing-sharp"
    },
    type: "commonjs",
    main: "lib/index.js",
    types: "lib/index.d.ts",
    files: [
      "install",
      "lib",
      "src/*.{cc,h,gyp}"
    ],
    repository: {
      type: "git",
      url: "git://github.com/lovell/sharp.git"
    },
    keywords: [
      "jpeg",
      "png",
      "webp",
      "avif",
      "tiff",
      "gif",
      "svg",
      "jp2",
      "dzi",
      "image",
      "resize",
      "thumbnail",
      "crop",
      "embed",
      "libvips",
      "vips"
    ],
    dependencies: {
      "@img/colour": "^1.0.0",
      "detect-libc": "^2.1.2",
      semver: "^7.7.3"
    },
    optionalDependencies: {
      "@img/sharp-darwin-arm64": "0.34.5",
      "@img/sharp-darwin-x64": "0.34.5",
      "@img/sharp-libvips-darwin-arm64": "1.2.4",
      "@img/sharp-libvips-darwin-x64": "1.2.4",
      "@img/sharp-libvips-linux-arm": "1.2.4",
      "@img/sharp-libvips-linux-arm64": "1.2.4",
      "@img/sharp-libvips-linux-ppc64": "1.2.4",
      "@img/sharp-libvips-linux-riscv64": "1.2.4",
      "@img/sharp-libvips-linux-s390x": "1.2.4",
      "@img/sharp-libvips-linux-x64": "1.2.4",
      "@img/sharp-libvips-linuxmusl-arm64": "1.2.4",
      "@img/sharp-libvips-linuxmusl-x64": "1.2.4",
      "@img/sharp-linux-arm": "0.34.5",
      "@img/sharp-linux-arm64": "0.34.5",
      "@img/sharp-linux-ppc64": "0.34.5",
      "@img/sharp-linux-riscv64": "0.34.5",
      "@img/sharp-linux-s390x": "0.34.5",
      "@img/sharp-linux-x64": "0.34.5",
      "@img/sharp-linuxmusl-arm64": "0.34.5",
      "@img/sharp-linuxmusl-x64": "0.34.5",
      "@img/sharp-wasm32": "0.34.5",
      "@img/sharp-win32-arm64": "0.34.5",
      "@img/sharp-win32-ia32": "0.34.5",
      "@img/sharp-win32-x64": "0.34.5"
    },
    devDependencies: {
      "@biomejs/biome": "^2.3.4",
      "@cpplint/cli": "^0.1.0",
      "@emnapi/runtime": "^1.7.0",
      "@img/sharp-libvips-dev": "1.2.4",
      "@img/sharp-libvips-dev-wasm32": "1.2.4",
      "@img/sharp-libvips-win32-arm64": "1.2.4",
      "@img/sharp-libvips-win32-ia32": "1.2.4",
      "@img/sharp-libvips-win32-x64": "1.2.4",
      "@types/node": "*",
      emnapi: "^1.7.0",
      "exif-reader": "^2.0.2",
      "extract-zip": "^2.0.1",
      icc: "^3.0.0",
      "jsdoc-to-markdown": "^9.1.3",
      "node-addon-api": "^8.5.0",
      "node-gyp": "^11.5.0",
      "tar-fs": "^3.1.1",
      tsd: "^0.33.0"
    },
    license: "Apache-2.0",
    engines: {
      node: "^18.17.0 || ^20.3.0 || >=21.0.0"
    },
    config: {
      libvips: ">=8.17.3"
    },
    funding: {
      url: "https://opencollective.com/libvips"
    }
  };
});

// backend/node_modules/sharp/lib/libvips.js
var require_libvips = __commonJS((exports2, module2) => {
  /*!
    Copyright 2013 Lovell Fuller and others.
    SPDX-License-Identifier: Apache-2.0
  */
  var { spawnSync } = require("node:child_process");
  var { createHash } = require("node:crypto");
  var semverCoerce = require_coerce();
  var semverGreaterThanOrEqualTo = require_gte();
  var semverSatisfies = require_satisfies();
  var detectLibc = require_detect_libc();
  var { config, engines, optionalDependencies } = require_package();
  var minimumLibvipsVersionLabelled = process.env.npm_package_config_libvips || config.libvips;
  var minimumLibvipsVersion = semverCoerce(minimumLibvipsVersionLabelled).version;
  var prebuiltPlatforms = [
    "darwin-arm64",
    "darwin-x64",
    "linux-arm",
    "linux-arm64",
    "linux-ppc64",
    "linux-riscv64",
    "linux-s390x",
    "linux-x64",
    "linuxmusl-arm64",
    "linuxmusl-x64",
    "win32-arm64",
    "win32-ia32",
    "win32-x64"
  ];
  var spawnSyncOptions = {
    encoding: "utf8",
    shell: true
  };
  var log2 = (item) => {
    if (item instanceof Error) {
      console.error(`sharp: Installation error: ${item.message}`);
    } else {
      console.log(`sharp: ${item}`);
    }
  };
  var runtimeLibc = () => detectLibc.isNonGlibcLinuxSync() ? detectLibc.familySync() : "";
  var runtimePlatformArch = () => `${process.platform}${runtimeLibc()}-${process.arch}`;
  var buildPlatformArch = () => {
    if (isEmscripten()) {
      return "wasm32";
    }
    const { npm_config_arch, npm_config_platform, npm_config_libc } = process.env;
    const libc = typeof npm_config_libc === "string" ? npm_config_libc : runtimeLibc();
    return `${npm_config_platform || process.platform}${libc}-${npm_config_arch || process.arch}`;
  };
  var buildSharpLibvipsIncludeDir = () => {
    try {
      return require(`@img/sharp-libvips-dev-${buildPlatformArch()}/include`);
    } catch {
      try {
        return (()=>{throw new Error("Cannot require module "+"@img/sharp-libvips-dev/include");})();
      } catch {}
    }
    return "";
  };
  var buildSharpLibvipsCPlusPlusDir = () => {
    try {
      return (()=>{throw new Error("Cannot require module "+"@img/sharp-libvips-dev/cplusplus");})();
    } catch {}
    return "";
  };
  var buildSharpLibvipsLibDir = () => {
    try {
      return require(`@img/sharp-libvips-dev-${buildPlatformArch()}/lib`);
    } catch {
      try {
        return require(`@img/sharp-libvips-${buildPlatformArch()}/lib`);
      } catch {}
    }
    return "";
  };
  var isUnsupportedNodeRuntime = () => {
    if (process.release?.name === "node" && process.versions) {
      if (!semverSatisfies(process.versions.node, engines.node)) {
        return { found: process.versions.node, expected: engines.node };
      }
    }
  };
  var isEmscripten = () => {
    const { CC } = process.env;
    return Boolean(CC?.endsWith("/emcc"));
  };
  var isRosetta = () => {
    if (process.platform === "darwin" && process.arch === "x64") {
      const translated = spawnSync("sysctl sysctl.proc_translated", spawnSyncOptions).stdout;
      return (translated || "").trim() === "sysctl.proc_translated: 1";
    }
    return false;
  };
  var sha512 = (s) => createHash("sha512").update(s).digest("hex");
  var yarnLocator = () => {
    try {
      const identHash = sha512(`imgsharp-libvips-${buildPlatformArch()}`);
      const npmVersion = semverCoerce(optionalDependencies[`@img/sharp-libvips-${buildPlatformArch()}`], {
        includePrerelease: true
      }).version;
      return sha512(`${identHash}npm:${npmVersion}`).slice(0, 10);
    } catch {}
    return "";
  };
  var spawnRebuild = () => spawnSync(`node-gyp rebuild --directory=src ${isEmscripten() ? "--nodedir=emscripten" : ""}`, {
    ...spawnSyncOptions,
    stdio: "inherit"
  }).status;
  var globalLibvipsVersion = () => {
    if (process.platform !== "win32") {
      const globalLibvipsVersion2 = spawnSync("pkg-config --modversion vips-cpp", {
        ...spawnSyncOptions,
        env: {
          ...process.env,
          PKG_CONFIG_PATH: pkgConfigPath()
        }
      }).stdout;
      return (globalLibvipsVersion2 || "").trim();
    } else {
      return "";
    }
  };
  var pkgConfigPath = () => {
    if (process.platform !== "win32") {
      const brewPkgConfigPath = spawnSync('which brew >/dev/null 2>&1 && brew environment --plain | grep PKG_CONFIG_LIBDIR | cut -d" " -f2', spawnSyncOptions).stdout || "";
      return [
        brewPkgConfigPath.trim(),
        process.env.PKG_CONFIG_PATH,
        "/usr/local/lib/pkgconfig",
        "/usr/lib/pkgconfig",
        "/usr/local/libdata/pkgconfig",
        "/usr/libdata/pkgconfig"
      ].filter(Boolean).join(":");
    } else {
      return "";
    }
  };
  var skipSearch = (status, reason, logger) => {
    if (logger) {
      logger(`Detected ${reason}, skipping search for globally-installed libvips`);
    }
    return status;
  };
  var useGlobalLibvips = (logger) => {
    if (Boolean(process.env.SHARP_IGNORE_GLOBAL_LIBVIPS) === true) {
      return skipSearch(false, "SHARP_IGNORE_GLOBAL_LIBVIPS", logger);
    }
    if (Boolean(process.env.SHARP_FORCE_GLOBAL_LIBVIPS) === true) {
      return skipSearch(true, "SHARP_FORCE_GLOBAL_LIBVIPS", logger);
    }
    if (isRosetta()) {
      return skipSearch(false, "Rosetta", logger);
    }
    const globalVipsVersion = globalLibvipsVersion();
    return !!globalVipsVersion && semverGreaterThanOrEqualTo(globalVipsVersion, minimumLibvipsVersion);
  };
  module2.exports = {
    minimumLibvipsVersion,
    prebuiltPlatforms,
    buildPlatformArch,
    buildSharpLibvipsIncludeDir,
    buildSharpLibvipsCPlusPlusDir,
    buildSharpLibvipsLibDir,
    isUnsupportedNodeRuntime,
    runtimePlatformArch,
    log: log2,
    yarnLocator,
    spawnRebuild,
    globalLibvipsVersion,
    pkgConfigPath,
    useGlobalLibvips
  };
});

// backend/node_modules/sharp/lib/sharp.js
var require_sharp = __commonJS((exports2, module2) => {
  /*!
    Copyright 2013 Lovell Fuller and others.
    SPDX-License-Identifier: Apache-2.0
  */
  var { familySync, versionSync } = require_detect_libc();
  var { runtimePlatformArch, isUnsupportedNodeRuntime, prebuiltPlatforms, minimumLibvipsVersion } = require_libvips();
  var runtimePlatform = runtimePlatformArch();
  var paths = [
    `../src/build/Release/sharp-${runtimePlatform}.node`,
    "../src/build/Release/sharp-wasm32.node",
    `@img/sharp-${runtimePlatform}/sharp.node`,
    "@img/sharp-wasm32/sharp.node"
  ];
  var path2;
  var sharp;
  var errors = [];
  for (path2 of paths) {
    try {
      sharp = require(path2);
      break;
    } catch (err) {
      errors.push(err);
    }
  }
  if (sharp && path2.startsWith("@img/sharp-linux-x64") && !sharp._isUsingX64V2()) {
    const err = new Error("Prebuilt binaries for linux-x64 require v2 microarchitecture");
    err.code = "Unsupported CPU";
    errors.push(err);
    sharp = null;
  }
  if (sharp) {
    module2.exports = sharp;
  } else {
    const [isLinux, isMacOs, isWindows] = ["linux", "darwin", "win32"].map((os) => runtimePlatform.startsWith(os));
    const help = [`Could not load the "sharp" module using the ${runtimePlatform} runtime`];
    errors.forEach((err) => {
      if (err.code !== "MODULE_NOT_FOUND") {
        help.push(`${err.code}: ${err.message}`);
      }
    });
    const messages = errors.map((err) => err.message).join(" ");
    help.push("Possible solutions:");
    if (isUnsupportedNodeRuntime()) {
      const { found, expected } = isUnsupportedNodeRuntime();
      help.push("- Please upgrade Node.js:", `    Found ${found}`, `    Requires ${expected}`);
    } else if (prebuiltPlatforms.includes(runtimePlatform)) {
      const [os, cpu] = runtimePlatform.split("-");
      const libc = os.endsWith("musl") ? " --libc=musl" : "";
      help.push("- Ensure optional dependencies can be installed:", "    npm install --include=optional sharp", "- Ensure your package manager supports multi-platform installation:", "    See https://sharp.pixelplumbing.com/install#cross-platform", "- Add platform-specific dependencies:", `    npm install --os=${os.replace("musl", "")}${libc} --cpu=${cpu} sharp`);
    } else {
      help.push(`- Manually install libvips >= ${minimumLibvipsVersion}`, "- Add experimental WebAssembly-based dependencies:", "    npm install --cpu=wasm32 sharp", "    npm install @img/sharp-wasm32");
    }
    if (isLinux && /(symbol not found|CXXABI_)/i.test(messages)) {
      try {
        const { config } = require(`@img/sharp-libvips-${runtimePlatform}/package`);
        const libcFound = `${familySync()} ${versionSync()}`;
        const libcRequires = `${config.musl ? "musl" : "glibc"} ${config.musl || config.glibc}`;
        help.push("- Update your OS:", `    Found ${libcFound}`, `    Requires ${libcRequires}`);
      } catch (_errEngines) {}
    }
    if (isLinux && /\/snap\/core[0-9]{2}/.test(messages)) {
      help.push("- Remove the Node.js Snap, which does not support native modules", "    snap remove node");
    }
    if (isMacOs && /Incompatible library version/.test(messages)) {
      help.push("- Update Homebrew:", "    brew update && brew upgrade vips");
    }
    if (errors.some((err) => err.code === "ERR_DLOPEN_DISABLED")) {
      help.push("- Run Node.js without using the --no-addons flag");
    }
    if (isWindows && /The specified procedure could not be found/.test(messages)) {
      help.push("- Using the canvas package on Windows?", "    See https://sharp.pixelplumbing.com/install#canvas-and-windows", "- Check for outdated versions of sharp in the dependency tree:", "    npm ls sharp");
    }
    help.push("- Consult the installation documentation:", "    See https://sharp.pixelplumbing.com/install");
    throw new Error(help.join(`
`));
  }
});

// backend/node_modules/sharp/lib/constructor.js
var require_constructor = __commonJS((exports2, module2) => {
  /*!
    Copyright 2013 Lovell Fuller and others.
    SPDX-License-Identifier: Apache-2.0
  */
  var util = require("node:util");
  var stream = require("node:stream");
  var is = require_is();
  require_sharp();
  var debuglog = util.debuglog("sharp");
  var queueListener = (queueLength) => {
    Sharp.queue.emit("change", queueLength);
  };
  var Sharp = function(input, options) {
    if (arguments.length === 1 && !is.defined(input)) {
      throw new Error("Invalid input");
    }
    if (!(this instanceof Sharp)) {
      return new Sharp(input, options);
    }
    stream.Duplex.call(this);
    this.options = {
      topOffsetPre: -1,
      leftOffsetPre: -1,
      widthPre: -1,
      heightPre: -1,
      topOffsetPost: -1,
      leftOffsetPost: -1,
      widthPost: -1,
      heightPost: -1,
      width: -1,
      height: -1,
      canvas: "crop",
      position: 0,
      resizeBackground: [0, 0, 0, 255],
      angle: 0,
      rotationAngle: 0,
      rotationBackground: [0, 0, 0, 255],
      rotateBefore: false,
      orientBefore: false,
      flip: false,
      flop: false,
      extendTop: 0,
      extendBottom: 0,
      extendLeft: 0,
      extendRight: 0,
      extendBackground: [0, 0, 0, 255],
      extendWith: "background",
      withoutEnlargement: false,
      withoutReduction: false,
      affineMatrix: [],
      affineBackground: [0, 0, 0, 255],
      affineIdx: 0,
      affineIdy: 0,
      affineOdx: 0,
      affineOdy: 0,
      affineInterpolator: this.constructor.interpolators.bilinear,
      kernel: "lanczos3",
      fastShrinkOnLoad: true,
      tint: [-1, 0, 0, 0],
      flatten: false,
      flattenBackground: [0, 0, 0],
      unflatten: false,
      negate: false,
      negateAlpha: true,
      medianSize: 0,
      blurSigma: 0,
      precision: "integer",
      minAmpl: 0.2,
      sharpenSigma: 0,
      sharpenM1: 1,
      sharpenM2: 2,
      sharpenX1: 2,
      sharpenY2: 10,
      sharpenY3: 20,
      threshold: 0,
      thresholdGrayscale: true,
      trimBackground: [],
      trimThreshold: -1,
      trimLineArt: false,
      dilateWidth: 0,
      erodeWidth: 0,
      gamma: 0,
      gammaOut: 0,
      greyscale: false,
      normalise: false,
      normaliseLower: 1,
      normaliseUpper: 99,
      claheWidth: 0,
      claheHeight: 0,
      claheMaxSlope: 3,
      brightness: 1,
      saturation: 1,
      hue: 0,
      lightness: 0,
      booleanBufferIn: null,
      booleanFileIn: "",
      joinChannelIn: [],
      extractChannel: -1,
      removeAlpha: false,
      ensureAlpha: -1,
      colourspace: "srgb",
      colourspacePipeline: "last",
      composite: [],
      fileOut: "",
      formatOut: "input",
      streamOut: false,
      keepMetadata: 0,
      withMetadataOrientation: -1,
      withMetadataDensity: 0,
      withIccProfile: "",
      withExif: {},
      withExifMerge: true,
      withXmp: "",
      resolveWithObject: false,
      loop: -1,
      delay: [],
      jpegQuality: 80,
      jpegProgressive: false,
      jpegChromaSubsampling: "4:2:0",
      jpegTrellisQuantisation: false,
      jpegOvershootDeringing: false,
      jpegOptimiseScans: false,
      jpegOptimiseCoding: true,
      jpegQuantisationTable: 0,
      pngProgressive: false,
      pngCompressionLevel: 6,
      pngAdaptiveFiltering: false,
      pngPalette: false,
      pngQuality: 100,
      pngEffort: 7,
      pngBitdepth: 8,
      pngDither: 1,
      jp2Quality: 80,
      jp2TileHeight: 512,
      jp2TileWidth: 512,
      jp2Lossless: false,
      jp2ChromaSubsampling: "4:4:4",
      webpQuality: 80,
      webpAlphaQuality: 100,
      webpLossless: false,
      webpNearLossless: false,
      webpSmartSubsample: false,
      webpSmartDeblock: false,
      webpPreset: "default",
      webpEffort: 4,
      webpMinSize: false,
      webpMixed: false,
      gifBitdepth: 8,
      gifEffort: 7,
      gifDither: 1,
      gifInterFrameMaxError: 0,
      gifInterPaletteMaxError: 3,
      gifKeepDuplicateFrames: false,
      gifReuse: true,
      gifProgressive: false,
      tiffQuality: 80,
      tiffCompression: "jpeg",
      tiffBigtiff: false,
      tiffPredictor: "horizontal",
      tiffPyramid: false,
      tiffMiniswhite: false,
      tiffBitdepth: 8,
      tiffTile: false,
      tiffTileHeight: 256,
      tiffTileWidth: 256,
      tiffXres: 1,
      tiffYres: 1,
      tiffResolutionUnit: "inch",
      heifQuality: 50,
      heifLossless: false,
      heifCompression: "av1",
      heifEffort: 4,
      heifChromaSubsampling: "4:4:4",
      heifBitdepth: 8,
      jxlDistance: 1,
      jxlDecodingTier: 0,
      jxlEffort: 7,
      jxlLossless: false,
      rawDepth: "uchar",
      tileSize: 256,
      tileOverlap: 0,
      tileContainer: "fs",
      tileLayout: "dz",
      tileFormat: "last",
      tileDepth: "last",
      tileAngle: 0,
      tileSkipBlanks: -1,
      tileBackground: [255, 255, 255, 255],
      tileCentre: false,
      tileId: "https://example.com/iiif",
      tileBasename: "",
      timeoutSeconds: 0,
      linearA: [],
      linearB: [],
      pdfBackground: [255, 255, 255, 255],
      debuglog: (warning) => {
        this.emit("warning", warning);
        debuglog(warning);
      },
      queueListener
    };
    this.options.input = this._createInputDescriptor(input, options, { allowStream: true });
    return this;
  };
  Object.setPrototypeOf(Sharp.prototype, stream.Duplex.prototype);
  Object.setPrototypeOf(Sharp, stream.Duplex);
  function clone() {
    const clone2 = this.constructor.call();
    const { debuglog: debuglog2, queueListener: queueListener2, ...options } = this.options;
    clone2.options = structuredClone(options);
    clone2.options.debuglog = debuglog2;
    clone2.options.queueListener = queueListener2;
    if (this._isStreamInput()) {
      this.on("finish", () => {
        this._flattenBufferIn();
        clone2.options.input.buffer = this.options.input.buffer;
        clone2.emit("finish");
      });
    }
    return clone2;
  }
  Object.assign(Sharp.prototype, { clone });
  module2.exports = Sharp;
});

// backend/node_modules/sharp/lib/input.js
var require_input = __commonJS((exports2, module2) => {
  /*!
    Copyright 2013 Lovell Fuller and others.
    SPDX-License-Identifier: Apache-2.0
  */
  var is = require_is();
  var sharp = require_sharp();
  var align = {
    left: "low",
    top: "low",
    low: "low",
    center: "centre",
    centre: "centre",
    right: "high",
    bottom: "high",
    high: "high"
  };
  var inputStreamParameters = [
    "failOn",
    "limitInputPixels",
    "unlimited",
    "animated",
    "autoOrient",
    "density",
    "ignoreIcc",
    "page",
    "pages",
    "sequentialRead",
    "jp2",
    "openSlide",
    "pdf",
    "raw",
    "svg",
    "tiff",
    "failOnError",
    "openSlideLevel",
    "pdfBackground",
    "tiffSubifd"
  ];
  function _inputOptionsFromObject(obj2) {
    const params = inputStreamParameters.filter((p) => is.defined(obj2[p])).map((p) => [p, obj2[p]]);
    return params.length ? Object.fromEntries(params) : undefined;
  }
  function _createInputDescriptor(input, inputOptions, containerOptions) {
    const inputDescriptor = {
      autoOrient: false,
      failOn: "warning",
      limitInputPixels: 16383 ** 2,
      ignoreIcc: false,
      unlimited: false,
      sequentialRead: true
    };
    if (is.string(input)) {
      inputDescriptor.file = input;
    } else if (is.buffer(input)) {
      if (input.length === 0) {
        throw Error("Input Buffer is empty");
      }
      inputDescriptor.buffer = input;
    } else if (is.arrayBuffer(input)) {
      if (input.byteLength === 0) {
        throw Error("Input bit Array is empty");
      }
      inputDescriptor.buffer = Buffer.from(input, 0, input.byteLength);
    } else if (is.typedArray(input)) {
      if (input.length === 0) {
        throw Error("Input Bit Array is empty");
      }
      inputDescriptor.buffer = Buffer.from(input.buffer, input.byteOffset, input.byteLength);
    } else if (is.plainObject(input) && !is.defined(inputOptions)) {
      inputOptions = input;
      if (_inputOptionsFromObject(inputOptions)) {
        inputDescriptor.buffer = [];
      }
    } else if (!is.defined(input) && !is.defined(inputOptions) && is.object(containerOptions) && containerOptions.allowStream) {
      inputDescriptor.buffer = [];
    } else if (Array.isArray(input)) {
      if (input.length > 1) {
        if (!this.options.joining) {
          this.options.joining = true;
          this.options.join = input.map((i) => this._createInputDescriptor(i));
        } else {
          throw new Error("Recursive join is unsupported");
        }
      } else {
        throw new Error("Expected at least two images to join");
      }
    } else {
      throw new Error(`Unsupported input '${input}' of type ${typeof input}${is.defined(inputOptions) ? ` when also providing options of type ${typeof inputOptions}` : ""}`);
    }
    if (is.object(inputOptions)) {
      if (is.defined(inputOptions.failOnError)) {
        if (is.bool(inputOptions.failOnError)) {
          inputDescriptor.failOn = inputOptions.failOnError ? "warning" : "none";
        } else {
          throw is.invalidParameterError("failOnError", "boolean", inputOptions.failOnError);
        }
      }
      if (is.defined(inputOptions.failOn)) {
        if (is.string(inputOptions.failOn) && is.inArray(inputOptions.failOn, ["none", "truncated", "error", "warning"])) {
          inputDescriptor.failOn = inputOptions.failOn;
        } else {
          throw is.invalidParameterError("failOn", "one of: none, truncated, error, warning", inputOptions.failOn);
        }
      }
      if (is.defined(inputOptions.autoOrient)) {
        if (is.bool(inputOptions.autoOrient)) {
          inputDescriptor.autoOrient = inputOptions.autoOrient;
        } else {
          throw is.invalidParameterError("autoOrient", "boolean", inputOptions.autoOrient);
        }
      }
      if (is.defined(inputOptions.density)) {
        if (is.inRange(inputOptions.density, 1, 1e5)) {
          inputDescriptor.density = inputOptions.density;
        } else {
          throw is.invalidParameterError("density", "number between 1 and 100000", inputOptions.density);
        }
      }
      if (is.defined(inputOptions.ignoreIcc)) {
        if (is.bool(inputOptions.ignoreIcc)) {
          inputDescriptor.ignoreIcc = inputOptions.ignoreIcc;
        } else {
          throw is.invalidParameterError("ignoreIcc", "boolean", inputOptions.ignoreIcc);
        }
      }
      if (is.defined(inputOptions.limitInputPixels)) {
        if (is.bool(inputOptions.limitInputPixels)) {
          inputDescriptor.limitInputPixels = inputOptions.limitInputPixels ? 16383 ** 2 : 0;
        } else if (is.integer(inputOptions.limitInputPixels) && is.inRange(inputOptions.limitInputPixels, 0, Number.MAX_SAFE_INTEGER)) {
          inputDescriptor.limitInputPixels = inputOptions.limitInputPixels;
        } else {
          throw is.invalidParameterError("limitInputPixels", "positive integer", inputOptions.limitInputPixels);
        }
      }
      if (is.defined(inputOptions.unlimited)) {
        if (is.bool(inputOptions.unlimited)) {
          inputDescriptor.unlimited = inputOptions.unlimited;
        } else {
          throw is.invalidParameterError("unlimited", "boolean", inputOptions.unlimited);
        }
      }
      if (is.defined(inputOptions.sequentialRead)) {
        if (is.bool(inputOptions.sequentialRead)) {
          inputDescriptor.sequentialRead = inputOptions.sequentialRead;
        } else {
          throw is.invalidParameterError("sequentialRead", "boolean", inputOptions.sequentialRead);
        }
      }
      if (is.defined(inputOptions.raw)) {
        if (is.object(inputOptions.raw) && is.integer(inputOptions.raw.width) && inputOptions.raw.width > 0 && is.integer(inputOptions.raw.height) && inputOptions.raw.height > 0 && is.integer(inputOptions.raw.channels) && is.inRange(inputOptions.raw.channels, 1, 4)) {
          inputDescriptor.rawWidth = inputOptions.raw.width;
          inputDescriptor.rawHeight = inputOptions.raw.height;
          inputDescriptor.rawChannels = inputOptions.raw.channels;
          switch (input.constructor) {
            case Uint8Array:
            case Uint8ClampedArray:
              inputDescriptor.rawDepth = "uchar";
              break;
            case Int8Array:
              inputDescriptor.rawDepth = "char";
              break;
            case Uint16Array:
              inputDescriptor.rawDepth = "ushort";
              break;
            case Int16Array:
              inputDescriptor.rawDepth = "short";
              break;
            case Uint32Array:
              inputDescriptor.rawDepth = "uint";
              break;
            case Int32Array:
              inputDescriptor.rawDepth = "int";
              break;
            case Float32Array:
              inputDescriptor.rawDepth = "float";
              break;
            case Float64Array:
              inputDescriptor.rawDepth = "double";
              break;
            default:
              inputDescriptor.rawDepth = "uchar";
              break;
          }
        } else {
          throw new Error("Expected width, height and channels for raw pixel input");
        }
        inputDescriptor.rawPremultiplied = false;
        if (is.defined(inputOptions.raw.premultiplied)) {
          if (is.bool(inputOptions.raw.premultiplied)) {
            inputDescriptor.rawPremultiplied = inputOptions.raw.premultiplied;
          } else {
            throw is.invalidParameterError("raw.premultiplied", "boolean", inputOptions.raw.premultiplied);
          }
        }
        inputDescriptor.rawPageHeight = 0;
        if (is.defined(inputOptions.raw.pageHeight)) {
          if (is.integer(inputOptions.raw.pageHeight) && inputOptions.raw.pageHeight > 0 && inputOptions.raw.pageHeight <= inputOptions.raw.height) {
            if (inputOptions.raw.height % inputOptions.raw.pageHeight !== 0) {
              throw new Error(`Expected raw.height ${inputOptions.raw.height} to be a multiple of raw.pageHeight ${inputOptions.raw.pageHeight}`);
            }
            inputDescriptor.rawPageHeight = inputOptions.raw.pageHeight;
          } else {
            throw is.invalidParameterError("raw.pageHeight", "positive integer", inputOptions.raw.pageHeight);
          }
        }
      }
      if (is.defined(inputOptions.animated)) {
        if (is.bool(inputOptions.animated)) {
          inputDescriptor.pages = inputOptions.animated ? -1 : 1;
        } else {
          throw is.invalidParameterError("animated", "boolean", inputOptions.animated);
        }
      }
      if (is.defined(inputOptions.pages)) {
        if (is.integer(inputOptions.pages) && is.inRange(inputOptions.pages, -1, 1e5)) {
          inputDescriptor.pages = inputOptions.pages;
        } else {
          throw is.invalidParameterError("pages", "integer between -1 and 100000", inputOptions.pages);
        }
      }
      if (is.defined(inputOptions.page)) {
        if (is.integer(inputOptions.page) && is.inRange(inputOptions.page, 0, 1e5)) {
          inputDescriptor.page = inputOptions.page;
        } else {
          throw is.invalidParameterError("page", "integer between 0 and 100000", inputOptions.page);
        }
      }
      if (is.object(inputOptions.openSlide) && is.defined(inputOptions.openSlide.level)) {
        if (is.integer(inputOptions.openSlide.level) && is.inRange(inputOptions.openSlide.level, 0, 256)) {
          inputDescriptor.openSlideLevel = inputOptions.openSlide.level;
        } else {
          throw is.invalidParameterError("openSlide.level", "integer between 0 and 256", inputOptions.openSlide.level);
        }
      } else if (is.defined(inputOptions.level)) {
        if (is.integer(inputOptions.level) && is.inRange(inputOptions.level, 0, 256)) {
          inputDescriptor.openSlideLevel = inputOptions.level;
        } else {
          throw is.invalidParameterError("level", "integer between 0 and 256", inputOptions.level);
        }
      }
      if (is.object(inputOptions.tiff) && is.defined(inputOptions.tiff.subifd)) {
        if (is.integer(inputOptions.tiff.subifd) && is.inRange(inputOptions.tiff.subifd, -1, 1e5)) {
          inputDescriptor.tiffSubifd = inputOptions.tiff.subifd;
        } else {
          throw is.invalidParameterError("tiff.subifd", "integer between -1 and 100000", inputOptions.tiff.subifd);
        }
      } else if (is.defined(inputOptions.subifd)) {
        if (is.integer(inputOptions.subifd) && is.inRange(inputOptions.subifd, -1, 1e5)) {
          inputDescriptor.tiffSubifd = inputOptions.subifd;
        } else {
          throw is.invalidParameterError("subifd", "integer between -1 and 100000", inputOptions.subifd);
        }
      }
      if (is.object(inputOptions.svg)) {
        if (is.defined(inputOptions.svg.stylesheet)) {
          if (is.string(inputOptions.svg.stylesheet)) {
            inputDescriptor.svgStylesheet = inputOptions.svg.stylesheet;
          } else {
            throw is.invalidParameterError("svg.stylesheet", "string", inputOptions.svg.stylesheet);
          }
        }
        if (is.defined(inputOptions.svg.highBitdepth)) {
          if (is.bool(inputOptions.svg.highBitdepth)) {
            inputDescriptor.svgHighBitdepth = inputOptions.svg.highBitdepth;
          } else {
            throw is.invalidParameterError("svg.highBitdepth", "boolean", inputOptions.svg.highBitdepth);
          }
        }
      }
      if (is.object(inputOptions.pdf) && is.defined(inputOptions.pdf.background)) {
        inputDescriptor.pdfBackground = this._getBackgroundColourOption(inputOptions.pdf.background);
      } else if (is.defined(inputOptions.pdfBackground)) {
        inputDescriptor.pdfBackground = this._getBackgroundColourOption(inputOptions.pdfBackground);
      }
      if (is.object(inputOptions.jp2) && is.defined(inputOptions.jp2.oneshot)) {
        if (is.bool(inputOptions.jp2.oneshot)) {
          inputDescriptor.jp2Oneshot = inputOptions.jp2.oneshot;
        } else {
          throw is.invalidParameterError("jp2.oneshot", "boolean", inputOptions.jp2.oneshot);
        }
      }
      if (is.defined(inputOptions.create)) {
        if (is.object(inputOptions.create) && is.integer(inputOptions.create.width) && inputOptions.create.width > 0 && is.integer(inputOptions.create.height) && inputOptions.create.height > 0 && is.integer(inputOptions.create.channels)) {
          inputDescriptor.createWidth = inputOptions.create.width;
          inputDescriptor.createHeight = inputOptions.create.height;
          inputDescriptor.createChannels = inputOptions.create.channels;
          inputDescriptor.createPageHeight = 0;
          if (is.defined(inputOptions.create.pageHeight)) {
            if (is.integer(inputOptions.create.pageHeight) && inputOptions.create.pageHeight > 0 && inputOptions.create.pageHeight <= inputOptions.create.height) {
              if (inputOptions.create.height % inputOptions.create.pageHeight !== 0) {
                throw new Error(`Expected create.height ${inputOptions.create.height} to be a multiple of create.pageHeight ${inputOptions.create.pageHeight}`);
              }
              inputDescriptor.createPageHeight = inputOptions.create.pageHeight;
            } else {
              throw is.invalidParameterError("create.pageHeight", "positive integer", inputOptions.create.pageHeight);
            }
          }
          if (is.defined(inputOptions.create.noise)) {
            if (!is.object(inputOptions.create.noise)) {
              throw new Error("Expected noise to be an object");
            }
            if (inputOptions.create.noise.type !== "gaussian") {
              throw new Error("Only gaussian noise is supported at the moment");
            }
            inputDescriptor.createNoiseType = inputOptions.create.noise.type;
            if (!is.inRange(inputOptions.create.channels, 1, 4)) {
              throw is.invalidParameterError("create.channels", "number between 1 and 4", inputOptions.create.channels);
            }
            inputDescriptor.createNoiseMean = 128;
            if (is.defined(inputOptions.create.noise.mean)) {
              if (is.number(inputOptions.create.noise.mean) && is.inRange(inputOptions.create.noise.mean, 0, 1e4)) {
                inputDescriptor.createNoiseMean = inputOptions.create.noise.mean;
              } else {
                throw is.invalidParameterError("create.noise.mean", "number between 0 and 10000", inputOptions.create.noise.mean);
              }
            }
            inputDescriptor.createNoiseSigma = 30;
            if (is.defined(inputOptions.create.noise.sigma)) {
              if (is.number(inputOptions.create.noise.sigma) && is.inRange(inputOptions.create.noise.sigma, 0, 1e4)) {
                inputDescriptor.createNoiseSigma = inputOptions.create.noise.sigma;
              } else {
                throw is.invalidParameterError("create.noise.sigma", "number between 0 and 10000", inputOptions.create.noise.sigma);
              }
            }
          } else if (is.defined(inputOptions.create.background)) {
            if (!is.inRange(inputOptions.create.channels, 3, 4)) {
              throw is.invalidParameterError("create.channels", "number between 3 and 4", inputOptions.create.channels);
            }
            inputDescriptor.createBackground = this._getBackgroundColourOption(inputOptions.create.background);
          } else {
            throw new Error("Expected valid noise or background to create a new input image");
          }
          delete inputDescriptor.buffer;
        } else {
          throw new Error("Expected valid width, height and channels to create a new input image");
        }
      }
      if (is.defined(inputOptions.text)) {
        if (is.object(inputOptions.text) && is.string(inputOptions.text.text)) {
          inputDescriptor.textValue = inputOptions.text.text;
          if (is.defined(inputOptions.text.height) && is.defined(inputOptions.text.dpi)) {
            throw new Error("Expected only one of dpi or height");
          }
          if (is.defined(inputOptions.text.font)) {
            if (is.string(inputOptions.text.font)) {
              inputDescriptor.textFont = inputOptions.text.font;
            } else {
              throw is.invalidParameterError("text.font", "string", inputOptions.text.font);
            }
          }
          if (is.defined(inputOptions.text.fontfile)) {
            if (is.string(inputOptions.text.fontfile)) {
              inputDescriptor.textFontfile = inputOptions.text.fontfile;
            } else {
              throw is.invalidParameterError("text.fontfile", "string", inputOptions.text.fontfile);
            }
          }
          if (is.defined(inputOptions.text.width)) {
            if (is.integer(inputOptions.text.width) && inputOptions.text.width > 0) {
              inputDescriptor.textWidth = inputOptions.text.width;
            } else {
              throw is.invalidParameterError("text.width", "positive integer", inputOptions.text.width);
            }
          }
          if (is.defined(inputOptions.text.height)) {
            if (is.integer(inputOptions.text.height) && inputOptions.text.height > 0) {
              inputDescriptor.textHeight = inputOptions.text.height;
            } else {
              throw is.invalidParameterError("text.height", "positive integer", inputOptions.text.height);
            }
          }
          if (is.defined(inputOptions.text.align)) {
            if (is.string(inputOptions.text.align) && is.string(this.constructor.align[inputOptions.text.align])) {
              inputDescriptor.textAlign = this.constructor.align[inputOptions.text.align];
            } else {
              throw is.invalidParameterError("text.align", "valid alignment", inputOptions.text.align);
            }
          }
          if (is.defined(inputOptions.text.justify)) {
            if (is.bool(inputOptions.text.justify)) {
              inputDescriptor.textJustify = inputOptions.text.justify;
            } else {
              throw is.invalidParameterError("text.justify", "boolean", inputOptions.text.justify);
            }
          }
          if (is.defined(inputOptions.text.dpi)) {
            if (is.integer(inputOptions.text.dpi) && is.inRange(inputOptions.text.dpi, 1, 1e6)) {
              inputDescriptor.textDpi = inputOptions.text.dpi;
            } else {
              throw is.invalidParameterError("text.dpi", "integer between 1 and 1000000", inputOptions.text.dpi);
            }
          }
          if (is.defined(inputOptions.text.rgba)) {
            if (is.bool(inputOptions.text.rgba)) {
              inputDescriptor.textRgba = inputOptions.text.rgba;
            } else {
              throw is.invalidParameterError("text.rgba", "bool", inputOptions.text.rgba);
            }
          }
          if (is.defined(inputOptions.text.spacing)) {
            if (is.integer(inputOptions.text.spacing) && is.inRange(inputOptions.text.spacing, -1e6, 1e6)) {
              inputDescriptor.textSpacing = inputOptions.text.spacing;
            } else {
              throw is.invalidParameterError("text.spacing", "integer between -1000000 and 1000000", inputOptions.text.spacing);
            }
          }
          if (is.defined(inputOptions.text.wrap)) {
            if (is.string(inputOptions.text.wrap) && is.inArray(inputOptions.text.wrap, ["word", "char", "word-char", "none"])) {
              inputDescriptor.textWrap = inputOptions.text.wrap;
            } else {
              throw is.invalidParameterError("text.wrap", "one of: word, char, word-char, none", inputOptions.text.wrap);
            }
          }
          delete inputDescriptor.buffer;
        } else {
          throw new Error("Expected a valid string to create an image with text.");
        }
      }
      if (is.defined(inputOptions.join)) {
        if (is.defined(this.options.join)) {
          if (is.defined(inputOptions.join.animated)) {
            if (is.bool(inputOptions.join.animated)) {
              inputDescriptor.joinAnimated = inputOptions.join.animated;
            } else {
              throw is.invalidParameterError("join.animated", "boolean", inputOptions.join.animated);
            }
          }
          if (is.defined(inputOptions.join.across)) {
            if (is.integer(inputOptions.join.across) && is.inRange(inputOptions.join.across, 1, 1e6)) {
              inputDescriptor.joinAcross = inputOptions.join.across;
            } else {
              throw is.invalidParameterError("join.across", "integer between 1 and 100000", inputOptions.join.across);
            }
          }
          if (is.defined(inputOptions.join.shim)) {
            if (is.integer(inputOptions.join.shim) && is.inRange(inputOptions.join.shim, 0, 1e6)) {
              inputDescriptor.joinShim = inputOptions.join.shim;
            } else {
              throw is.invalidParameterError("join.shim", "integer between 0 and 100000", inputOptions.join.shim);
            }
          }
          if (is.defined(inputOptions.join.background)) {
            inputDescriptor.joinBackground = this._getBackgroundColourOption(inputOptions.join.background);
          }
          if (is.defined(inputOptions.join.halign)) {
            if (is.string(inputOptions.join.halign) && is.string(this.constructor.align[inputOptions.join.halign])) {
              inputDescriptor.joinHalign = this.constructor.align[inputOptions.join.halign];
            } else {
              throw is.invalidParameterError("join.halign", "valid alignment", inputOptions.join.halign);
            }
          }
          if (is.defined(inputOptions.join.valign)) {
            if (is.string(inputOptions.join.valign) && is.string(this.constructor.align[inputOptions.join.valign])) {
              inputDescriptor.joinValign = this.constructor.align[inputOptions.join.valign];
            } else {
              throw is.invalidParameterError("join.valign", "valid alignment", inputOptions.join.valign);
            }
          }
        } else {
          throw new Error("Expected input to be an array of images to join");
        }
      }
    } else if (is.defined(inputOptions)) {
      throw new Error(`Invalid input options ${inputOptions}`);
    }
    return inputDescriptor;
  }
  function _write(chunk, _encoding, callback) {
    if (Array.isArray(this.options.input.buffer)) {
      if (is.buffer(chunk)) {
        if (this.options.input.buffer.length === 0) {
          this.on("finish", () => {
            this.streamInFinished = true;
          });
        }
        this.options.input.buffer.push(chunk);
        callback();
      } else {
        callback(new Error("Non-Buffer data on Writable Stream"));
      }
    } else {
      callback(new Error("Unexpected data on Writable Stream"));
    }
  }
  function _flattenBufferIn() {
    if (this._isStreamInput()) {
      this.options.input.buffer = Buffer.concat(this.options.input.buffer);
    }
  }
  function _isStreamInput() {
    return Array.isArray(this.options.input.buffer);
  }
  function metadata(callback) {
    const stack = Error();
    if (is.fn(callback)) {
      if (this._isStreamInput()) {
        this.on("finish", () => {
          this._flattenBufferIn();
          sharp.metadata(this.options, (err, metadata2) => {
            if (err) {
              callback(is.nativeError(err, stack));
            } else {
              callback(null, metadata2);
            }
          });
        });
      } else {
        sharp.metadata(this.options, (err, metadata2) => {
          if (err) {
            callback(is.nativeError(err, stack));
          } else {
            callback(null, metadata2);
          }
        });
      }
      return this;
    } else {
      if (this._isStreamInput()) {
        return new Promise((resolve, reject) => {
          const finished = () => {
            this._flattenBufferIn();
            sharp.metadata(this.options, (err, metadata2) => {
              if (err) {
                reject(is.nativeError(err, stack));
              } else {
                resolve(metadata2);
              }
            });
          };
          if (this.writableFinished) {
            finished();
          } else {
            this.once("finish", finished);
          }
        });
      } else {
        return new Promise((resolve, reject) => {
          sharp.metadata(this.options, (err, metadata2) => {
            if (err) {
              reject(is.nativeError(err, stack));
            } else {
              resolve(metadata2);
            }
          });
        });
      }
    }
  }
  function stats(callback) {
    const stack = Error();
    if (is.fn(callback)) {
      if (this._isStreamInput()) {
        this.on("finish", () => {
          this._flattenBufferIn();
          sharp.stats(this.options, (err, stats2) => {
            if (err) {
              callback(is.nativeError(err, stack));
            } else {
              callback(null, stats2);
            }
          });
        });
      } else {
        sharp.stats(this.options, (err, stats2) => {
          if (err) {
            callback(is.nativeError(err, stack));
          } else {
            callback(null, stats2);
          }
        });
      }
      return this;
    } else {
      if (this._isStreamInput()) {
        return new Promise((resolve, reject) => {
          this.on("finish", function() {
            this._flattenBufferIn();
            sharp.stats(this.options, (err, stats2) => {
              if (err) {
                reject(is.nativeError(err, stack));
              } else {
                resolve(stats2);
              }
            });
          });
        });
      } else {
        return new Promise((resolve, reject) => {
          sharp.stats(this.options, (err, stats2) => {
            if (err) {
              reject(is.nativeError(err, stack));
            } else {
              resolve(stats2);
            }
          });
        });
      }
    }
  }
  module2.exports = (Sharp) => {
    Object.assign(Sharp.prototype, {
      _inputOptionsFromObject,
      _createInputDescriptor,
      _write,
      _flattenBufferIn,
      _isStreamInput,
      metadata,
      stats
    });
    Sharp.align = align;
  };
});

// backend/node_modules/sharp/lib/resize.js
var require_resize = __commonJS((exports2, module2) => {
  /*!
    Copyright 2013 Lovell Fuller and others.
    SPDX-License-Identifier: Apache-2.0
  */
  var is = require_is();
  var gravity = {
    center: 0,
    centre: 0,
    north: 1,
    east: 2,
    south: 3,
    west: 4,
    northeast: 5,
    southeast: 6,
    southwest: 7,
    northwest: 8
  };
  var position = {
    top: 1,
    right: 2,
    bottom: 3,
    left: 4,
    "right top": 5,
    "right bottom": 6,
    "left bottom": 7,
    "left top": 8
  };
  var extendWith = {
    background: "background",
    copy: "copy",
    repeat: "repeat",
    mirror: "mirror"
  };
  var strategy = {
    entropy: 16,
    attention: 17
  };
  var kernel = {
    nearest: "nearest",
    linear: "linear",
    cubic: "cubic",
    mitchell: "mitchell",
    lanczos2: "lanczos2",
    lanczos3: "lanczos3",
    mks2013: "mks2013",
    mks2021: "mks2021"
  };
  var fit = {
    contain: "contain",
    cover: "cover",
    fill: "fill",
    inside: "inside",
    outside: "outside"
  };
  var mapFitToCanvas = {
    contain: "embed",
    cover: "crop",
    fill: "ignore_aspect",
    inside: "max",
    outside: "min"
  };
  function isRotationExpected(options) {
    return options.angle % 360 !== 0 || options.rotationAngle !== 0;
  }
  function isResizeExpected(options) {
    return options.width !== -1 || options.height !== -1;
  }
  function resize(widthOrOptions, height, options) {
    if (isResizeExpected(this.options)) {
      this.options.debuglog("ignoring previous resize options");
    }
    if (this.options.widthPost !== -1) {
      this.options.debuglog("operation order will be: extract, resize, extract");
    }
    if (is.defined(widthOrOptions)) {
      if (is.object(widthOrOptions) && !is.defined(options)) {
        options = widthOrOptions;
      } else if (is.integer(widthOrOptions) && widthOrOptions > 0) {
        this.options.width = widthOrOptions;
      } else {
        throw is.invalidParameterError("width", "positive integer", widthOrOptions);
      }
    } else {
      this.options.width = -1;
    }
    if (is.defined(height)) {
      if (is.integer(height) && height > 0) {
        this.options.height = height;
      } else {
        throw is.invalidParameterError("height", "positive integer", height);
      }
    } else {
      this.options.height = -1;
    }
    if (is.object(options)) {
      if (is.defined(options.width)) {
        if (is.integer(options.width) && options.width > 0) {
          this.options.width = options.width;
        } else {
          throw is.invalidParameterError("width", "positive integer", options.width);
        }
      }
      if (is.defined(options.height)) {
        if (is.integer(options.height) && options.height > 0) {
          this.options.height = options.height;
        } else {
          throw is.invalidParameterError("height", "positive integer", options.height);
        }
      }
      if (is.defined(options.fit)) {
        const canvas = mapFitToCanvas[options.fit];
        if (is.string(canvas)) {
          this.options.canvas = canvas;
        } else {
          throw is.invalidParameterError("fit", "valid fit", options.fit);
        }
      }
      if (is.defined(options.position)) {
        const pos = is.integer(options.position) ? options.position : strategy[options.position] || position[options.position] || gravity[options.position];
        if (is.integer(pos) && (is.inRange(pos, 0, 8) || is.inRange(pos, 16, 17))) {
          this.options.position = pos;
        } else {
          throw is.invalidParameterError("position", "valid position/gravity/strategy", options.position);
        }
      }
      this._setBackgroundColourOption("resizeBackground", options.background);
      if (is.defined(options.kernel)) {
        if (is.string(kernel[options.kernel])) {
          this.options.kernel = kernel[options.kernel];
        } else {
          throw is.invalidParameterError("kernel", "valid kernel name", options.kernel);
        }
      }
      if (is.defined(options.withoutEnlargement)) {
        this._setBooleanOption("withoutEnlargement", options.withoutEnlargement);
      }
      if (is.defined(options.withoutReduction)) {
        this._setBooleanOption("withoutReduction", options.withoutReduction);
      }
      if (is.defined(options.fastShrinkOnLoad)) {
        this._setBooleanOption("fastShrinkOnLoad", options.fastShrinkOnLoad);
      }
    }
    if (isRotationExpected(this.options) && isResizeExpected(this.options)) {
      this.options.rotateBefore = true;
    }
    return this;
  }
  function extend(extend2) {
    if (is.integer(extend2) && extend2 > 0) {
      this.options.extendTop = extend2;
      this.options.extendBottom = extend2;
      this.options.extendLeft = extend2;
      this.options.extendRight = extend2;
    } else if (is.object(extend2)) {
      if (is.defined(extend2.top)) {
        if (is.integer(extend2.top) && extend2.top >= 0) {
          this.options.extendTop = extend2.top;
        } else {
          throw is.invalidParameterError("top", "positive integer", extend2.top);
        }
      }
      if (is.defined(extend2.bottom)) {
        if (is.integer(extend2.bottom) && extend2.bottom >= 0) {
          this.options.extendBottom = extend2.bottom;
        } else {
          throw is.invalidParameterError("bottom", "positive integer", extend2.bottom);
        }
      }
      if (is.defined(extend2.left)) {
        if (is.integer(extend2.left) && extend2.left >= 0) {
          this.options.extendLeft = extend2.left;
        } else {
          throw is.invalidParameterError("left", "positive integer", extend2.left);
        }
      }
      if (is.defined(extend2.right)) {
        if (is.integer(extend2.right) && extend2.right >= 0) {
          this.options.extendRight = extend2.right;
        } else {
          throw is.invalidParameterError("right", "positive integer", extend2.right);
        }
      }
      this._setBackgroundColourOption("extendBackground", extend2.background);
      if (is.defined(extend2.extendWith)) {
        if (is.string(extendWith[extend2.extendWith])) {
          this.options.extendWith = extendWith[extend2.extendWith];
        } else {
          throw is.invalidParameterError("extendWith", "one of: background, copy, repeat, mirror", extend2.extendWith);
        }
      }
    } else {
      throw is.invalidParameterError("extend", "integer or object", extend2);
    }
    return this;
  }
  function extract(options) {
    const suffix = isResizeExpected(this.options) || this.options.widthPre !== -1 ? "Post" : "Pre";
    if (this.options[`width${suffix}`] !== -1) {
      this.options.debuglog("ignoring previous extract options");
    }
    ["left", "top", "width", "height"].forEach(function(name) {
      const value = options[name];
      if (is.integer(value) && value >= 0) {
        this.options[name + (name === "left" || name === "top" ? "Offset" : "") + suffix] = value;
      } else {
        throw is.invalidParameterError(name, "integer", value);
      }
    }, this);
    if (isRotationExpected(this.options) && !isResizeExpected(this.options)) {
      if (this.options.widthPre === -1 || this.options.widthPost === -1) {
        this.options.rotateBefore = true;
      }
    }
    if (this.options.input.autoOrient) {
      this.options.orientBefore = true;
    }
    return this;
  }
  function trim(options) {
    this.options.trimThreshold = 10;
    if (is.defined(options)) {
      if (is.object(options)) {
        if (is.defined(options.background)) {
          this._setBackgroundColourOption("trimBackground", options.background);
        }
        if (is.defined(options.threshold)) {
          if (is.number(options.threshold) && options.threshold >= 0) {
            this.options.trimThreshold = options.threshold;
          } else {
            throw is.invalidParameterError("threshold", "positive number", options.threshold);
          }
        }
        if (is.defined(options.lineArt)) {
          this._setBooleanOption("trimLineArt", options.lineArt);
        }
      } else {
        throw is.invalidParameterError("trim", "object", options);
      }
    }
    if (isRotationExpected(this.options)) {
      this.options.rotateBefore = true;
    }
    return this;
  }
  module2.exports = (Sharp) => {
    Object.assign(Sharp.prototype, {
      resize,
      extend,
      extract,
      trim
    });
    Sharp.gravity = gravity;
    Sharp.strategy = strategy;
    Sharp.kernel = kernel;
    Sharp.fit = fit;
    Sharp.position = position;
  };
});

// backend/node_modules/sharp/lib/composite.js
var require_composite = __commonJS((exports2, module2) => {
  /*!
    Copyright 2013 Lovell Fuller and others.
    SPDX-License-Identifier: Apache-2.0
  */
  var is = require_is();
  var blend = {
    clear: "clear",
    source: "source",
    over: "over",
    in: "in",
    out: "out",
    atop: "atop",
    dest: "dest",
    "dest-over": "dest-over",
    "dest-in": "dest-in",
    "dest-out": "dest-out",
    "dest-atop": "dest-atop",
    xor: "xor",
    add: "add",
    saturate: "saturate",
    multiply: "multiply",
    screen: "screen",
    overlay: "overlay",
    darken: "darken",
    lighten: "lighten",
    "colour-dodge": "colour-dodge",
    "color-dodge": "colour-dodge",
    "colour-burn": "colour-burn",
    "color-burn": "colour-burn",
    "hard-light": "hard-light",
    "soft-light": "soft-light",
    difference: "difference",
    exclusion: "exclusion"
  };
  function composite(images) {
    if (!Array.isArray(images)) {
      throw is.invalidParameterError("images to composite", "array", images);
    }
    this.options.composite = images.map((image) => {
      if (!is.object(image)) {
        throw is.invalidParameterError("image to composite", "object", image);
      }
      const inputOptions = this._inputOptionsFromObject(image);
      const composite2 = {
        input: this._createInputDescriptor(image.input, inputOptions, { allowStream: false }),
        blend: "over",
        tile: false,
        left: 0,
        top: 0,
        hasOffset: false,
        gravity: 0,
        premultiplied: false
      };
      if (is.defined(image.blend)) {
        if (is.string(blend[image.blend])) {
          composite2.blend = blend[image.blend];
        } else {
          throw is.invalidParameterError("blend", "valid blend name", image.blend);
        }
      }
      if (is.defined(image.tile)) {
        if (is.bool(image.tile)) {
          composite2.tile = image.tile;
        } else {
          throw is.invalidParameterError("tile", "boolean", image.tile);
        }
      }
      if (is.defined(image.left)) {
        if (is.integer(image.left)) {
          composite2.left = image.left;
        } else {
          throw is.invalidParameterError("left", "integer", image.left);
        }
      }
      if (is.defined(image.top)) {
        if (is.integer(image.top)) {
          composite2.top = image.top;
        } else {
          throw is.invalidParameterError("top", "integer", image.top);
        }
      }
      if (is.defined(image.top) !== is.defined(image.left)) {
        throw new Error("Expected both left and top to be set");
      } else {
        composite2.hasOffset = is.integer(image.top) && is.integer(image.left);
      }
      if (is.defined(image.gravity)) {
        if (is.integer(image.gravity) && is.inRange(image.gravity, 0, 8)) {
          composite2.gravity = image.gravity;
        } else if (is.string(image.gravity) && is.integer(this.constructor.gravity[image.gravity])) {
          composite2.gravity = this.constructor.gravity[image.gravity];
        } else {
          throw is.invalidParameterError("gravity", "valid gravity", image.gravity);
        }
      }
      if (is.defined(image.premultiplied)) {
        if (is.bool(image.premultiplied)) {
          composite2.premultiplied = image.premultiplied;
        } else {
          throw is.invalidParameterError("premultiplied", "boolean", image.premultiplied);
        }
      }
      return composite2;
    });
    return this;
  }
  module2.exports = (Sharp) => {
    Sharp.prototype.composite = composite;
    Sharp.blend = blend;
  };
});

// backend/node_modules/sharp/lib/operation.js
var require_operation = __commonJS((exports2, module2) => {
  /*!
    Copyright 2013 Lovell Fuller and others.
    SPDX-License-Identifier: Apache-2.0
  */
  var is = require_is();
  var vipsPrecision = {
    integer: "integer",
    float: "float",
    approximate: "approximate"
  };
  function rotate(angle, options) {
    if (!is.defined(angle)) {
      return this.autoOrient();
    }
    if (this.options.angle || this.options.rotationAngle) {
      this.options.debuglog("ignoring previous rotate options");
      this.options.angle = 0;
      this.options.rotationAngle = 0;
    }
    if (is.integer(angle) && !(angle % 90)) {
      this.options.angle = angle;
    } else if (is.number(angle)) {
      this.options.rotationAngle = angle;
      if (is.object(options) && options.background) {
        this._setBackgroundColourOption("rotationBackground", options.background);
      }
    } else {
      throw is.invalidParameterError("angle", "numeric", angle);
    }
    return this;
  }
  function autoOrient() {
    this.options.input.autoOrient = true;
    return this;
  }
  function flip(flip2) {
    this.options.flip = is.bool(flip2) ? flip2 : true;
    return this;
  }
  function flop(flop2) {
    this.options.flop = is.bool(flop2) ? flop2 : true;
    return this;
  }
  function affine(matrix, options) {
    const flatMatrix = [].concat(...matrix);
    if (flatMatrix.length === 4 && flatMatrix.every(is.number)) {
      this.options.affineMatrix = flatMatrix;
    } else {
      throw is.invalidParameterError("matrix", "1x4 or 2x2 array", matrix);
    }
    if (is.defined(options)) {
      if (is.object(options)) {
        this._setBackgroundColourOption("affineBackground", options.background);
        if (is.defined(options.idx)) {
          if (is.number(options.idx)) {
            this.options.affineIdx = options.idx;
          } else {
            throw is.invalidParameterError("options.idx", "number", options.idx);
          }
        }
        if (is.defined(options.idy)) {
          if (is.number(options.idy)) {
            this.options.affineIdy = options.idy;
          } else {
            throw is.invalidParameterError("options.idy", "number", options.idy);
          }
        }
        if (is.defined(options.odx)) {
          if (is.number(options.odx)) {
            this.options.affineOdx = options.odx;
          } else {
            throw is.invalidParameterError("options.odx", "number", options.odx);
          }
        }
        if (is.defined(options.ody)) {
          if (is.number(options.ody)) {
            this.options.affineOdy = options.ody;
          } else {
            throw is.invalidParameterError("options.ody", "number", options.ody);
          }
        }
        if (is.defined(options.interpolator)) {
          if (is.inArray(options.interpolator, Object.values(this.constructor.interpolators))) {
            this.options.affineInterpolator = options.interpolator;
          } else {
            throw is.invalidParameterError("options.interpolator", "valid interpolator name", options.interpolator);
          }
        }
      } else {
        throw is.invalidParameterError("options", "object", options);
      }
    }
    return this;
  }
  function sharpen(options, flat, jagged) {
    if (!is.defined(options)) {
      this.options.sharpenSigma = -1;
    } else if (is.bool(options)) {
      this.options.sharpenSigma = options ? -1 : 0;
    } else if (is.number(options) && is.inRange(options, 0.01, 1e4)) {
      this.options.sharpenSigma = options;
      if (is.defined(flat)) {
        if (is.number(flat) && is.inRange(flat, 0, 1e4)) {
          this.options.sharpenM1 = flat;
        } else {
          throw is.invalidParameterError("flat", "number between 0 and 10000", flat);
        }
      }
      if (is.defined(jagged)) {
        if (is.number(jagged) && is.inRange(jagged, 0, 1e4)) {
          this.options.sharpenM2 = jagged;
        } else {
          throw is.invalidParameterError("jagged", "number between 0 and 10000", jagged);
        }
      }
    } else if (is.plainObject(options)) {
      if (is.number(options.sigma) && is.inRange(options.sigma, 0.000001, 10)) {
        this.options.sharpenSigma = options.sigma;
      } else {
        throw is.invalidParameterError("options.sigma", "number between 0.000001 and 10", options.sigma);
      }
      if (is.defined(options.m1)) {
        if (is.number(options.m1) && is.inRange(options.m1, 0, 1e6)) {
          this.options.sharpenM1 = options.m1;
        } else {
          throw is.invalidParameterError("options.m1", "number between 0 and 1000000", options.m1);
        }
      }
      if (is.defined(options.m2)) {
        if (is.number(options.m2) && is.inRange(options.m2, 0, 1e6)) {
          this.options.sharpenM2 = options.m2;
        } else {
          throw is.invalidParameterError("options.m2", "number between 0 and 1000000", options.m2);
        }
      }
      if (is.defined(options.x1)) {
        if (is.number(options.x1) && is.inRange(options.x1, 0, 1e6)) {
          this.options.sharpenX1 = options.x1;
        } else {
          throw is.invalidParameterError("options.x1", "number between 0 and 1000000", options.x1);
        }
      }
      if (is.defined(options.y2)) {
        if (is.number(options.y2) && is.inRange(options.y2, 0, 1e6)) {
          this.options.sharpenY2 = options.y2;
        } else {
          throw is.invalidParameterError("options.y2", "number between 0 and 1000000", options.y2);
        }
      }
      if (is.defined(options.y3)) {
        if (is.number(options.y3) && is.inRange(options.y3, 0, 1e6)) {
          this.options.sharpenY3 = options.y3;
        } else {
          throw is.invalidParameterError("options.y3", "number between 0 and 1000000", options.y3);
        }
      }
    } else {
      throw is.invalidParameterError("sigma", "number between 0.01 and 10000", options);
    }
    return this;
  }
  function median(size) {
    if (!is.defined(size)) {
      this.options.medianSize = 3;
    } else if (is.integer(size) && is.inRange(size, 1, 1000)) {
      this.options.medianSize = size;
    } else {
      throw is.invalidParameterError("size", "integer between 1 and 1000", size);
    }
    return this;
  }
  function blur(options) {
    let sigma;
    if (is.number(options)) {
      sigma = options;
    } else if (is.plainObject(options)) {
      if (!is.number(options.sigma)) {
        throw is.invalidParameterError("options.sigma", "number between 0.3 and 1000", sigma);
      }
      sigma = options.sigma;
      if ("precision" in options) {
        if (is.string(vipsPrecision[options.precision])) {
          this.options.precision = vipsPrecision[options.precision];
        } else {
          throw is.invalidParameterError("precision", "one of: integer, float, approximate", options.precision);
        }
      }
      if ("minAmplitude" in options) {
        if (is.number(options.minAmplitude) && is.inRange(options.minAmplitude, 0.001, 1)) {
          this.options.minAmpl = options.minAmplitude;
        } else {
          throw is.invalidParameterError("minAmplitude", "number between 0.001 and 1", options.minAmplitude);
        }
      }
    }
    if (!is.defined(options)) {
      this.options.blurSigma = -1;
    } else if (is.bool(options)) {
      this.options.blurSigma = options ? -1 : 0;
    } else if (is.number(sigma) && is.inRange(sigma, 0.3, 1000)) {
      this.options.blurSigma = sigma;
    } else {
      throw is.invalidParameterError("sigma", "number between 0.3 and 1000", sigma);
    }
    return this;
  }
  function dilate(width) {
    if (!is.defined(width)) {
      this.options.dilateWidth = 1;
    } else if (is.integer(width) && width > 0) {
      this.options.dilateWidth = width;
    } else {
      throw is.invalidParameterError("dilate", "positive integer", dilate);
    }
    return this;
  }
  function erode(width) {
    if (!is.defined(width)) {
      this.options.erodeWidth = 1;
    } else if (is.integer(width) && width > 0) {
      this.options.erodeWidth = width;
    } else {
      throw is.invalidParameterError("erode", "positive integer", erode);
    }
    return this;
  }
  function flatten(options) {
    this.options.flatten = is.bool(options) ? options : true;
    if (is.object(options)) {
      this._setBackgroundColourOption("flattenBackground", options.background);
    }
    return this;
  }
  function unflatten() {
    this.options.unflatten = true;
    return this;
  }
  function gamma(gamma2, gammaOut) {
    if (!is.defined(gamma2)) {
      this.options.gamma = 2.2;
    } else if (is.number(gamma2) && is.inRange(gamma2, 1, 3)) {
      this.options.gamma = gamma2;
    } else {
      throw is.invalidParameterError("gamma", "number between 1.0 and 3.0", gamma2);
    }
    if (!is.defined(gammaOut)) {
      this.options.gammaOut = this.options.gamma;
    } else if (is.number(gammaOut) && is.inRange(gammaOut, 1, 3)) {
      this.options.gammaOut = gammaOut;
    } else {
      throw is.invalidParameterError("gammaOut", "number between 1.0 and 3.0", gammaOut);
    }
    return this;
  }
  function negate(options) {
    this.options.negate = is.bool(options) ? options : true;
    if (is.plainObject(options) && "alpha" in options) {
      if (!is.bool(options.alpha)) {
        throw is.invalidParameterError("alpha", "should be boolean value", options.alpha);
      } else {
        this.options.negateAlpha = options.alpha;
      }
    }
    return this;
  }
  function normalise(options) {
    if (is.plainObject(options)) {
      if (is.defined(options.lower)) {
        if (is.number(options.lower) && is.inRange(options.lower, 0, 99)) {
          this.options.normaliseLower = options.lower;
        } else {
          throw is.invalidParameterError("lower", "number between 0 and 99", options.lower);
        }
      }
      if (is.defined(options.upper)) {
        if (is.number(options.upper) && is.inRange(options.upper, 1, 100)) {
          this.options.normaliseUpper = options.upper;
        } else {
          throw is.invalidParameterError("upper", "number between 1 and 100", options.upper);
        }
      }
    }
    if (this.options.normaliseLower >= this.options.normaliseUpper) {
      throw is.invalidParameterError("range", "lower to be less than upper", `${this.options.normaliseLower} >= ${this.options.normaliseUpper}`);
    }
    this.options.normalise = true;
    return this;
  }
  function normalize(options) {
    return this.normalise(options);
  }
  function clahe(options) {
    if (is.plainObject(options)) {
      if (is.integer(options.width) && options.width > 0) {
        this.options.claheWidth = options.width;
      } else {
        throw is.invalidParameterError("width", "integer greater than zero", options.width);
      }
      if (is.integer(options.height) && options.height > 0) {
        this.options.claheHeight = options.height;
      } else {
        throw is.invalidParameterError("height", "integer greater than zero", options.height);
      }
      if (is.defined(options.maxSlope)) {
        if (is.integer(options.maxSlope) && is.inRange(options.maxSlope, 0, 100)) {
          this.options.claheMaxSlope = options.maxSlope;
        } else {
          throw is.invalidParameterError("maxSlope", "integer between 0 and 100", options.maxSlope);
        }
      }
    } else {
      throw is.invalidParameterError("options", "plain object", options);
    }
    return this;
  }
  function convolve(kernel) {
    if (!is.object(kernel) || !Array.isArray(kernel.kernel) || !is.integer(kernel.width) || !is.integer(kernel.height) || !is.inRange(kernel.width, 3, 1001) || !is.inRange(kernel.height, 3, 1001) || kernel.height * kernel.width !== kernel.kernel.length) {
      throw new Error("Invalid convolution kernel");
    }
    if (!is.integer(kernel.scale)) {
      kernel.scale = kernel.kernel.reduce((a, b) => a + b, 0);
    }
    if (kernel.scale < 1) {
      kernel.scale = 1;
    }
    if (!is.integer(kernel.offset)) {
      kernel.offset = 0;
    }
    this.options.convKernel = kernel;
    return this;
  }
  function threshold(threshold2, options) {
    if (!is.defined(threshold2)) {
      this.options.threshold = 128;
    } else if (is.bool(threshold2)) {
      this.options.threshold = threshold2 ? 128 : 0;
    } else if (is.integer(threshold2) && is.inRange(threshold2, 0, 255)) {
      this.options.threshold = threshold2;
    } else {
      throw is.invalidParameterError("threshold", "integer between 0 and 255", threshold2);
    }
    if (!is.object(options) || options.greyscale === true || options.grayscale === true) {
      this.options.thresholdGrayscale = true;
    } else {
      this.options.thresholdGrayscale = false;
    }
    return this;
  }
  function boolean(operand, operator, options) {
    this.options.boolean = this._createInputDescriptor(operand, options);
    if (is.string(operator) && is.inArray(operator, ["and", "or", "eor"])) {
      this.options.booleanOp = operator;
    } else {
      throw is.invalidParameterError("operator", "one of: and, or, eor", operator);
    }
    return this;
  }
  function linear(a, b) {
    if (!is.defined(a) && is.number(b)) {
      a = 1;
    } else if (is.number(a) && !is.defined(b)) {
      b = 0;
    }
    if (!is.defined(a)) {
      this.options.linearA = [];
    } else if (is.number(a)) {
      this.options.linearA = [a];
    } else if (Array.isArray(a) && a.length && a.every(is.number)) {
      this.options.linearA = a;
    } else {
      throw is.invalidParameterError("a", "number or array of numbers", a);
    }
    if (!is.defined(b)) {
      this.options.linearB = [];
    } else if (is.number(b)) {
      this.options.linearB = [b];
    } else if (Array.isArray(b) && b.length && b.every(is.number)) {
      this.options.linearB = b;
    } else {
      throw is.invalidParameterError("b", "number or array of numbers", b);
    }
    if (this.options.linearA.length !== this.options.linearB.length) {
      throw new Error("Expected a and b to be arrays of the same length");
    }
    return this;
  }
  function recomb(inputMatrix) {
    if (!Array.isArray(inputMatrix)) {
      throw is.invalidParameterError("inputMatrix", "array", inputMatrix);
    }
    if (inputMatrix.length !== 3 && inputMatrix.length !== 4) {
      throw is.invalidParameterError("inputMatrix", "3x3 or 4x4 array", inputMatrix.length);
    }
    const recombMatrix = inputMatrix.flat().map(Number);
    if (recombMatrix.length !== 9 && recombMatrix.length !== 16) {
      throw is.invalidParameterError("inputMatrix", "cardinality of 9 or 16", recombMatrix.length);
    }
    this.options.recombMatrix = recombMatrix;
    return this;
  }
  function modulate(options) {
    if (!is.plainObject(options)) {
      throw is.invalidParameterError("options", "plain object", options);
    }
    if ("brightness" in options) {
      if (is.number(options.brightness) && options.brightness >= 0) {
        this.options.brightness = options.brightness;
      } else {
        throw is.invalidParameterError("brightness", "number above zero", options.brightness);
      }
    }
    if ("saturation" in options) {
      if (is.number(options.saturation) && options.saturation >= 0) {
        this.options.saturation = options.saturation;
      } else {
        throw is.invalidParameterError("saturation", "number above zero", options.saturation);
      }
    }
    if ("hue" in options) {
      if (is.integer(options.hue)) {
        this.options.hue = options.hue % 360;
      } else {
        throw is.invalidParameterError("hue", "number", options.hue);
      }
    }
    if ("lightness" in options) {
      if (is.number(options.lightness)) {
        this.options.lightness = options.lightness;
      } else {
        throw is.invalidParameterError("lightness", "number", options.lightness);
      }
    }
    return this;
  }
  module2.exports = (Sharp) => {
    Object.assign(Sharp.prototype, {
      autoOrient,
      rotate,
      flip,
      flop,
      affine,
      sharpen,
      erode,
      dilate,
      median,
      blur,
      flatten,
      unflatten,
      gamma,
      negate,
      normalise,
      normalize,
      clahe,
      convolve,
      threshold,
      boolean,
      linear,
      recomb,
      modulate
    });
  };
});

// backend/node_modules/@img/colour/color.cjs
var require_color = __commonJS((exports2, module2) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var index_exports = {};
  __export2(index_exports, {
    default: () => index_default
  });
  module2.exports = __toCommonJS2(index_exports);
  var color_name_default = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
  var reverseNames = /* @__PURE__ */ Object.create(null);
  for (const name in color_name_default) {
    if (Object.hasOwn(color_name_default, name)) {
      reverseNames[color_name_default[name]] = name;
    }
  }
  var cs = {
    to: {},
    get: {}
  };
  cs.get = function(string) {
    const prefix = string.slice(0, 3).toLowerCase();
    let value;
    let model;
    switch (prefix) {
      case "hsl": {
        value = cs.get.hsl(string);
        model = "hsl";
        break;
      }
      case "hwb": {
        value = cs.get.hwb(string);
        model = "hwb";
        break;
      }
      default: {
        value = cs.get.rgb(string);
        model = "rgb";
        break;
      }
    }
    if (!value) {
      return null;
    }
    return { model, value };
  };
  cs.get.rgb = function(string) {
    if (!string) {
      return null;
    }
    const abbr = /^#([a-f\d]{3,4})$/i;
    const hex = /^#([a-f\d]{6})([a-f\d]{2})?$/i;
    const rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[\s,|/]\s*([+-]?[\d.]+)(%?)\s*)?\)$/;
    const per = /^rgba?\(\s*([+-]?[\d.]+)%\s*,?\s*([+-]?[\d.]+)%\s*,?\s*([+-]?[\d.]+)%\s*(?:[\s,|/]\s*([+-]?[\d.]+)(%?)\s*)?\)$/;
    const keyword = /^(\w+)$/;
    let rgb = [0, 0, 0, 1];
    let match2;
    let i;
    let hexAlpha;
    if (match2 = string.match(hex)) {
      hexAlpha = match2[2];
      match2 = match2[1];
      for (i = 0;i < 3; i++) {
        const i2 = i * 2;
        rgb[i] = Number.parseInt(match2.slice(i2, i2 + 2), 16);
      }
      if (hexAlpha) {
        rgb[3] = Number.parseInt(hexAlpha, 16) / 255;
      }
    } else if (match2 = string.match(abbr)) {
      match2 = match2[1];
      hexAlpha = match2[3];
      for (i = 0;i < 3; i++) {
        rgb[i] = Number.parseInt(match2[i] + match2[i], 16);
      }
      if (hexAlpha) {
        rgb[3] = Number.parseInt(hexAlpha + hexAlpha, 16) / 255;
      }
    } else if (match2 = string.match(rgba)) {
      for (i = 0;i < 3; i++) {
        rgb[i] = Number.parseInt(match2[i + 1], 10);
      }
      if (match2[4]) {
        rgb[3] = match2[5] ? Number.parseFloat(match2[4]) * 0.01 : Number.parseFloat(match2[4]);
      }
    } else if (match2 = string.match(per)) {
      for (i = 0;i < 3; i++) {
        rgb[i] = Math.round(Number.parseFloat(match2[i + 1]) * 2.55);
      }
      if (match2[4]) {
        rgb[3] = match2[5] ? Number.parseFloat(match2[4]) * 0.01 : Number.parseFloat(match2[4]);
      }
    } else if (match2 = string.match(keyword)) {
      if (match2[1] === "transparent") {
        return [0, 0, 0, 0];
      }
      if (!Object.hasOwn(color_name_default, match2[1])) {
        return null;
      }
      rgb = color_name_default[match2[1]];
      rgb[3] = 1;
      return rgb;
    } else {
      return null;
    }
    for (i = 0;i < 3; i++) {
      rgb[i] = clamp(rgb[i], 0, 255);
    }
    rgb[3] = clamp(rgb[3], 0, 1);
    return rgb;
  };
  cs.get.hsl = function(string) {
    if (!string) {
      return null;
    }
    const hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d.]+)%\s*,?\s*([+-]?[\d.]+)%\s*(?:[,|/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    const match2 = string.match(hsl);
    if (match2) {
      const alpha = Number.parseFloat(match2[4]);
      const h = (Number.parseFloat(match2[1]) % 360 + 360) % 360;
      const s = clamp(Number.parseFloat(match2[2]), 0, 100);
      const l = clamp(Number.parseFloat(match2[3]), 0, 100);
      const a = clamp(Number.isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, s, l, a];
    }
    return null;
  };
  cs.get.hwb = function(string) {
    if (!string) {
      return null;
    }
    const hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*[\s,]\s*([+-]?[\d.]+)%\s*[\s,]\s*([+-]?[\d.]+)%\s*(?:[\s,]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
    const match2 = string.match(hwb);
    if (match2) {
      const alpha = Number.parseFloat(match2[4]);
      const h = (Number.parseFloat(match2[1]) % 360 + 360) % 360;
      const w = clamp(Number.parseFloat(match2[2]), 0, 100);
      const b = clamp(Number.parseFloat(match2[3]), 0, 100);
      const a = clamp(Number.isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, w, b, a];
    }
    return null;
  };
  cs.to.hex = function(...rgba) {
    return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
  };
  cs.to.rgb = function(...rgba) {
    return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
  };
  cs.to.rgb.percent = function(...rgba) {
    const r = Math.round(rgba[0] / 255 * 100);
    const g = Math.round(rgba[1] / 255 * 100);
    const b = Math.round(rgba[2] / 255 * 100);
    return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
  };
  cs.to.hsl = function(...hsla) {
    return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
  };
  cs.to.hwb = function(...hwba) {
    let a = "";
    if (hwba.length >= 4 && hwba[3] !== 1) {
      a = ", " + hwba[3];
    }
    return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
  };
  cs.to.keyword = function(...rgb) {
    return reverseNames[rgb.slice(0, 3)];
  };
  function clamp(number_, min, max) {
    return Math.min(Math.max(min, number_), max);
  }
  function hexDouble(number_) {
    const string_ = Math.round(number_).toString(16).toUpperCase();
    return string_.length < 2 ? "0" + string_ : string_;
  }
  var color_string_default = cs;
  var reverseKeywords = {};
  for (const key of Object.keys(color_name_default)) {
    reverseKeywords[color_name_default[key]] = key;
  }
  var convert = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    oklab: { channels: 3, labels: ["okl", "oka", "okb"] },
    lch: { channels: 3, labels: "lch" },
    oklch: { channels: 3, labels: ["okl", "okc", "okh"] },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  var conversions_default = convert;
  var LAB_FT = (6 / 29) ** 3;
  function srgbNonlinearTransform(c) {
    const cc = c > 0.0031308 ? 1.055 * c ** (1 / 2.4) - 0.055 : c * 12.92;
    return Math.min(Math.max(0, cc), 1);
  }
  function srgbNonlinearTransformInv(c) {
    return c > 0.04045 ? ((c + 0.055) / 1.055) ** 2.4 : c / 12.92;
  }
  for (const model of Object.keys(convert)) {
    if (!("channels" in convert[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert[model].labels.length !== convert[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    const { channels, labels } = convert[model];
    delete convert[model].channels;
    delete convert[model].labels;
    Object.defineProperty(convert[model], "channels", { value: channels });
    Object.defineProperty(convert[model], "labels", { value: labels });
  }
  convert.rgb.hsl = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    let h;
    let s;
    switch (max) {
      case min: {
        h = 0;
        break;
      }
      case r: {
        h = (g - b) / delta;
        break;
      }
      case g: {
        h = 2 + (b - r) / delta;
        break;
      }
      case b: {
        h = 4 + (r - g) / delta;
        break;
      }
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
      h += 360;
    }
    const l = (min + max) / 2;
    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }
    return [h, s * 100, l * 100];
  };
  convert.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);
    const diffc = function(c) {
      return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h = 0;
      s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      switch (v) {
        case r: {
          h = bdif - gdif;
          break;
        }
        case g: {
          h = 1 / 3 + rdif - bdif;
          break;
        }
        case b: {
          h = 2 / 3 + gdif - rdif;
          break;
        }
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return [
      h * 360,
      s * 100,
      v * 100
    ];
  };
  convert.rgb.hwb = function(rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h = convert.rgb.hsl(rgb)[0];
    const w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };
  convert.rgb.oklab = function(rgb) {
    const r = srgbNonlinearTransformInv(rgb[0] / 255);
    const g = srgbNonlinearTransformInv(rgb[1] / 255);
    const b = srgbNonlinearTransformInv(rgb[2] / 255);
    const lp = Math.cbrt(0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b);
    const mp = Math.cbrt(0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b);
    const sp = Math.cbrt(0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b);
    const l = 0.2104542553 * lp + 0.793617785 * mp - 0.0040720468 * sp;
    const aa = 1.9779984951 * lp - 2.428592205 * mp + 0.4505937099 * sp;
    const bb = 0.0259040371 * lp + 0.7827717662 * mp - 0.808675766 * sp;
    return [l * 100, aa * 100, bb * 100];
  };
  convert.rgb.cmyk = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  function comparativeDistance(x, y) {
    return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
  }
  convert.rgb.keyword = function(rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    let currentClosestDistance = Number.POSITIVE_INFINITY;
    let currentClosestKeyword;
    for (const keyword of Object.keys(color_name_default)) {
      const value = color_name_default[keyword];
      const distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
    return currentClosestKeyword;
  };
  convert.keyword.rgb = function(keyword) {
    return color_name_default[keyword];
  };
  convert.rgb.xyz = function(rgb) {
    const r = srgbNonlinearTransformInv(rgb[0] / 255);
    const g = srgbNonlinearTransformInv(rgb[1] / 255);
    const b = srgbNonlinearTransformInv(rgb[2] / 255);
    const x = r * 0.4124564 + g * 0.3575761 + b * 0.1804375;
    const y = r * 0.2126729 + g * 0.7151522 + b * 0.072175;
    const z = r * 0.0193339 + g * 0.119192 + b * 0.9503041;
    return [x * 100, y * 100, z * 100];
  };
  convert.rgb.lab = function(rgb) {
    const xyz = convert.rgb.xyz(rgb);
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > LAB_FT ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > LAB_FT ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > LAB_FT ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert.hsl.rgb = function(hsl) {
    const h = hsl[0] / 360;
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t3;
    let value;
    if (s === 0) {
      value = l * 255;
      return [value, value, value];
    }
    const t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const t1 = 2 * l - t2;
    const rgb = [0, 0, 0];
    for (let i = 0;i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        value = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        value = t2;
      } else if (3 * t3 < 2) {
        value = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        value = t1;
      }
      rgb[i] = value * 255;
    }
    return rgb;
  };
  convert.hsl.hsv = function(hsl) {
    const h = hsl[0];
    let s = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };
  convert.hsv.rgb = function(hsv) {
    const h = hsv[0] / 60;
    const s = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v * (1 - s);
    const q2 = 255 * v * (1 - s * f);
    const t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch (hi) {
      case 0: {
        return [v, t, p];
      }
      case 1: {
        return [q2, v, p];
      }
      case 2: {
        return [p, v, t];
      }
      case 3: {
        return [p, q2, v];
      }
      case 4: {
        return [t, p, v];
      }
      case 5: {
        return [v, p, q2];
      }
    }
  };
  convert.hsv.hsl = function(hsv) {
    const h = hsv[0];
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s) * v;
    const lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };
  convert.hwb.rgb = function(hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    const i = Math.floor(6 * h);
    const v = 1 - bl;
    f = 6 * h - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    const n = wh + f * (v - wh);
    let r;
    let g;
    let b;
    switch (i) {
      default:
      case 6:
      case 0: {
        r = v;
        g = n;
        b = wh;
        break;
      }
      case 1: {
        r = n;
        g = v;
        b = wh;
        break;
      }
      case 2: {
        r = wh;
        g = v;
        b = n;
        break;
      }
      case 3: {
        r = wh;
        g = n;
        b = v;
        break;
      }
      case 4: {
        r = n;
        g = wh;
        b = v;
        break;
      }
      case 5: {
        r = v;
        g = wh;
        b = n;
        break;
      }
    }
    return [r * 255, g * 255, b * 255];
  };
  convert.cmyk.rgb = function(cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.rgb = function(xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2404542 + y * -1.5371385 + z * -0.4985314;
    g = x * -0.969266 + y * 1.8760108 + z * 0.041556;
    b = x * 0.0556434 + y * -0.2040259 + z * 1.0572252;
    r = srgbNonlinearTransform(r);
    g = srgbNonlinearTransform(g);
    b = srgbNonlinearTransform(b);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.lab = function(xyz) {
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > LAB_FT ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > LAB_FT ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > LAB_FT ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert.xyz.oklab = function(xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    const lp = Math.cbrt(0.8189330101 * x + 0.3618667424 * y - 0.1288597137 * z);
    const mp = Math.cbrt(0.0329845436 * x + 0.9293118715 * y + 0.0361456387 * z);
    const sp = Math.cbrt(0.0482003018 * x + 0.2643662691 * y + 0.633851707 * z);
    const l = 0.2104542553 * lp + 0.793617785 * mp - 0.0040720468 * sp;
    const a = 1.9779984951 * lp - 2.428592205 * mp + 0.4505937099 * sp;
    const b = 0.0259040371 * lp + 0.7827717662 * mp - 0.808675766 * sp;
    return [l * 100, a * 100, b * 100];
  };
  convert.oklab.oklch = function(oklab) {
    return convert.lab.lch(oklab);
  };
  convert.oklab.xyz = function(oklab) {
    const ll = oklab[0] / 100;
    const a = oklab[1] / 100;
    const b = oklab[2] / 100;
    const l = (0.999999998 * ll + 0.396337792 * a + 0.215803758 * b) ** 3;
    const m = (1.000000008 * ll - 0.105561342 * a - 0.063854175 * b) ** 3;
    const s = (1.000000055 * ll - 0.089484182 * a - 1.291485538 * b) ** 3;
    const x = 1.227013851 * l - 0.55779998 * m + 0.281256149 * s;
    const y = -0.040580178 * l + 1.11225687 * m - 0.071676679 * s;
    const z = -0.076381285 * l - 0.421481978 * m + 1.58616322 * s;
    return [x * 100, y * 100, z * 100];
  };
  convert.oklab.rgb = function(oklab) {
    const ll = oklab[0] / 100;
    const aa = oklab[1] / 100;
    const bb = oklab[2] / 100;
    const l = (ll + 0.3963377774 * aa + 0.2158037573 * bb) ** 3;
    const m = (ll - 0.1055613458 * aa - 0.0638541728 * bb) ** 3;
    const s = (ll - 0.0894841775 * aa - 1.291485548 * bb) ** 3;
    const r = srgbNonlinearTransform(4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s);
    const g = srgbNonlinearTransform(-1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s);
    const b = srgbNonlinearTransform(-0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s);
    return [r * 255, g * 255, b * 255];
  };
  convert.oklch.oklab = function(oklch) {
    return convert.lch.lab(oklch);
  };
  convert.lab.xyz = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y;
    let z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    const y2 = y ** 3;
    const x2 = x ** 3;
    const z2 = z ** 3;
    y = y2 > LAB_FT ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > LAB_FT ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > LAB_FT ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };
  convert.lab.lch = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    const c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };
  convert.lch.lab = function(lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr = h / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert.rgb.ansi16 = function(args, saturation = null) {
    const [r, g, b] = args;
    let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert.hsv.ansi16 = function(args) {
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };
  convert.rgb.ansi256 = function(args) {
    const r = args[0];
    const g = args[1];
    const b = args[2];
    if (r >> 4 === g >> 4 && g >> 4 === b >> 4) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert.ansi16.rgb = function(args) {
    args = args[0];
    let color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    const mult = (Math.trunc(args > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g = (color >> 1 & 1) * mult * 255;
    const b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert.ansi256.rgb = function(args) {
    args = args[0];
    if (args >= 232) {
      const c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert.rgb.hex = function(args) {
    const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    const string = integer.toString(16).toUpperCase();
    return "000000".slice(string.length) + string;
  };
  convert.hex.rgb = function(args) {
    const match2 = args.toString(16).match(/[a-f\d]{6}|[a-f\d]{3}/i);
    if (!match2) {
      return [0, 0, 0];
    }
    let colorString = match2[0];
    if (match2[0].length === 3) {
      colorString = [...colorString].map((char) => char + char).join("");
    }
    const integer = Number.parseInt(colorString, 16);
    const r = integer >> 16 & 255;
    const g = integer >> 8 & 255;
    const b = integer & 255;
    return [r, g, b];
  };
  convert.rgb.hcg = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    const chroma = max - min;
    let hue;
    const grayscale = chroma < 1 ? min / (1 - chroma) : 0;
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert.hsl.hcg = function(hsl) {
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
    let f = 0;
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert.hsv.hcg = function(hsv) {
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s * v;
    let f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert.hcg.rgb = function(hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    const pure = [0, 0, 0];
    const hi = h % 1 * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg = 0;
    switch (Math.floor(hi)) {
      case 0: {
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      }
      case 1: {
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      }
      case 2: {
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      }
      case 3: {
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      }
      case 4: {
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      }
      default: {
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
      }
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  convert.hcg.hsv = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    let f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert.hcg.hsl = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1 - c) + 0.5 * c;
    let s = 0;
    if (l > 0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s = c / (2 * (1 - l));
    }
    return [hcg[0], s * 100, l * 100];
  };
  convert.hcg.hwb = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert.hwb.hcg = function(hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w;
    let g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert.gray.hsl = function(args) {
    return [0, 0, args[0]];
  };
  convert.gray.hsv = convert.gray.hsl;
  convert.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert.gray.hex = function(gray) {
    const value = Math.round(gray[0] / 100 * 255) & 255;
    const integer = (value << 16) + (value << 8) + value;
    const string = integer.toString(16).toUpperCase();
    return "000000".slice(string.length) + string;
  };
  convert.rgb.gray = function(rgb) {
    const value = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [value / 255 * 100];
  };
  function buildGraph() {
    const graph = {};
    const models2 = Object.keys(conversions_default);
    for (let { length } = models2, i = 0;i < length; i++) {
      graph[models2[i]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length > 0) {
      const current = queue.pop();
      const adjacents = Object.keys(conversions_default[current]);
      for (let { length } = adjacents, i = 0;i < length; i++) {
        const adjacent = adjacents[i];
        const node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link(from, to) {
    return function(args) {
      return to(from(args));
    };
  }
  function wrapConversion(toModel, graph) {
    const path2 = [graph[toModel].parent, toModel];
    let fn = conversions_default[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path2.unshift(graph[cur].parent);
      fn = link(conversions_default[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path2;
    return fn;
  }
  function route(fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models2 = Object.keys(graph);
    for (let { length } = models2, i = 0;i < length; i++) {
      const toModel = models2[i];
      const node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  }
  var route_default = route;
  var convert2 = {};
  var models = Object.keys(conversions_default);
  function wrapRaw(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === undefined || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      return fn(args);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === undefined || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      const result = fn(args);
      if (typeof result === "object") {
        for (let { length } = result, i = 0;i < length; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  for (const fromModel of models) {
    convert2[fromModel] = {};
    Object.defineProperty(convert2[fromModel], "channels", { value: conversions_default[fromModel].channels });
    Object.defineProperty(convert2[fromModel], "labels", { value: conversions_default[fromModel].labels });
    const routes = route_default(fromModel);
    const routeModels = Object.keys(routes);
    for (const toModel of routeModels) {
      const fn = routes[toModel];
      convert2[fromModel][toModel] = wrapRounded(fn);
      convert2[fromModel][toModel].raw = wrapRaw(fn);
    }
  }
  var color_convert_default = convert2;
  var skippedModels = [
    "keyword",
    "gray",
    "hex"
  ];
  var hashedModelKeys = {};
  for (const model of Object.keys(color_convert_default)) {
    hashedModelKeys[[...color_convert_default[model].labels].sort().join("")] = model;
  }
  var limiters = {};
  function Color(object, model) {
    if (!(this instanceof Color)) {
      return new Color(object, model);
    }
    if (model && model in skippedModels) {
      model = null;
    }
    if (model && !(model in color_convert_default)) {
      throw new Error("Unknown model: " + model);
    }
    let i;
    let channels;
    if (object == null) {
      this.model = "rgb";
      this.color = [0, 0, 0];
      this.valpha = 1;
    } else if (object instanceof Color) {
      this.model = object.model;
      this.color = [...object.color];
      this.valpha = object.valpha;
    } else if (typeof object === "string") {
      const result = color_string_default.get(object);
      if (result === null) {
        throw new Error("Unable to parse color from string: " + object);
      }
      this.model = result.model;
      channels = color_convert_default[this.model].channels;
      this.color = result.value.slice(0, channels);
      this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
    } else if (object.length > 0) {
      this.model = model || "rgb";
      channels = color_convert_default[this.model].channels;
      const newArray = Array.prototype.slice.call(object, 0, channels);
      this.color = zeroArray(newArray, channels);
      this.valpha = typeof object[channels] === "number" ? object[channels] : 1;
    } else if (typeof object === "number") {
      this.model = "rgb";
      this.color = [
        object >> 16 & 255,
        object >> 8 & 255,
        object & 255
      ];
      this.valpha = 1;
    } else {
      this.valpha = 1;
      const keys = Object.keys(object);
      if ("alpha" in object) {
        keys.splice(keys.indexOf("alpha"), 1);
        this.valpha = typeof object.alpha === "number" ? object.alpha : 0;
      }
      const hashedKeys = keys.sort().join("");
      if (!(hashedKeys in hashedModelKeys)) {
        throw new Error("Unable to parse color from object: " + JSON.stringify(object));
      }
      this.model = hashedModelKeys[hashedKeys];
      const { labels } = color_convert_default[this.model];
      const color = [];
      for (i = 0;i < labels.length; i++) {
        color.push(object[labels[i]]);
      }
      this.color = zeroArray(color);
    }
    if (limiters[this.model]) {
      channels = color_convert_default[this.model].channels;
      for (i = 0;i < channels; i++) {
        const limit2 = limiters[this.model][i];
        if (limit2) {
          this.color[i] = limit2(this.color[i]);
        }
      }
    }
    this.valpha = Math.max(0, Math.min(1, this.valpha));
    if (Object.freeze) {
      Object.freeze(this);
    }
  }
  Color.prototype = {
    toString() {
      return this.string();
    },
    toJSON() {
      return this[this.model]();
    },
    string(places) {
      let self2 = this.model in color_string_default.to ? this : this.rgb();
      self2 = self2.round(typeof places === "number" ? places : 1);
      const arguments_ = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
      return color_string_default.to[self2.model](...arguments_);
    },
    percentString(places) {
      const self2 = this.rgb().round(typeof places === "number" ? places : 1);
      const arguments_ = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
      return color_string_default.to.rgb.percent(...arguments_);
    },
    array() {
      return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
    },
    object() {
      const result = {};
      const { channels } = color_convert_default[this.model];
      const { labels } = color_convert_default[this.model];
      for (let i = 0;i < channels; i++) {
        result[labels[i]] = this.color[i];
      }
      if (this.valpha !== 1) {
        result.alpha = this.valpha;
      }
      return result;
    },
    unitArray() {
      const rgb = this.rgb().color;
      rgb[0] /= 255;
      rgb[1] /= 255;
      rgb[2] /= 255;
      if (this.valpha !== 1) {
        rgb.push(this.valpha);
      }
      return rgb;
    },
    unitObject() {
      const rgb = this.rgb().object();
      rgb.r /= 255;
      rgb.g /= 255;
      rgb.b /= 255;
      if (this.valpha !== 1) {
        rgb.alpha = this.valpha;
      }
      return rgb;
    },
    round(places) {
      places = Math.max(places || 0, 0);
      return new Color([...this.color.map(roundToPlace(places)), this.valpha], this.model);
    },
    alpha(value) {
      if (value !== undefined) {
        return new Color([...this.color, Math.max(0, Math.min(1, value))], this.model);
      }
      return this.valpha;
    },
    red: getset("rgb", 0, maxfn(255)),
    green: getset("rgb", 1, maxfn(255)),
    blue: getset("rgb", 2, maxfn(255)),
    hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, (value) => (value % 360 + 360) % 360),
    saturationl: getset("hsl", 1, maxfn(100)),
    lightness: getset("hsl", 2, maxfn(100)),
    saturationv: getset("hsv", 1, maxfn(100)),
    value: getset("hsv", 2, maxfn(100)),
    chroma: getset("hcg", 1, maxfn(100)),
    gray: getset("hcg", 2, maxfn(100)),
    white: getset("hwb", 1, maxfn(100)),
    wblack: getset("hwb", 2, maxfn(100)),
    cyan: getset("cmyk", 0, maxfn(100)),
    magenta: getset("cmyk", 1, maxfn(100)),
    yellow: getset("cmyk", 2, maxfn(100)),
    black: getset("cmyk", 3, maxfn(100)),
    x: getset("xyz", 0, maxfn(95.047)),
    y: getset("xyz", 1, maxfn(100)),
    z: getset("xyz", 2, maxfn(108.833)),
    l: getset("lab", 0, maxfn(100)),
    a: getset("lab", 1),
    b: getset("lab", 2),
    keyword(value) {
      if (value !== undefined) {
        return new Color(value);
      }
      return color_convert_default[this.model].keyword(this.color);
    },
    hex(value) {
      if (value !== undefined) {
        return new Color(value);
      }
      return color_string_default.to.hex(...this.rgb().round().color);
    },
    hexa(value) {
      if (value !== undefined) {
        return new Color(value);
      }
      const rgbArray = this.rgb().round().color;
      let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
      if (alphaHex.length === 1) {
        alphaHex = "0" + alphaHex;
      }
      return color_string_default.to.hex(...rgbArray) + alphaHex;
    },
    rgbNumber() {
      const rgb = this.rgb().color;
      return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
    },
    luminosity() {
      const rgb = this.rgb().color;
      const lum = [];
      for (const [i, element] of rgb.entries()) {
        const chan = element / 255;
        lum[i] = chan <= 0.04045 ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;
      }
      return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
    },
    contrast(color2) {
      const lum1 = this.luminosity();
      const lum2 = color2.luminosity();
      if (lum1 > lum2) {
        return (lum1 + 0.05) / (lum2 + 0.05);
      }
      return (lum2 + 0.05) / (lum1 + 0.05);
    },
    level(color2) {
      const contrastRatio = this.contrast(color2);
      if (contrastRatio >= 7) {
        return "AAA";
      }
      return contrastRatio >= 4.5 ? "AA" : "";
    },
    isDark() {
      const rgb = this.rgb().color;
      const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 1e4;
      return yiq < 128;
    },
    isLight() {
      return !this.isDark();
    },
    negate() {
      const rgb = this.rgb();
      for (let i = 0;i < 3; i++) {
        rgb.color[i] = 255 - rgb.color[i];
      }
      return rgb;
    },
    lighten(ratio) {
      const hsl = this.hsl();
      hsl.color[2] += hsl.color[2] * ratio;
      return hsl;
    },
    darken(ratio) {
      const hsl = this.hsl();
      hsl.color[2] -= hsl.color[2] * ratio;
      return hsl;
    },
    saturate(ratio) {
      const hsl = this.hsl();
      hsl.color[1] += hsl.color[1] * ratio;
      return hsl;
    },
    desaturate(ratio) {
      const hsl = this.hsl();
      hsl.color[1] -= hsl.color[1] * ratio;
      return hsl;
    },
    whiten(ratio) {
      const hwb = this.hwb();
      hwb.color[1] += hwb.color[1] * ratio;
      return hwb;
    },
    blacken(ratio) {
      const hwb = this.hwb();
      hwb.color[2] += hwb.color[2] * ratio;
      return hwb;
    },
    grayscale() {
      const rgb = this.rgb().color;
      const value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
      return Color.rgb(value, value, value);
    },
    fade(ratio) {
      return this.alpha(this.valpha - this.valpha * ratio);
    },
    opaquer(ratio) {
      return this.alpha(this.valpha + this.valpha * ratio);
    },
    rotate(degrees) {
      const hsl = this.hsl();
      let hue = hsl.color[0];
      hue = (hue + degrees) % 360;
      hue = hue < 0 ? 360 + hue : hue;
      hsl.color[0] = hue;
      return hsl;
    },
    mix(mixinColor, weight) {
      if (!mixinColor || !mixinColor.rgb) {
        throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
      }
      const color1 = mixinColor.rgb();
      const color2 = this.rgb();
      const p = weight === undefined ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = color1.alpha() - color2.alpha();
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      const w2 = 1 - w1;
      return Color.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue(), color1.alpha() * p + color2.alpha() * (1 - p));
    }
  };
  for (const model of Object.keys(color_convert_default)) {
    if (skippedModels.includes(model)) {
      continue;
    }
    const { channels } = color_convert_default[model];
    Color.prototype[model] = function(...arguments_) {
      if (this.model === model) {
        return new Color(this);
      }
      if (arguments_.length > 0) {
        return new Color(arguments_, model);
      }
      return new Color([...assertArray(color_convert_default[this.model][model].raw(this.color)), this.valpha], model);
    };
    Color[model] = function(...arguments_) {
      let color = arguments_[0];
      if (typeof color === "number") {
        color = zeroArray(arguments_, channels);
      }
      return new Color(color, model);
    };
  }
  function roundTo(number, places) {
    return Number(number.toFixed(places));
  }
  function roundToPlace(places) {
    return function(number) {
      return roundTo(number, places);
    };
  }
  function getset(model, channel, modifier) {
    model = Array.isArray(model) ? model : [model];
    for (const m of model) {
      (limiters[m] ||= [])[channel] = modifier;
    }
    model = model[0];
    return function(value) {
      let result;
      if (value !== undefined) {
        if (modifier) {
          value = modifier(value);
        }
        result = this[model]();
        result.color[channel] = value;
        return result;
      }
      result = this[model]().color[channel];
      if (modifier) {
        result = modifier(result);
      }
      return result;
    };
  }
  function maxfn(max) {
    return function(v) {
      return Math.max(0, Math.min(max, v));
    };
  }
  function assertArray(value) {
    return Array.isArray(value) ? value : [value];
  }
  function zeroArray(array, length) {
    for (let i = 0;i < length; i++) {
      if (typeof array[i] !== "number") {
        array[i] = 0;
      }
    }
    return array;
  }
  var index_default = Color;
});

// backend/node_modules/@img/colour/index.cjs
var require_colour = __commonJS((exports2, module2) => {
  module2.exports = require_color().default;
});

// backend/node_modules/sharp/lib/colour.js
var require_colour2 = __commonJS((exports2, module2) => {
  /*!
    Copyright 2013 Lovell Fuller and others.
    SPDX-License-Identifier: Apache-2.0
  */
  var color = require_colour();
  var is = require_is();
  var colourspace = {
    multiband: "multiband",
    "b-w": "b-w",
    bw: "b-w",
    cmyk: "cmyk",
    srgb: "srgb"
  };
  function tint(tint2) {
    this._setBackgroundColourOption("tint", tint2);
    return this;
  }
  function greyscale(greyscale2) {
    this.options.greyscale = is.bool(greyscale2) ? greyscale2 : true;
    return this;
  }
  function grayscale(grayscale2) {
    return this.greyscale(grayscale2);
  }
  function pipelineColourspace(colourspace2) {
    if (!is.string(colourspace2)) {
      throw is.invalidParameterError("colourspace", "string", colourspace2);
    }
    this.options.colourspacePipeline = colourspace2;
    return this;
  }
  function pipelineColorspace(colorspace) {
    return this.pipelineColourspace(colorspace);
  }
  function toColourspace(colourspace2) {
    if (!is.string(colourspace2)) {
      throw is.invalidParameterError("colourspace", "string", colourspace2);
    }
    this.options.colourspace = colourspace2;
    return this;
  }
  function toColorspace(colorspace) {
    return this.toColourspace(colorspace);
  }
  function _getBackgroundColourOption(value) {
    if (is.object(value) || is.string(value) && value.length >= 3 && value.length <= 200) {
      const colour = color(value);
      return [
        colour.red(),
        colour.green(),
        colour.blue(),
        Math.round(colour.alpha() * 255)
      ];
    } else {
      throw is.invalidParameterError("background", "object or string", value);
    }
  }
  function _setBackgroundColourOption(key, value) {
    if (is.defined(value)) {
      this.options[key] = _getBackgroundColourOption(value);
    }
  }
  module2.exports = (Sharp) => {
    Object.assign(Sharp.prototype, {
      tint,
      greyscale,
      grayscale,
      pipelineColourspace,
      pipelineColorspace,
      toColourspace,
      toColorspace,
      _getBackgroundColourOption,
      _setBackgroundColourOption
    });
    Sharp.colourspace = colourspace;
    Sharp.colorspace = colourspace;
  };
});

// backend/node_modules/sharp/lib/channel.js
var require_channel = __commonJS((exports2, module2) => {
  /*!
    Copyright 2013 Lovell Fuller and others.
    SPDX-License-Identifier: Apache-2.0
  */
  var is = require_is();
  var bool = {
    and: "and",
    or: "or",
    eor: "eor"
  };
  function removeAlpha() {
    this.options.removeAlpha = true;
    return this;
  }
  function ensureAlpha(alpha) {
    if (is.defined(alpha)) {
      if (is.number(alpha) && is.inRange(alpha, 0, 1)) {
        this.options.ensureAlpha = alpha;
      } else {
        throw is.invalidParameterError("alpha", "number between 0 and 1", alpha);
      }
    } else {
      this.options.ensureAlpha = 1;
    }
    return this;
  }
  function extractChannel(channel) {
    const channelMap = { red: 0, green: 1, blue: 2, alpha: 3 };
    if (Object.keys(channelMap).includes(channel)) {
      channel = channelMap[channel];
    }
    if (is.integer(channel) && is.inRange(channel, 0, 4)) {
      this.options.extractChannel = channel;
    } else {
      throw is.invalidParameterError("channel", "integer or one of: red, green, blue, alpha", channel);
    }
    return this;
  }
  function joinChannel(images, options) {
    if (Array.isArray(images)) {
      images.forEach(function(image) {
        this.options.joinChannelIn.push(this._createInputDescriptor(image, options));
      }, this);
    } else {
      this.options.joinChannelIn.push(this._createInputDescriptor(images, options));
    }
    return this;
  }
  function bandbool(boolOp) {
    if (is.string(boolOp) && is.inArray(boolOp, ["and", "or", "eor"])) {
      this.options.bandBoolOp = boolOp;
    } else {
      throw is.invalidParameterError("boolOp", "one of: and, or, eor", boolOp);
    }
    return this;
  }
  module2.exports = (Sharp) => {
    Object.assign(Sharp.prototype, {
      removeAlpha,
      ensureAlpha,
      extractChannel,
      joinChannel,
      bandbool
    });
    Sharp.bool = bool;
  };
});

// backend/node_modules/sharp/lib/output.js
var require_output = __commonJS((exports2, module2) => {
  /*!
    Copyright 2013 Lovell Fuller and others.
    SPDX-License-Identifier: Apache-2.0
  */
  var path2 = require("node:path");
  var is = require_is();
  var sharp = require_sharp();
  var formats = new Map([
    ["heic", "heif"],
    ["heif", "heif"],
    ["avif", "avif"],
    ["jpeg", "jpeg"],
    ["jpg", "jpeg"],
    ["jpe", "jpeg"],
    ["tile", "tile"],
    ["dz", "tile"],
    ["png", "png"],
    ["raw", "raw"],
    ["tiff", "tiff"],
    ["tif", "tiff"],
    ["webp", "webp"],
    ["gif", "gif"],
    ["jp2", "jp2"],
    ["jpx", "jp2"],
    ["j2k", "jp2"],
    ["j2c", "jp2"],
    ["jxl", "jxl"]
  ]);
  var jp2Regex = /\.(jp[2x]|j2[kc])$/i;
  var errJp2Save = () => new Error("JP2 output requires libvips with support for OpenJPEG");
  var bitdepthFromColourCount = (colours) => 1 << 31 - Math.clz32(Math.ceil(Math.log2(colours)));
  function toFile2(fileOut, callback) {
    let err;
    if (!is.string(fileOut)) {
      err = new Error("Missing output file path");
    } else if (is.string(this.options.input.file) && path2.resolve(this.options.input.file) === path2.resolve(fileOut)) {
      err = new Error("Cannot use same file for input and output");
    } else if (jp2Regex.test(path2.extname(fileOut)) && !this.constructor.format.jp2k.output.file) {
      err = errJp2Save();
    }
    if (err) {
      if (is.fn(callback)) {
        callback(err);
      } else {
        return Promise.reject(err);
      }
    } else {
      this.options.fileOut = fileOut;
      const stack = Error();
      return this._pipeline(callback, stack);
    }
    return this;
  }
  function toBuffer(options, callback) {
    if (is.object(options)) {
      this._setBooleanOption("resolveWithObject", options.resolveWithObject);
    } else if (this.options.resolveWithObject) {
      this.options.resolveWithObject = false;
    }
    this.options.fileOut = "";
    const stack = Error();
    return this._pipeline(is.fn(options) ? options : callback, stack);
  }
  function keepExif() {
    this.options.keepMetadata |= 1;
    return this;
  }
  function withExif(exif) {
    if (is.object(exif)) {
      for (const [ifd, entries] of Object.entries(exif)) {
        if (is.object(entries)) {
          for (const [k, v] of Object.entries(entries)) {
            if (is.string(v)) {
              this.options.withExif[`exif-${ifd.toLowerCase()}-${k}`] = v;
            } else {
              throw is.invalidParameterError(`${ifd}.${k}`, "string", v);
            }
          }
        } else {
          throw is.invalidParameterError(ifd, "object", entries);
        }
      }
    } else {
      throw is.invalidParameterError("exif", "object", exif);
    }
    this.options.withExifMerge = false;
    return this.keepExif();
  }
  function withExifMerge(exif) {
    this.withExif(exif);
    this.options.withExifMerge = true;
    return this;
  }
  function keepIccProfile() {
    this.options.keepMetadata |= 8;
    return this;
  }
  function withIccProfile(icc, options) {
    if (is.string(icc)) {
      this.options.withIccProfile = icc;
    } else {
      throw is.invalidParameterError("icc", "string", icc);
    }
    this.keepIccProfile();
    if (is.object(options)) {
      if (is.defined(options.attach)) {
        if (is.bool(options.attach)) {
          if (!options.attach) {
            this.options.keepMetadata &= ~8;
          }
        } else {
          throw is.invalidParameterError("attach", "boolean", options.attach);
        }
      }
    }
    return this;
  }
  function keepXmp() {
    this.options.keepMetadata |= 2;
    return this;
  }
  function withXmp(xmp) {
    if (is.string(xmp) && xmp.length > 0) {
      this.options.withXmp = xmp;
      this.options.keepMetadata |= 2;
    } else {
      throw is.invalidParameterError("xmp", "non-empty string", xmp);
    }
    return this;
  }
  function keepMetadata() {
    this.options.keepMetadata = 31;
    return this;
  }
  function withMetadata(options) {
    this.keepMetadata();
    this.withIccProfile("srgb");
    if (is.object(options)) {
      if (is.defined(options.orientation)) {
        if (is.integer(options.orientation) && is.inRange(options.orientation, 1, 8)) {
          this.options.withMetadataOrientation = options.orientation;
        } else {
          throw is.invalidParameterError("orientation", "integer between 1 and 8", options.orientation);
        }
      }
      if (is.defined(options.density)) {
        if (is.number(options.density) && options.density > 0) {
          this.options.withMetadataDensity = options.density;
        } else {
          throw is.invalidParameterError("density", "positive number", options.density);
        }
      }
      if (is.defined(options.icc)) {
        this.withIccProfile(options.icc);
      }
      if (is.defined(options.exif)) {
        this.withExifMerge(options.exif);
      }
    }
    return this;
  }
  function toFormat(format, options) {
    const actualFormat = formats.get((is.object(format) && is.string(format.id) ? format.id : format).toLowerCase());
    if (!actualFormat) {
      throw is.invalidParameterError("format", `one of: ${[...formats.keys()].join(", ")}`, format);
    }
    return this[actualFormat](options);
  }
  function jpeg(options) {
    if (is.object(options)) {
      if (is.defined(options.quality)) {
        if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {
          this.options.jpegQuality = options.quality;
        } else {
          throw is.invalidParameterError("quality", "integer between 1 and 100", options.quality);
        }
      }
      if (is.defined(options.progressive)) {
        this._setBooleanOption("jpegProgressive", options.progressive);
      }
      if (is.defined(options.chromaSubsampling)) {
        if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ["4:2:0", "4:4:4"])) {
          this.options.jpegChromaSubsampling = options.chromaSubsampling;
        } else {
          throw is.invalidParameterError("chromaSubsampling", "one of: 4:2:0, 4:4:4", options.chromaSubsampling);
        }
      }
      const optimiseCoding = is.bool(options.optimizeCoding) ? options.optimizeCoding : options.optimiseCoding;
      if (is.defined(optimiseCoding)) {
        this._setBooleanOption("jpegOptimiseCoding", optimiseCoding);
      }
      if (is.defined(options.mozjpeg)) {
        if (is.bool(options.mozjpeg)) {
          if (options.mozjpeg) {
            this.options.jpegTrellisQuantisation = true;
            this.options.jpegOvershootDeringing = true;
            this.options.jpegOptimiseScans = true;
            this.options.jpegProgressive = true;
            this.options.jpegQuantisationTable = 3;
          }
        } else {
          throw is.invalidParameterError("mozjpeg", "boolean", options.mozjpeg);
        }
      }
      const trellisQuantisation = is.bool(options.trellisQuantization) ? options.trellisQuantization : options.trellisQuantisation;
      if (is.defined(trellisQuantisation)) {
        this._setBooleanOption("jpegTrellisQuantisation", trellisQuantisation);
      }
      if (is.defined(options.overshootDeringing)) {
        this._setBooleanOption("jpegOvershootDeringing", options.overshootDeringing);
      }
      const optimiseScans = is.bool(options.optimizeScans) ? options.optimizeScans : options.optimiseScans;
      if (is.defined(optimiseScans)) {
        this._setBooleanOption("jpegOptimiseScans", optimiseScans);
        if (optimiseScans) {
          this.options.jpegProgressive = true;
        }
      }
      const quantisationTable = is.number(options.quantizationTable) ? options.quantizationTable : options.quantisationTable;
      if (is.defined(quantisationTable)) {
        if (is.integer(quantisationTable) && is.inRange(quantisationTable, 0, 8)) {
          this.options.jpegQuantisationTable = quantisationTable;
        } else {
          throw is.invalidParameterError("quantisationTable", "integer between 0 and 8", quantisationTable);
        }
      }
    }
    return this._updateFormatOut("jpeg", options);
  }
  function png(options) {
    if (is.object(options)) {
      if (is.defined(options.progressive)) {
        this._setBooleanOption("pngProgressive", options.progressive);
      }
      if (is.defined(options.compressionLevel)) {
        if (is.integer(options.compressionLevel) && is.inRange(options.compressionLevel, 0, 9)) {
          this.options.pngCompressionLevel = options.compressionLevel;
        } else {
          throw is.invalidParameterError("compressionLevel", "integer between 0 and 9", options.compressionLevel);
        }
      }
      if (is.defined(options.adaptiveFiltering)) {
        this._setBooleanOption("pngAdaptiveFiltering", options.adaptiveFiltering);
      }
      const colours = options.colours || options.colors;
      if (is.defined(colours)) {
        if (is.integer(colours) && is.inRange(colours, 2, 256)) {
          this.options.pngBitdepth = bitdepthFromColourCount(colours);
        } else {
          throw is.invalidParameterError("colours", "integer between 2 and 256", colours);
        }
      }
      if (is.defined(options.palette)) {
        this._setBooleanOption("pngPalette", options.palette);
      } else if ([options.quality, options.effort, options.colours, options.colors, options.dither].some(is.defined)) {
        this._setBooleanOption("pngPalette", true);
      }
      if (this.options.pngPalette) {
        if (is.defined(options.quality)) {
          if (is.integer(options.quality) && is.inRange(options.quality, 0, 100)) {
            this.options.pngQuality = options.quality;
          } else {
            throw is.invalidParameterError("quality", "integer between 0 and 100", options.quality);
          }
        }
        if (is.defined(options.effort)) {
          if (is.integer(options.effort) && is.inRange(options.effort, 1, 10)) {
            this.options.pngEffort = options.effort;
          } else {
            throw is.invalidParameterError("effort", "integer between 1 and 10", options.effort);
          }
        }
        if (is.defined(options.dither)) {
          if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {
            this.options.pngDither = options.dither;
          } else {
            throw is.invalidParameterError("dither", "number between 0.0 and 1.0", options.dither);
          }
        }
      }
    }
    return this._updateFormatOut("png", options);
  }
  function webp(options) {
    if (is.object(options)) {
      if (is.defined(options.quality)) {
        if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {
          this.options.webpQuality = options.quality;
        } else {
          throw is.invalidParameterError("quality", "integer between 1 and 100", options.quality);
        }
      }
      if (is.defined(options.alphaQuality)) {
        if (is.integer(options.alphaQuality) && is.inRange(options.alphaQuality, 0, 100)) {
          this.options.webpAlphaQuality = options.alphaQuality;
        } else {
          throw is.invalidParameterError("alphaQuality", "integer between 0 and 100", options.alphaQuality);
        }
      }
      if (is.defined(options.lossless)) {
        this._setBooleanOption("webpLossless", options.lossless);
      }
      if (is.defined(options.nearLossless)) {
        this._setBooleanOption("webpNearLossless", options.nearLossless);
      }
      if (is.defined(options.smartSubsample)) {
        this._setBooleanOption("webpSmartSubsample", options.smartSubsample);
      }
      if (is.defined(options.smartDeblock)) {
        this._setBooleanOption("webpSmartDeblock", options.smartDeblock);
      }
      if (is.defined(options.preset)) {
        if (is.string(options.preset) && is.inArray(options.preset, ["default", "photo", "picture", "drawing", "icon", "text"])) {
          this.options.webpPreset = options.preset;
        } else {
          throw is.invalidParameterError("preset", "one of: default, photo, picture, drawing, icon, text", options.preset);
        }
      }
      if (is.defined(options.effort)) {
        if (is.integer(options.effort) && is.inRange(options.effort, 0, 6)) {
          this.options.webpEffort = options.effort;
        } else {
          throw is.invalidParameterError("effort", "integer between 0 and 6", options.effort);
        }
      }
      if (is.defined(options.minSize)) {
        this._setBooleanOption("webpMinSize", options.minSize);
      }
      if (is.defined(options.mixed)) {
        this._setBooleanOption("webpMixed", options.mixed);
      }
    }
    trySetAnimationOptions(options, this.options);
    return this._updateFormatOut("webp", options);
  }
  function gif(options) {
    if (is.object(options)) {
      if (is.defined(options.reuse)) {
        this._setBooleanOption("gifReuse", options.reuse);
      }
      if (is.defined(options.progressive)) {
        this._setBooleanOption("gifProgressive", options.progressive);
      }
      const colours = options.colours || options.colors;
      if (is.defined(colours)) {
        if (is.integer(colours) && is.inRange(colours, 2, 256)) {
          this.options.gifBitdepth = bitdepthFromColourCount(colours);
        } else {
          throw is.invalidParameterError("colours", "integer between 2 and 256", colours);
        }
      }
      if (is.defined(options.effort)) {
        if (is.number(options.effort) && is.inRange(options.effort, 1, 10)) {
          this.options.gifEffort = options.effort;
        } else {
          throw is.invalidParameterError("effort", "integer between 1 and 10", options.effort);
        }
      }
      if (is.defined(options.dither)) {
        if (is.number(options.dither) && is.inRange(options.dither, 0, 1)) {
          this.options.gifDither = options.dither;
        } else {
          throw is.invalidParameterError("dither", "number between 0.0 and 1.0", options.dither);
        }
      }
      if (is.defined(options.interFrameMaxError)) {
        if (is.number(options.interFrameMaxError) && is.inRange(options.interFrameMaxError, 0, 32)) {
          this.options.gifInterFrameMaxError = options.interFrameMaxError;
        } else {
          throw is.invalidParameterError("interFrameMaxError", "number between 0.0 and 32.0", options.interFrameMaxError);
        }
      }
      if (is.defined(options.interPaletteMaxError)) {
        if (is.number(options.interPaletteMaxError) && is.inRange(options.interPaletteMaxError, 0, 256)) {
          this.options.gifInterPaletteMaxError = options.interPaletteMaxError;
        } else {
          throw is.invalidParameterError("interPaletteMaxError", "number between 0.0 and 256.0", options.interPaletteMaxError);
        }
      }
      if (is.defined(options.keepDuplicateFrames)) {
        if (is.bool(options.keepDuplicateFrames)) {
          this._setBooleanOption("gifKeepDuplicateFrames", options.keepDuplicateFrames);
        } else {
          throw is.invalidParameterError("keepDuplicateFrames", "boolean", options.keepDuplicateFrames);
        }
      }
    }
    trySetAnimationOptions(options, this.options);
    return this._updateFormatOut("gif", options);
  }
  function jp2(options) {
    if (!this.constructor.format.jp2k.output.buffer) {
      throw errJp2Save();
    }
    if (is.object(options)) {
      if (is.defined(options.quality)) {
        if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {
          this.options.jp2Quality = options.quality;
        } else {
          throw is.invalidParameterError("quality", "integer between 1 and 100", options.quality);
        }
      }
      if (is.defined(options.lossless)) {
        if (is.bool(options.lossless)) {
          this.options.jp2Lossless = options.lossless;
        } else {
          throw is.invalidParameterError("lossless", "boolean", options.lossless);
        }
      }
      if (is.defined(options.tileWidth)) {
        if (is.integer(options.tileWidth) && is.inRange(options.tileWidth, 1, 32768)) {
          this.options.jp2TileWidth = options.tileWidth;
        } else {
          throw is.invalidParameterError("tileWidth", "integer between 1 and 32768", options.tileWidth);
        }
      }
      if (is.defined(options.tileHeight)) {
        if (is.integer(options.tileHeight) && is.inRange(options.tileHeight, 1, 32768)) {
          this.options.jp2TileHeight = options.tileHeight;
        } else {
          throw is.invalidParameterError("tileHeight", "integer between 1 and 32768", options.tileHeight);
        }
      }
      if (is.defined(options.chromaSubsampling)) {
        if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ["4:2:0", "4:4:4"])) {
          this.options.jp2ChromaSubsampling = options.chromaSubsampling;
        } else {
          throw is.invalidParameterError("chromaSubsampling", "one of: 4:2:0, 4:4:4", options.chromaSubsampling);
        }
      }
    }
    return this._updateFormatOut("jp2", options);
  }
  function trySetAnimationOptions(source, target) {
    if (is.object(source) && is.defined(source.loop)) {
      if (is.integer(source.loop) && is.inRange(source.loop, 0, 65535)) {
        target.loop = source.loop;
      } else {
        throw is.invalidParameterError("loop", "integer between 0 and 65535", source.loop);
      }
    }
    if (is.object(source) && is.defined(source.delay)) {
      if (is.integer(source.delay) && is.inRange(source.delay, 0, 65535)) {
        target.delay = [source.delay];
      } else if (Array.isArray(source.delay) && source.delay.every(is.integer) && source.delay.every((v) => is.inRange(v, 0, 65535))) {
        target.delay = source.delay;
      } else {
        throw is.invalidParameterError("delay", "integer or an array of integers between 0 and 65535", source.delay);
      }
    }
  }
  function tiff(options) {
    if (is.object(options)) {
      if (is.defined(options.quality)) {
        if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {
          this.options.tiffQuality = options.quality;
        } else {
          throw is.invalidParameterError("quality", "integer between 1 and 100", options.quality);
        }
      }
      if (is.defined(options.bitdepth)) {
        if (is.integer(options.bitdepth) && is.inArray(options.bitdepth, [1, 2, 4, 8])) {
          this.options.tiffBitdepth = options.bitdepth;
        } else {
          throw is.invalidParameterError("bitdepth", "1, 2, 4 or 8", options.bitdepth);
        }
      }
      if (is.defined(options.tile)) {
        this._setBooleanOption("tiffTile", options.tile);
      }
      if (is.defined(options.tileWidth)) {
        if (is.integer(options.tileWidth) && options.tileWidth > 0) {
          this.options.tiffTileWidth = options.tileWidth;
        } else {
          throw is.invalidParameterError("tileWidth", "integer greater than zero", options.tileWidth);
        }
      }
      if (is.defined(options.tileHeight)) {
        if (is.integer(options.tileHeight) && options.tileHeight > 0) {
          this.options.tiffTileHeight = options.tileHeight;
        } else {
          throw is.invalidParameterError("tileHeight", "integer greater than zero", options.tileHeight);
        }
      }
      if (is.defined(options.miniswhite)) {
        this._setBooleanOption("tiffMiniswhite", options.miniswhite);
      }
      if (is.defined(options.pyramid)) {
        this._setBooleanOption("tiffPyramid", options.pyramid);
      }
      if (is.defined(options.xres)) {
        if (is.number(options.xres) && options.xres > 0) {
          this.options.tiffXres = options.xres;
        } else {
          throw is.invalidParameterError("xres", "number greater than zero", options.xres);
        }
      }
      if (is.defined(options.yres)) {
        if (is.number(options.yres) && options.yres > 0) {
          this.options.tiffYres = options.yres;
        } else {
          throw is.invalidParameterError("yres", "number greater than zero", options.yres);
        }
      }
      if (is.defined(options.compression)) {
        if (is.string(options.compression) && is.inArray(options.compression, ["none", "jpeg", "deflate", "packbits", "ccittfax4", "lzw", "webp", "zstd", "jp2k"])) {
          this.options.tiffCompression = options.compression;
        } else {
          throw is.invalidParameterError("compression", "one of: none, jpeg, deflate, packbits, ccittfax4, lzw, webp, zstd, jp2k", options.compression);
        }
      }
      if (is.defined(options.bigtiff)) {
        this._setBooleanOption("tiffBigtiff", options.bigtiff);
      }
      if (is.defined(options.predictor)) {
        if (is.string(options.predictor) && is.inArray(options.predictor, ["none", "horizontal", "float"])) {
          this.options.tiffPredictor = options.predictor;
        } else {
          throw is.invalidParameterError("predictor", "one of: none, horizontal, float", options.predictor);
        }
      }
      if (is.defined(options.resolutionUnit)) {
        if (is.string(options.resolutionUnit) && is.inArray(options.resolutionUnit, ["inch", "cm"])) {
          this.options.tiffResolutionUnit = options.resolutionUnit;
        } else {
          throw is.invalidParameterError("resolutionUnit", "one of: inch, cm", options.resolutionUnit);
        }
      }
    }
    return this._updateFormatOut("tiff", options);
  }
  function avif(options) {
    return this.heif({ ...options, compression: "av1" });
  }
  function heif(options) {
    if (is.object(options)) {
      if (is.string(options.compression) && is.inArray(options.compression, ["av1", "hevc"])) {
        this.options.heifCompression = options.compression;
      } else {
        throw is.invalidParameterError("compression", "one of: av1, hevc", options.compression);
      }
      if (is.defined(options.quality)) {
        if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {
          this.options.heifQuality = options.quality;
        } else {
          throw is.invalidParameterError("quality", "integer between 1 and 100", options.quality);
        }
      }
      if (is.defined(options.lossless)) {
        if (is.bool(options.lossless)) {
          this.options.heifLossless = options.lossless;
        } else {
          throw is.invalidParameterError("lossless", "boolean", options.lossless);
        }
      }
      if (is.defined(options.effort)) {
        if (is.integer(options.effort) && is.inRange(options.effort, 0, 9)) {
          this.options.heifEffort = options.effort;
        } else {
          throw is.invalidParameterError("effort", "integer between 0 and 9", options.effort);
        }
      }
      if (is.defined(options.chromaSubsampling)) {
        if (is.string(options.chromaSubsampling) && is.inArray(options.chromaSubsampling, ["4:2:0", "4:4:4"])) {
          this.options.heifChromaSubsampling = options.chromaSubsampling;
        } else {
          throw is.invalidParameterError("chromaSubsampling", "one of: 4:2:0, 4:4:4", options.chromaSubsampling);
        }
      }
      if (is.defined(options.bitdepth)) {
        if (is.integer(options.bitdepth) && is.inArray(options.bitdepth, [8, 10, 12])) {
          if (options.bitdepth !== 8 && this.constructor.versions.heif) {
            throw is.invalidParameterError("bitdepth when using prebuilt binaries", 8, options.bitdepth);
          }
          this.options.heifBitdepth = options.bitdepth;
        } else {
          throw is.invalidParameterError("bitdepth", "8, 10 or 12", options.bitdepth);
        }
      }
    } else {
      throw is.invalidParameterError("options", "Object", options);
    }
    return this._updateFormatOut("heif", options);
  }
  function jxl(options) {
    if (is.object(options)) {
      if (is.defined(options.quality)) {
        if (is.integer(options.quality) && is.inRange(options.quality, 1, 100)) {
          this.options.jxlDistance = options.quality >= 30 ? 0.1 + (100 - options.quality) * 0.09 : 53 / 3000 * options.quality * options.quality - 23 / 20 * options.quality + 25;
        } else {
          throw is.invalidParameterError("quality", "integer between 1 and 100", options.quality);
        }
      } else if (is.defined(options.distance)) {
        if (is.number(options.distance) && is.inRange(options.distance, 0, 15)) {
          this.options.jxlDistance = options.distance;
        } else {
          throw is.invalidParameterError("distance", "number between 0.0 and 15.0", options.distance);
        }
      }
      if (is.defined(options.decodingTier)) {
        if (is.integer(options.decodingTier) && is.inRange(options.decodingTier, 0, 4)) {
          this.options.jxlDecodingTier = options.decodingTier;
        } else {
          throw is.invalidParameterError("decodingTier", "integer between 0 and 4", options.decodingTier);
        }
      }
      if (is.defined(options.lossless)) {
        if (is.bool(options.lossless)) {
          this.options.jxlLossless = options.lossless;
        } else {
          throw is.invalidParameterError("lossless", "boolean", options.lossless);
        }
      }
      if (is.defined(options.effort)) {
        if (is.integer(options.effort) && is.inRange(options.effort, 1, 9)) {
          this.options.jxlEffort = options.effort;
        } else {
          throw is.invalidParameterError("effort", "integer between 1 and 9", options.effort);
        }
      }
    }
    trySetAnimationOptions(options, this.options);
    return this._updateFormatOut("jxl", options);
  }
  function raw2(options) {
    if (is.object(options)) {
      if (is.defined(options.depth)) {
        if (is.string(options.depth) && is.inArray(options.depth, ["char", "uchar", "short", "ushort", "int", "uint", "float", "complex", "double", "dpcomplex"])) {
          this.options.rawDepth = options.depth;
        } else {
          throw is.invalidParameterError("depth", "one of: char, uchar, short, ushort, int, uint, float, complex, double, dpcomplex", options.depth);
        }
      }
    }
    return this._updateFormatOut("raw");
  }
  function tile(options) {
    if (is.object(options)) {
      if (is.defined(options.size)) {
        if (is.integer(options.size) && is.inRange(options.size, 1, 8192)) {
          this.options.tileSize = options.size;
        } else {
          throw is.invalidParameterError("size", "integer between 1 and 8192", options.size);
        }
      }
      if (is.defined(options.overlap)) {
        if (is.integer(options.overlap) && is.inRange(options.overlap, 0, 8192)) {
          if (options.overlap > this.options.tileSize) {
            throw is.invalidParameterError("overlap", `<= size (${this.options.tileSize})`, options.overlap);
          }
          this.options.tileOverlap = options.overlap;
        } else {
          throw is.invalidParameterError("overlap", "integer between 0 and 8192", options.overlap);
        }
      }
      if (is.defined(options.container)) {
        if (is.string(options.container) && is.inArray(options.container, ["fs", "zip"])) {
          this.options.tileContainer = options.container;
        } else {
          throw is.invalidParameterError("container", "one of: fs, zip", options.container);
        }
      }
      if (is.defined(options.layout)) {
        if (is.string(options.layout) && is.inArray(options.layout, ["dz", "google", "iiif", "iiif3", "zoomify"])) {
          this.options.tileLayout = options.layout;
        } else {
          throw is.invalidParameterError("layout", "one of: dz, google, iiif, iiif3, zoomify", options.layout);
        }
      }
      if (is.defined(options.angle)) {
        if (is.integer(options.angle) && !(options.angle % 90)) {
          this.options.tileAngle = options.angle;
        } else {
          throw is.invalidParameterError("angle", "positive/negative multiple of 90", options.angle);
        }
      }
      this._setBackgroundColourOption("tileBackground", options.background);
      if (is.defined(options.depth)) {
        if (is.string(options.depth) && is.inArray(options.depth, ["onepixel", "onetile", "one"])) {
          this.options.tileDepth = options.depth;
        } else {
          throw is.invalidParameterError("depth", "one of: onepixel, onetile, one", options.depth);
        }
      }
      if (is.defined(options.skipBlanks)) {
        if (is.integer(options.skipBlanks) && is.inRange(options.skipBlanks, -1, 65535)) {
          this.options.tileSkipBlanks = options.skipBlanks;
        } else {
          throw is.invalidParameterError("skipBlanks", "integer between -1 and 255/65535", options.skipBlanks);
        }
      } else if (is.defined(options.layout) && options.layout === "google") {
        this.options.tileSkipBlanks = 5;
      }
      const centre = is.bool(options.center) ? options.center : options.centre;
      if (is.defined(centre)) {
        this._setBooleanOption("tileCentre", centre);
      }
      if (is.defined(options.id)) {
        if (is.string(options.id)) {
          this.options.tileId = options.id;
        } else {
          throw is.invalidParameterError("id", "string", options.id);
        }
      }
      if (is.defined(options.basename)) {
        if (is.string(options.basename)) {
          this.options.tileBasename = options.basename;
        } else {
          throw is.invalidParameterError("basename", "string", options.basename);
        }
      }
    }
    if (is.inArray(this.options.formatOut, ["jpeg", "png", "webp"])) {
      this.options.tileFormat = this.options.formatOut;
    } else if (this.options.formatOut !== "input") {
      throw is.invalidParameterError("format", "one of: jpeg, png, webp", this.options.formatOut);
    }
    return this._updateFormatOut("dz");
  }
  function timeout(options) {
    if (!is.plainObject(options)) {
      throw is.invalidParameterError("options", "object", options);
    }
    if (is.integer(options.seconds) && is.inRange(options.seconds, 0, 3600)) {
      this.options.timeoutSeconds = options.seconds;
    } else {
      throw is.invalidParameterError("seconds", "integer between 0 and 3600", options.seconds);
    }
    return this;
  }
  function _updateFormatOut(formatOut, options) {
    if (!(is.object(options) && options.force === false)) {
      this.options.formatOut = formatOut;
    }
    return this;
  }
  function _setBooleanOption(key, val) {
    if (is.bool(val)) {
      this.options[key] = val;
    } else {
      throw is.invalidParameterError(key, "boolean", val);
    }
  }
  function _read() {
    if (!this.options.streamOut) {
      this.options.streamOut = true;
      const stack = Error();
      this._pipeline(undefined, stack);
    }
  }
  function _pipeline(callback, stack) {
    if (typeof callback === "function") {
      if (this._isStreamInput()) {
        this.on("finish", () => {
          this._flattenBufferIn();
          sharp.pipeline(this.options, (err, data, info) => {
            if (err) {
              callback(is.nativeError(err, stack));
            } else {
              callback(null, data, info);
            }
          });
        });
      } else {
        sharp.pipeline(this.options, (err, data, info) => {
          if (err) {
            callback(is.nativeError(err, stack));
          } else {
            callback(null, data, info);
          }
        });
      }
      return this;
    } else if (this.options.streamOut) {
      if (this._isStreamInput()) {
        this.once("finish", () => {
          this._flattenBufferIn();
          sharp.pipeline(this.options, (err, data, info) => {
            if (err) {
              this.emit("error", is.nativeError(err, stack));
            } else {
              this.emit("info", info);
              this.push(data);
            }
            this.push(null);
            this.on("end", () => this.emit("close"));
          });
        });
        if (this.streamInFinished) {
          this.emit("finish");
        }
      } else {
        sharp.pipeline(this.options, (err, data, info) => {
          if (err) {
            this.emit("error", is.nativeError(err, stack));
          } else {
            this.emit("info", info);
            this.push(data);
          }
          this.push(null);
          this.on("end", () => this.emit("close"));
        });
      }
      return this;
    } else {
      if (this._isStreamInput()) {
        return new Promise((resolve, reject) => {
          this.once("finish", () => {
            this._flattenBufferIn();
            sharp.pipeline(this.options, (err, data, info) => {
              if (err) {
                reject(is.nativeError(err, stack));
              } else {
                if (this.options.resolveWithObject) {
                  resolve({ data, info });
                } else {
                  resolve(data);
                }
              }
            });
          });
        });
      } else {
        return new Promise((resolve, reject) => {
          sharp.pipeline(this.options, (err, data, info) => {
            if (err) {
              reject(is.nativeError(err, stack));
            } else {
              if (this.options.resolveWithObject) {
                resolve({ data, info });
              } else {
                resolve(data);
              }
            }
          });
        });
      }
    }
  }
  module2.exports = (Sharp) => {
    Object.assign(Sharp.prototype, {
      toFile: toFile2,
      toBuffer,
      keepExif,
      withExif,
      withExifMerge,
      keepIccProfile,
      withIccProfile,
      keepXmp,
      withXmp,
      keepMetadata,
      withMetadata,
      toFormat,
      jpeg,
      jp2,
      png,
      webp,
      tiff,
      avif,
      heif,
      jxl,
      gif,
      raw: raw2,
      tile,
      timeout,
      _updateFormatOut,
      _setBooleanOption,
      _read,
      _pipeline
    });
  };
});

// backend/node_modules/sharp/lib/utility.js
var require_utility = __commonJS((exports2, module2) => {
  /*!
    Copyright 2013 Lovell Fuller and others.
    SPDX-License-Identifier: Apache-2.0
  */
  var events = require("node:events");
  var detectLibc = require_detect_libc();
  var is = require_is();
  var { runtimePlatformArch } = require_libvips();
  var sharp = require_sharp();
  var runtimePlatform = runtimePlatformArch();
  var libvipsVersion = sharp.libvipsVersion();
  var format = sharp.format();
  format.heif.output.alias = ["avif", "heic"];
  format.jpeg.output.alias = ["jpe", "jpg"];
  format.tiff.output.alias = ["tif"];
  format.jp2k.output.alias = ["j2c", "j2k", "jp2", "jpx"];
  var interpolators = {
    nearest: "nearest",
    bilinear: "bilinear",
    bicubic: "bicubic",
    locallyBoundedBicubic: "lbb",
    nohalo: "nohalo",
    vertexSplitQuadraticBasisSpline: "vsqbs"
  };
  var versions = {
    vips: libvipsVersion.semver
  };
  if (!libvipsVersion.isGlobal) {
    if (!libvipsVersion.isWasm) {
      try {
        versions = require(`@img/sharp-${runtimePlatform}/versions`);
      } catch (_) {
        try {
          versions = require(`@img/sharp-libvips-${runtimePlatform}/versions`);
        } catch (_2) {}
      }
    } else {
      try {
        versions = (()=>{throw new Error("Cannot require module "+"@img/sharp-wasm32/versions");})();
      } catch (_) {}
    }
  }
  versions.sharp = require_package().version;
  if (versions.heif && format.heif) {
    format.heif.input.fileSuffix = [".avif"];
    format.heif.output.alias = ["avif"];
  }
  function cache(options) {
    if (is.bool(options)) {
      if (options) {
        return sharp.cache(50, 20, 100);
      } else {
        return sharp.cache(0, 0, 0);
      }
    } else if (is.object(options)) {
      return sharp.cache(options.memory, options.files, options.items);
    } else {
      return sharp.cache();
    }
  }
  cache(true);
  function concurrency(concurrency2) {
    return sharp.concurrency(is.integer(concurrency2) ? concurrency2 : null);
  }
  if (detectLibc.familySync() === detectLibc.GLIBC && !sharp._isUsingJemalloc()) {
    sharp.concurrency(1);
  } else if (detectLibc.familySync() === detectLibc.MUSL && sharp.concurrency() === 1024) {
    sharp.concurrency(require("node:os").availableParallelism());
  }
  var queue = new events.EventEmitter;
  function counters() {
    return sharp.counters();
  }
  function simd(simd2) {
    return sharp.simd(is.bool(simd2) ? simd2 : null);
  }
  function block(options) {
    if (is.object(options)) {
      if (Array.isArray(options.operation) && options.operation.every(is.string)) {
        sharp.block(options.operation, true);
      } else {
        throw is.invalidParameterError("operation", "Array<string>", options.operation);
      }
    } else {
      throw is.invalidParameterError("options", "object", options);
    }
  }
  function unblock(options) {
    if (is.object(options)) {
      if (Array.isArray(options.operation) && options.operation.every(is.string)) {
        sharp.block(options.operation, false);
      } else {
        throw is.invalidParameterError("operation", "Array<string>", options.operation);
      }
    } else {
      throw is.invalidParameterError("options", "object", options);
    }
  }
  module2.exports = (Sharp) => {
    Sharp.cache = cache;
    Sharp.concurrency = concurrency;
    Sharp.counters = counters;
    Sharp.simd = simd;
    Sharp.format = format;
    Sharp.interpolators = interpolators;
    Sharp.versions = versions;
    Sharp.queue = queue;
    Sharp.block = block;
    Sharp.unblock = unblock;
  };
});

// backend/node_modules/sharp/lib/index.js
var require_lib = __commonJS((exports2, module2) => {
  /*!
    Copyright 2013 Lovell Fuller and others.
    SPDX-License-Identifier: Apache-2.0
  */
  var Sharp = require_constructor();
  require_input()(Sharp);
  require_resize()(Sharp);
  require_composite()(Sharp);
  require_operation()(Sharp);
  require_colour2()(Sharp);
  require_channel()(Sharp);
  require_output()(Sharp);
  require_utility()(Sharp);
  module2.exports = Sharp;
});

// backend/node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// backend/node_modules/axios/lib/utils.js
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
function forEach(obj2, fn, { allOwnKeys = false } = {}) {
  if (obj2 === null || typeof obj2 === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj2 !== "object") {
    obj2 = [obj2];
  }
  if (isArray2(obj2)) {
    for (i = 0, l = obj2.length;i < l; i++) {
      fn.call(null, obj2[i], i, obj2);
    }
  } else {
    if (isBuffer(obj2)) {
      return;
    }
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj2) : Object.keys(obj2);
    const len = keys.length;
    let key;
    for (i = 0;i < len; i++) {
      key = keys[i];
      fn.call(null, obj2[key], key, obj2);
    }
  }
}
function findKey(obj2, key) {
  if (isBuffer(obj2)) {
    return null;
  }
  key = key.toLowerCase();
  const keys = Object.keys(obj2);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
function merge() {
  const { caseless, skipUndefined } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray2(val)) {
      result[targetKey] = val.slice();
    } else if (!skipUndefined || !isUndefined(val)) {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length;i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
}
var toString, getPrototypeOf, iterator, toStringTag, kindOf, kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
}, typeOfTest = (type) => (thing) => typeof thing === type, isArray2, isUndefined, isArrayBuffer, isString, isFunction, isNumber, isObject = (thing) => thing !== null && typeof thing === "object", isBoolean = (thing) => thing === true || thing === false, isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(toStringTag in val) && !(iterator in val);
}, isEmptyObject = (val) => {
  if (!isObject(val) || isBuffer(val)) {
    return false;
  }
  try {
    return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
  } catch (e) {
    return false;
  }
}, isDate, isFile, isBlob, isFileList, isStream = (val) => isObject(val) && isFunction(val.pipe), isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
}, isURLSearchParams, isReadableStream, isRequest, isResponse, isHeaders, trim = (str2) => str2.trim ? str2.trim() : str2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), _global, isContextDefined = (context) => !isUndefined(context) && context !== _global, extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
}, stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
}, inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
}, toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
}, endsWith = (str2, searchString, position) => {
  str2 = String(str2);
  if (position === undefined || position > str2.length) {
    position = str2.length;
  }
  position -= searchString.length;
  const lastIndex = str2.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}, toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray2(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}, isTypedArray, forEachEntry = (obj2, fn) => {
  const generator = obj2 && obj2[iterator];
  const _iterator = generator.call(obj2);
  let result;
  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj2, pair[0], pair[1]);
  }
}, matchAll = (regExp, str2) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str2)) !== null) {
    arr.push(matches);
  }
  return arr;
}, isHTMLForm, toCamelCase = (str2) => {
  return str2.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
    return p1.toUpperCase() + p2;
  });
}, hasOwnProperty, isRegExp, reduceDescriptors = (obj2, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj2);
  const reducedDescriptors = {};
  forEach(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj2)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj2, reducedDescriptors);
}, freezeMethods = (obj2) => {
  reduceDescriptors(obj2, (descriptor, name) => {
    if (isFunction(obj2) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj2[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
}, toObjectSet = (arrayOrString, delimiter) => {
  const obj2 = {};
  const define2 = (arr) => {
    arr.forEach((value) => {
      obj2[value] = true;
    });
  };
  isArray2(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
  return obj2;
}, noop2 = () => {}, toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
}, toJSONObject = (obj2) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (isBuffer(source)) {
        return source;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray2(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = undefined;
        return target;
      }
    }
    return source;
  };
  return visit(obj2, 0);
}, isAsyncFn, isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch), _setImmediate, asap, isIterable = (thing) => thing != null && isFunction(thing[iterator]), utils_default;
var init_utils = __esm(() => {
  ({ toString } = Object.prototype);
  ({ getPrototypeOf } = Object);
  ({ iterator, toStringTag } = Symbol);
  kindOf = ((cache) => (thing) => {
    const str2 = toString.call(thing);
    return cache[str2] || (cache[str2] = str2.slice(8, -1).toLowerCase());
  })(Object.create(null));
  ({ isArray: isArray2 } = Array);
  isUndefined = typeOfTest("undefined");
  isArrayBuffer = kindOfTest("ArrayBuffer");
  isString = typeOfTest("string");
  isFunction = typeOfTest("function");
  isNumber = typeOfTest("number");
  isDate = kindOfTest("Date");
  isFile = kindOfTest("File");
  isBlob = kindOfTest("Blob");
  isFileList = kindOfTest("FileList");
  isURLSearchParams = kindOfTest("URLSearchParams");
  [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
  _global = (() => {
    if (typeof globalThis !== "undefined")
      return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
  })();
  isTypedArray = ((TypedArray) => {
    return (thing) => {
      return TypedArray && thing instanceof TypedArray;
    };
  })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
  isHTMLForm = kindOfTest("HTMLFormElement");
  hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj2, prop) => hasOwnProperty2.call(obj2, prop))(Object.prototype);
  isRegExp = kindOfTest("RegExp");
  isAsyncFn = kindOfTest("AsyncFunction");
  _setImmediate = ((setImmediateSupported, postMessageSupported) => {
    if (setImmediateSupported) {
      return setImmediate;
    }
    return postMessageSupported ? ((token, callbacks) => {
      _global.addEventListener("message", ({ source, data }) => {
        if (source === _global && data === token) {
          callbacks.length && callbacks.shift()();
        }
      }, false);
      return (cb) => {
        callbacks.push(cb);
        _global.postMessage(token, "*");
      };
    })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
  })(typeof setImmediate === "function", isFunction(_global.postMessage));
  asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
  utils_default = {
    isArray: isArray2,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isBoolean,
    isObject,
    isPlainObject,
    isEmptyObject,
    isReadableStream,
    isRequest,
    isResponse,
    isHeaders,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop: noop2,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable,
    setImmediate: _setImmediate,
    asap,
    isIterable
  };
});

// backend/node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
var prototype, descriptors, AxiosError_default;
var init_AxiosError = __esm(() => {
  init_utils();
  utils_default.inherits(AxiosError, Error, {
    toJSON: function toJSON() {
      return {
        message: this.message,
        name: this.name,
        description: this.description,
        number: this.number,
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        config: utils_default.toJSONObject(this.config),
        code: this.code,
        status: this.status
      };
    }
  });
  prototype = AxiosError.prototype;
  descriptors = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
  ].forEach((code) => {
    descriptors[code] = { value: code };
  });
  Object.defineProperties(AxiosError, descriptors);
  Object.defineProperty(prototype, "isAxiosError", { value: true });
  AxiosError.from = (error2, code, config, request, response, customProps) => {
    const axiosError = Object.create(prototype);
    utils_default.toFlatObject(error2, axiosError, function filter(obj2) {
      return obj2 !== Error.prototype;
    }, (prop) => {
      return prop !== "isAxiosError";
    });
    const msg = error2 && error2.message ? error2.message : "Error";
    const errCode = code == null && error2 ? error2.code : code;
    AxiosError.call(axiosError, msg, errCode, config, request, response);
    if (error2 && axiosError.cause == null) {
      Object.defineProperty(axiosError, "cause", { value: error2, configurable: true });
    }
    axiosError.name = error2 && error2.name || "Error";
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  AxiosError_default = AxiosError;
});

// backend/node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS((exports2, module2) => {
  var Stream2 = require("stream").Stream;
  var util = require("util");
  module2.exports = DelayedStream;
  function DelayedStream() {
    this.source = null;
    this.dataSize = 0;
    this.maxDataSize = 1024 * 1024;
    this.pauseStream = true;
    this._maxDataSizeExceeded = false;
    this._released = false;
    this._bufferedEvents = [];
  }
  util.inherits(DelayedStream, Stream2);
  DelayedStream.create = function(source, options) {
    var delayedStream = new this;
    options = options || {};
    for (var option in options) {
      delayedStream[option] = options[option];
    }
    delayedStream.source = source;
    var realEmit = source.emit;
    source.emit = function() {
      delayedStream._handleEmit(arguments);
      return realEmit.apply(source, arguments);
    };
    source.on("error", function() {});
    if (delayedStream.pauseStream) {
      source.pause();
    }
    return delayedStream;
  };
  Object.defineProperty(DelayedStream.prototype, "readable", {
    configurable: true,
    enumerable: true,
    get: function() {
      return this.source.readable;
    }
  });
  DelayedStream.prototype.setEncoding = function() {
    return this.source.setEncoding.apply(this.source, arguments);
  };
  DelayedStream.prototype.resume = function() {
    if (!this._released) {
      this.release();
    }
    this.source.resume();
  };
  DelayedStream.prototype.pause = function() {
    this.source.pause();
  };
  DelayedStream.prototype.release = function() {
    this._released = true;
    this._bufferedEvents.forEach(function(args) {
      this.emit.apply(this, args);
    }.bind(this));
    this._bufferedEvents = [];
  };
  DelayedStream.prototype.pipe = function() {
    var r = Stream2.prototype.pipe.apply(this, arguments);
    this.resume();
    return r;
  };
  DelayedStream.prototype._handleEmit = function(args) {
    if (this._released) {
      this.emit.apply(this, args);
      return;
    }
    if (args[0] === "data") {
      this.dataSize += args[1].length;
      this._checkIfMaxDataSizeExceeded();
    }
    this._bufferedEvents.push(args);
  };
  DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
    if (this._maxDataSizeExceeded) {
      return;
    }
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    this._maxDataSizeExceeded = true;
    var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this.emit("error", new Error(message));
  };
});

// backend/node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS((exports2, module2) => {
  var util = require("util");
  var Stream2 = require("stream").Stream;
  var DelayedStream = require_delayed_stream();
  module2.exports = CombinedStream;
  function CombinedStream() {
    this.writable = false;
    this.readable = true;
    this.dataSize = 0;
    this.maxDataSize = 2 * 1024 * 1024;
    this.pauseStreams = true;
    this._released = false;
    this._streams = [];
    this._currentStream = null;
    this._insideLoop = false;
    this._pendingNext = false;
  }
  util.inherits(CombinedStream, Stream2);
  CombinedStream.create = function(options) {
    var combinedStream = new this;
    options = options || {};
    for (var option in options) {
      combinedStream[option] = options[option];
    }
    return combinedStream;
  };
  CombinedStream.isStreamLike = function(stream) {
    return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
  };
  CombinedStream.prototype.append = function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      if (!(stream instanceof DelayedStream)) {
        var newStream = DelayedStream.create(stream, {
          maxDataSize: Infinity,
          pauseStream: this.pauseStreams
        });
        stream.on("data", this._checkDataSize.bind(this));
        stream = newStream;
      }
      this._handleErrors(stream);
      if (this.pauseStreams) {
        stream.pause();
      }
    }
    this._streams.push(stream);
    return this;
  };
  CombinedStream.prototype.pipe = function(dest, options) {
    Stream2.prototype.pipe.call(this, dest, options);
    this.resume();
    return dest;
  };
  CombinedStream.prototype._getNext = function() {
    this._currentStream = null;
    if (this._insideLoop) {
      this._pendingNext = true;
      return;
    }
    this._insideLoop = true;
    try {
      do {
        this._pendingNext = false;
        this._realGetNext();
      } while (this._pendingNext);
    } finally {
      this._insideLoop = false;
    }
  };
  CombinedStream.prototype._realGetNext = function() {
    var stream = this._streams.shift();
    if (typeof stream == "undefined") {
      this.end();
      return;
    }
    if (typeof stream !== "function") {
      this._pipeNext(stream);
      return;
    }
    var getStream = stream;
    getStream(function(stream2) {
      var isStreamLike = CombinedStream.isStreamLike(stream2);
      if (isStreamLike) {
        stream2.on("data", this._checkDataSize.bind(this));
        this._handleErrors(stream2);
      }
      this._pipeNext(stream2);
    }.bind(this));
  };
  CombinedStream.prototype._pipeNext = function(stream) {
    this._currentStream = stream;
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on("end", this._getNext.bind(this));
      stream.pipe(this, { end: false });
      return;
    }
    var value = stream;
    this.write(value);
    this._getNext();
  };
  CombinedStream.prototype._handleErrors = function(stream) {
    var self2 = this;
    stream.on("error", function(err) {
      self2._emitError(err);
    });
  };
  CombinedStream.prototype.write = function(data) {
    this.emit("data", data);
  };
  CombinedStream.prototype.pause = function() {
    if (!this.pauseStreams) {
      return;
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
      this._currentStream.pause();
    this.emit("pause");
  };
  CombinedStream.prototype.resume = function() {
    if (!this._released) {
      this._released = true;
      this.writable = true;
      this._getNext();
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
      this._currentStream.resume();
    this.emit("resume");
  };
  CombinedStream.prototype.end = function() {
    this._reset();
    this.emit("end");
  };
  CombinedStream.prototype.destroy = function() {
    this._reset();
    this.emit("close");
  };
  CombinedStream.prototype._reset = function() {
    this.writable = false;
    this._streams = [];
    this._currentStream = null;
  };
  CombinedStream.prototype._checkDataSize = function() {
    this._updateDataSize();
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this._emitError(new Error(message));
  };
  CombinedStream.prototype._updateDataSize = function() {
    this.dataSize = 0;
    var self2 = this;
    this._streams.forEach(function(stream) {
      if (!stream.dataSize) {
        return;
      }
      self2.dataSize += stream.dataSize;
    });
    if (this._currentStream && this._currentStream.dataSize) {
      this.dataSize += this._currentStream.dataSize;
    }
  };
  CombinedStream.prototype._emitError = function(err) {
    this._reset();
    this.emit("error", err);
  };
});

// backend/node_modules/mime-db/db.json
var require_db = __commonJS((exports2, module2) => {
  module2.exports = {
    "application/1d-interleaved-parityfec": {
      source: "iana"
    },
    "application/3gpdash-qoe-report+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/3gpp-ims+xml": {
      source: "iana",
      compressible: true
    },
    "application/3gpphal+json": {
      source: "iana",
      compressible: true
    },
    "application/3gpphalforms+json": {
      source: "iana",
      compressible: true
    },
    "application/a2l": {
      source: "iana"
    },
    "application/ace+cbor": {
      source: "iana"
    },
    "application/activemessage": {
      source: "iana"
    },
    "application/activity+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-directory+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcost+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcostparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointprop+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointpropparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-error+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamcontrol+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamparams+json": {
      source: "iana",
      compressible: true
    },
    "application/aml": {
      source: "iana"
    },
    "application/andrew-inset": {
      source: "iana",
      extensions: ["ez"]
    },
    "application/applefile": {
      source: "iana"
    },
    "application/applixware": {
      source: "apache",
      extensions: ["aw"]
    },
    "application/at+jwt": {
      source: "iana"
    },
    "application/atf": {
      source: "iana"
    },
    "application/atfx": {
      source: "iana"
    },
    "application/atom+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atom"]
    },
    "application/atomcat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomcat"]
    },
    "application/atomdeleted+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomdeleted"]
    },
    "application/atomicmail": {
      source: "iana"
    },
    "application/atomsvc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomsvc"]
    },
    "application/atsc-dwd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dwd"]
    },
    "application/atsc-dynamic-event-message": {
      source: "iana"
    },
    "application/atsc-held+xml": {
      source: "iana",
      compressible: true,
      extensions: ["held"]
    },
    "application/atsc-rdt+json": {
      source: "iana",
      compressible: true
    },
    "application/atsc-rsat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsat"]
    },
    "application/atxml": {
      source: "iana"
    },
    "application/auth-policy+xml": {
      source: "iana",
      compressible: true
    },
    "application/bacnet-xdd+zip": {
      source: "iana",
      compressible: false
    },
    "application/batch-smtp": {
      source: "iana"
    },
    "application/bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/beep+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/calendar+json": {
      source: "iana",
      compressible: true
    },
    "application/calendar+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xcs"]
    },
    "application/call-completion": {
      source: "iana"
    },
    "application/cals-1840": {
      source: "iana"
    },
    "application/captive+json": {
      source: "iana",
      compressible: true
    },
    "application/cbor": {
      source: "iana"
    },
    "application/cbor-seq": {
      source: "iana"
    },
    "application/cccex": {
      source: "iana"
    },
    "application/ccmp+xml": {
      source: "iana",
      compressible: true
    },
    "application/ccxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ccxml"]
    },
    "application/cdfx+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdfx"]
    },
    "application/cdmi-capability": {
      source: "iana",
      extensions: ["cdmia"]
    },
    "application/cdmi-container": {
      source: "iana",
      extensions: ["cdmic"]
    },
    "application/cdmi-domain": {
      source: "iana",
      extensions: ["cdmid"]
    },
    "application/cdmi-object": {
      source: "iana",
      extensions: ["cdmio"]
    },
    "application/cdmi-queue": {
      source: "iana",
      extensions: ["cdmiq"]
    },
    "application/cdni": {
      source: "iana"
    },
    "application/cea": {
      source: "iana"
    },
    "application/cea-2018+xml": {
      source: "iana",
      compressible: true
    },
    "application/cellml+xml": {
      source: "iana",
      compressible: true
    },
    "application/cfw": {
      source: "iana"
    },
    "application/city+json": {
      source: "iana",
      compressible: true
    },
    "application/clr": {
      source: "iana"
    },
    "application/clue+xml": {
      source: "iana",
      compressible: true
    },
    "application/clue_info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cms": {
      source: "iana"
    },
    "application/cnrp+xml": {
      source: "iana",
      compressible: true
    },
    "application/coap-group+json": {
      source: "iana",
      compressible: true
    },
    "application/coap-payload": {
      source: "iana"
    },
    "application/commonground": {
      source: "iana"
    },
    "application/conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cose": {
      source: "iana"
    },
    "application/cose-key": {
      source: "iana"
    },
    "application/cose-key-set": {
      source: "iana"
    },
    "application/cpl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cpl"]
    },
    "application/csrattrs": {
      source: "iana"
    },
    "application/csta+xml": {
      source: "iana",
      compressible: true
    },
    "application/cstadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/csvm+json": {
      source: "iana",
      compressible: true
    },
    "application/cu-seeme": {
      source: "apache",
      extensions: ["cu"]
    },
    "application/cwt": {
      source: "iana"
    },
    "application/cybercash": {
      source: "iana"
    },
    "application/dart": {
      compressible: true
    },
    "application/dash+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpd"]
    },
    "application/dash-patch+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpp"]
    },
    "application/dashdelta": {
      source: "iana"
    },
    "application/davmount+xml": {
      source: "iana",
      compressible: true,
      extensions: ["davmount"]
    },
    "application/dca-rft": {
      source: "iana"
    },
    "application/dcd": {
      source: "iana"
    },
    "application/dec-dx": {
      source: "iana"
    },
    "application/dialog-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/dicom": {
      source: "iana"
    },
    "application/dicom+json": {
      source: "iana",
      compressible: true
    },
    "application/dicom+xml": {
      source: "iana",
      compressible: true
    },
    "application/dii": {
      source: "iana"
    },
    "application/dit": {
      source: "iana"
    },
    "application/dns": {
      source: "iana"
    },
    "application/dns+json": {
      source: "iana",
      compressible: true
    },
    "application/dns-message": {
      source: "iana"
    },
    "application/docbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dbk"]
    },
    "application/dots+cbor": {
      source: "iana"
    },
    "application/dskpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/dssc+der": {
      source: "iana",
      extensions: ["dssc"]
    },
    "application/dssc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdssc"]
    },
    "application/dvcs": {
      source: "iana"
    },
    "application/ecmascript": {
      source: "iana",
      compressible: true,
      extensions: ["es", "ecma"]
    },
    "application/edi-consent": {
      source: "iana"
    },
    "application/edi-x12": {
      source: "iana",
      compressible: false
    },
    "application/edifact": {
      source: "iana",
      compressible: false
    },
    "application/efi": {
      source: "iana"
    },
    "application/elm+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/elm+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.cap+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/emergencycalldata.comment+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.control+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.deviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.ecall.msd": {
      source: "iana"
    },
    "application/emergencycalldata.providerinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.serviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.subscriberinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.veds+xml": {
      source: "iana",
      compressible: true
    },
    "application/emma+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emma"]
    },
    "application/emotionml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emotionml"]
    },
    "application/encaprtp": {
      source: "iana"
    },
    "application/epp+xml": {
      source: "iana",
      compressible: true
    },
    "application/epub+zip": {
      source: "iana",
      compressible: false,
      extensions: ["epub"]
    },
    "application/eshop": {
      source: "iana"
    },
    "application/exi": {
      source: "iana",
      extensions: ["exi"]
    },
    "application/expect-ct-report+json": {
      source: "iana",
      compressible: true
    },
    "application/express": {
      source: "iana",
      extensions: ["exp"]
    },
    "application/fastinfoset": {
      source: "iana"
    },
    "application/fastsoap": {
      source: "iana"
    },
    "application/fdt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fdt"]
    },
    "application/fhir+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fhir+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fido.trusted-apps+json": {
      compressible: true
    },
    "application/fits": {
      source: "iana"
    },
    "application/flexfec": {
      source: "iana"
    },
    "application/font-sfnt": {
      source: "iana"
    },
    "application/font-tdpfr": {
      source: "iana",
      extensions: ["pfr"]
    },
    "application/font-woff": {
      source: "iana",
      compressible: false
    },
    "application/framework-attributes+xml": {
      source: "iana",
      compressible: true
    },
    "application/geo+json": {
      source: "iana",
      compressible: true,
      extensions: ["geojson"]
    },
    "application/geo+json-seq": {
      source: "iana"
    },
    "application/geopackage+sqlite3": {
      source: "iana"
    },
    "application/geoxacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/gltf-buffer": {
      source: "iana"
    },
    "application/gml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["gml"]
    },
    "application/gpx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["gpx"]
    },
    "application/gxf": {
      source: "apache",
      extensions: ["gxf"]
    },
    "application/gzip": {
      source: "iana",
      compressible: false,
      extensions: ["gz"]
    },
    "application/h224": {
      source: "iana"
    },
    "application/held+xml": {
      source: "iana",
      compressible: true
    },
    "application/hjson": {
      extensions: ["hjson"]
    },
    "application/http": {
      source: "iana"
    },
    "application/hyperstudio": {
      source: "iana",
      extensions: ["stk"]
    },
    "application/ibe-key-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pkg-reply+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pp-data": {
      source: "iana"
    },
    "application/iges": {
      source: "iana"
    },
    "application/im-iscomposing+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/index": {
      source: "iana"
    },
    "application/index.cmd": {
      source: "iana"
    },
    "application/index.obj": {
      source: "iana"
    },
    "application/index.response": {
      source: "iana"
    },
    "application/index.vnd": {
      source: "iana"
    },
    "application/inkml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ink", "inkml"]
    },
    "application/iotp": {
      source: "iana"
    },
    "application/ipfix": {
      source: "iana",
      extensions: ["ipfix"]
    },
    "application/ipp": {
      source: "iana"
    },
    "application/isup": {
      source: "iana"
    },
    "application/its+xml": {
      source: "iana",
      compressible: true,
      extensions: ["its"]
    },
    "application/java-archive": {
      source: "apache",
      compressible: false,
      extensions: ["jar", "war", "ear"]
    },
    "application/java-serialized-object": {
      source: "apache",
      compressible: false,
      extensions: ["ser"]
    },
    "application/java-vm": {
      source: "apache",
      compressible: false,
      extensions: ["class"]
    },
    "application/javascript": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["js", "mjs"]
    },
    "application/jf2feed+json": {
      source: "iana",
      compressible: true
    },
    "application/jose": {
      source: "iana"
    },
    "application/jose+json": {
      source: "iana",
      compressible: true
    },
    "application/jrd+json": {
      source: "iana",
      compressible: true
    },
    "application/jscalendar+json": {
      source: "iana",
      compressible: true
    },
    "application/json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["json", "map"]
    },
    "application/json-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/json-seq": {
      source: "iana"
    },
    "application/json5": {
      extensions: ["json5"]
    },
    "application/jsonml+json": {
      source: "apache",
      compressible: true,
      extensions: ["jsonml"]
    },
    "application/jwk+json": {
      source: "iana",
      compressible: true
    },
    "application/jwk-set+json": {
      source: "iana",
      compressible: true
    },
    "application/jwt": {
      source: "iana"
    },
    "application/kpml-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/kpml-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/ld+json": {
      source: "iana",
      compressible: true,
      extensions: ["jsonld"]
    },
    "application/lgr+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lgr"]
    },
    "application/link-format": {
      source: "iana"
    },
    "application/load-control+xml": {
      source: "iana",
      compressible: true
    },
    "application/lost+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lostxml"]
    },
    "application/lostsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/lpf+zip": {
      source: "iana",
      compressible: false
    },
    "application/lxf": {
      source: "iana"
    },
    "application/mac-binhex40": {
      source: "iana",
      extensions: ["hqx"]
    },
    "application/mac-compactpro": {
      source: "apache",
      extensions: ["cpt"]
    },
    "application/macwriteii": {
      source: "iana"
    },
    "application/mads+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mads"]
    },
    "application/manifest+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["webmanifest"]
    },
    "application/marc": {
      source: "iana",
      extensions: ["mrc"]
    },
    "application/marcxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mrcx"]
    },
    "application/mathematica": {
      source: "iana",
      extensions: ["ma", "nb", "mb"]
    },
    "application/mathml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mathml"]
    },
    "application/mathml-content+xml": {
      source: "iana",
      compressible: true
    },
    "application/mathml-presentation+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-associated-procedure-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-deregister+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-envelope+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-protection-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-reception-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-schedule+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-user-service-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbox": {
      source: "iana",
      extensions: ["mbox"]
    },
    "application/media-policy-dataset+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpf"]
    },
    "application/media_control+xml": {
      source: "iana",
      compressible: true
    },
    "application/mediaservercontrol+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mscml"]
    },
    "application/merge-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/metalink+xml": {
      source: "apache",
      compressible: true,
      extensions: ["metalink"]
    },
    "application/metalink4+xml": {
      source: "iana",
      compressible: true,
      extensions: ["meta4"]
    },
    "application/mets+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mets"]
    },
    "application/mf4": {
      source: "iana"
    },
    "application/mikey": {
      source: "iana"
    },
    "application/mipc": {
      source: "iana"
    },
    "application/missing-blocks+cbor-seq": {
      source: "iana"
    },
    "application/mmt-aei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["maei"]
    },
    "application/mmt-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musd"]
    },
    "application/mods+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mods"]
    },
    "application/moss-keys": {
      source: "iana"
    },
    "application/moss-signature": {
      source: "iana"
    },
    "application/mosskey-data": {
      source: "iana"
    },
    "application/mosskey-request": {
      source: "iana"
    },
    "application/mp21": {
      source: "iana",
      extensions: ["m21", "mp21"]
    },
    "application/mp4": {
      source: "iana",
      extensions: ["mp4s", "m4p"]
    },
    "application/mpeg4-generic": {
      source: "iana"
    },
    "application/mpeg4-iod": {
      source: "iana"
    },
    "application/mpeg4-iod-xmt": {
      source: "iana"
    },
    "application/mrb-consumer+xml": {
      source: "iana",
      compressible: true
    },
    "application/mrb-publish+xml": {
      source: "iana",
      compressible: true
    },
    "application/msc-ivr+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msc-mixer+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msword": {
      source: "iana",
      compressible: false,
      extensions: ["doc", "dot"]
    },
    "application/mud+json": {
      source: "iana",
      compressible: true
    },
    "application/multipart-core": {
      source: "iana"
    },
    "application/mxf": {
      source: "iana",
      extensions: ["mxf"]
    },
    "application/n-quads": {
      source: "iana",
      extensions: ["nq"]
    },
    "application/n-triples": {
      source: "iana",
      extensions: ["nt"]
    },
    "application/nasdata": {
      source: "iana"
    },
    "application/news-checkgroups": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-groupinfo": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-transmission": {
      source: "iana"
    },
    "application/nlsml+xml": {
      source: "iana",
      compressible: true
    },
    "application/node": {
      source: "iana",
      extensions: ["cjs"]
    },
    "application/nss": {
      source: "iana"
    },
    "application/oauth-authz-req+jwt": {
      source: "iana"
    },
    "application/oblivious-dns-message": {
      source: "iana"
    },
    "application/ocsp-request": {
      source: "iana"
    },
    "application/ocsp-response": {
      source: "iana"
    },
    "application/octet-stream": {
      source: "iana",
      compressible: false,
      extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
    },
    "application/oda": {
      source: "iana",
      extensions: ["oda"]
    },
    "application/odm+xml": {
      source: "iana",
      compressible: true
    },
    "application/odx": {
      source: "iana"
    },
    "application/oebps-package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["opf"]
    },
    "application/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogx"]
    },
    "application/omdoc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["omdoc"]
    },
    "application/onenote": {
      source: "apache",
      extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
    },
    "application/opc-nodeset+xml": {
      source: "iana",
      compressible: true
    },
    "application/oscore": {
      source: "iana"
    },
    "application/oxps": {
      source: "iana",
      extensions: ["oxps"]
    },
    "application/p21": {
      source: "iana"
    },
    "application/p21+zip": {
      source: "iana",
      compressible: false
    },
    "application/p2p-overlay+xml": {
      source: "iana",
      compressible: true,
      extensions: ["relo"]
    },
    "application/parityfec": {
      source: "iana"
    },
    "application/passport": {
      source: "iana"
    },
    "application/patch-ops-error+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xer"]
    },
    "application/pdf": {
      source: "iana",
      compressible: false,
      extensions: ["pdf"]
    },
    "application/pdx": {
      source: "iana"
    },
    "application/pem-certificate-chain": {
      source: "iana"
    },
    "application/pgp-encrypted": {
      source: "iana",
      compressible: false,
      extensions: ["pgp"]
    },
    "application/pgp-keys": {
      source: "iana",
      extensions: ["asc"]
    },
    "application/pgp-signature": {
      source: "iana",
      extensions: ["asc", "sig"]
    },
    "application/pics-rules": {
      source: "apache",
      extensions: ["prf"]
    },
    "application/pidf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pidf-diff+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pkcs10": {
      source: "iana",
      extensions: ["p10"]
    },
    "application/pkcs12": {
      source: "iana"
    },
    "application/pkcs7-mime": {
      source: "iana",
      extensions: ["p7m", "p7c"]
    },
    "application/pkcs7-signature": {
      source: "iana",
      extensions: ["p7s"]
    },
    "application/pkcs8": {
      source: "iana",
      extensions: ["p8"]
    },
    "application/pkcs8-encrypted": {
      source: "iana"
    },
    "application/pkix-attr-cert": {
      source: "iana",
      extensions: ["ac"]
    },
    "application/pkix-cert": {
      source: "iana",
      extensions: ["cer"]
    },
    "application/pkix-crl": {
      source: "iana",
      extensions: ["crl"]
    },
    "application/pkix-pkipath": {
      source: "iana",
      extensions: ["pkipath"]
    },
    "application/pkixcmp": {
      source: "iana",
      extensions: ["pki"]
    },
    "application/pls+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pls"]
    },
    "application/poc-settings+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/postscript": {
      source: "iana",
      compressible: true,
      extensions: ["ai", "eps", "ps"]
    },
    "application/ppsp-tracker+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+xml": {
      source: "iana",
      compressible: true
    },
    "application/provenance+xml": {
      source: "iana",
      compressible: true,
      extensions: ["provx"]
    },
    "application/prs.alvestrand.titrax-sheet": {
      source: "iana"
    },
    "application/prs.cww": {
      source: "iana",
      extensions: ["cww"]
    },
    "application/prs.cyn": {
      source: "iana",
      charset: "7-BIT"
    },
    "application/prs.hpub+zip": {
      source: "iana",
      compressible: false
    },
    "application/prs.nprend": {
      source: "iana"
    },
    "application/prs.plucker": {
      source: "iana"
    },
    "application/prs.rdf-xml-crypt": {
      source: "iana"
    },
    "application/prs.xsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/pskc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pskcxml"]
    },
    "application/pvd+json": {
      source: "iana",
      compressible: true
    },
    "application/qsig": {
      source: "iana"
    },
    "application/raml+yaml": {
      compressible: true,
      extensions: ["raml"]
    },
    "application/raptorfec": {
      source: "iana"
    },
    "application/rdap+json": {
      source: "iana",
      compressible: true
    },
    "application/rdf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rdf", "owl"]
    },
    "application/reginfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rif"]
    },
    "application/relax-ng-compact-syntax": {
      source: "iana",
      extensions: ["rnc"]
    },
    "application/remote-printing": {
      source: "iana"
    },
    "application/reputon+json": {
      source: "iana",
      compressible: true
    },
    "application/resource-lists+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rl"]
    },
    "application/resource-lists-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rld"]
    },
    "application/rfc+xml": {
      source: "iana",
      compressible: true
    },
    "application/riscos": {
      source: "iana"
    },
    "application/rlmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/rls-services+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rs"]
    },
    "application/route-apd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rapd"]
    },
    "application/route-s-tsid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sls"]
    },
    "application/route-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rusd"]
    },
    "application/rpki-ghostbusters": {
      source: "iana",
      extensions: ["gbr"]
    },
    "application/rpki-manifest": {
      source: "iana",
      extensions: ["mft"]
    },
    "application/rpki-publication": {
      source: "iana"
    },
    "application/rpki-roa": {
      source: "iana",
      extensions: ["roa"]
    },
    "application/rpki-updown": {
      source: "iana"
    },
    "application/rsd+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rsd"]
    },
    "application/rss+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rss"]
    },
    "application/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "application/rtploopback": {
      source: "iana"
    },
    "application/rtx": {
      source: "iana"
    },
    "application/samlassertion+xml": {
      source: "iana",
      compressible: true
    },
    "application/samlmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/sarif+json": {
      source: "iana",
      compressible: true
    },
    "application/sarif-external-properties+json": {
      source: "iana",
      compressible: true
    },
    "application/sbe": {
      source: "iana"
    },
    "application/sbml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sbml"]
    },
    "application/scaip+xml": {
      source: "iana",
      compressible: true
    },
    "application/scim+json": {
      source: "iana",
      compressible: true
    },
    "application/scvp-cv-request": {
      source: "iana",
      extensions: ["scq"]
    },
    "application/scvp-cv-response": {
      source: "iana",
      extensions: ["scs"]
    },
    "application/scvp-vp-request": {
      source: "iana",
      extensions: ["spq"]
    },
    "application/scvp-vp-response": {
      source: "iana",
      extensions: ["spp"]
    },
    "application/sdp": {
      source: "iana",
      extensions: ["sdp"]
    },
    "application/secevent+jwt": {
      source: "iana"
    },
    "application/senml+cbor": {
      source: "iana"
    },
    "application/senml+json": {
      source: "iana",
      compressible: true
    },
    "application/senml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["senmlx"]
    },
    "application/senml-etch+cbor": {
      source: "iana"
    },
    "application/senml-etch+json": {
      source: "iana",
      compressible: true
    },
    "application/senml-exi": {
      source: "iana"
    },
    "application/sensml+cbor": {
      source: "iana"
    },
    "application/sensml+json": {
      source: "iana",
      compressible: true
    },
    "application/sensml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sensmlx"]
    },
    "application/sensml-exi": {
      source: "iana"
    },
    "application/sep+xml": {
      source: "iana",
      compressible: true
    },
    "application/sep-exi": {
      source: "iana"
    },
    "application/session-info": {
      source: "iana"
    },
    "application/set-payment": {
      source: "iana"
    },
    "application/set-payment-initiation": {
      source: "iana",
      extensions: ["setpay"]
    },
    "application/set-registration": {
      source: "iana"
    },
    "application/set-registration-initiation": {
      source: "iana",
      extensions: ["setreg"]
    },
    "application/sgml": {
      source: "iana"
    },
    "application/sgml-open-catalog": {
      source: "iana"
    },
    "application/shf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["shf"]
    },
    "application/sieve": {
      source: "iana",
      extensions: ["siv", "sieve"]
    },
    "application/simple-filter+xml": {
      source: "iana",
      compressible: true
    },
    "application/simple-message-summary": {
      source: "iana"
    },
    "application/simplesymbolcontainer": {
      source: "iana"
    },
    "application/sipc": {
      source: "iana"
    },
    "application/slate": {
      source: "iana"
    },
    "application/smil": {
      source: "iana"
    },
    "application/smil+xml": {
      source: "iana",
      compressible: true,
      extensions: ["smi", "smil"]
    },
    "application/smpte336m": {
      source: "iana"
    },
    "application/soap+fastinfoset": {
      source: "iana"
    },
    "application/soap+xml": {
      source: "iana",
      compressible: true
    },
    "application/sparql-query": {
      source: "iana",
      extensions: ["rq"]
    },
    "application/sparql-results+xml": {
      source: "iana",
      compressible: true,
      extensions: ["srx"]
    },
    "application/spdx+json": {
      source: "iana",
      compressible: true
    },
    "application/spirits-event+xml": {
      source: "iana",
      compressible: true
    },
    "application/sql": {
      source: "iana"
    },
    "application/srgs": {
      source: "iana",
      extensions: ["gram"]
    },
    "application/srgs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["grxml"]
    },
    "application/sru+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sru"]
    },
    "application/ssdl+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ssdl"]
    },
    "application/ssml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ssml"]
    },
    "application/stix+json": {
      source: "iana",
      compressible: true
    },
    "application/swid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["swidtag"]
    },
    "application/tamp-apex-update": {
      source: "iana"
    },
    "application/tamp-apex-update-confirm": {
      source: "iana"
    },
    "application/tamp-community-update": {
      source: "iana"
    },
    "application/tamp-community-update-confirm": {
      source: "iana"
    },
    "application/tamp-error": {
      source: "iana"
    },
    "application/tamp-sequence-adjust": {
      source: "iana"
    },
    "application/tamp-sequence-adjust-confirm": {
      source: "iana"
    },
    "application/tamp-status-query": {
      source: "iana"
    },
    "application/tamp-status-response": {
      source: "iana"
    },
    "application/tamp-update": {
      source: "iana"
    },
    "application/tamp-update-confirm": {
      source: "iana"
    },
    "application/tar": {
      compressible: true
    },
    "application/taxii+json": {
      source: "iana",
      compressible: true
    },
    "application/td+json": {
      source: "iana",
      compressible: true
    },
    "application/tei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tei", "teicorpus"]
    },
    "application/tetra_isi": {
      source: "iana"
    },
    "application/thraud+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tfi"]
    },
    "application/timestamp-query": {
      source: "iana"
    },
    "application/timestamp-reply": {
      source: "iana"
    },
    "application/timestamped-data": {
      source: "iana",
      extensions: ["tsd"]
    },
    "application/tlsrpt+gzip": {
      source: "iana"
    },
    "application/tlsrpt+json": {
      source: "iana",
      compressible: true
    },
    "application/tnauthlist": {
      source: "iana"
    },
    "application/token-introspection+jwt": {
      source: "iana"
    },
    "application/toml": {
      compressible: true,
      extensions: ["toml"]
    },
    "application/trickle-ice-sdpfrag": {
      source: "iana"
    },
    "application/trig": {
      source: "iana",
      extensions: ["trig"]
    },
    "application/ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ttml"]
    },
    "application/tve-trigger": {
      source: "iana"
    },
    "application/tzif": {
      source: "iana"
    },
    "application/tzif-leap": {
      source: "iana"
    },
    "application/ubjson": {
      compressible: false,
      extensions: ["ubj"]
    },
    "application/ulpfec": {
      source: "iana"
    },
    "application/urc-grpsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/urc-ressheet+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsheet"]
    },
    "application/urc-targetdesc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["td"]
    },
    "application/urc-uisocketdesc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vcard+json": {
      source: "iana",
      compressible: true
    },
    "application/vcard+xml": {
      source: "iana",
      compressible: true
    },
    "application/vemmi": {
      source: "iana"
    },
    "application/vividence.scriptfile": {
      source: "apache"
    },
    "application/vnd.1000minds.decision-model+xml": {
      source: "iana",
      compressible: true,
      extensions: ["1km"]
    },
    "application/vnd.3gpp-prose+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc3ch+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-v2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.5gnas": {
      source: "iana"
    },
    "application/vnd.3gpp.access-transfer-events+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.bsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gmop+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gtpc": {
      source: "iana"
    },
    "application/vnd.3gpp.interworking-data": {
      source: "iana"
    },
    "application/vnd.3gpp.lpp": {
      source: "iana"
    },
    "application/vnd.3gpp.mc-signalling-ear": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-payload": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-signalling": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mid-call+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ngap": {
      source: "iana"
    },
    "application/vnd.3gpp.pfcp": {
      source: "iana"
    },
    "application/vnd.3gpp.pic-bw-large": {
      source: "iana",
      extensions: ["plb"]
    },
    "application/vnd.3gpp.pic-bw-small": {
      source: "iana",
      extensions: ["psb"]
    },
    "application/vnd.3gpp.pic-bw-var": {
      source: "iana",
      extensions: ["pvb"]
    },
    "application/vnd.3gpp.s1ap": {
      source: "iana"
    },
    "application/vnd.3gpp.sms": {
      source: "iana"
    },
    "application/vnd.3gpp.sms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-ext+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.state-and-event-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ussd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.bcmcsinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.sms": {
      source: "iana"
    },
    "application/vnd.3gpp2.tcap": {
      source: "iana",
      extensions: ["tcap"]
    },
    "application/vnd.3lightssoftware.imagescal": {
      source: "iana"
    },
    "application/vnd.3m.post-it-notes": {
      source: "iana",
      extensions: ["pwn"]
    },
    "application/vnd.accpac.simply.aso": {
      source: "iana",
      extensions: ["aso"]
    },
    "application/vnd.accpac.simply.imp": {
      source: "iana",
      extensions: ["imp"]
    },
    "application/vnd.acucobol": {
      source: "iana",
      extensions: ["acu"]
    },
    "application/vnd.acucorp": {
      source: "iana",
      extensions: ["atc", "acutc"]
    },
    "application/vnd.adobe.air-application-installer-package+zip": {
      source: "apache",
      compressible: false,
      extensions: ["air"]
    },
    "application/vnd.adobe.flash.movie": {
      source: "iana"
    },
    "application/vnd.adobe.formscentral.fcdt": {
      source: "iana",
      extensions: ["fcdt"]
    },
    "application/vnd.adobe.fxp": {
      source: "iana",
      extensions: ["fxp", "fxpl"]
    },
    "application/vnd.adobe.partial-upload": {
      source: "iana"
    },
    "application/vnd.adobe.xdp+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdp"]
    },
    "application/vnd.adobe.xfdf": {
      source: "iana",
      extensions: ["xfdf"]
    },
    "application/vnd.aether.imp": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata-pagedef": {
      source: "iana"
    },
    "application/vnd.afpc.cmoca-cmresource": {
      source: "iana"
    },
    "application/vnd.afpc.foca-charset": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codedfont": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codepage": {
      source: "iana"
    },
    "application/vnd.afpc.modca": {
      source: "iana"
    },
    "application/vnd.afpc.modca-cmtable": {
      source: "iana"
    },
    "application/vnd.afpc.modca-formdef": {
      source: "iana"
    },
    "application/vnd.afpc.modca-mediummap": {
      source: "iana"
    },
    "application/vnd.afpc.modca-objectcontainer": {
      source: "iana"
    },
    "application/vnd.afpc.modca-overlay": {
      source: "iana"
    },
    "application/vnd.afpc.modca-pagesegment": {
      source: "iana"
    },
    "application/vnd.age": {
      source: "iana",
      extensions: ["age"]
    },
    "application/vnd.ah-barcode": {
      source: "iana"
    },
    "application/vnd.ahead.space": {
      source: "iana",
      extensions: ["ahead"]
    },
    "application/vnd.airzip.filesecure.azf": {
      source: "iana",
      extensions: ["azf"]
    },
    "application/vnd.airzip.filesecure.azs": {
      source: "iana",
      extensions: ["azs"]
    },
    "application/vnd.amadeus+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.amazon.ebook": {
      source: "apache",
      extensions: ["azw"]
    },
    "application/vnd.amazon.mobi8-ebook": {
      source: "iana"
    },
    "application/vnd.americandynamics.acc": {
      source: "iana",
      extensions: ["acc"]
    },
    "application/vnd.amiga.ami": {
      source: "iana",
      extensions: ["ami"]
    },
    "application/vnd.amundsen.maze+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.android.ota": {
      source: "iana"
    },
    "application/vnd.android.package-archive": {
      source: "apache",
      compressible: false,
      extensions: ["apk"]
    },
    "application/vnd.anki": {
      source: "iana"
    },
    "application/vnd.anser-web-certificate-issue-initiation": {
      source: "iana",
      extensions: ["cii"]
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
      source: "apache",
      extensions: ["fti"]
    },
    "application/vnd.antix.game-component": {
      source: "iana",
      extensions: ["atx"]
    },
    "application/vnd.apache.arrow.file": {
      source: "iana"
    },
    "application/vnd.apache.arrow.stream": {
      source: "iana"
    },
    "application/vnd.apache.thrift.binary": {
      source: "iana"
    },
    "application/vnd.apache.thrift.compact": {
      source: "iana"
    },
    "application/vnd.apache.thrift.json": {
      source: "iana"
    },
    "application/vnd.api+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.aplextor.warrp+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apothekende.reservation+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apple.installer+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpkg"]
    },
    "application/vnd.apple.keynote": {
      source: "iana",
      extensions: ["key"]
    },
    "application/vnd.apple.mpegurl": {
      source: "iana",
      extensions: ["m3u8"]
    },
    "application/vnd.apple.numbers": {
      source: "iana",
      extensions: ["numbers"]
    },
    "application/vnd.apple.pages": {
      source: "iana",
      extensions: ["pages"]
    },
    "application/vnd.apple.pkpass": {
      compressible: false,
      extensions: ["pkpass"]
    },
    "application/vnd.arastra.swi": {
      source: "iana"
    },
    "application/vnd.aristanetworks.swi": {
      source: "iana",
      extensions: ["swi"]
    },
    "application/vnd.artisan+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.artsquare": {
      source: "iana"
    },
    "application/vnd.astraea-software.iota": {
      source: "iana",
      extensions: ["iota"]
    },
    "application/vnd.audiograph": {
      source: "iana",
      extensions: ["aep"]
    },
    "application/vnd.autopackage": {
      source: "iana"
    },
    "application/vnd.avalon+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.avistar+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.balsamiq.bmml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["bmml"]
    },
    "application/vnd.balsamiq.bmpr": {
      source: "iana"
    },
    "application/vnd.banana-accounting": {
      source: "iana"
    },
    "application/vnd.bbf.usp.error": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bekitzur-stech+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bint.med-content": {
      source: "iana"
    },
    "application/vnd.biopax.rdf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.blink-idb-value-wrapper": {
      source: "iana"
    },
    "application/vnd.blueice.multipass": {
      source: "iana",
      extensions: ["mpm"]
    },
    "application/vnd.bluetooth.ep.oob": {
      source: "iana"
    },
    "application/vnd.bluetooth.le.oob": {
      source: "iana"
    },
    "application/vnd.bmi": {
      source: "iana",
      extensions: ["bmi"]
    },
    "application/vnd.bpf": {
      source: "iana"
    },
    "application/vnd.bpf3": {
      source: "iana"
    },
    "application/vnd.businessobjects": {
      source: "iana",
      extensions: ["rep"]
    },
    "application/vnd.byu.uapi+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cab-jscript": {
      source: "iana"
    },
    "application/vnd.canon-cpdl": {
      source: "iana"
    },
    "application/vnd.canon-lips": {
      source: "iana"
    },
    "application/vnd.capasystems-pg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cendio.thinlinc.clientconf": {
      source: "iana"
    },
    "application/vnd.century-systems.tcp_stream": {
      source: "iana"
    },
    "application/vnd.chemdraw+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdxml"]
    },
    "application/vnd.chess-pgn": {
      source: "iana"
    },
    "application/vnd.chipnuts.karaoke-mmd": {
      source: "iana",
      extensions: ["mmd"]
    },
    "application/vnd.ciedi": {
      source: "iana"
    },
    "application/vnd.cinderella": {
      source: "iana",
      extensions: ["cdy"]
    },
    "application/vnd.cirpack.isdn-ext": {
      source: "iana"
    },
    "application/vnd.citationstyles.style+xml": {
      source: "iana",
      compressible: true,
      extensions: ["csl"]
    },
    "application/vnd.claymore": {
      source: "iana",
      extensions: ["cla"]
    },
    "application/vnd.cloanto.rp9": {
      source: "iana",
      extensions: ["rp9"]
    },
    "application/vnd.clonk.c4group": {
      source: "iana",
      extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
    },
    "application/vnd.cluetrust.cartomobile-config": {
      source: "iana",
      extensions: ["c11amc"]
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
      source: "iana",
      extensions: ["c11amz"]
    },
    "application/vnd.coffeescript": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
      source: "iana"
    },
    "application/vnd.collection+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.doc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.next+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.comicbook+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.comicbook-rar": {
      source: "iana"
    },
    "application/vnd.commerce-battelle": {
      source: "iana"
    },
    "application/vnd.commonspace": {
      source: "iana",
      extensions: ["csp"]
    },
    "application/vnd.contact.cmsg": {
      source: "iana",
      extensions: ["cdbcmsg"]
    },
    "application/vnd.coreos.ignition+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cosmocaller": {
      source: "iana",
      extensions: ["cmc"]
    },
    "application/vnd.crick.clicker": {
      source: "iana",
      extensions: ["clkx"]
    },
    "application/vnd.crick.clicker.keyboard": {
      source: "iana",
      extensions: ["clkk"]
    },
    "application/vnd.crick.clicker.palette": {
      source: "iana",
      extensions: ["clkp"]
    },
    "application/vnd.crick.clicker.template": {
      source: "iana",
      extensions: ["clkt"]
    },
    "application/vnd.crick.clicker.wordbank": {
      source: "iana",
      extensions: ["clkw"]
    },
    "application/vnd.criticaltools.wbs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wbs"]
    },
    "application/vnd.cryptii.pipe+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.crypto-shade-file": {
      source: "iana"
    },
    "application/vnd.cryptomator.encrypted": {
      source: "iana"
    },
    "application/vnd.cryptomator.vault": {
      source: "iana"
    },
    "application/vnd.ctc-posml": {
      source: "iana",
      extensions: ["pml"]
    },
    "application/vnd.ctct.ws+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cups-pdf": {
      source: "iana"
    },
    "application/vnd.cups-postscript": {
      source: "iana"
    },
    "application/vnd.cups-ppd": {
      source: "iana",
      extensions: ["ppd"]
    },
    "application/vnd.cups-raster": {
      source: "iana"
    },
    "application/vnd.cups-raw": {
      source: "iana"
    },
    "application/vnd.curl": {
      source: "iana"
    },
    "application/vnd.curl.car": {
      source: "apache",
      extensions: ["car"]
    },
    "application/vnd.curl.pcurl": {
      source: "apache",
      extensions: ["pcurl"]
    },
    "application/vnd.cyan.dean.root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cybank": {
      source: "iana"
    },
    "application/vnd.cyclonedx+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cyclonedx+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.d2l.coursepackage1p0+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.d3m-dataset": {
      source: "iana"
    },
    "application/vnd.d3m-problem": {
      source: "iana"
    },
    "application/vnd.dart": {
      source: "iana",
      compressible: true,
      extensions: ["dart"]
    },
    "application/vnd.data-vision.rdz": {
      source: "iana",
      extensions: ["rdz"]
    },
    "application/vnd.datapackage+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dataresource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dbf": {
      source: "iana",
      extensions: ["dbf"]
    },
    "application/vnd.debian.binary-package": {
      source: "iana"
    },
    "application/vnd.dece.data": {
      source: "iana",
      extensions: ["uvf", "uvvf", "uvd", "uvvd"]
    },
    "application/vnd.dece.ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uvt", "uvvt"]
    },
    "application/vnd.dece.unspecified": {
      source: "iana",
      extensions: ["uvx", "uvvx"]
    },
    "application/vnd.dece.zip": {
      source: "iana",
      extensions: ["uvz", "uvvz"]
    },
    "application/vnd.denovo.fcselayout-link": {
      source: "iana",
      extensions: ["fe_launch"]
    },
    "application/vnd.desmume.movie": {
      source: "iana"
    },
    "application/vnd.dir-bi.plate-dl-nosuffix": {
      source: "iana"
    },
    "application/vnd.dm.delegation+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dna": {
      source: "iana",
      extensions: ["dna"]
    },
    "application/vnd.document+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dolby.mlp": {
      source: "apache",
      extensions: ["mlp"]
    },
    "application/vnd.dolby.mobile.1": {
      source: "iana"
    },
    "application/vnd.dolby.mobile.2": {
      source: "iana"
    },
    "application/vnd.doremir.scorecloud-binary-document": {
      source: "iana"
    },
    "application/vnd.dpgraph": {
      source: "iana",
      extensions: ["dpg"]
    },
    "application/vnd.dreamfactory": {
      source: "iana",
      extensions: ["dfac"]
    },
    "application/vnd.drive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ds-keypoint": {
      source: "apache",
      extensions: ["kpxx"]
    },
    "application/vnd.dtg.local": {
      source: "iana"
    },
    "application/vnd.dtg.local.flash": {
      source: "iana"
    },
    "application/vnd.dtg.local.html": {
      source: "iana"
    },
    "application/vnd.dvb.ait": {
      source: "iana",
      extensions: ["ait"]
    },
    "application/vnd.dvb.dvbisl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.dvbj": {
      source: "iana"
    },
    "application/vnd.dvb.esgcontainer": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcdftnotifaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess2": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgpdd": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcroaming": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-base": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-enhancement": {
      source: "iana"
    },
    "application/vnd.dvb.notif-aggregate-root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-container+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-generic+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-init+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.pfr": {
      source: "iana"
    },
    "application/vnd.dvb.service": {
      source: "iana",
      extensions: ["svc"]
    },
    "application/vnd.dxr": {
      source: "iana"
    },
    "application/vnd.dynageo": {
      source: "iana",
      extensions: ["geo"]
    },
    "application/vnd.dzr": {
      source: "iana"
    },
    "application/vnd.easykaraoke.cdgdownload": {
      source: "iana"
    },
    "application/vnd.ecdis-update": {
      source: "iana"
    },
    "application/vnd.ecip.rlp": {
      source: "iana"
    },
    "application/vnd.eclipse.ditto+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ecowin.chart": {
      source: "iana",
      extensions: ["mag"]
    },
    "application/vnd.ecowin.filerequest": {
      source: "iana"
    },
    "application/vnd.ecowin.fileupdate": {
      source: "iana"
    },
    "application/vnd.ecowin.series": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesrequest": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesupdate": {
      source: "iana"
    },
    "application/vnd.efi.img": {
      source: "iana"
    },
    "application/vnd.efi.iso": {
      source: "iana"
    },
    "application/vnd.emclient.accessrequest+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.enliven": {
      source: "iana",
      extensions: ["nml"]
    },
    "application/vnd.enphase.envoy": {
      source: "iana"
    },
    "application/vnd.eprints.data+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.epson.esf": {
      source: "iana",
      extensions: ["esf"]
    },
    "application/vnd.epson.msf": {
      source: "iana",
      extensions: ["msf"]
    },
    "application/vnd.epson.quickanime": {
      source: "iana",
      extensions: ["qam"]
    },
    "application/vnd.epson.salt": {
      source: "iana",
      extensions: ["slt"]
    },
    "application/vnd.epson.ssf": {
      source: "iana",
      extensions: ["ssf"]
    },
    "application/vnd.ericsson.quickcall": {
      source: "iana"
    },
    "application/vnd.espass-espass+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.eszigno3+xml": {
      source: "iana",
      compressible: true,
      extensions: ["es3", "et3"]
    },
    "application/vnd.etsi.aoc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.asic-e+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.asic-s+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.cug+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvcommand+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-bc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-cod+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvservice+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mcid+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mheg5": {
      source: "iana"
    },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.pstn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.sci+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.simservs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.timestamp-token": {
      source: "iana"
    },
    "application/vnd.etsi.tsl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.tsl.der": {
      source: "iana"
    },
    "application/vnd.eu.kasparian.car+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.eudora.data": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.profile": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.settings": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.theme": {
      source: "iana"
    },
    "application/vnd.exstream-empower+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.exstream-package": {
      source: "iana"
    },
    "application/vnd.ezpix-album": {
      source: "iana",
      extensions: ["ez2"]
    },
    "application/vnd.ezpix-package": {
      source: "iana",
      extensions: ["ez3"]
    },
    "application/vnd.f-secure.mobile": {
      source: "iana"
    },
    "application/vnd.familysearch.gedcom+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.fastcopy-disk-image": {
      source: "iana"
    },
    "application/vnd.fdf": {
      source: "iana",
      extensions: ["fdf"]
    },
    "application/vnd.fdsn.mseed": {
      source: "iana",
      extensions: ["mseed"]
    },
    "application/vnd.fdsn.seed": {
      source: "iana",
      extensions: ["seed", "dataless"]
    },
    "application/vnd.ffsns": {
      source: "iana"
    },
    "application/vnd.ficlab.flb+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.filmit.zfc": {
      source: "iana"
    },
    "application/vnd.fints": {
      source: "iana"
    },
    "application/vnd.firemonkeys.cloudcell": {
      source: "iana"
    },
    "application/vnd.flographit": {
      source: "iana",
      extensions: ["gph"]
    },
    "application/vnd.fluxtime.clip": {
      source: "iana",
      extensions: ["ftc"]
    },
    "application/vnd.font-fontforge-sfd": {
      source: "iana"
    },
    "application/vnd.framemaker": {
      source: "iana",
      extensions: ["fm", "frame", "maker", "book"]
    },
    "application/vnd.frogans.fnc": {
      source: "iana",
      extensions: ["fnc"]
    },
    "application/vnd.frogans.ltf": {
      source: "iana",
      extensions: ["ltf"]
    },
    "application/vnd.fsc.weblaunch": {
      source: "iana",
      extensions: ["fsc"]
    },
    "application/vnd.fujifilm.fb.docuworks": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.binder": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.jfi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fujitsu.oasys": {
      source: "iana",
      extensions: ["oas"]
    },
    "application/vnd.fujitsu.oasys2": {
      source: "iana",
      extensions: ["oa2"]
    },
    "application/vnd.fujitsu.oasys3": {
      source: "iana",
      extensions: ["oa3"]
    },
    "application/vnd.fujitsu.oasysgp": {
      source: "iana",
      extensions: ["fg5"]
    },
    "application/vnd.fujitsu.oasysprs": {
      source: "iana",
      extensions: ["bh2"]
    },
    "application/vnd.fujixerox.art-ex": {
      source: "iana"
    },
    "application/vnd.fujixerox.art4": {
      source: "iana"
    },
    "application/vnd.fujixerox.ddd": {
      source: "iana",
      extensions: ["ddd"]
    },
    "application/vnd.fujixerox.docuworks": {
      source: "iana",
      extensions: ["xdw"]
    },
    "application/vnd.fujixerox.docuworks.binder": {
      source: "iana",
      extensions: ["xbd"]
    },
    "application/vnd.fujixerox.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujixerox.hbpl": {
      source: "iana"
    },
    "application/vnd.fut-misnet": {
      source: "iana"
    },
    "application/vnd.futoin+cbor": {
      source: "iana"
    },
    "application/vnd.futoin+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fuzzysheet": {
      source: "iana",
      extensions: ["fzs"]
    },
    "application/vnd.genomatix.tuxedo": {
      source: "iana",
      extensions: ["txd"]
    },
    "application/vnd.gentics.grd+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geo+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geocube+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geogebra.file": {
      source: "iana",
      extensions: ["ggb"]
    },
    "application/vnd.geogebra.slides": {
      source: "iana"
    },
    "application/vnd.geogebra.tool": {
      source: "iana",
      extensions: ["ggt"]
    },
    "application/vnd.geometry-explorer": {
      source: "iana",
      extensions: ["gex", "gre"]
    },
    "application/vnd.geonext": {
      source: "iana",
      extensions: ["gxt"]
    },
    "application/vnd.geoplan": {
      source: "iana",
      extensions: ["g2w"]
    },
    "application/vnd.geospace": {
      source: "iana",
      extensions: ["g3w"]
    },
    "application/vnd.gerber": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt-response": {
      source: "iana"
    },
    "application/vnd.gmx": {
      source: "iana",
      extensions: ["gmx"]
    },
    "application/vnd.google-apps.document": {
      compressible: false,
      extensions: ["gdoc"]
    },
    "application/vnd.google-apps.presentation": {
      compressible: false,
      extensions: ["gslides"]
    },
    "application/vnd.google-apps.spreadsheet": {
      compressible: false,
      extensions: ["gsheet"]
    },
    "application/vnd.google-earth.kml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["kml"]
    },
    "application/vnd.google-earth.kmz": {
      source: "iana",
      compressible: false,
      extensions: ["kmz"]
    },
    "application/vnd.gov.sk.e-form+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gov.sk.e-form+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.grafeq": {
      source: "iana",
      extensions: ["gqf", "gqs"]
    },
    "application/vnd.gridmp": {
      source: "iana"
    },
    "application/vnd.groove-account": {
      source: "iana",
      extensions: ["gac"]
    },
    "application/vnd.groove-help": {
      source: "iana",
      extensions: ["ghf"]
    },
    "application/vnd.groove-identity-message": {
      source: "iana",
      extensions: ["gim"]
    },
    "application/vnd.groove-injector": {
      source: "iana",
      extensions: ["grv"]
    },
    "application/vnd.groove-tool-message": {
      source: "iana",
      extensions: ["gtm"]
    },
    "application/vnd.groove-tool-template": {
      source: "iana",
      extensions: ["tpl"]
    },
    "application/vnd.groove-vcard": {
      source: "iana",
      extensions: ["vcg"]
    },
    "application/vnd.hal+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hal+xml": {
      source: "iana",
      compressible: true,
      extensions: ["hal"]
    },
    "application/vnd.handheld-entertainment+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zmm"]
    },
    "application/vnd.hbci": {
      source: "iana",
      extensions: ["hbci"]
    },
    "application/vnd.hc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hcl-bireports": {
      source: "iana"
    },
    "application/vnd.hdt": {
      source: "iana"
    },
    "application/vnd.heroku+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hhe.lesson-player": {
      source: "iana",
      extensions: ["les"]
    },
    "application/vnd.hl7cda+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hl7v2+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hp-hpgl": {
      source: "iana",
      extensions: ["hpgl"]
    },
    "application/vnd.hp-hpid": {
      source: "iana",
      extensions: ["hpid"]
    },
    "application/vnd.hp-hps": {
      source: "iana",
      extensions: ["hps"]
    },
    "application/vnd.hp-jlyt": {
      source: "iana",
      extensions: ["jlt"]
    },
    "application/vnd.hp-pcl": {
      source: "iana",
      extensions: ["pcl"]
    },
    "application/vnd.hp-pclxl": {
      source: "iana",
      extensions: ["pclxl"]
    },
    "application/vnd.httphone": {
      source: "iana"
    },
    "application/vnd.hydrostatix.sof-data": {
      source: "iana",
      extensions: ["sfd-hdstx"]
    },
    "application/vnd.hyper+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyper-item+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyperdrive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hzn-3d-crossword": {
      source: "iana"
    },
    "application/vnd.ibm.afplinedata": {
      source: "iana"
    },
    "application/vnd.ibm.electronic-media": {
      source: "iana"
    },
    "application/vnd.ibm.minipay": {
      source: "iana",
      extensions: ["mpy"]
    },
    "application/vnd.ibm.modcap": {
      source: "iana",
      extensions: ["afp", "listafp", "list3820"]
    },
    "application/vnd.ibm.rights-management": {
      source: "iana",
      extensions: ["irm"]
    },
    "application/vnd.ibm.secure-container": {
      source: "iana",
      extensions: ["sc"]
    },
    "application/vnd.iccprofile": {
      source: "iana",
      extensions: ["icc", "icm"]
    },
    "application/vnd.ieee.1905": {
      source: "iana"
    },
    "application/vnd.igloader": {
      source: "iana",
      extensions: ["igl"]
    },
    "application/vnd.imagemeter.folder+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.imagemeter.image+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.immervision-ivp": {
      source: "iana",
      extensions: ["ivp"]
    },
    "application/vnd.immervision-ivu": {
      source: "iana",
      extensions: ["ivu"]
    },
    "application/vnd.ims.imsccv1p1": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p2": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p3": {
      source: "iana"
    },
    "application/vnd.ims.lis.v2.result+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informedcontrol.rms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informix-visionary": {
      source: "iana"
    },
    "application/vnd.infotech.project": {
      source: "iana"
    },
    "application/vnd.infotech.project+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.innopath.wamp.notification": {
      source: "iana"
    },
    "application/vnd.insors.igm": {
      source: "iana",
      extensions: ["igm"]
    },
    "application/vnd.intercon.formnet": {
      source: "iana",
      extensions: ["xpw", "xpx"]
    },
    "application/vnd.intergeo": {
      source: "iana",
      extensions: ["i2g"]
    },
    "application/vnd.intertrust.digibox": {
      source: "iana"
    },
    "application/vnd.intertrust.nncp": {
      source: "iana"
    },
    "application/vnd.intu.qbo": {
      source: "iana",
      extensions: ["qbo"]
    },
    "application/vnd.intu.qfx": {
      source: "iana",
      extensions: ["qfx"]
    },
    "application/vnd.iptc.g2.catalogitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.packageitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.planningitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ipunplugged.rcprofile": {
      source: "iana",
      extensions: ["rcprofile"]
    },
    "application/vnd.irepository.package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["irp"]
    },
    "application/vnd.is-xpr": {
      source: "iana",
      extensions: ["xpr"]
    },
    "application/vnd.isac.fcs": {
      source: "iana",
      extensions: ["fcs"]
    },
    "application/vnd.iso11783-10+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.jam": {
      source: "iana",
      extensions: ["jam"]
    },
    "application/vnd.japannet-directory-service": {
      source: "iana"
    },
    "application/vnd.japannet-jpnstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-payment-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-registration": {
      source: "iana"
    },
    "application/vnd.japannet-registration-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-setstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-verification": {
      source: "iana"
    },
    "application/vnd.japannet-verification-wakeup": {
      source: "iana"
    },
    "application/vnd.jcp.javame.midlet-rms": {
      source: "iana",
      extensions: ["rms"]
    },
    "application/vnd.jisp": {
      source: "iana",
      extensions: ["jisp"]
    },
    "application/vnd.joost.joda-archive": {
      source: "iana",
      extensions: ["joda"]
    },
    "application/vnd.jsk.isdn-ngn": {
      source: "iana"
    },
    "application/vnd.kahootz": {
      source: "iana",
      extensions: ["ktz", "ktr"]
    },
    "application/vnd.kde.karbon": {
      source: "iana",
      extensions: ["karbon"]
    },
    "application/vnd.kde.kchart": {
      source: "iana",
      extensions: ["chrt"]
    },
    "application/vnd.kde.kformula": {
      source: "iana",
      extensions: ["kfo"]
    },
    "application/vnd.kde.kivio": {
      source: "iana",
      extensions: ["flw"]
    },
    "application/vnd.kde.kontour": {
      source: "iana",
      extensions: ["kon"]
    },
    "application/vnd.kde.kpresenter": {
      source: "iana",
      extensions: ["kpr", "kpt"]
    },
    "application/vnd.kde.kspread": {
      source: "iana",
      extensions: ["ksp"]
    },
    "application/vnd.kde.kword": {
      source: "iana",
      extensions: ["kwd", "kwt"]
    },
    "application/vnd.kenameaapp": {
      source: "iana",
      extensions: ["htke"]
    },
    "application/vnd.kidspiration": {
      source: "iana",
      extensions: ["kia"]
    },
    "application/vnd.kinar": {
      source: "iana",
      extensions: ["kne", "knp"]
    },
    "application/vnd.koan": {
      source: "iana",
      extensions: ["skp", "skd", "skt", "skm"]
    },
    "application/vnd.kodak-descriptor": {
      source: "iana",
      extensions: ["sse"]
    },
    "application/vnd.las": {
      source: "iana"
    },
    "application/vnd.las.las+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.las.las+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lasxml"]
    },
    "application/vnd.laszip": {
      source: "iana"
    },
    "application/vnd.leap+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.liberty-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.llamagraphics.life-balance.desktop": {
      source: "iana",
      extensions: ["lbd"]
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lbe"]
    },
    "application/vnd.logipipe.circuit+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.loom": {
      source: "iana"
    },
    "application/vnd.lotus-1-2-3": {
      source: "iana",
      extensions: ["123"]
    },
    "application/vnd.lotus-approach": {
      source: "iana",
      extensions: ["apr"]
    },
    "application/vnd.lotus-freelance": {
      source: "iana",
      extensions: ["pre"]
    },
    "application/vnd.lotus-notes": {
      source: "iana",
      extensions: ["nsf"]
    },
    "application/vnd.lotus-organizer": {
      source: "iana",
      extensions: ["org"]
    },
    "application/vnd.lotus-screencam": {
      source: "iana",
      extensions: ["scm"]
    },
    "application/vnd.lotus-wordpro": {
      source: "iana",
      extensions: ["lwp"]
    },
    "application/vnd.macports.portpkg": {
      source: "iana",
      extensions: ["portpkg"]
    },
    "application/vnd.mapbox-vector-tile": {
      source: "iana",
      extensions: ["mvt"]
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.conftoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.license+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.mdcf": {
      source: "iana"
    },
    "application/vnd.mason+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.maxar.archive.3tz+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.maxmind.maxmind-db": {
      source: "iana"
    },
    "application/vnd.mcd": {
      source: "iana",
      extensions: ["mcd"]
    },
    "application/vnd.medcalcdata": {
      source: "iana",
      extensions: ["mc1"]
    },
    "application/vnd.mediastation.cdkey": {
      source: "iana",
      extensions: ["cdkey"]
    },
    "application/vnd.meridian-slingshot": {
      source: "iana"
    },
    "application/vnd.mfer": {
      source: "iana",
      extensions: ["mwf"]
    },
    "application/vnd.mfmp": {
      source: "iana",
      extensions: ["mfm"]
    },
    "application/vnd.micro+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.micrografx.flo": {
      source: "iana",
      extensions: ["flo"]
    },
    "application/vnd.micrografx.igx": {
      source: "iana",
      extensions: ["igx"]
    },
    "application/vnd.microsoft.portable-executable": {
      source: "iana"
    },
    "application/vnd.microsoft.windows.thumbnail-cache": {
      source: "iana"
    },
    "application/vnd.miele+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.mif": {
      source: "iana",
      extensions: ["mif"]
    },
    "application/vnd.minisoft-hp3000-save": {
      source: "iana"
    },
    "application/vnd.mitsubishi.misty-guard.trustweb": {
      source: "iana"
    },
    "application/vnd.mobius.daf": {
      source: "iana",
      extensions: ["daf"]
    },
    "application/vnd.mobius.dis": {
      source: "iana",
      extensions: ["dis"]
    },
    "application/vnd.mobius.mbk": {
      source: "iana",
      extensions: ["mbk"]
    },
    "application/vnd.mobius.mqy": {
      source: "iana",
      extensions: ["mqy"]
    },
    "application/vnd.mobius.msl": {
      source: "iana",
      extensions: ["msl"]
    },
    "application/vnd.mobius.plc": {
      source: "iana",
      extensions: ["plc"]
    },
    "application/vnd.mobius.txf": {
      source: "iana",
      extensions: ["txf"]
    },
    "application/vnd.mophun.application": {
      source: "iana",
      extensions: ["mpn"]
    },
    "application/vnd.mophun.certificate": {
      source: "iana",
      extensions: ["mpc"]
    },
    "application/vnd.motorola.flexsuite": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.adsi": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.fis": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.gotap": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.kmr": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.ttc": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.wem": {
      source: "iana"
    },
    "application/vnd.motorola.iprm": {
      source: "iana"
    },
    "application/vnd.mozilla.xul+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xul"]
    },
    "application/vnd.ms-3mfdocument": {
      source: "iana"
    },
    "application/vnd.ms-artgalry": {
      source: "iana",
      extensions: ["cil"]
    },
    "application/vnd.ms-asf": {
      source: "iana"
    },
    "application/vnd.ms-cab-compressed": {
      source: "iana",
      extensions: ["cab"]
    },
    "application/vnd.ms-color.iccprofile": {
      source: "apache"
    },
    "application/vnd.ms-excel": {
      source: "iana",
      compressible: false,
      extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
      source: "iana",
      extensions: ["xlam"]
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
      source: "iana",
      extensions: ["xlsb"]
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
      source: "iana",
      extensions: ["xlsm"]
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
      source: "iana",
      extensions: ["xltm"]
    },
    "application/vnd.ms-fontobject": {
      source: "iana",
      compressible: true,
      extensions: ["eot"]
    },
    "application/vnd.ms-htmlhelp": {
      source: "iana",
      extensions: ["chm"]
    },
    "application/vnd.ms-ims": {
      source: "iana",
      extensions: ["ims"]
    },
    "application/vnd.ms-lrm": {
      source: "iana",
      extensions: ["lrm"]
    },
    "application/vnd.ms-office.activex+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-officetheme": {
      source: "iana",
      extensions: ["thmx"]
    },
    "application/vnd.ms-opentype": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-outlook": {
      compressible: false,
      extensions: ["msg"]
    },
    "application/vnd.ms-package.obfuscated-opentype": {
      source: "apache"
    },
    "application/vnd.ms-pki.seccat": {
      source: "apache",
      extensions: ["cat"]
    },
    "application/vnd.ms-pki.stl": {
      source: "apache",
      extensions: ["stl"]
    },
    "application/vnd.ms-playready.initiator+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-powerpoint": {
      source: "iana",
      compressible: false,
      extensions: ["ppt", "pps", "pot"]
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
      source: "iana",
      extensions: ["ppam"]
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
      source: "iana",
      extensions: ["pptm"]
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
      source: "iana",
      extensions: ["sldm"]
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
      source: "iana",
      extensions: ["ppsm"]
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
      source: "iana",
      extensions: ["potm"]
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-printing.printticket+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-printschematicket+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-project": {
      source: "iana",
      extensions: ["mpp", "mpt"]
    },
    "application/vnd.ms-tnef": {
      source: "iana"
    },
    "application/vnd.ms-windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.nwprinting.oob": {
      source: "iana"
    },
    "application/vnd.ms-windows.printerpairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.wsd.oob": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-resp": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-resp": {
      source: "iana"
    },
    "application/vnd.ms-word.document.macroenabled.12": {
      source: "iana",
      extensions: ["docm"]
    },
    "application/vnd.ms-word.template.macroenabled.12": {
      source: "iana",
      extensions: ["dotm"]
    },
    "application/vnd.ms-works": {
      source: "iana",
      extensions: ["wps", "wks", "wcm", "wdb"]
    },
    "application/vnd.ms-wpl": {
      source: "iana",
      extensions: ["wpl"]
    },
    "application/vnd.ms-xpsdocument": {
      source: "iana",
      compressible: false,
      extensions: ["xps"]
    },
    "application/vnd.msa-disk-image": {
      source: "iana"
    },
    "application/vnd.mseq": {
      source: "iana",
      extensions: ["mseq"]
    },
    "application/vnd.msign": {
      source: "iana"
    },
    "application/vnd.multiad.creator": {
      source: "iana"
    },
    "application/vnd.multiad.creator.cif": {
      source: "iana"
    },
    "application/vnd.music-niff": {
      source: "iana"
    },
    "application/vnd.musician": {
      source: "iana",
      extensions: ["mus"]
    },
    "application/vnd.muvee.style": {
      source: "iana",
      extensions: ["msty"]
    },
    "application/vnd.mynfc": {
      source: "iana",
      extensions: ["taglet"]
    },
    "application/vnd.nacamar.ybrid+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ncd.control": {
      source: "iana"
    },
    "application/vnd.ncd.reference": {
      source: "iana"
    },
    "application/vnd.nearst.inv+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nebumind.line": {
      source: "iana"
    },
    "application/vnd.nervana": {
      source: "iana"
    },
    "application/vnd.netfpx": {
      source: "iana"
    },
    "application/vnd.neurolanguage.nlu": {
      source: "iana",
      extensions: ["nlu"]
    },
    "application/vnd.nimn": {
      source: "iana"
    },
    "application/vnd.nintendo.nitro.rom": {
      source: "iana"
    },
    "application/vnd.nintendo.snes.rom": {
      source: "iana"
    },
    "application/vnd.nitf": {
      source: "iana",
      extensions: ["ntf", "nitf"]
    },
    "application/vnd.noblenet-directory": {
      source: "iana",
      extensions: ["nnd"]
    },
    "application/vnd.noblenet-sealer": {
      source: "iana",
      extensions: ["nns"]
    },
    "application/vnd.noblenet-web": {
      source: "iana",
      extensions: ["nnw"]
    },
    "application/vnd.nokia.catalogs": {
      source: "iana"
    },
    "application/vnd.nokia.conml+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.conml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.iptv.config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.isds-radio-presets": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.landmarkcollection+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.n-gage.ac+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ac"]
    },
    "application/vnd.nokia.n-gage.data": {
      source: "iana",
      extensions: ["ngdat"]
    },
    "application/vnd.nokia.n-gage.symbian.install": {
      source: "iana",
      extensions: ["n-gage"]
    },
    "application/vnd.nokia.ncd": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.radio-preset": {
      source: "iana",
      extensions: ["rpst"]
    },
    "application/vnd.nokia.radio-presets": {
      source: "iana",
      extensions: ["rpss"]
    },
    "application/vnd.novadigm.edm": {
      source: "iana",
      extensions: ["edm"]
    },
    "application/vnd.novadigm.edx": {
      source: "iana",
      extensions: ["edx"]
    },
    "application/vnd.novadigm.ext": {
      source: "iana",
      extensions: ["ext"]
    },
    "application/vnd.ntt-local.content-share": {
      source: "iana"
    },
    "application/vnd.ntt-local.file-transfer": {
      source: "iana"
    },
    "application/vnd.ntt-local.ogw_remote-access": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_remote": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_tcp_stream": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.chart": {
      source: "iana",
      extensions: ["odc"]
    },
    "application/vnd.oasis.opendocument.chart-template": {
      source: "iana",
      extensions: ["otc"]
    },
    "application/vnd.oasis.opendocument.database": {
      source: "iana",
      extensions: ["odb"]
    },
    "application/vnd.oasis.opendocument.formula": {
      source: "iana",
      extensions: ["odf"]
    },
    "application/vnd.oasis.opendocument.formula-template": {
      source: "iana",
      extensions: ["odft"]
    },
    "application/vnd.oasis.opendocument.graphics": {
      source: "iana",
      compressible: false,
      extensions: ["odg"]
    },
    "application/vnd.oasis.opendocument.graphics-template": {
      source: "iana",
      extensions: ["otg"]
    },
    "application/vnd.oasis.opendocument.image": {
      source: "iana",
      extensions: ["odi"]
    },
    "application/vnd.oasis.opendocument.image-template": {
      source: "iana",
      extensions: ["oti"]
    },
    "application/vnd.oasis.opendocument.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["odp"]
    },
    "application/vnd.oasis.opendocument.presentation-template": {
      source: "iana",
      extensions: ["otp"]
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
      source: "iana",
      compressible: false,
      extensions: ["ods"]
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
      source: "iana",
      extensions: ["ots"]
    },
    "application/vnd.oasis.opendocument.text": {
      source: "iana",
      compressible: false,
      extensions: ["odt"]
    },
    "application/vnd.oasis.opendocument.text-master": {
      source: "iana",
      extensions: ["odm"]
    },
    "application/vnd.oasis.opendocument.text-template": {
      source: "iana",
      extensions: ["ott"]
    },
    "application/vnd.oasis.opendocument.text-web": {
      source: "iana",
      extensions: ["oth"]
    },
    "application/vnd.obn": {
      source: "iana"
    },
    "application/vnd.ocf+cbor": {
      source: "iana"
    },
    "application/vnd.oci.image.manifest.v1+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oftn.l10n+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessdownload+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.cspg-hexbinary": {
      source: "iana"
    },
    "application/vnd.oipf.dae.svg+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.dae.xhtml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.pae.gem": {
      source: "iana"
    },
    "application/vnd.oipf.spdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.spdlist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.ueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.userprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.olpc-sugar": {
      source: "iana",
      extensions: ["xo"]
    },
    "application/vnd.oma-scws-config": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-request": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-response": {
      source: "iana"
    },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.imd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.ltkm": {
      source: "iana"
    },
    "application/vnd.oma.bcast.notification+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.provisioningtrigger": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgboot": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgdd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sgdu": {
      source: "iana"
    },
    "application/vnd.oma.bcast.simple-symbol-container": {
      source: "iana"
    },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sprov+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.stkm": {
      source: "iana"
    },
    "application/vnd.oma.cab-address-book+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-feature-handler+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-pcc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-subs-invite+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-user-prefs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.dcd": {
      source: "iana"
    },
    "application/vnd.oma.dcdc": {
      source: "iana"
    },
    "application/vnd.oma.dd2+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dd2"]
    },
    "application/vnd.oma.drm.risd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.group-usage-list+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+cbor": {
      source: "iana"
    },
    "application/vnd.oma.lwm2m+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+tlv": {
      source: "iana"
    },
    "application/vnd.oma.pal+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.final-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.groups+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.push": {
      source: "iana"
    },
    "application/vnd.oma.scidm.messages+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.xcap-directory+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.omads-email+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-file+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-folder+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omaloc-supl-init": {
      source: "iana"
    },
    "application/vnd.onepager": {
      source: "iana"
    },
    "application/vnd.onepagertamp": {
      source: "iana"
    },
    "application/vnd.onepagertamx": {
      source: "iana"
    },
    "application/vnd.onepagertat": {
      source: "iana"
    },
    "application/vnd.onepagertatp": {
      source: "iana"
    },
    "application/vnd.onepagertatx": {
      source: "iana"
    },
    "application/vnd.openblox.game+xml": {
      source: "iana",
      compressible: true,
      extensions: ["obgx"]
    },
    "application/vnd.openblox.game-binary": {
      source: "iana"
    },
    "application/vnd.openeye.oeb": {
      source: "iana"
    },
    "application/vnd.openofficeorg.extension": {
      source: "apache",
      extensions: ["oxt"]
    },
    "application/vnd.openstreetmap.data+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osm"]
    },
    "application/vnd.opentimestamps.ots": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["pptx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
      source: "iana",
      extensions: ["sldx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
      source: "iana",
      extensions: ["ppsx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
      source: "iana",
      extensions: ["potx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
      source: "iana",
      compressible: false,
      extensions: ["xlsx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
      source: "iana",
      extensions: ["xltx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
      source: "iana",
      compressible: false,
      extensions: ["docx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
      source: "iana",
      extensions: ["dotx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.core-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.relationships+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oracle.resource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.orange.indata": {
      source: "iana"
    },
    "application/vnd.osa.netdeploy": {
      source: "iana"
    },
    "application/vnd.osgeo.mapguide.package": {
      source: "iana",
      extensions: ["mgp"]
    },
    "application/vnd.osgi.bundle": {
      source: "iana"
    },
    "application/vnd.osgi.dp": {
      source: "iana",
      extensions: ["dp"]
    },
    "application/vnd.osgi.subsystem": {
      source: "iana",
      extensions: ["esa"]
    },
    "application/vnd.otps.ct-kip+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oxli.countgraph": {
      source: "iana"
    },
    "application/vnd.pagerduty+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.palm": {
      source: "iana",
      extensions: ["pdb", "pqa", "oprc"]
    },
    "application/vnd.panoply": {
      source: "iana"
    },
    "application/vnd.paos.xml": {
      source: "iana"
    },
    "application/vnd.patentdive": {
      source: "iana"
    },
    "application/vnd.patientecommsdoc": {
      source: "iana"
    },
    "application/vnd.pawaafile": {
      source: "iana",
      extensions: ["paw"]
    },
    "application/vnd.pcos": {
      source: "iana"
    },
    "application/vnd.pg.format": {
      source: "iana",
      extensions: ["str"]
    },
    "application/vnd.pg.osasli": {
      source: "iana",
      extensions: ["ei6"]
    },
    "application/vnd.piaccess.application-licence": {
      source: "iana"
    },
    "application/vnd.picsel": {
      source: "iana",
      extensions: ["efif"]
    },
    "application/vnd.pmi.widget": {
      source: "iana",
      extensions: ["wg"]
    },
    "application/vnd.poc.group-advertisement+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.pocketlearn": {
      source: "iana",
      extensions: ["plf"]
    },
    "application/vnd.powerbuilder6": {
      source: "iana",
      extensions: ["pbd"]
    },
    "application/vnd.powerbuilder6-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder7": {
      source: "iana"
    },
    "application/vnd.powerbuilder7-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder75": {
      source: "iana"
    },
    "application/vnd.powerbuilder75-s": {
      source: "iana"
    },
    "application/vnd.preminet": {
      source: "iana"
    },
    "application/vnd.previewsystems.box": {
      source: "iana",
      extensions: ["box"]
    },
    "application/vnd.proteus.magazine": {
      source: "iana",
      extensions: ["mgz"]
    },
    "application/vnd.psfs": {
      source: "iana"
    },
    "application/vnd.publishare-delta-tree": {
      source: "iana",
      extensions: ["qps"]
    },
    "application/vnd.pvi.ptid1": {
      source: "iana",
      extensions: ["ptid"]
    },
    "application/vnd.pwg-multiplexed": {
      source: "iana"
    },
    "application/vnd.pwg-xhtml-print+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.qualcomm.brew-app-res": {
      source: "iana"
    },
    "application/vnd.quarantainenet": {
      source: "iana"
    },
    "application/vnd.quark.quarkxpress": {
      source: "iana",
      extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
    },
    "application/vnd.quobject-quoxdocument": {
      source: "iana"
    },
    "application/vnd.radisys.moml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rainstor.data": {
      source: "iana"
    },
    "application/vnd.rapid": {
      source: "iana"
    },
    "application/vnd.rar": {
      source: "iana",
      extensions: ["rar"]
    },
    "application/vnd.realvnc.bed": {
      source: "iana",
      extensions: ["bed"]
    },
    "application/vnd.recordare.musicxml": {
      source: "iana",
      extensions: ["mxl"]
    },
    "application/vnd.recordare.musicxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musicxml"]
    },
    "application/vnd.renlearn.rlprint": {
      source: "iana"
    },
    "application/vnd.resilient.logic": {
      source: "iana"
    },
    "application/vnd.restful+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rig.cryptonote": {
      source: "iana",
      extensions: ["cryptonote"]
    },
    "application/vnd.rim.cod": {
      source: "apache",
      extensions: ["cod"]
    },
    "application/vnd.rn-realmedia": {
      source: "apache",
      extensions: ["rm"]
    },
    "application/vnd.rn-realmedia-vbr": {
      source: "apache",
      extensions: ["rmvb"]
    },
    "application/vnd.route66.link66+xml": {
      source: "iana",
      compressible: true,
      extensions: ["link66"]
    },
    "application/vnd.rs-274x": {
      source: "iana"
    },
    "application/vnd.ruckus.download": {
      source: "iana"
    },
    "application/vnd.s3sms": {
      source: "iana"
    },
    "application/vnd.sailingtracker.track": {
      source: "iana",
      extensions: ["st"]
    },
    "application/vnd.sar": {
      source: "iana"
    },
    "application/vnd.sbm.cid": {
      source: "iana"
    },
    "application/vnd.sbm.mid2": {
      source: "iana"
    },
    "application/vnd.scribus": {
      source: "iana"
    },
    "application/vnd.sealed.3df": {
      source: "iana"
    },
    "application/vnd.sealed.csf": {
      source: "iana"
    },
    "application/vnd.sealed.doc": {
      source: "iana"
    },
    "application/vnd.sealed.eml": {
      source: "iana"
    },
    "application/vnd.sealed.mht": {
      source: "iana"
    },
    "application/vnd.sealed.net": {
      source: "iana"
    },
    "application/vnd.sealed.ppt": {
      source: "iana"
    },
    "application/vnd.sealed.tiff": {
      source: "iana"
    },
    "application/vnd.sealed.xls": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.html": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.pdf": {
      source: "iana"
    },
    "application/vnd.seemail": {
      source: "iana",
      extensions: ["see"]
    },
    "application/vnd.seis+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.sema": {
      source: "iana",
      extensions: ["sema"]
    },
    "application/vnd.semd": {
      source: "iana",
      extensions: ["semd"]
    },
    "application/vnd.semf": {
      source: "iana",
      extensions: ["semf"]
    },
    "application/vnd.shade-save-file": {
      source: "iana"
    },
    "application/vnd.shana.informed.formdata": {
      source: "iana",
      extensions: ["ifm"]
    },
    "application/vnd.shana.informed.formtemplate": {
      source: "iana",
      extensions: ["itp"]
    },
    "application/vnd.shana.informed.interchange": {
      source: "iana",
      extensions: ["iif"]
    },
    "application/vnd.shana.informed.package": {
      source: "iana",
      extensions: ["ipk"]
    },
    "application/vnd.shootproof+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shopkick+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shp": {
      source: "iana"
    },
    "application/vnd.shx": {
      source: "iana"
    },
    "application/vnd.sigrok.session": {
      source: "iana"
    },
    "application/vnd.simtech-mindmapper": {
      source: "iana",
      extensions: ["twd", "twds"]
    },
    "application/vnd.siren+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.smaf": {
      source: "iana",
      extensions: ["mmf"]
    },
    "application/vnd.smart.notebook": {
      source: "iana"
    },
    "application/vnd.smart.teacher": {
      source: "iana",
      extensions: ["teacher"]
    },
    "application/vnd.snesdev-page-table": {
      source: "iana"
    },
    "application/vnd.software602.filler.form+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fo"]
    },
    "application/vnd.software602.filler.form-xml-zip": {
      source: "iana"
    },
    "application/vnd.solent.sdkm+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sdkm", "sdkd"]
    },
    "application/vnd.spotfire.dxp": {
      source: "iana",
      extensions: ["dxp"]
    },
    "application/vnd.spotfire.sfs": {
      source: "iana",
      extensions: ["sfs"]
    },
    "application/vnd.sqlite3": {
      source: "iana"
    },
    "application/vnd.sss-cod": {
      source: "iana"
    },
    "application/vnd.sss-dtf": {
      source: "iana"
    },
    "application/vnd.sss-ntf": {
      source: "iana"
    },
    "application/vnd.stardivision.calc": {
      source: "apache",
      extensions: ["sdc"]
    },
    "application/vnd.stardivision.draw": {
      source: "apache",
      extensions: ["sda"]
    },
    "application/vnd.stardivision.impress": {
      source: "apache",
      extensions: ["sdd"]
    },
    "application/vnd.stardivision.math": {
      source: "apache",
      extensions: ["smf"]
    },
    "application/vnd.stardivision.writer": {
      source: "apache",
      extensions: ["sdw", "vor"]
    },
    "application/vnd.stardivision.writer-global": {
      source: "apache",
      extensions: ["sgl"]
    },
    "application/vnd.stepmania.package": {
      source: "iana",
      extensions: ["smzip"]
    },
    "application/vnd.stepmania.stepchart": {
      source: "iana",
      extensions: ["sm"]
    },
    "application/vnd.street-stream": {
      source: "iana"
    },
    "application/vnd.sun.wadl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wadl"]
    },
    "application/vnd.sun.xml.calc": {
      source: "apache",
      extensions: ["sxc"]
    },
    "application/vnd.sun.xml.calc.template": {
      source: "apache",
      extensions: ["stc"]
    },
    "application/vnd.sun.xml.draw": {
      source: "apache",
      extensions: ["sxd"]
    },
    "application/vnd.sun.xml.draw.template": {
      source: "apache",
      extensions: ["std"]
    },
    "application/vnd.sun.xml.impress": {
      source: "apache",
      extensions: ["sxi"]
    },
    "application/vnd.sun.xml.impress.template": {
      source: "apache",
      extensions: ["sti"]
    },
    "application/vnd.sun.xml.math": {
      source: "apache",
      extensions: ["sxm"]
    },
    "application/vnd.sun.xml.writer": {
      source: "apache",
      extensions: ["sxw"]
    },
    "application/vnd.sun.xml.writer.global": {
      source: "apache",
      extensions: ["sxg"]
    },
    "application/vnd.sun.xml.writer.template": {
      source: "apache",
      extensions: ["stw"]
    },
    "application/vnd.sus-calendar": {
      source: "iana",
      extensions: ["sus", "susp"]
    },
    "application/vnd.svd": {
      source: "iana",
      extensions: ["svd"]
    },
    "application/vnd.swiftview-ics": {
      source: "iana"
    },
    "application/vnd.sycle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.syft+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.symbian.install": {
      source: "apache",
      extensions: ["sis", "sisx"]
    },
    "application/vnd.syncml+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xsm"]
    },
    "application/vnd.syncml.dm+wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["bdm"]
    },
    "application/vnd.syncml.dm+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xdm"]
    },
    "application/vnd.syncml.dm.notification": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["ddf"]
    },
    "application/vnd.syncml.dmtnds+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmtnds+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.syncml.ds.notification": {
      source: "iana"
    },
    "application/vnd.tableschema+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tao.intent-module-archive": {
      source: "iana",
      extensions: ["tao"]
    },
    "application/vnd.tcpdump.pcap": {
      source: "iana",
      extensions: ["pcap", "cap", "dmp"]
    },
    "application/vnd.think-cell.ppttc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tmd.mediaflex.api+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tml": {
      source: "iana"
    },
    "application/vnd.tmobile-livetv": {
      source: "iana",
      extensions: ["tmo"]
    },
    "application/vnd.tri.onesource": {
      source: "iana"
    },
    "application/vnd.trid.tpt": {
      source: "iana",
      extensions: ["tpt"]
    },
    "application/vnd.triscape.mxs": {
      source: "iana",
      extensions: ["mxs"]
    },
    "application/vnd.trueapp": {
      source: "iana",
      extensions: ["tra"]
    },
    "application/vnd.truedoc": {
      source: "iana"
    },
    "application/vnd.ubisoft.webplayer": {
      source: "iana"
    },
    "application/vnd.ufdl": {
      source: "iana",
      extensions: ["ufd", "ufdl"]
    },
    "application/vnd.uiq.theme": {
      source: "iana",
      extensions: ["utz"]
    },
    "application/vnd.umajin": {
      source: "iana",
      extensions: ["umj"]
    },
    "application/vnd.unity": {
      source: "iana",
      extensions: ["unityweb"]
    },
    "application/vnd.uoml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uoml"]
    },
    "application/vnd.uplanet.alert": {
      source: "iana"
    },
    "application/vnd.uplanet.alert-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.channel": {
      source: "iana"
    },
    "application/vnd.uplanet.channel-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.list": {
      source: "iana"
    },
    "application/vnd.uplanet.list-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.signal": {
      source: "iana"
    },
    "application/vnd.uri-map": {
      source: "iana"
    },
    "application/vnd.valve.source.material": {
      source: "iana"
    },
    "application/vnd.vcx": {
      source: "iana",
      extensions: ["vcx"]
    },
    "application/vnd.vd-study": {
      source: "iana"
    },
    "application/vnd.vectorworks": {
      source: "iana"
    },
    "application/vnd.vel+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.verimatrix.vcas": {
      source: "iana"
    },
    "application/vnd.veritone.aion+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.veryant.thin": {
      source: "iana"
    },
    "application/vnd.ves.encrypted": {
      source: "iana"
    },
    "application/vnd.vidsoft.vidconference": {
      source: "iana"
    },
    "application/vnd.visio": {
      source: "iana",
      extensions: ["vsd", "vst", "vss", "vsw"]
    },
    "application/vnd.visionary": {
      source: "iana",
      extensions: ["vis"]
    },
    "application/vnd.vividence.scriptfile": {
      source: "iana"
    },
    "application/vnd.vsf": {
      source: "iana",
      extensions: ["vsf"]
    },
    "application/vnd.wap.sic": {
      source: "iana"
    },
    "application/vnd.wap.slc": {
      source: "iana"
    },
    "application/vnd.wap.wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["wbxml"]
    },
    "application/vnd.wap.wmlc": {
      source: "iana",
      extensions: ["wmlc"]
    },
    "application/vnd.wap.wmlscriptc": {
      source: "iana",
      extensions: ["wmlsc"]
    },
    "application/vnd.webturbo": {
      source: "iana",
      extensions: ["wtb"]
    },
    "application/vnd.wfa.dpp": {
      source: "iana"
    },
    "application/vnd.wfa.p2p": {
      source: "iana"
    },
    "application/vnd.wfa.wsc": {
      source: "iana"
    },
    "application/vnd.windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.wmc": {
      source: "iana"
    },
    "application/vnd.wmf.bootstrap": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica.package": {
      source: "iana"
    },
    "application/vnd.wolfram.player": {
      source: "iana",
      extensions: ["nbp"]
    },
    "application/vnd.wordperfect": {
      source: "iana",
      extensions: ["wpd"]
    },
    "application/vnd.wqd": {
      source: "iana",
      extensions: ["wqd"]
    },
    "application/vnd.wrq-hp3000-labelled": {
      source: "iana"
    },
    "application/vnd.wt.stf": {
      source: "iana",
      extensions: ["stf"]
    },
    "application/vnd.wv.csp+wbxml": {
      source: "iana"
    },
    "application/vnd.wv.csp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.wv.ssp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xacml+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xara": {
      source: "iana",
      extensions: ["xar"]
    },
    "application/vnd.xfdl": {
      source: "iana",
      extensions: ["xfdl"]
    },
    "application/vnd.xfdl.webform": {
      source: "iana"
    },
    "application/vnd.xmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xmpie.cpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.dpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.plan": {
      source: "iana"
    },
    "application/vnd.xmpie.ppkg": {
      source: "iana"
    },
    "application/vnd.xmpie.xlim": {
      source: "iana"
    },
    "application/vnd.yamaha.hv-dic": {
      source: "iana",
      extensions: ["hvd"]
    },
    "application/vnd.yamaha.hv-script": {
      source: "iana",
      extensions: ["hvs"]
    },
    "application/vnd.yamaha.hv-voice": {
      source: "iana",
      extensions: ["hvp"]
    },
    "application/vnd.yamaha.openscoreformat": {
      source: "iana",
      extensions: ["osf"]
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osfpvg"]
    },
    "application/vnd.yamaha.remote-setup": {
      source: "iana"
    },
    "application/vnd.yamaha.smaf-audio": {
      source: "iana",
      extensions: ["saf"]
    },
    "application/vnd.yamaha.smaf-phrase": {
      source: "iana",
      extensions: ["spf"]
    },
    "application/vnd.yamaha.through-ngn": {
      source: "iana"
    },
    "application/vnd.yamaha.tunnel-udpencap": {
      source: "iana"
    },
    "application/vnd.yaoweme": {
      source: "iana"
    },
    "application/vnd.yellowriver-custom-menu": {
      source: "iana",
      extensions: ["cmp"]
    },
    "application/vnd.youtube.yt": {
      source: "iana"
    },
    "application/vnd.zul": {
      source: "iana",
      extensions: ["zir", "zirz"]
    },
    "application/vnd.zzazz.deck+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zaz"]
    },
    "application/voicexml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["vxml"]
    },
    "application/voucher-cms+json": {
      source: "iana",
      compressible: true
    },
    "application/vq-rtcpxr": {
      source: "iana"
    },
    "application/wasm": {
      source: "iana",
      compressible: true,
      extensions: ["wasm"]
    },
    "application/watcherinfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wif"]
    },
    "application/webpush-options+json": {
      source: "iana",
      compressible: true
    },
    "application/whoispp-query": {
      source: "iana"
    },
    "application/whoispp-response": {
      source: "iana"
    },
    "application/widget": {
      source: "iana",
      extensions: ["wgt"]
    },
    "application/winhlp": {
      source: "apache",
      extensions: ["hlp"]
    },
    "application/wita": {
      source: "iana"
    },
    "application/wordperfect5.1": {
      source: "iana"
    },
    "application/wsdl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wsdl"]
    },
    "application/wspolicy+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wspolicy"]
    },
    "application/x-7z-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["7z"]
    },
    "application/x-abiword": {
      source: "apache",
      extensions: ["abw"]
    },
    "application/x-ace-compressed": {
      source: "apache",
      extensions: ["ace"]
    },
    "application/x-amf": {
      source: "apache"
    },
    "application/x-apple-diskimage": {
      source: "apache",
      extensions: ["dmg"]
    },
    "application/x-arj": {
      compressible: false,
      extensions: ["arj"]
    },
    "application/x-authorware-bin": {
      source: "apache",
      extensions: ["aab", "x32", "u32", "vox"]
    },
    "application/x-authorware-map": {
      source: "apache",
      extensions: ["aam"]
    },
    "application/x-authorware-seg": {
      source: "apache",
      extensions: ["aas"]
    },
    "application/x-bcpio": {
      source: "apache",
      extensions: ["bcpio"]
    },
    "application/x-bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/x-bittorrent": {
      source: "apache",
      extensions: ["torrent"]
    },
    "application/x-blorb": {
      source: "apache",
      extensions: ["blb", "blorb"]
    },
    "application/x-bzip": {
      source: "apache",
      compressible: false,
      extensions: ["bz"]
    },
    "application/x-bzip2": {
      source: "apache",
      compressible: false,
      extensions: ["bz2", "boz"]
    },
    "application/x-cbr": {
      source: "apache",
      extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
    },
    "application/x-cdlink": {
      source: "apache",
      extensions: ["vcd"]
    },
    "application/x-cfs-compressed": {
      source: "apache",
      extensions: ["cfs"]
    },
    "application/x-chat": {
      source: "apache",
      extensions: ["chat"]
    },
    "application/x-chess-pgn": {
      source: "apache",
      extensions: ["pgn"]
    },
    "application/x-chrome-extension": {
      extensions: ["crx"]
    },
    "application/x-cocoa": {
      source: "nginx",
      extensions: ["cco"]
    },
    "application/x-compress": {
      source: "apache"
    },
    "application/x-conference": {
      source: "apache",
      extensions: ["nsc"]
    },
    "application/x-cpio": {
      source: "apache",
      extensions: ["cpio"]
    },
    "application/x-csh": {
      source: "apache",
      extensions: ["csh"]
    },
    "application/x-deb": {
      compressible: false
    },
    "application/x-debian-package": {
      source: "apache",
      extensions: ["deb", "udeb"]
    },
    "application/x-dgc-compressed": {
      source: "apache",
      extensions: ["dgc"]
    },
    "application/x-director": {
      source: "apache",
      extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
    },
    "application/x-doom": {
      source: "apache",
      extensions: ["wad"]
    },
    "application/x-dtbncx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ncx"]
    },
    "application/x-dtbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dtb"]
    },
    "application/x-dtbresource+xml": {
      source: "apache",
      compressible: true,
      extensions: ["res"]
    },
    "application/x-dvi": {
      source: "apache",
      compressible: false,
      extensions: ["dvi"]
    },
    "application/x-envoy": {
      source: "apache",
      extensions: ["evy"]
    },
    "application/x-eva": {
      source: "apache",
      extensions: ["eva"]
    },
    "application/x-font-bdf": {
      source: "apache",
      extensions: ["bdf"]
    },
    "application/x-font-dos": {
      source: "apache"
    },
    "application/x-font-framemaker": {
      source: "apache"
    },
    "application/x-font-ghostscript": {
      source: "apache",
      extensions: ["gsf"]
    },
    "application/x-font-libgrx": {
      source: "apache"
    },
    "application/x-font-linux-psf": {
      source: "apache",
      extensions: ["psf"]
    },
    "application/x-font-pcf": {
      source: "apache",
      extensions: ["pcf"]
    },
    "application/x-font-snf": {
      source: "apache",
      extensions: ["snf"]
    },
    "application/x-font-speedo": {
      source: "apache"
    },
    "application/x-font-sunos-news": {
      source: "apache"
    },
    "application/x-font-type1": {
      source: "apache",
      extensions: ["pfa", "pfb", "pfm", "afm"]
    },
    "application/x-font-vfont": {
      source: "apache"
    },
    "application/x-freearc": {
      source: "apache",
      extensions: ["arc"]
    },
    "application/x-futuresplash": {
      source: "apache",
      extensions: ["spl"]
    },
    "application/x-gca-compressed": {
      source: "apache",
      extensions: ["gca"]
    },
    "application/x-glulx": {
      source: "apache",
      extensions: ["ulx"]
    },
    "application/x-gnumeric": {
      source: "apache",
      extensions: ["gnumeric"]
    },
    "application/x-gramps-xml": {
      source: "apache",
      extensions: ["gramps"]
    },
    "application/x-gtar": {
      source: "apache",
      extensions: ["gtar"]
    },
    "application/x-gzip": {
      source: "apache"
    },
    "application/x-hdf": {
      source: "apache",
      extensions: ["hdf"]
    },
    "application/x-httpd-php": {
      compressible: true,
      extensions: ["php"]
    },
    "application/x-install-instructions": {
      source: "apache",
      extensions: ["install"]
    },
    "application/x-iso9660-image": {
      source: "apache",
      extensions: ["iso"]
    },
    "application/x-iwork-keynote-sffkey": {
      extensions: ["key"]
    },
    "application/x-iwork-numbers-sffnumbers": {
      extensions: ["numbers"]
    },
    "application/x-iwork-pages-sffpages": {
      extensions: ["pages"]
    },
    "application/x-java-archive-diff": {
      source: "nginx",
      extensions: ["jardiff"]
    },
    "application/x-java-jnlp-file": {
      source: "apache",
      compressible: false,
      extensions: ["jnlp"]
    },
    "application/x-javascript": {
      compressible: true
    },
    "application/x-keepass2": {
      extensions: ["kdbx"]
    },
    "application/x-latex": {
      source: "apache",
      compressible: false,
      extensions: ["latex"]
    },
    "application/x-lua-bytecode": {
      extensions: ["luac"]
    },
    "application/x-lzh-compressed": {
      source: "apache",
      extensions: ["lzh", "lha"]
    },
    "application/x-makeself": {
      source: "nginx",
      extensions: ["run"]
    },
    "application/x-mie": {
      source: "apache",
      extensions: ["mie"]
    },
    "application/x-mobipocket-ebook": {
      source: "apache",
      extensions: ["prc", "mobi"]
    },
    "application/x-mpegurl": {
      compressible: false
    },
    "application/x-ms-application": {
      source: "apache",
      extensions: ["application"]
    },
    "application/x-ms-shortcut": {
      source: "apache",
      extensions: ["lnk"]
    },
    "application/x-ms-wmd": {
      source: "apache",
      extensions: ["wmd"]
    },
    "application/x-ms-wmz": {
      source: "apache",
      extensions: ["wmz"]
    },
    "application/x-ms-xbap": {
      source: "apache",
      extensions: ["xbap"]
    },
    "application/x-msaccess": {
      source: "apache",
      extensions: ["mdb"]
    },
    "application/x-msbinder": {
      source: "apache",
      extensions: ["obd"]
    },
    "application/x-mscardfile": {
      source: "apache",
      extensions: ["crd"]
    },
    "application/x-msclip": {
      source: "apache",
      extensions: ["clp"]
    },
    "application/x-msdos-program": {
      extensions: ["exe"]
    },
    "application/x-msdownload": {
      source: "apache",
      extensions: ["exe", "dll", "com", "bat", "msi"]
    },
    "application/x-msmediaview": {
      source: "apache",
      extensions: ["mvb", "m13", "m14"]
    },
    "application/x-msmetafile": {
      source: "apache",
      extensions: ["wmf", "wmz", "emf", "emz"]
    },
    "application/x-msmoney": {
      source: "apache",
      extensions: ["mny"]
    },
    "application/x-mspublisher": {
      source: "apache",
      extensions: ["pub"]
    },
    "application/x-msschedule": {
      source: "apache",
      extensions: ["scd"]
    },
    "application/x-msterminal": {
      source: "apache",
      extensions: ["trm"]
    },
    "application/x-mswrite": {
      source: "apache",
      extensions: ["wri"]
    },
    "application/x-netcdf": {
      source: "apache",
      extensions: ["nc", "cdf"]
    },
    "application/x-ns-proxy-autoconfig": {
      compressible: true,
      extensions: ["pac"]
    },
    "application/x-nzb": {
      source: "apache",
      extensions: ["nzb"]
    },
    "application/x-perl": {
      source: "nginx",
      extensions: ["pl", "pm"]
    },
    "application/x-pilot": {
      source: "nginx",
      extensions: ["prc", "pdb"]
    },
    "application/x-pkcs12": {
      source: "apache",
      compressible: false,
      extensions: ["p12", "pfx"]
    },
    "application/x-pkcs7-certificates": {
      source: "apache",
      extensions: ["p7b", "spc"]
    },
    "application/x-pkcs7-certreqresp": {
      source: "apache",
      extensions: ["p7r"]
    },
    "application/x-pki-message": {
      source: "iana"
    },
    "application/x-rar-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["rar"]
    },
    "application/x-redhat-package-manager": {
      source: "nginx",
      extensions: ["rpm"]
    },
    "application/x-research-info-systems": {
      source: "apache",
      extensions: ["ris"]
    },
    "application/x-sea": {
      source: "nginx",
      extensions: ["sea"]
    },
    "application/x-sh": {
      source: "apache",
      compressible: true,
      extensions: ["sh"]
    },
    "application/x-shar": {
      source: "apache",
      extensions: ["shar"]
    },
    "application/x-shockwave-flash": {
      source: "apache",
      compressible: false,
      extensions: ["swf"]
    },
    "application/x-silverlight-app": {
      source: "apache",
      extensions: ["xap"]
    },
    "application/x-sql": {
      source: "apache",
      extensions: ["sql"]
    },
    "application/x-stuffit": {
      source: "apache",
      compressible: false,
      extensions: ["sit"]
    },
    "application/x-stuffitx": {
      source: "apache",
      extensions: ["sitx"]
    },
    "application/x-subrip": {
      source: "apache",
      extensions: ["srt"]
    },
    "application/x-sv4cpio": {
      source: "apache",
      extensions: ["sv4cpio"]
    },
    "application/x-sv4crc": {
      source: "apache",
      extensions: ["sv4crc"]
    },
    "application/x-t3vm-image": {
      source: "apache",
      extensions: ["t3"]
    },
    "application/x-tads": {
      source: "apache",
      extensions: ["gam"]
    },
    "application/x-tar": {
      source: "apache",
      compressible: true,
      extensions: ["tar"]
    },
    "application/x-tcl": {
      source: "apache",
      extensions: ["tcl", "tk"]
    },
    "application/x-tex": {
      source: "apache",
      extensions: ["tex"]
    },
    "application/x-tex-tfm": {
      source: "apache",
      extensions: ["tfm"]
    },
    "application/x-texinfo": {
      source: "apache",
      extensions: ["texinfo", "texi"]
    },
    "application/x-tgif": {
      source: "apache",
      extensions: ["obj"]
    },
    "application/x-ustar": {
      source: "apache",
      extensions: ["ustar"]
    },
    "application/x-virtualbox-hdd": {
      compressible: true,
      extensions: ["hdd"]
    },
    "application/x-virtualbox-ova": {
      compressible: true,
      extensions: ["ova"]
    },
    "application/x-virtualbox-ovf": {
      compressible: true,
      extensions: ["ovf"]
    },
    "application/x-virtualbox-vbox": {
      compressible: true,
      extensions: ["vbox"]
    },
    "application/x-virtualbox-vbox-extpack": {
      compressible: false,
      extensions: ["vbox-extpack"]
    },
    "application/x-virtualbox-vdi": {
      compressible: true,
      extensions: ["vdi"]
    },
    "application/x-virtualbox-vhd": {
      compressible: true,
      extensions: ["vhd"]
    },
    "application/x-virtualbox-vmdk": {
      compressible: true,
      extensions: ["vmdk"]
    },
    "application/x-wais-source": {
      source: "apache",
      extensions: ["src"]
    },
    "application/x-web-app-manifest+json": {
      compressible: true,
      extensions: ["webapp"]
    },
    "application/x-www-form-urlencoded": {
      source: "iana",
      compressible: true
    },
    "application/x-x509-ca-cert": {
      source: "iana",
      extensions: ["der", "crt", "pem"]
    },
    "application/x-x509-ca-ra-cert": {
      source: "iana"
    },
    "application/x-x509-next-ca-cert": {
      source: "iana"
    },
    "application/x-xfig": {
      source: "apache",
      extensions: ["fig"]
    },
    "application/x-xliff+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/x-xpinstall": {
      source: "apache",
      compressible: false,
      extensions: ["xpi"]
    },
    "application/x-xz": {
      source: "apache",
      extensions: ["xz"]
    },
    "application/x-zmachine": {
      source: "apache",
      extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
    },
    "application/x400-bp": {
      source: "iana"
    },
    "application/xacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/xaml+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xaml"]
    },
    "application/xcap-att+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xav"]
    },
    "application/xcap-caps+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xca"]
    },
    "application/xcap-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdf"]
    },
    "application/xcap-el+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xel"]
    },
    "application/xcap-error+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcap-ns+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xns"]
    },
    "application/xcon-conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcon-conference-info-diff+xml": {
      source: "iana",
      compressible: true
    },
    "application/xenc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xenc"]
    },
    "application/xhtml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xhtml", "xht"]
    },
    "application/xhtml-voice+xml": {
      source: "apache",
      compressible: true
    },
    "application/xliff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml", "xsl", "xsd", "rng"]
    },
    "application/xml-dtd": {
      source: "iana",
      compressible: true,
      extensions: ["dtd"]
    },
    "application/xml-external-parsed-entity": {
      source: "iana"
    },
    "application/xml-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/xmpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/xop+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xop"]
    },
    "application/xproc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xpl"]
    },
    "application/xslt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xsl", "xslt"]
    },
    "application/xspf+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xspf"]
    },
    "application/xv+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mxml", "xhvml", "xvml", "xvm"]
    },
    "application/yang": {
      source: "iana",
      extensions: ["yang"]
    },
    "application/yang-data+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-data+xml": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/yin+xml": {
      source: "iana",
      compressible: true,
      extensions: ["yin"]
    },
    "application/zip": {
      source: "iana",
      compressible: false,
      extensions: ["zip"]
    },
    "application/zlib": {
      source: "iana"
    },
    "application/zstd": {
      source: "iana"
    },
    "audio/1d-interleaved-parityfec": {
      source: "iana"
    },
    "audio/32kadpcm": {
      source: "iana"
    },
    "audio/3gpp": {
      source: "iana",
      compressible: false,
      extensions: ["3gpp"]
    },
    "audio/3gpp2": {
      source: "iana"
    },
    "audio/aac": {
      source: "iana"
    },
    "audio/ac3": {
      source: "iana"
    },
    "audio/adpcm": {
      source: "apache",
      extensions: ["adp"]
    },
    "audio/amr": {
      source: "iana",
      extensions: ["amr"]
    },
    "audio/amr-wb": {
      source: "iana"
    },
    "audio/amr-wb+": {
      source: "iana"
    },
    "audio/aptx": {
      source: "iana"
    },
    "audio/asc": {
      source: "iana"
    },
    "audio/atrac-advanced-lossless": {
      source: "iana"
    },
    "audio/atrac-x": {
      source: "iana"
    },
    "audio/atrac3": {
      source: "iana"
    },
    "audio/basic": {
      source: "iana",
      compressible: false,
      extensions: ["au", "snd"]
    },
    "audio/bv16": {
      source: "iana"
    },
    "audio/bv32": {
      source: "iana"
    },
    "audio/clearmode": {
      source: "iana"
    },
    "audio/cn": {
      source: "iana"
    },
    "audio/dat12": {
      source: "iana"
    },
    "audio/dls": {
      source: "iana"
    },
    "audio/dsr-es201108": {
      source: "iana"
    },
    "audio/dsr-es202050": {
      source: "iana"
    },
    "audio/dsr-es202211": {
      source: "iana"
    },
    "audio/dsr-es202212": {
      source: "iana"
    },
    "audio/dv": {
      source: "iana"
    },
    "audio/dvi4": {
      source: "iana"
    },
    "audio/eac3": {
      source: "iana"
    },
    "audio/encaprtp": {
      source: "iana"
    },
    "audio/evrc": {
      source: "iana"
    },
    "audio/evrc-qcp": {
      source: "iana"
    },
    "audio/evrc0": {
      source: "iana"
    },
    "audio/evrc1": {
      source: "iana"
    },
    "audio/evrcb": {
      source: "iana"
    },
    "audio/evrcb0": {
      source: "iana"
    },
    "audio/evrcb1": {
      source: "iana"
    },
    "audio/evrcnw": {
      source: "iana"
    },
    "audio/evrcnw0": {
      source: "iana"
    },
    "audio/evrcnw1": {
      source: "iana"
    },
    "audio/evrcwb": {
      source: "iana"
    },
    "audio/evrcwb0": {
      source: "iana"
    },
    "audio/evrcwb1": {
      source: "iana"
    },
    "audio/evs": {
      source: "iana"
    },
    "audio/flexfec": {
      source: "iana"
    },
    "audio/fwdred": {
      source: "iana"
    },
    "audio/g711-0": {
      source: "iana"
    },
    "audio/g719": {
      source: "iana"
    },
    "audio/g722": {
      source: "iana"
    },
    "audio/g7221": {
      source: "iana"
    },
    "audio/g723": {
      source: "iana"
    },
    "audio/g726-16": {
      source: "iana"
    },
    "audio/g726-24": {
      source: "iana"
    },
    "audio/g726-32": {
      source: "iana"
    },
    "audio/g726-40": {
      source: "iana"
    },
    "audio/g728": {
      source: "iana"
    },
    "audio/g729": {
      source: "iana"
    },
    "audio/g7291": {
      source: "iana"
    },
    "audio/g729d": {
      source: "iana"
    },
    "audio/g729e": {
      source: "iana"
    },
    "audio/gsm": {
      source: "iana"
    },
    "audio/gsm-efr": {
      source: "iana"
    },
    "audio/gsm-hr-08": {
      source: "iana"
    },
    "audio/ilbc": {
      source: "iana"
    },
    "audio/ip-mr_v2.5": {
      source: "iana"
    },
    "audio/isac": {
      source: "apache"
    },
    "audio/l16": {
      source: "iana"
    },
    "audio/l20": {
      source: "iana"
    },
    "audio/l24": {
      source: "iana",
      compressible: false
    },
    "audio/l8": {
      source: "iana"
    },
    "audio/lpc": {
      source: "iana"
    },
    "audio/melp": {
      source: "iana"
    },
    "audio/melp1200": {
      source: "iana"
    },
    "audio/melp2400": {
      source: "iana"
    },
    "audio/melp600": {
      source: "iana"
    },
    "audio/mhas": {
      source: "iana"
    },
    "audio/midi": {
      source: "apache",
      extensions: ["mid", "midi", "kar", "rmi"]
    },
    "audio/mobile-xmf": {
      source: "iana",
      extensions: ["mxmf"]
    },
    "audio/mp3": {
      compressible: false,
      extensions: ["mp3"]
    },
    "audio/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["m4a", "mp4a"]
    },
    "audio/mp4a-latm": {
      source: "iana"
    },
    "audio/mpa": {
      source: "iana"
    },
    "audio/mpa-robust": {
      source: "iana"
    },
    "audio/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
    },
    "audio/mpeg4-generic": {
      source: "iana"
    },
    "audio/musepack": {
      source: "apache"
    },
    "audio/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["oga", "ogg", "spx", "opus"]
    },
    "audio/opus": {
      source: "iana"
    },
    "audio/parityfec": {
      source: "iana"
    },
    "audio/pcma": {
      source: "iana"
    },
    "audio/pcma-wb": {
      source: "iana"
    },
    "audio/pcmu": {
      source: "iana"
    },
    "audio/pcmu-wb": {
      source: "iana"
    },
    "audio/prs.sid": {
      source: "iana"
    },
    "audio/qcelp": {
      source: "iana"
    },
    "audio/raptorfec": {
      source: "iana"
    },
    "audio/red": {
      source: "iana"
    },
    "audio/rtp-enc-aescm128": {
      source: "iana"
    },
    "audio/rtp-midi": {
      source: "iana"
    },
    "audio/rtploopback": {
      source: "iana"
    },
    "audio/rtx": {
      source: "iana"
    },
    "audio/s3m": {
      source: "apache",
      extensions: ["s3m"]
    },
    "audio/scip": {
      source: "iana"
    },
    "audio/silk": {
      source: "apache",
      extensions: ["sil"]
    },
    "audio/smv": {
      source: "iana"
    },
    "audio/smv-qcp": {
      source: "iana"
    },
    "audio/smv0": {
      source: "iana"
    },
    "audio/sofa": {
      source: "iana"
    },
    "audio/sp-midi": {
      source: "iana"
    },
    "audio/speex": {
      source: "iana"
    },
    "audio/t140c": {
      source: "iana"
    },
    "audio/t38": {
      source: "iana"
    },
    "audio/telephone-event": {
      source: "iana"
    },
    "audio/tetra_acelp": {
      source: "iana"
    },
    "audio/tetra_acelp_bb": {
      source: "iana"
    },
    "audio/tone": {
      source: "iana"
    },
    "audio/tsvcis": {
      source: "iana"
    },
    "audio/uemclip": {
      source: "iana"
    },
    "audio/ulpfec": {
      source: "iana"
    },
    "audio/usac": {
      source: "iana"
    },
    "audio/vdvi": {
      source: "iana"
    },
    "audio/vmr-wb": {
      source: "iana"
    },
    "audio/vnd.3gpp.iufp": {
      source: "iana"
    },
    "audio/vnd.4sb": {
      source: "iana"
    },
    "audio/vnd.audiokoz": {
      source: "iana"
    },
    "audio/vnd.celp": {
      source: "iana"
    },
    "audio/vnd.cisco.nse": {
      source: "iana"
    },
    "audio/vnd.cmles.radio-events": {
      source: "iana"
    },
    "audio/vnd.cns.anp1": {
      source: "iana"
    },
    "audio/vnd.cns.inf1": {
      source: "iana"
    },
    "audio/vnd.dece.audio": {
      source: "iana",
      extensions: ["uva", "uvva"]
    },
    "audio/vnd.digital-winds": {
      source: "iana",
      extensions: ["eol"]
    },
    "audio/vnd.dlna.adts": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.1": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.2": {
      source: "iana"
    },
    "audio/vnd.dolby.mlp": {
      source: "iana"
    },
    "audio/vnd.dolby.mps": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2x": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2z": {
      source: "iana"
    },
    "audio/vnd.dolby.pulse.1": {
      source: "iana"
    },
    "audio/vnd.dra": {
      source: "iana",
      extensions: ["dra"]
    },
    "audio/vnd.dts": {
      source: "iana",
      extensions: ["dts"]
    },
    "audio/vnd.dts.hd": {
      source: "iana",
      extensions: ["dtshd"]
    },
    "audio/vnd.dts.uhd": {
      source: "iana"
    },
    "audio/vnd.dvb.file": {
      source: "iana"
    },
    "audio/vnd.everad.plj": {
      source: "iana"
    },
    "audio/vnd.hns.audio": {
      source: "iana"
    },
    "audio/vnd.lucent.voice": {
      source: "iana",
      extensions: ["lvp"]
    },
    "audio/vnd.ms-playready.media.pya": {
      source: "iana",
      extensions: ["pya"]
    },
    "audio/vnd.nokia.mobile-xmf": {
      source: "iana"
    },
    "audio/vnd.nortel.vbk": {
      source: "iana"
    },
    "audio/vnd.nuera.ecelp4800": {
      source: "iana",
      extensions: ["ecelp4800"]
    },
    "audio/vnd.nuera.ecelp7470": {
      source: "iana",
      extensions: ["ecelp7470"]
    },
    "audio/vnd.nuera.ecelp9600": {
      source: "iana",
      extensions: ["ecelp9600"]
    },
    "audio/vnd.octel.sbc": {
      source: "iana"
    },
    "audio/vnd.presonus.multitrack": {
      source: "iana"
    },
    "audio/vnd.qcelp": {
      source: "iana"
    },
    "audio/vnd.rhetorex.32kadpcm": {
      source: "iana"
    },
    "audio/vnd.rip": {
      source: "iana",
      extensions: ["rip"]
    },
    "audio/vnd.rn-realaudio": {
      compressible: false
    },
    "audio/vnd.sealedmedia.softseal.mpeg": {
      source: "iana"
    },
    "audio/vnd.vmx.cvsd": {
      source: "iana"
    },
    "audio/vnd.wave": {
      compressible: false
    },
    "audio/vorbis": {
      source: "iana",
      compressible: false
    },
    "audio/vorbis-config": {
      source: "iana"
    },
    "audio/wav": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/wave": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/webm": {
      source: "apache",
      compressible: false,
      extensions: ["weba"]
    },
    "audio/x-aac": {
      source: "apache",
      compressible: false,
      extensions: ["aac"]
    },
    "audio/x-aiff": {
      source: "apache",
      extensions: ["aif", "aiff", "aifc"]
    },
    "audio/x-caf": {
      source: "apache",
      compressible: false,
      extensions: ["caf"]
    },
    "audio/x-flac": {
      source: "apache",
      extensions: ["flac"]
    },
    "audio/x-m4a": {
      source: "nginx",
      extensions: ["m4a"]
    },
    "audio/x-matroska": {
      source: "apache",
      extensions: ["mka"]
    },
    "audio/x-mpegurl": {
      source: "apache",
      extensions: ["m3u"]
    },
    "audio/x-ms-wax": {
      source: "apache",
      extensions: ["wax"]
    },
    "audio/x-ms-wma": {
      source: "apache",
      extensions: ["wma"]
    },
    "audio/x-pn-realaudio": {
      source: "apache",
      extensions: ["ram", "ra"]
    },
    "audio/x-pn-realaudio-plugin": {
      source: "apache",
      extensions: ["rmp"]
    },
    "audio/x-realaudio": {
      source: "nginx",
      extensions: ["ra"]
    },
    "audio/x-tta": {
      source: "apache"
    },
    "audio/x-wav": {
      source: "apache",
      extensions: ["wav"]
    },
    "audio/xm": {
      source: "apache",
      extensions: ["xm"]
    },
    "chemical/x-cdx": {
      source: "apache",
      extensions: ["cdx"]
    },
    "chemical/x-cif": {
      source: "apache",
      extensions: ["cif"]
    },
    "chemical/x-cmdf": {
      source: "apache",
      extensions: ["cmdf"]
    },
    "chemical/x-cml": {
      source: "apache",
      extensions: ["cml"]
    },
    "chemical/x-csml": {
      source: "apache",
      extensions: ["csml"]
    },
    "chemical/x-pdb": {
      source: "apache"
    },
    "chemical/x-xyz": {
      source: "apache",
      extensions: ["xyz"]
    },
    "font/collection": {
      source: "iana",
      extensions: ["ttc"]
    },
    "font/otf": {
      source: "iana",
      compressible: true,
      extensions: ["otf"]
    },
    "font/sfnt": {
      source: "iana"
    },
    "font/ttf": {
      source: "iana",
      compressible: true,
      extensions: ["ttf"]
    },
    "font/woff": {
      source: "iana",
      extensions: ["woff"]
    },
    "font/woff2": {
      source: "iana",
      extensions: ["woff2"]
    },
    "image/aces": {
      source: "iana",
      extensions: ["exr"]
    },
    "image/apng": {
      compressible: false,
      extensions: ["apng"]
    },
    "image/avci": {
      source: "iana",
      extensions: ["avci"]
    },
    "image/avcs": {
      source: "iana",
      extensions: ["avcs"]
    },
    "image/avif": {
      source: "iana",
      compressible: false,
      extensions: ["avif"]
    },
    "image/bmp": {
      source: "iana",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/cgm": {
      source: "iana",
      extensions: ["cgm"]
    },
    "image/dicom-rle": {
      source: "iana",
      extensions: ["drle"]
    },
    "image/emf": {
      source: "iana",
      extensions: ["emf"]
    },
    "image/fits": {
      source: "iana",
      extensions: ["fits"]
    },
    "image/g3fax": {
      source: "iana",
      extensions: ["g3"]
    },
    "image/gif": {
      source: "iana",
      compressible: false,
      extensions: ["gif"]
    },
    "image/heic": {
      source: "iana",
      extensions: ["heic"]
    },
    "image/heic-sequence": {
      source: "iana",
      extensions: ["heics"]
    },
    "image/heif": {
      source: "iana",
      extensions: ["heif"]
    },
    "image/heif-sequence": {
      source: "iana",
      extensions: ["heifs"]
    },
    "image/hej2k": {
      source: "iana",
      extensions: ["hej2"]
    },
    "image/hsj2": {
      source: "iana",
      extensions: ["hsj2"]
    },
    "image/ief": {
      source: "iana",
      extensions: ["ief"]
    },
    "image/jls": {
      source: "iana",
      extensions: ["jls"]
    },
    "image/jp2": {
      source: "iana",
      compressible: false,
      extensions: ["jp2", "jpg2"]
    },
    "image/jpeg": {
      source: "iana",
      compressible: false,
      extensions: ["jpeg", "jpg", "jpe"]
    },
    "image/jph": {
      source: "iana",
      extensions: ["jph"]
    },
    "image/jphc": {
      source: "iana",
      extensions: ["jhc"]
    },
    "image/jpm": {
      source: "iana",
      compressible: false,
      extensions: ["jpm"]
    },
    "image/jpx": {
      source: "iana",
      compressible: false,
      extensions: ["jpx", "jpf"]
    },
    "image/jxr": {
      source: "iana",
      extensions: ["jxr"]
    },
    "image/jxra": {
      source: "iana",
      extensions: ["jxra"]
    },
    "image/jxrs": {
      source: "iana",
      extensions: ["jxrs"]
    },
    "image/jxs": {
      source: "iana",
      extensions: ["jxs"]
    },
    "image/jxsc": {
      source: "iana",
      extensions: ["jxsc"]
    },
    "image/jxsi": {
      source: "iana",
      extensions: ["jxsi"]
    },
    "image/jxss": {
      source: "iana",
      extensions: ["jxss"]
    },
    "image/ktx": {
      source: "iana",
      extensions: ["ktx"]
    },
    "image/ktx2": {
      source: "iana",
      extensions: ["ktx2"]
    },
    "image/naplps": {
      source: "iana"
    },
    "image/pjpeg": {
      compressible: false
    },
    "image/png": {
      source: "iana",
      compressible: false,
      extensions: ["png"]
    },
    "image/prs.btif": {
      source: "iana",
      extensions: ["btif"]
    },
    "image/prs.pti": {
      source: "iana",
      extensions: ["pti"]
    },
    "image/pwg-raster": {
      source: "iana"
    },
    "image/sgi": {
      source: "apache",
      extensions: ["sgi"]
    },
    "image/svg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["svg", "svgz"]
    },
    "image/t38": {
      source: "iana",
      extensions: ["t38"]
    },
    "image/tiff": {
      source: "iana",
      compressible: false,
      extensions: ["tif", "tiff"]
    },
    "image/tiff-fx": {
      source: "iana",
      extensions: ["tfx"]
    },
    "image/vnd.adobe.photoshop": {
      source: "iana",
      compressible: true,
      extensions: ["psd"]
    },
    "image/vnd.airzip.accelerator.azv": {
      source: "iana",
      extensions: ["azv"]
    },
    "image/vnd.cns.inf2": {
      source: "iana"
    },
    "image/vnd.dece.graphic": {
      source: "iana",
      extensions: ["uvi", "uvvi", "uvg", "uvvg"]
    },
    "image/vnd.djvu": {
      source: "iana",
      extensions: ["djvu", "djv"]
    },
    "image/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "image/vnd.dwg": {
      source: "iana",
      extensions: ["dwg"]
    },
    "image/vnd.dxf": {
      source: "iana",
      extensions: ["dxf"]
    },
    "image/vnd.fastbidsheet": {
      source: "iana",
      extensions: ["fbs"]
    },
    "image/vnd.fpx": {
      source: "iana",
      extensions: ["fpx"]
    },
    "image/vnd.fst": {
      source: "iana",
      extensions: ["fst"]
    },
    "image/vnd.fujixerox.edmics-mmr": {
      source: "iana",
      extensions: ["mmr"]
    },
    "image/vnd.fujixerox.edmics-rlc": {
      source: "iana",
      extensions: ["rlc"]
    },
    "image/vnd.globalgraphics.pgb": {
      source: "iana"
    },
    "image/vnd.microsoft.icon": {
      source: "iana",
      compressible: true,
      extensions: ["ico"]
    },
    "image/vnd.mix": {
      source: "iana"
    },
    "image/vnd.mozilla.apng": {
      source: "iana"
    },
    "image/vnd.ms-dds": {
      compressible: true,
      extensions: ["dds"]
    },
    "image/vnd.ms-modi": {
      source: "iana",
      extensions: ["mdi"]
    },
    "image/vnd.ms-photo": {
      source: "apache",
      extensions: ["wdp"]
    },
    "image/vnd.net-fpx": {
      source: "iana",
      extensions: ["npx"]
    },
    "image/vnd.pco.b16": {
      source: "iana",
      extensions: ["b16"]
    },
    "image/vnd.radiance": {
      source: "iana"
    },
    "image/vnd.sealed.png": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.gif": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.jpg": {
      source: "iana"
    },
    "image/vnd.svf": {
      source: "iana"
    },
    "image/vnd.tencent.tap": {
      source: "iana",
      extensions: ["tap"]
    },
    "image/vnd.valve.source.texture": {
      source: "iana",
      extensions: ["vtf"]
    },
    "image/vnd.wap.wbmp": {
      source: "iana",
      extensions: ["wbmp"]
    },
    "image/vnd.xiff": {
      source: "iana",
      extensions: ["xif"]
    },
    "image/vnd.zbrush.pcx": {
      source: "iana",
      extensions: ["pcx"]
    },
    "image/webp": {
      source: "apache",
      extensions: ["webp"]
    },
    "image/wmf": {
      source: "iana",
      extensions: ["wmf"]
    },
    "image/x-3ds": {
      source: "apache",
      extensions: ["3ds"]
    },
    "image/x-cmu-raster": {
      source: "apache",
      extensions: ["ras"]
    },
    "image/x-cmx": {
      source: "apache",
      extensions: ["cmx"]
    },
    "image/x-freehand": {
      source: "apache",
      extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
    },
    "image/x-icon": {
      source: "apache",
      compressible: true,
      extensions: ["ico"]
    },
    "image/x-jng": {
      source: "nginx",
      extensions: ["jng"]
    },
    "image/x-mrsid-image": {
      source: "apache",
      extensions: ["sid"]
    },
    "image/x-ms-bmp": {
      source: "nginx",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/x-pcx": {
      source: "apache",
      extensions: ["pcx"]
    },
    "image/x-pict": {
      source: "apache",
      extensions: ["pic", "pct"]
    },
    "image/x-portable-anymap": {
      source: "apache",
      extensions: ["pnm"]
    },
    "image/x-portable-bitmap": {
      source: "apache",
      extensions: ["pbm"]
    },
    "image/x-portable-graymap": {
      source: "apache",
      extensions: ["pgm"]
    },
    "image/x-portable-pixmap": {
      source: "apache",
      extensions: ["ppm"]
    },
    "image/x-rgb": {
      source: "apache",
      extensions: ["rgb"]
    },
    "image/x-tga": {
      source: "apache",
      extensions: ["tga"]
    },
    "image/x-xbitmap": {
      source: "apache",
      extensions: ["xbm"]
    },
    "image/x-xcf": {
      compressible: false
    },
    "image/x-xpixmap": {
      source: "apache",
      extensions: ["xpm"]
    },
    "image/x-xwindowdump": {
      source: "apache",
      extensions: ["xwd"]
    },
    "message/cpim": {
      source: "iana"
    },
    "message/delivery-status": {
      source: "iana"
    },
    "message/disposition-notification": {
      source: "iana",
      extensions: [
        "disposition-notification"
      ]
    },
    "message/external-body": {
      source: "iana"
    },
    "message/feedback-report": {
      source: "iana"
    },
    "message/global": {
      source: "iana",
      extensions: ["u8msg"]
    },
    "message/global-delivery-status": {
      source: "iana",
      extensions: ["u8dsn"]
    },
    "message/global-disposition-notification": {
      source: "iana",
      extensions: ["u8mdn"]
    },
    "message/global-headers": {
      source: "iana",
      extensions: ["u8hdr"]
    },
    "message/http": {
      source: "iana",
      compressible: false
    },
    "message/imdn+xml": {
      source: "iana",
      compressible: true
    },
    "message/news": {
      source: "iana"
    },
    "message/partial": {
      source: "iana",
      compressible: false
    },
    "message/rfc822": {
      source: "iana",
      compressible: true,
      extensions: ["eml", "mime"]
    },
    "message/s-http": {
      source: "iana"
    },
    "message/sip": {
      source: "iana"
    },
    "message/sipfrag": {
      source: "iana"
    },
    "message/tracking-status": {
      source: "iana"
    },
    "message/vnd.si.simp": {
      source: "iana"
    },
    "message/vnd.wfa.wsc": {
      source: "iana",
      extensions: ["wsc"]
    },
    "model/3mf": {
      source: "iana",
      extensions: ["3mf"]
    },
    "model/e57": {
      source: "iana"
    },
    "model/gltf+json": {
      source: "iana",
      compressible: true,
      extensions: ["gltf"]
    },
    "model/gltf-binary": {
      source: "iana",
      compressible: true,
      extensions: ["glb"]
    },
    "model/iges": {
      source: "iana",
      compressible: false,
      extensions: ["igs", "iges"]
    },
    "model/mesh": {
      source: "iana",
      compressible: false,
      extensions: ["msh", "mesh", "silo"]
    },
    "model/mtl": {
      source: "iana",
      extensions: ["mtl"]
    },
    "model/obj": {
      source: "iana",
      extensions: ["obj"]
    },
    "model/step": {
      source: "iana"
    },
    "model/step+xml": {
      source: "iana",
      compressible: true,
      extensions: ["stpx"]
    },
    "model/step+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpz"]
    },
    "model/step-xml+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpxz"]
    },
    "model/stl": {
      source: "iana",
      extensions: ["stl"]
    },
    "model/vnd.collada+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dae"]
    },
    "model/vnd.dwf": {
      source: "iana",
      extensions: ["dwf"]
    },
    "model/vnd.flatland.3dml": {
      source: "iana"
    },
    "model/vnd.gdl": {
      source: "iana",
      extensions: ["gdl"]
    },
    "model/vnd.gs-gdl": {
      source: "apache"
    },
    "model/vnd.gs.gdl": {
      source: "iana"
    },
    "model/vnd.gtw": {
      source: "iana",
      extensions: ["gtw"]
    },
    "model/vnd.moml+xml": {
      source: "iana",
      compressible: true
    },
    "model/vnd.mts": {
      source: "iana",
      extensions: ["mts"]
    },
    "model/vnd.opengex": {
      source: "iana",
      extensions: ["ogex"]
    },
    "model/vnd.parasolid.transmit.binary": {
      source: "iana",
      extensions: ["x_b"]
    },
    "model/vnd.parasolid.transmit.text": {
      source: "iana",
      extensions: ["x_t"]
    },
    "model/vnd.pytha.pyox": {
      source: "iana"
    },
    "model/vnd.rosette.annotated-data-model": {
      source: "iana"
    },
    "model/vnd.sap.vds": {
      source: "iana",
      extensions: ["vds"]
    },
    "model/vnd.usdz+zip": {
      source: "iana",
      compressible: false,
      extensions: ["usdz"]
    },
    "model/vnd.valve.source.compiled-map": {
      source: "iana",
      extensions: ["bsp"]
    },
    "model/vnd.vtu": {
      source: "iana",
      extensions: ["vtu"]
    },
    "model/vrml": {
      source: "iana",
      compressible: false,
      extensions: ["wrl", "vrml"]
    },
    "model/x3d+binary": {
      source: "apache",
      compressible: false,
      extensions: ["x3db", "x3dbz"]
    },
    "model/x3d+fastinfoset": {
      source: "iana",
      extensions: ["x3db"]
    },
    "model/x3d+vrml": {
      source: "apache",
      compressible: false,
      extensions: ["x3dv", "x3dvz"]
    },
    "model/x3d+xml": {
      source: "iana",
      compressible: true,
      extensions: ["x3d", "x3dz"]
    },
    "model/x3d-vrml": {
      source: "iana",
      extensions: ["x3dv"]
    },
    "multipart/alternative": {
      source: "iana",
      compressible: false
    },
    "multipart/appledouble": {
      source: "iana"
    },
    "multipart/byteranges": {
      source: "iana"
    },
    "multipart/digest": {
      source: "iana"
    },
    "multipart/encrypted": {
      source: "iana",
      compressible: false
    },
    "multipart/form-data": {
      source: "iana",
      compressible: false
    },
    "multipart/header-set": {
      source: "iana"
    },
    "multipart/mixed": {
      source: "iana"
    },
    "multipart/multilingual": {
      source: "iana"
    },
    "multipart/parallel": {
      source: "iana"
    },
    "multipart/related": {
      source: "iana",
      compressible: false
    },
    "multipart/report": {
      source: "iana"
    },
    "multipart/signed": {
      source: "iana",
      compressible: false
    },
    "multipart/vnd.bint.med-plus": {
      source: "iana"
    },
    "multipart/voice-message": {
      source: "iana"
    },
    "multipart/x-mixed-replace": {
      source: "iana"
    },
    "text/1d-interleaved-parityfec": {
      source: "iana"
    },
    "text/cache-manifest": {
      source: "iana",
      compressible: true,
      extensions: ["appcache", "manifest"]
    },
    "text/calendar": {
      source: "iana",
      extensions: ["ics", "ifb"]
    },
    "text/calender": {
      compressible: true
    },
    "text/cmd": {
      compressible: true
    },
    "text/coffeescript": {
      extensions: ["coffee", "litcoffee"]
    },
    "text/cql": {
      source: "iana"
    },
    "text/cql-expression": {
      source: "iana"
    },
    "text/cql-identifier": {
      source: "iana"
    },
    "text/css": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["css"]
    },
    "text/csv": {
      source: "iana",
      compressible: true,
      extensions: ["csv"]
    },
    "text/csv-schema": {
      source: "iana"
    },
    "text/directory": {
      source: "iana"
    },
    "text/dns": {
      source: "iana"
    },
    "text/ecmascript": {
      source: "iana"
    },
    "text/encaprtp": {
      source: "iana"
    },
    "text/enriched": {
      source: "iana"
    },
    "text/fhirpath": {
      source: "iana"
    },
    "text/flexfec": {
      source: "iana"
    },
    "text/fwdred": {
      source: "iana"
    },
    "text/gff3": {
      source: "iana"
    },
    "text/grammar-ref-list": {
      source: "iana"
    },
    "text/html": {
      source: "iana",
      compressible: true,
      extensions: ["html", "htm", "shtml"]
    },
    "text/jade": {
      extensions: ["jade"]
    },
    "text/javascript": {
      source: "iana",
      compressible: true
    },
    "text/jcr-cnd": {
      source: "iana"
    },
    "text/jsx": {
      compressible: true,
      extensions: ["jsx"]
    },
    "text/less": {
      compressible: true,
      extensions: ["less"]
    },
    "text/markdown": {
      source: "iana",
      compressible: true,
      extensions: ["markdown", "md"]
    },
    "text/mathml": {
      source: "nginx",
      extensions: ["mml"]
    },
    "text/mdx": {
      compressible: true,
      extensions: ["mdx"]
    },
    "text/mizar": {
      source: "iana"
    },
    "text/n3": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["n3"]
    },
    "text/parameters": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/parityfec": {
      source: "iana"
    },
    "text/plain": {
      source: "iana",
      compressible: true,
      extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
    },
    "text/provenance-notation": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/prs.fallenstein.rst": {
      source: "iana"
    },
    "text/prs.lines.tag": {
      source: "iana",
      extensions: ["dsc"]
    },
    "text/prs.prop.logic": {
      source: "iana"
    },
    "text/raptorfec": {
      source: "iana"
    },
    "text/red": {
      source: "iana"
    },
    "text/rfc822-headers": {
      source: "iana"
    },
    "text/richtext": {
      source: "iana",
      compressible: true,
      extensions: ["rtx"]
    },
    "text/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "text/rtp-enc-aescm128": {
      source: "iana"
    },
    "text/rtploopback": {
      source: "iana"
    },
    "text/rtx": {
      source: "iana"
    },
    "text/sgml": {
      source: "iana",
      extensions: ["sgml", "sgm"]
    },
    "text/shaclc": {
      source: "iana"
    },
    "text/shex": {
      source: "iana",
      extensions: ["shex"]
    },
    "text/slim": {
      extensions: ["slim", "slm"]
    },
    "text/spdx": {
      source: "iana",
      extensions: ["spdx"]
    },
    "text/strings": {
      source: "iana"
    },
    "text/stylus": {
      extensions: ["stylus", "styl"]
    },
    "text/t140": {
      source: "iana"
    },
    "text/tab-separated-values": {
      source: "iana",
      compressible: true,
      extensions: ["tsv"]
    },
    "text/troff": {
      source: "iana",
      extensions: ["t", "tr", "roff", "man", "me", "ms"]
    },
    "text/turtle": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["ttl"]
    },
    "text/ulpfec": {
      source: "iana"
    },
    "text/uri-list": {
      source: "iana",
      compressible: true,
      extensions: ["uri", "uris", "urls"]
    },
    "text/vcard": {
      source: "iana",
      compressible: true,
      extensions: ["vcard"]
    },
    "text/vnd.a": {
      source: "iana"
    },
    "text/vnd.abc": {
      source: "iana"
    },
    "text/vnd.ascii-art": {
      source: "iana"
    },
    "text/vnd.curl": {
      source: "iana",
      extensions: ["curl"]
    },
    "text/vnd.curl.dcurl": {
      source: "apache",
      extensions: ["dcurl"]
    },
    "text/vnd.curl.mcurl": {
      source: "apache",
      extensions: ["mcurl"]
    },
    "text/vnd.curl.scurl": {
      source: "apache",
      extensions: ["scurl"]
    },
    "text/vnd.debian.copyright": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.dmclientscript": {
      source: "iana"
    },
    "text/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "text/vnd.esmertec.theme-descriptor": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.familysearch.gedcom": {
      source: "iana",
      extensions: ["ged"]
    },
    "text/vnd.ficlab.flt": {
      source: "iana"
    },
    "text/vnd.fly": {
      source: "iana",
      extensions: ["fly"]
    },
    "text/vnd.fmi.flexstor": {
      source: "iana",
      extensions: ["flx"]
    },
    "text/vnd.gml": {
      source: "iana"
    },
    "text/vnd.graphviz": {
      source: "iana",
      extensions: ["gv"]
    },
    "text/vnd.hans": {
      source: "iana"
    },
    "text/vnd.hgl": {
      source: "iana"
    },
    "text/vnd.in3d.3dml": {
      source: "iana",
      extensions: ["3dml"]
    },
    "text/vnd.in3d.spot": {
      source: "iana",
      extensions: ["spot"]
    },
    "text/vnd.iptc.newsml": {
      source: "iana"
    },
    "text/vnd.iptc.nitf": {
      source: "iana"
    },
    "text/vnd.latex-z": {
      source: "iana"
    },
    "text/vnd.motorola.reflex": {
      source: "iana"
    },
    "text/vnd.ms-mediapackage": {
      source: "iana"
    },
    "text/vnd.net2phone.commcenter.command": {
      source: "iana"
    },
    "text/vnd.radisys.msml-basic-layout": {
      source: "iana"
    },
    "text/vnd.senx.warpscript": {
      source: "iana"
    },
    "text/vnd.si.uricatalogue": {
      source: "iana"
    },
    "text/vnd.sosi": {
      source: "iana"
    },
    "text/vnd.sun.j2me.app-descriptor": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["jad"]
    },
    "text/vnd.trolltech.linguist": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.wap.si": {
      source: "iana"
    },
    "text/vnd.wap.sl": {
      source: "iana"
    },
    "text/vnd.wap.wml": {
      source: "iana",
      extensions: ["wml"]
    },
    "text/vnd.wap.wmlscript": {
      source: "iana",
      extensions: ["wmls"]
    },
    "text/vtt": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["vtt"]
    },
    "text/x-asm": {
      source: "apache",
      extensions: ["s", "asm"]
    },
    "text/x-c": {
      source: "apache",
      extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
    },
    "text/x-component": {
      source: "nginx",
      extensions: ["htc"]
    },
    "text/x-fortran": {
      source: "apache",
      extensions: ["f", "for", "f77", "f90"]
    },
    "text/x-gwt-rpc": {
      compressible: true
    },
    "text/x-handlebars-template": {
      extensions: ["hbs"]
    },
    "text/x-java-source": {
      source: "apache",
      extensions: ["java"]
    },
    "text/x-jquery-tmpl": {
      compressible: true
    },
    "text/x-lua": {
      extensions: ["lua"]
    },
    "text/x-markdown": {
      compressible: true,
      extensions: ["mkd"]
    },
    "text/x-nfo": {
      source: "apache",
      extensions: ["nfo"]
    },
    "text/x-opml": {
      source: "apache",
      extensions: ["opml"]
    },
    "text/x-org": {
      compressible: true,
      extensions: ["org"]
    },
    "text/x-pascal": {
      source: "apache",
      extensions: ["p", "pas"]
    },
    "text/x-processing": {
      compressible: true,
      extensions: ["pde"]
    },
    "text/x-sass": {
      extensions: ["sass"]
    },
    "text/x-scss": {
      extensions: ["scss"]
    },
    "text/x-setext": {
      source: "apache",
      extensions: ["etx"]
    },
    "text/x-sfv": {
      source: "apache",
      extensions: ["sfv"]
    },
    "text/x-suse-ymp": {
      compressible: true,
      extensions: ["ymp"]
    },
    "text/x-uuencode": {
      source: "apache",
      extensions: ["uu"]
    },
    "text/x-vcalendar": {
      source: "apache",
      extensions: ["vcs"]
    },
    "text/x-vcard": {
      source: "apache",
      extensions: ["vcf"]
    },
    "text/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml"]
    },
    "text/xml-external-parsed-entity": {
      source: "iana"
    },
    "text/yaml": {
      compressible: true,
      extensions: ["yaml", "yml"]
    },
    "video/1d-interleaved-parityfec": {
      source: "iana"
    },
    "video/3gpp": {
      source: "iana",
      extensions: ["3gp", "3gpp"]
    },
    "video/3gpp-tt": {
      source: "iana"
    },
    "video/3gpp2": {
      source: "iana",
      extensions: ["3g2"]
    },
    "video/av1": {
      source: "iana"
    },
    "video/bmpeg": {
      source: "iana"
    },
    "video/bt656": {
      source: "iana"
    },
    "video/celb": {
      source: "iana"
    },
    "video/dv": {
      source: "iana"
    },
    "video/encaprtp": {
      source: "iana"
    },
    "video/ffv1": {
      source: "iana"
    },
    "video/flexfec": {
      source: "iana"
    },
    "video/h261": {
      source: "iana",
      extensions: ["h261"]
    },
    "video/h263": {
      source: "iana",
      extensions: ["h263"]
    },
    "video/h263-1998": {
      source: "iana"
    },
    "video/h263-2000": {
      source: "iana"
    },
    "video/h264": {
      source: "iana",
      extensions: ["h264"]
    },
    "video/h264-rcdo": {
      source: "iana"
    },
    "video/h264-svc": {
      source: "iana"
    },
    "video/h265": {
      source: "iana"
    },
    "video/iso.segment": {
      source: "iana",
      extensions: ["m4s"]
    },
    "video/jpeg": {
      source: "iana",
      extensions: ["jpgv"]
    },
    "video/jpeg2000": {
      source: "iana"
    },
    "video/jpm": {
      source: "apache",
      extensions: ["jpm", "jpgm"]
    },
    "video/jxsv": {
      source: "iana"
    },
    "video/mj2": {
      source: "iana",
      extensions: ["mj2", "mjp2"]
    },
    "video/mp1s": {
      source: "iana"
    },
    "video/mp2p": {
      source: "iana"
    },
    "video/mp2t": {
      source: "iana",
      extensions: ["ts"]
    },
    "video/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["mp4", "mp4v", "mpg4"]
    },
    "video/mp4v-es": {
      source: "iana"
    },
    "video/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
    },
    "video/mpeg4-generic": {
      source: "iana"
    },
    "video/mpv": {
      source: "iana"
    },
    "video/nv": {
      source: "iana"
    },
    "video/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogv"]
    },
    "video/parityfec": {
      source: "iana"
    },
    "video/pointer": {
      source: "iana"
    },
    "video/quicktime": {
      source: "iana",
      compressible: false,
      extensions: ["qt", "mov"]
    },
    "video/raptorfec": {
      source: "iana"
    },
    "video/raw": {
      source: "iana"
    },
    "video/rtp-enc-aescm128": {
      source: "iana"
    },
    "video/rtploopback": {
      source: "iana"
    },
    "video/rtx": {
      source: "iana"
    },
    "video/scip": {
      source: "iana"
    },
    "video/smpte291": {
      source: "iana"
    },
    "video/smpte292m": {
      source: "iana"
    },
    "video/ulpfec": {
      source: "iana"
    },
    "video/vc1": {
      source: "iana"
    },
    "video/vc2": {
      source: "iana"
    },
    "video/vnd.cctv": {
      source: "iana"
    },
    "video/vnd.dece.hd": {
      source: "iana",
      extensions: ["uvh", "uvvh"]
    },
    "video/vnd.dece.mobile": {
      source: "iana",
      extensions: ["uvm", "uvvm"]
    },
    "video/vnd.dece.mp4": {
      source: "iana"
    },
    "video/vnd.dece.pd": {
      source: "iana",
      extensions: ["uvp", "uvvp"]
    },
    "video/vnd.dece.sd": {
      source: "iana",
      extensions: ["uvs", "uvvs"]
    },
    "video/vnd.dece.video": {
      source: "iana",
      extensions: ["uvv", "uvvv"]
    },
    "video/vnd.directv.mpeg": {
      source: "iana"
    },
    "video/vnd.directv.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dlna.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dvb.file": {
      source: "iana",
      extensions: ["dvb"]
    },
    "video/vnd.fvt": {
      source: "iana",
      extensions: ["fvt"]
    },
    "video/vnd.hns.video": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsavc": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsmpeg2": {
      source: "iana"
    },
    "video/vnd.motorola.video": {
      source: "iana"
    },
    "video/vnd.motorola.videop": {
      source: "iana"
    },
    "video/vnd.mpegurl": {
      source: "iana",
      extensions: ["mxu", "m4u"]
    },
    "video/vnd.ms-playready.media.pyv": {
      source: "iana",
      extensions: ["pyv"]
    },
    "video/vnd.nokia.interleaved-multimedia": {
      source: "iana"
    },
    "video/vnd.nokia.mp4vr": {
      source: "iana"
    },
    "video/vnd.nokia.videovoip": {
      source: "iana"
    },
    "video/vnd.objectvideo": {
      source: "iana"
    },
    "video/vnd.radgamettools.bink": {
      source: "iana"
    },
    "video/vnd.radgamettools.smacker": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg1": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg4": {
      source: "iana"
    },
    "video/vnd.sealed.swf": {
      source: "iana"
    },
    "video/vnd.sealedmedia.softseal.mov": {
      source: "iana"
    },
    "video/vnd.uvvu.mp4": {
      source: "iana",
      extensions: ["uvu", "uvvu"]
    },
    "video/vnd.vivo": {
      source: "iana",
      extensions: ["viv"]
    },
    "video/vnd.youtube.yt": {
      source: "iana"
    },
    "video/vp8": {
      source: "iana"
    },
    "video/vp9": {
      source: "iana"
    },
    "video/webm": {
      source: "apache",
      compressible: false,
      extensions: ["webm"]
    },
    "video/x-f4v": {
      source: "apache",
      extensions: ["f4v"]
    },
    "video/x-fli": {
      source: "apache",
      extensions: ["fli"]
    },
    "video/x-flv": {
      source: "apache",
      compressible: false,
      extensions: ["flv"]
    },
    "video/x-m4v": {
      source: "apache",
      extensions: ["m4v"]
    },
    "video/x-matroska": {
      source: "apache",
      compressible: false,
      extensions: ["mkv", "mk3d", "mks"]
    },
    "video/x-mng": {
      source: "apache",
      extensions: ["mng"]
    },
    "video/x-ms-asf": {
      source: "apache",
      extensions: ["asf", "asx"]
    },
    "video/x-ms-vob": {
      source: "apache",
      extensions: ["vob"]
    },
    "video/x-ms-wm": {
      source: "apache",
      extensions: ["wm"]
    },
    "video/x-ms-wmv": {
      source: "apache",
      compressible: false,
      extensions: ["wmv"]
    },
    "video/x-ms-wmx": {
      source: "apache",
      extensions: ["wmx"]
    },
    "video/x-ms-wvx": {
      source: "apache",
      extensions: ["wvx"]
    },
    "video/x-msvideo": {
      source: "apache",
      extensions: ["avi"]
    },
    "video/x-sgi-movie": {
      source: "apache",
      extensions: ["movie"]
    },
    "video/x-smv": {
      source: "apache",
      extensions: ["smv"]
    },
    "x-conference/x-cooltalk": {
      source: "apache",
      extensions: ["ice"]
    },
    "x-shader/x-fragment": {
      compressible: true
    },
    "x-shader/x-vertex": {
      compressible: true
    }
  };
});

// backend/node_modules/mime-db/index.js
var require_mime_db = __commonJS((exports2, module2) => {
  /*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   */
  module2.exports = require_db();
});

// backend/node_modules/mime-types/index.js
var require_mime_types = __commonJS((exports2) => {
  /*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var db = require_mime_db();
  var extname = require("path").extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports2.charset = charset;
  exports2.charsets = { lookup: charset };
  exports2.contentType = contentType;
  exports2.extension = extension;
  exports2.extensions = Object.create(null);
  exports2.lookup = lookup;
  exports2.types = Object.create(null);
  populateMaps(exports2.extensions, exports2.types);
  function charset(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match2 = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match2 && db[match2[1].toLowerCase()];
    if (mime && mime.charset) {
      return mime.charset;
    }
    if (match2 && TEXT_TYPE_REGEXP.test(match2[1])) {
      return "UTF-8";
    }
    return false;
  }
  function contentType(str2) {
    if (!str2 || typeof str2 !== "string") {
      return false;
    }
    var mime = str2.indexOf("/") === -1 ? exports2.lookup(str2) : str2;
    if (!mime) {
      return false;
    }
    if (mime.indexOf("charset") === -1) {
      var charset2 = exports2.charset(mime);
      if (charset2)
        mime += "; charset=" + charset2.toLowerCase();
    }
    return mime;
  }
  function extension(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match2 = EXTRACT_TYPE_REGEXP.exec(type);
    var exts = match2 && exports2.extensions[match2[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup(path2) {
    if (!path2 || typeof path2 !== "string") {
      return false;
    }
    var extension2 = extname("x." + path2).toLowerCase().substr(1);
    if (!extension2) {
      return false;
    }
    return exports2.types[extension2] || false;
  }
  function populateMaps(extensions, types) {
    var preference = ["nginx", "apache", undefined, "iana"];
    Object.keys(db).forEach(function forEachMimeType(type) {
      var mime = db[type];
      var exts = mime.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type] = exts;
      for (var i = 0;i < exts.length; i++) {
        var extension2 = exts[i];
        if (types[extension2]) {
          var from = preference.indexOf(db[types[extension2]].source);
          var to = preference.indexOf(mime.source);
          if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
            continue;
          }
        }
        types[extension2] = type;
      }
    });
  }
});

// backend/node_modules/asynckit/lib/defer.js
var require_defer = __commonJS((exports2, module2) => {
  module2.exports = defer;
  function defer(fn) {
    var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
    if (nextTick) {
      nextTick(fn);
    } else {
      setTimeout(fn, 0);
    }
  }
});

// backend/node_modules/asynckit/lib/async.js
var require_async = __commonJS((exports2, module2) => {
  var defer = require_defer();
  module2.exports = async;
  function async(callback) {
    var isAsync = false;
    defer(function() {
      isAsync = true;
    });
    return function async_callback(err, result) {
      if (isAsync) {
        callback(err, result);
      } else {
        defer(function nextTick_callback() {
          callback(err, result);
        });
      }
    };
  }
});

// backend/node_modules/asynckit/lib/abort.js
var require_abort = __commonJS((exports2, module2) => {
  module2.exports = abort;
  function abort(state) {
    Object.keys(state.jobs).forEach(clean.bind(state));
    state.jobs = {};
  }
  function clean(key) {
    if (typeof this.jobs[key] == "function") {
      this.jobs[key]();
    }
  }
});

// backend/node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS((exports2, module2) => {
  var async = require_async();
  var abort = require_abort();
  module2.exports = iterate;
  function iterate(list, iterator2, state, callback) {
    var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
    state.jobs[key] = runJob(iterator2, key, list[key], function(error2, output) {
      if (!(key in state.jobs)) {
        return;
      }
      delete state.jobs[key];
      if (error2) {
        abort(state);
      } else {
        state.results[key] = output;
      }
      callback(error2, state.results);
    });
  }
  function runJob(iterator2, key, item, callback) {
    var aborter;
    if (iterator2.length == 2) {
      aborter = iterator2(item, async(callback));
    } else {
      aborter = iterator2(item, key, async(callback));
    }
    return aborter;
  }
});

// backend/node_modules/asynckit/lib/state.js
var require_state = __commonJS((exports2, module2) => {
  module2.exports = state;
  function state(list, sortMethod) {
    var isNamedList = !Array.isArray(list), initState = {
      index: 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs: {},
      results: isNamedList ? {} : [],
      size: isNamedList ? Object.keys(list).length : list.length
    };
    if (sortMethod) {
      initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
        return sortMethod(list[a], list[b]);
      });
    }
    return initState;
  }
});

// backend/node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS((exports2, module2) => {
  var abort = require_abort();
  var async = require_async();
  module2.exports = terminator;
  function terminator(callback) {
    if (!Object.keys(this.jobs).length) {
      return;
    }
    this.index = this.size;
    abort(this);
    async(callback)(null, this.results);
  }
});

// backend/node_modules/asynckit/parallel.js
var require_parallel = __commonJS((exports2, module2) => {
  var iterate = require_iterate();
  var initState = require_state();
  var terminator = require_terminator();
  module2.exports = parallel;
  function parallel(list, iterator2, callback) {
    var state = initState(list);
    while (state.index < (state["keyedList"] || list).length) {
      iterate(list, iterator2, state, function(error2, result) {
        if (error2) {
          callback(error2, result);
          return;
        }
        if (Object.keys(state.jobs).length === 0) {
          callback(null, state.results);
          return;
        }
      });
      state.index++;
    }
    return terminator.bind(state, callback);
  }
});

// backend/node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS((exports2, module2) => {
  var iterate = require_iterate();
  var initState = require_state();
  var terminator = require_terminator();
  module2.exports = serialOrdered;
  module2.exports.ascending = ascending;
  module2.exports.descending = descending;
  function serialOrdered(list, iterator2, sortMethod, callback) {
    var state = initState(list, sortMethod);
    iterate(list, iterator2, state, function iteratorHandler(error2, result) {
      if (error2) {
        callback(error2, result);
        return;
      }
      state.index++;
      if (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator2, state, iteratorHandler);
        return;
      }
      callback(null, state.results);
    });
    return terminator.bind(state, callback);
  }
  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }
  function descending(a, b) {
    return -1 * ascending(a, b);
  }
});

// backend/node_modules/asynckit/serial.js
var require_serial = __commonJS((exports2, module2) => {
  var serialOrdered = require_serialOrdered();
  module2.exports = serial;
  function serial(list, iterator2, callback) {
    return serialOrdered(list, iterator2, null, callback);
  }
});

// backend/node_modules/asynckit/index.js
var require_asynckit = __commonJS((exports2, module2) => {
  module2.exports = {
    parallel: require_parallel(),
    serial: require_serial(),
    serialOrdered: require_serialOrdered()
  };
});

// backend/node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS((exports2, module2) => {
  module2.exports = Object;
});

// backend/node_modules/es-errors/index.js
var require_es_errors = __commonJS((exports2, module2) => {
  module2.exports = Error;
});

// backend/node_modules/es-errors/eval.js
var require_eval = __commonJS((exports2, module2) => {
  module2.exports = EvalError;
});

// backend/node_modules/es-errors/range.js
var require_range2 = __commonJS((exports2, module2) => {
  module2.exports = RangeError;
});

// backend/node_modules/es-errors/ref.js
var require_ref = __commonJS((exports2, module2) => {
  module2.exports = ReferenceError;
});

// backend/node_modules/es-errors/syntax.js
var require_syntax = __commonJS((exports2, module2) => {
  module2.exports = SyntaxError;
});

// backend/node_modules/es-errors/type.js
var require_type = __commonJS((exports2, module2) => {
  module2.exports = TypeError;
});

// backend/node_modules/es-errors/uri.js
var require_uri = __commonJS((exports2, module2) => {
  module2.exports = URIError;
});

// backend/node_modules/math-intrinsics/abs.js
var require_abs = __commonJS((exports2, module2) => {
  module2.exports = Math.abs;
});

// backend/node_modules/math-intrinsics/floor.js
var require_floor = __commonJS((exports2, module2) => {
  module2.exports = Math.floor;
});

// backend/node_modules/math-intrinsics/max.js
var require_max = __commonJS((exports2, module2) => {
  module2.exports = Math.max;
});

// backend/node_modules/math-intrinsics/min.js
var require_min = __commonJS((exports2, module2) => {
  module2.exports = Math.min;
});

// backend/node_modules/math-intrinsics/pow.js
var require_pow = __commonJS((exports2, module2) => {
  module2.exports = Math.pow;
});

// backend/node_modules/math-intrinsics/round.js
var require_round = __commonJS((exports2, module2) => {
  module2.exports = Math.round;
});

// backend/node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS((exports2, module2) => {
  module2.exports = Number.isNaN || function isNaN(a) {
    return a !== a;
  };
});

// backend/node_modules/math-intrinsics/sign.js
var require_sign = __commonJS((exports2, module2) => {
  var $isNaN = require_isNaN();
  module2.exports = function sign(number) {
    if ($isNaN(number) || number === 0) {
      return number;
    }
    return number < 0 ? -1 : 1;
  };
});

// backend/node_modules/gopd/gOPD.js
var require_gOPD = __commonJS((exports2, module2) => {
  module2.exports = Object.getOwnPropertyDescriptor;
});

// backend/node_modules/gopd/index.js
var require_gopd = __commonJS((exports2, module2) => {
  var $gOPD = require_gOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  module2.exports = $gOPD;
});

// backend/node_modules/es-define-property/index.js
var require_es_define_property = __commonJS((exports2, module2) => {
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  module2.exports = $defineProperty;
});

// backend/node_modules/has-symbols/shams.js
var require_shams = __commonJS((exports2, module2) => {
  module2.exports = function hasSymbols() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj2 = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj2[sym] = symVal;
    for (var _ in obj2) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj2).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj2).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj2);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj2, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = Object.getOwnPropertyDescriptor(obj2, sym);
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
});

// backend/node_modules/has-symbols/index.js
var require_has_symbols = __commonJS((exports2, module2) => {
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = require_shams();
  module2.exports = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
});

// backend/node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS((exports2, module2) => {
  module2.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
});

// backend/node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS((exports2, module2) => {
  var $Object = require_es_object_atoms();
  module2.exports = $Object.getPrototypeOf || null;
});

// backend/node_modules/function-bind/implementation.js
var require_implementation = __commonJS((exports2, module2) => {
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty(a, b) {
    var arr = [];
    for (var i = 0;i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j = 0;j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0;i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str2 = "";
    for (var i = 0;i < arr.length; i += 1) {
      str2 += arr[i];
      if (i + 1 < arr.length) {
        str2 += joiner;
      }
    }
    return str2;
  };
  module2.exports = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(this, concatty(args, arguments));
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0;i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty() {};
      Empty.prototype = target.prototype;
      bound.prototype = new Empty;
      Empty.prototype = null;
    }
    return bound;
  };
});

// backend/node_modules/function-bind/index.js
var require_function_bind = __commonJS((exports2, module2) => {
  var implementation = require_implementation();
  module2.exports = Function.prototype.bind || implementation;
});

// backend/node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS((exports2, module2) => {
  module2.exports = Function.prototype.call;
});

// backend/node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS((exports2, module2) => {
  module2.exports = Function.prototype.apply;
});

// backend/node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS((exports2, module2) => {
  module2.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
});

// backend/node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS((exports2, module2) => {
  var bind2 = require_function_bind();
  var $apply = require_functionApply();
  var $call = require_functionCall();
  var $reflectApply = require_reflectApply();
  module2.exports = $reflectApply || bind2.call($call, $apply);
});

// backend/node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS((exports2, module2) => {
  var bind2 = require_function_bind();
  var $TypeError = require_type();
  var $call = require_functionCall();
  var $actualApply = require_actualApply();
  module2.exports = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind2, $call, args);
  };
});

// backend/node_modules/dunder-proto/get.js
var require_get = __commonJS((exports2, module2) => {
  var callBind = require_call_bind_apply_helpers();
  var gOPD = require_gopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, "__proto__");
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  module2.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? function getDunder(value) {
    return $getPrototypeOf(value == null ? value : $Object(value));
  } : false;
});

// backend/node_modules/get-proto/index.js
var require_get_proto = __commonJS((exports2, module2) => {
  var reflectGetProto = require_Reflect_getPrototypeOf();
  var originalGetProto = require_Object_getPrototypeOf();
  var getDunderProto = require_get();
  module2.exports = reflectGetProto ? function getProto(O) {
    return reflectGetProto(O);
  } : originalGetProto ? function getProto(O) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O);
  } : getDunderProto ? function getProto(O) {
    return getDunderProto(O);
  } : null;
});

// backend/node_modules/hasown/index.js
var require_hasown = __commonJS((exports2, module2) => {
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind2 = require_function_bind();
  module2.exports = bind2.call(call, $hasOwn);
});

// backend/node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS((exports2, module2) => {
  var undefined2;
  var $Object = require_es_object_atoms();
  var $Error = require_es_errors();
  var $EvalError = require_eval();
  var $RangeError = require_range2();
  var $ReferenceError = require_ref();
  var $SyntaxError = require_syntax();
  var $TypeError = require_type();
  var $URIError = require_uri();
  var abs = require_abs();
  var floor = require_floor();
  var max = require_max();
  var min = require_min();
  var pow = require_pow();
  var round = require_round();
  var sign = require_sign();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {}
  };
  var $gOPD = require_gopd();
  var $defineProperty = require_es_define_property();
  var throwTypeError = function() {
    throw new $TypeError;
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols = require_has_symbols()();
  var getProto = require_get_proto();
  var $ObjectGPO = require_Object_getPrototypeOf();
  var $ReflectGPO = require_Reflect_getPrototypeOf();
  var $apply = require_functionApply();
  var $call = require_functionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
    "%AsyncFromSyncIteratorPrototype%": undefined2,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    "%EvalError%": $EvalError,
    "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
    "%JSON%": typeof JSON === "object" ? JSON : undefined2,
    "%Map%": typeof Map === "undefined" ? undefined2 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto(new Map()[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined2 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto(new Set()[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
    "%Symbol%": hasSymbols ? Symbol : undefined2,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Object.getPrototypeOf%": $ObjectGPO,
    "%Math.abs%": abs,
    "%Math.floor%": floor,
    "%Math.max%": max,
    "%Math.min%": min,
    "%Math.pow%": pow,
    "%Math.round%": round,
    "%Math.sign%": sign,
    "%Reflect.getPrototypeOf%": $ReflectGPO
  };
  if (getProto) {
    try {
      null.error;
    } catch (e) {
      errorProto = getProto(getProto(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var errorProto;
  var doEval = function doEval(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval("%AsyncGenerator%");
      if (gen && getProto) {
        value = getProto(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind2 = require_function_bind();
  var hasOwn2 = require_hasown();
  var $concat = bind2.call($call, Array.prototype.concat);
  var $spliceApply = bind2.call($apply, Array.prototype.splice);
  var $replace = bind2.call($call, String.prototype.replace);
  var $strSlice = bind2.call($call, String.prototype.slice);
  var $exec = bind2.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName, function(match2, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match2;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn2(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn2(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  module2.exports = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true;i < parts.length; i += 1) {
      var part = parts[i];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn2(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn2(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
});

// backend/node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS((exports2, module2) => {
  var hasSymbols = require_shams();
  module2.exports = function hasToStringTagShams() {
    return hasSymbols() && !!Symbol.toStringTag;
  };
});

// backend/node_modules/es-set-tostringtag/index.js
var require_es_set_tostringtag = __commonJS((exports2, module2) => {
  var GetIntrinsic = require_get_intrinsic();
  var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
  var hasToStringTag = require_shams2()();
  var hasOwn2 = require_hasown();
  var $TypeError = require_type();
  var toStringTag2 = hasToStringTag ? Symbol.toStringTag : null;
  module2.exports = function setToStringTag(object, value) {
    var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
    var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
    if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") {
      throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
    }
    if (toStringTag2 && (overrideIfSet || !hasOwn2(object, toStringTag2))) {
      if ($defineProperty) {
        $defineProperty(object, toStringTag2, {
          configurable: !nonConfigurable,
          enumerable: false,
          value,
          writable: false
        });
      } else {
        object[toStringTag2] = value;
      }
    }
  };
});

// backend/node_modules/form-data/lib/populate.js
var require_populate = __commonJS((exports2, module2) => {
  module2.exports = function(dst, src) {
    Object.keys(src).forEach(function(prop) {
      dst[prop] = dst[prop] || src[prop];
    });
    return dst;
  };
});

// backend/node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS((exports2, module2) => {
  var CombinedStream = require_combined_stream();
  var util = require("util");
  var path2 = require("path");
  var http = require("http");
  var https = require("https");
  var parseUrl = require("url").parse;
  var fs = require("fs");
  var Stream2 = require("stream").Stream;
  var crypto2 = require("crypto");
  var mime = require_mime_types();
  var asynckit = require_asynckit();
  var setToStringTag = require_es_set_tostringtag();
  var hasOwn2 = require_hasown();
  var populate = require_populate();
  function FormData2(options) {
    if (!(this instanceof FormData2)) {
      return new FormData2(options);
    }
    this._overheadLength = 0;
    this._valueLength = 0;
    this._valuesToMeasure = [];
    CombinedStream.call(this);
    options = options || {};
    for (var option in options) {
      this[option] = options[option];
    }
  }
  util.inherits(FormData2, CombinedStream);
  FormData2.LINE_BREAK = `\r
`;
  FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
  FormData2.prototype.append = function(field, value, options) {
    options = options || {};
    if (typeof options === "string") {
      options = { filename: options };
    }
    var append = CombinedStream.prototype.append.bind(this);
    if (typeof value === "number" || value == null) {
      value = String(value);
    }
    if (Array.isArray(value)) {
      this._error(new Error("Arrays are not supported."));
      return;
    }
    var header = this._multiPartHeader(field, value, options);
    var footer = this._multiPartFooter();
    append(header);
    append(value);
    append(footer);
    this._trackLength(header, value, options);
  };
  FormData2.prototype._trackLength = function(header, value, options) {
    var valueLength = 0;
    if (options.knownLength != null) {
      valueLength += Number(options.knownLength);
    } else if (Buffer.isBuffer(value)) {
      valueLength = value.length;
    } else if (typeof value === "string") {
      valueLength = Buffer.byteLength(value);
    }
    this._valueLength += valueLength;
    this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
    if (!value || !value.path && !(value.readable && hasOwn2(value, "httpVersion")) && !(value instanceof Stream2)) {
      return;
    }
    if (!options.knownLength) {
      this._valuesToMeasure.push(value);
    }
  };
  FormData2.prototype._lengthRetriever = function(value, callback) {
    if (hasOwn2(value, "fd")) {
      if (value.end != null && value.end != Infinity && value.start != null) {
        callback(null, value.end + 1 - (value.start ? value.start : 0));
      } else {
        fs.stat(value.path, function(err, stat) {
          if (err) {
            callback(err);
            return;
          }
          var fileSize = stat.size - (value.start ? value.start : 0);
          callback(null, fileSize);
        });
      }
    } else if (hasOwn2(value, "httpVersion")) {
      callback(null, Number(value.headers["content-length"]));
    } else if (hasOwn2(value, "httpModule")) {
      value.on("response", function(response) {
        value.pause();
        callback(null, Number(response.headers["content-length"]));
      });
      value.resume();
    } else {
      callback("Unknown stream");
    }
  };
  FormData2.prototype._multiPartHeader = function(field, value, options) {
    if (typeof options.header === "string") {
      return options.header;
    }
    var contentDisposition = this._getContentDisposition(value, options);
    var contentType = this._getContentType(value, options);
    var contents = "";
    var headers = {
      "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
      "Content-Type": [].concat(contentType || [])
    };
    if (typeof options.header === "object") {
      populate(headers, options.header);
    }
    var header;
    for (var prop in headers) {
      if (hasOwn2(headers, prop)) {
        header = headers[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
        }
      }
    }
    return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
  };
  FormData2.prototype._getContentDisposition = function(value, options) {
    var filename;
    if (typeof options.filepath === "string") {
      filename = path2.normalize(options.filepath).replace(/\\/g, "/");
    } else if (options.filename || value && (value.name || value.path)) {
      filename = path2.basename(options.filename || value && (value.name || value.path));
    } else if (value && value.readable && hasOwn2(value, "httpVersion")) {
      filename = path2.basename(value.client._httpMessage.path || "");
    }
    if (filename) {
      return 'filename="' + filename + '"';
    }
  };
  FormData2.prototype._getContentType = function(value, options) {
    var contentType = options.contentType;
    if (!contentType && value && value.name) {
      contentType = mime.lookup(value.name);
    }
    if (!contentType && value && value.path) {
      contentType = mime.lookup(value.path);
    }
    if (!contentType && value && value.readable && hasOwn2(value, "httpVersion")) {
      contentType = value.headers["content-type"];
    }
    if (!contentType && (options.filepath || options.filename)) {
      contentType = mime.lookup(options.filepath || options.filename);
    }
    if (!contentType && value && typeof value === "object") {
      contentType = FormData2.DEFAULT_CONTENT_TYPE;
    }
    return contentType;
  };
  FormData2.prototype._multiPartFooter = function() {
    return function(next) {
      var footer = FormData2.LINE_BREAK;
      var lastPart = this._streams.length === 0;
      if (lastPart) {
        footer += this._lastBoundary();
      }
      next(footer);
    }.bind(this);
  };
  FormData2.prototype._lastBoundary = function() {
    return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
  };
  FormData2.prototype.getHeaders = function(userHeaders) {
    var header;
    var formHeaders = {
      "content-type": "multipart/form-data; boundary=" + this.getBoundary()
    };
    for (header in userHeaders) {
      if (hasOwn2(userHeaders, header)) {
        formHeaders[header.toLowerCase()] = userHeaders[header];
      }
    }
    return formHeaders;
  };
  FormData2.prototype.setBoundary = function(boundary) {
    if (typeof boundary !== "string") {
      throw new TypeError("FormData boundary must be a string");
    }
    this._boundary = boundary;
  };
  FormData2.prototype.getBoundary = function() {
    if (!this._boundary) {
      this._generateBoundary();
    }
    return this._boundary;
  };
  FormData2.prototype.getBuffer = function() {
    var dataBuffer = new Buffer.alloc(0);
    var boundary = this.getBoundary();
    for (var i = 0, len = this._streams.length;i < len; i++) {
      if (typeof this._streams[i] !== "function") {
        if (Buffer.isBuffer(this._streams[i])) {
          dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
        } else {
          dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
        }
        if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
          dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
        }
      }
    }
    return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
  };
  FormData2.prototype._generateBoundary = function() {
    this._boundary = "--------------------------" + crypto2.randomBytes(12).toString("hex");
  };
  FormData2.prototype.getLengthSync = function() {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this.hasKnownLength()) {
      this._error(new Error("Cannot calculate proper length in synchronous way."));
    }
    return knownLength;
  };
  FormData2.prototype.hasKnownLength = function() {
    var hasKnownLength = true;
    if (this._valuesToMeasure.length) {
      hasKnownLength = false;
    }
    return hasKnownLength;
  };
  FormData2.prototype.getLength = function(cb) {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this._valuesToMeasure.length) {
      process.nextTick(cb.bind(this, null, knownLength));
      return;
    }
    asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values2) {
      if (err) {
        cb(err);
        return;
      }
      values2.forEach(function(length) {
        knownLength += length;
      });
      cb(null, knownLength);
    });
  };
  FormData2.prototype.submit = function(params, cb) {
    var request;
    var options;
    var defaults2 = { method: "post" };
    if (typeof params === "string") {
      params = parseUrl(params);
      options = populate({
        port: params.port,
        path: params.pathname,
        host: params.hostname,
        protocol: params.protocol
      }, defaults2);
    } else {
      options = populate(params, defaults2);
      if (!options.port) {
        options.port = options.protocol === "https:" ? 443 : 80;
      }
    }
    options.headers = this.getHeaders(params.headers);
    if (options.protocol === "https:") {
      request = https.request(options);
    } else {
      request = http.request(options);
    }
    this.getLength(function(err, length) {
      if (err && err !== "Unknown stream") {
        this._error(err);
        return;
      }
      if (length) {
        request.setHeader("Content-Length", length);
      }
      this.pipe(request);
      if (cb) {
        var onResponse;
        var callback = function(error2, responce) {
          request.removeListener("error", callback);
          request.removeListener("response", onResponse);
          return cb.call(this, error2, responce);
        };
        onResponse = callback.bind(this, null);
        request.on("error", callback);
        request.on("response", onResponse);
      }
    }.bind(this));
    return request;
  };
  FormData2.prototype._error = function(err) {
    if (!this.error) {
      this.error = err;
      this.pause();
      this.emit("error", err);
    }
  };
  FormData2.prototype.toString = function() {
    return "[object FormData]";
  };
  setToStringTag(FormData2.prototype, "FormData");
  module2.exports = FormData2;
});

// backend/node_modules/axios/lib/platform/node/classes/FormData.js
var import_form_data, FormData_default;
var init_FormData = __esm(() => {
  import_form_data = __toESM(require_form_data(), 1);
  FormData_default = import_form_data.default;
});

// backend/node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path2, key, dots) {
  if (!path2)
    return key;
  return path2.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
function toFormData(obj2, formData, options) {
  if (!utils_default.isObject(obj2)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (FormData_default || FormData);
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (utils_default.isBoolean(value)) {
      return value.toString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path2) {
    let arr = value;
    if (value && !path2 && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]", convertValue(el));
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path2, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path2) {
    if (utils_default.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path2.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(formData, el, utils_default.isString(key) ? key.trim() : key, path2, exposedHelpers);
      if (result === true) {
        build(el, path2 ? path2.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj2)) {
    throw new TypeError("data must be an object");
  }
  build(obj2);
  return formData;
}
var predicates, toFormData_default;
var init_toFormData = __esm(() => {
  init_utils();
  init_AxiosError();
  init_FormData();
  predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
    return /^is[A-Z]/.test(prop);
  });
  toFormData_default = toFormData;
});

// backend/node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode2(str2) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\x00"
  };
  return encodeURIComponent(str2).replace(/[!'()~]|%20|%00/g, function replacer(match2) {
    return charMap[match2];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2, AxiosURLSearchParams_default;
var init_AxiosURLSearchParams = __esm(() => {
  init_toFormData();
  prototype2 = AxiosURLSearchParams.prototype;
  prototype2.append = function append(name, value) {
    this._pairs.push([name, value]);
  };
  prototype2.toString = function toString2(encoder) {
    const _encode = encoder ? function(value) {
      return encoder.call(this, value, encode2);
    } : encode2;
    return this._pairs.map(function each(pair) {
      return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
  };
  AxiosURLSearchParams_default = AxiosURLSearchParams;
});

// backend/node_modules/axios/lib/helpers/buildURL.js
function encode3(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode3;
  if (utils_default.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
var init_buildURL = __esm(() => {
  init_utils();
  init_AxiosURLSearchParams();
});

// backend/node_modules/axios/lib/core/InterceptorManager.js
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}
var InterceptorManager_default;
var init_InterceptorManager = __esm(() => {
  init_utils();
  InterceptorManager_default = InterceptorManager;
});

// backend/node_modules/axios/lib/defaults/transitional.js
var transitional_default;
var init_transitional = __esm(() => {
  transitional_default = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };
});

// backend/node_modules/axios/lib/platform/node/classes/URLSearchParams.js
var import_url6, URLSearchParams_default;
var init_URLSearchParams = __esm(() => {
  import_url6 = __toESM(require("url"));
  URLSearchParams_default = import_url6.default.URLSearchParams;
});

// backend/node_modules/axios/lib/platform/node/index.js
var import_crypto, ALPHA = "abcdefghijklmnopqrstuvwxyz", DIGIT = "0123456789", ALPHABET, generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str2 = "";
  const { length } = alphabet;
  const randomValues = new Uint32Array(size);
  import_crypto.default.randomFillSync(randomValues);
  for (let i = 0;i < size; i++) {
    str2 += alphabet[randomValues[i] % length];
  }
  return str2;
}, node_default;
var init_node = __esm(() => {
  init_URLSearchParams();
  init_FormData();
  import_crypto = __toESM(require("crypto"));
  ALPHABET = {
    DIGIT,
    ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
  };
  node_default = {
    isNode: true,
    classes: {
      URLSearchParams: URLSearchParams_default,
      FormData: FormData_default,
      Blob: typeof Blob !== "undefined" && Blob || null
    },
    ALPHABET,
    generateString,
    protocols: ["http", "https", "file", "data"]
  };
});

// backend/node_modules/axios/lib/platform/common/utils.js
var exports_utils = {};
__export(exports_utils, {
  origin: () => origin,
  navigator: () => _navigator,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasBrowserEnv: () => hasBrowserEnv
});
var hasBrowserEnv, _navigator, hasStandardBrowserEnv, hasStandardBrowserWebWorkerEnv, origin;
var init_utils2 = __esm(() => {
  hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
  _navigator = typeof navigator === "object" && navigator || undefined;
  hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
  hasStandardBrowserWebWorkerEnv = (() => {
    return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
  })();
  origin = hasBrowserEnv && window.location.href || "http://localhost";
});

// backend/node_modules/axios/lib/platform/index.js
var platform_default;
var init_platform = __esm(() => {
  init_node();
  init_utils2();
  platform_default = {
    ...exports_utils,
    ...node_default
  };
});

// backend/node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams, {
    visitor: function(value, key, path2, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    },
    ...options
  });
}
var init_toURLEncodedForm = __esm(() => {
  init_utils();
  init_toFormData();
  init_platform();
});

// backend/node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match2) => {
    return match2[0] === "[]" ? "" : match2[1] || match2[0];
  });
}
function arrayToObject(arr) {
  const obj2 = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0;i < len; i++) {
    key = keys[i];
    obj2[key] = arr[key];
  }
  return obj2;
}
function formDataToJSON(formData) {
  function buildPath(path2, value, target, index) {
    let name = path2[index++];
    if (name === "__proto__")
      return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path2.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path2, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj2 = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj2, 0);
    });
    return obj2;
  }
  return null;
}
var formDataToJSON_default;
var init_formDataToJSON = __esm(() => {
  init_utils();
  formDataToJSON_default = formDataToJSON;
});

// backend/node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults2, defaults_default;
var init_defaults = __esm(() => {
  init_utils();
  init_AxiosError();
  init_transitional();
  init_toFormData();
  init_toURLEncodedForm();
  init_platform();
  init_formDataToJSON();
  defaults2 = {
    transitional: transitional_default,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function transformRequest(data, headers) {
      const contentType = headers.getContentType() || "";
      const hasJSONContentType = contentType.indexOf("application/json") > -1;
      const isObjectPayload = utils_default.isObject(data);
      if (isObjectPayload && utils_default.isHTMLForm(data)) {
        data = new FormData(data);
      }
      const isFormData2 = utils_default.isFormData(data);
      if (isFormData2) {
        return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
      }
      if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
        return data;
      }
      if (utils_default.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils_default.isURLSearchParams(data)) {
        headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
        return data.toString();
      }
      let isFileList2;
      if (isObjectPayload) {
        if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
          return toURLEncodedForm(data, this.formSerializer).toString();
        }
        if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
          const _FormData = this.env && this.env.FormData;
          return toFormData_default(isFileList2 ? { "files[]": data } : data, _FormData && new _FormData, this.formSerializer);
        }
      }
      if (isObjectPayload || hasJSONContentType) {
        headers.setContentType("application/json", false);
        return stringifySafely(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      const transitional = this.transitional || defaults2.transitional;
      const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
      const JSONRequested = this.responseType === "json";
      if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
        return data;
      }
      if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
        const silentJSONParsing = transitional && transitional.silentJSONParsing;
        const strictJSONParsing = !silentJSONParsing && JSONRequested;
        try {
          return JSON.parse(data, this.parseReviver);
        } catch (e) {
          if (strictJSONParsing) {
            if (e.name === "SyntaxError") {
              throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e;
          }
        }
      }
      return data;
    }],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: platform_default.classes.FormData,
      Blob: platform_default.classes.Blob
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        Accept: "application/json, text/plain, */*",
        "Content-Type": undefined
      }
    }
  };
  utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
    defaults2.headers[method] = {};
  });
  defaults_default = defaults2;
});

// backend/node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf, parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split(`
`).forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
var init_parseHeaders = __esm(() => {
  init_utils();
  ignoreDuplicateOf = utils_default.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]);
});

// backend/node_modules/axios/lib/core/AxiosHeaders.js
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str2) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match2;
  while (match2 = tokensRE.exec(str2)) {
    tokens[match2[1]] = match2[2];
  }
  return tokens;
}
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value))
    return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str2) => {
    return char.toUpperCase() + str2;
  });
}
function buildAccessors(obj2, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj2, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var $internals, isValidHeaderName = (str2) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str2.trim()), AxiosHeaders, AxiosHeaders_default;
var init_AxiosHeaders = __esm(() => {
  init_utils();
  init_parseHeaders();
  $internals = Symbol("internals");
  AxiosHeaders = class AxiosHeaders {
    constructor(headers) {
      headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
      const self2 = this;
      function setHeader(_value, _header, _rewrite) {
        const lHeader = normalizeHeader(_header);
        if (!lHeader) {
          throw new Error("header name must be a non-empty string");
        }
        const key = utils_default.findKey(self2, lHeader);
        if (!key || self2[key] === undefined || _rewrite === true || _rewrite === undefined && self2[key] !== false) {
          self2[key || _header] = normalizeValue(_value);
        }
      }
      const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
      if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
        setHeaders(header, valueOrRewrite);
      } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
        setHeaders(parseHeaders_default(header), valueOrRewrite);
      } else if (utils_default.isObject(header) && utils_default.isIterable(header)) {
        let obj2 = {}, dest, key;
        for (const entry of header) {
          if (!utils_default.isArray(entry)) {
            throw TypeError("Object iterator must return a key-value pair");
          }
          obj2[key = entry[0]] = (dest = obj2[key]) ? utils_default.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
        }
        setHeaders(obj2, valueOrRewrite);
      } else {
        header != null && setHeader(valueOrRewrite, header, rewrite);
      }
      return this;
    }
    get(header, parser) {
      header = normalizeHeader(header);
      if (header) {
        const key = utils_default.findKey(this, header);
        if (key) {
          const value = this[key];
          if (!parser) {
            return value;
          }
          if (parser === true) {
            return parseTokens(value);
          }
          if (utils_default.isFunction(parser)) {
            return parser.call(this, value, key);
          }
          if (utils_default.isRegExp(parser)) {
            return parser.exec(value);
          }
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(header, matcher) {
      header = normalizeHeader(header);
      if (header) {
        const key = utils_default.findKey(this, header);
        return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
      }
      return false;
    }
    delete(header, matcher) {
      const self2 = this;
      let deleted = false;
      function deleteHeader(_header) {
        _header = normalizeHeader(_header);
        if (_header) {
          const key = utils_default.findKey(self2, _header);
          if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
            delete self2[key];
            deleted = true;
          }
        }
      }
      if (utils_default.isArray(header)) {
        header.forEach(deleteHeader);
      } else {
        deleteHeader(header);
      }
      return deleted;
    }
    clear(matcher) {
      const keys = Object.keys(this);
      let i = keys.length;
      let deleted = false;
      while (i--) {
        const key = keys[i];
        if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
          delete this[key];
          deleted = true;
        }
      }
      return deleted;
    }
    normalize(format) {
      const self2 = this;
      const headers = {};
      utils_default.forEach(this, (value, header) => {
        const key = utils_default.findKey(headers, header);
        if (key) {
          self2[key] = normalizeValue(value);
          delete self2[header];
          return;
        }
        const normalized = format ? formatHeader(header) : String(header).trim();
        if (normalized !== header) {
          delete self2[header];
        }
        self2[normalized] = normalizeValue(value);
        headers[normalized] = true;
      });
      return this;
    }
    concat(...targets) {
      return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
      const obj2 = Object.create(null);
      utils_default.forEach(this, (value, header) => {
        value != null && value !== false && (obj2[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
      });
      return obj2;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join(`
`);
    }
    getSetCookie() {
      return this.get("set-cookie") || [];
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
      const computed = new this(first);
      targets.forEach((target) => computed.set(target));
      return computed;
    }
    static accessor(header) {
      const internals = this[$internals] = this[$internals] = {
        accessors: {}
      };
      const accessors = internals.accessors;
      const prototype3 = this.prototype;
      function defineAccessor(_header) {
        const lHeader = normalizeHeader(_header);
        if (!accessors[lHeader]) {
          buildAccessors(prototype3, _header);
          accessors[lHeader] = true;
        }
      }
      utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
      return this;
    }
  };
  AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
    let mapped = key[0].toUpperCase() + key.slice(1);
    return {
      get: () => value,
      set(headerValue) {
        this[mapped] = headerValue;
      }
    };
  });
  utils_default.freezeMethods(AxiosHeaders);
  AxiosHeaders_default = AxiosHeaders;
});

// backend/node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });
  headers.normalize();
  return data;
}
var init_transformData = __esm(() => {
  init_utils();
  init_defaults();
  init_AxiosHeaders();
});

// backend/node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// backend/node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
var CanceledError_default;
var init_CanceledError = __esm(() => {
  init_AxiosError();
  init_utils();
  utils_default.inherits(CanceledError, AxiosError_default, {
    __CANCEL__: true
  });
  CanceledError_default = CanceledError;
});

// backend/node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default("Request failed with status code " + response.status, [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
  }
}
var init_settle = __esm(() => {
  init_AxiosError();
});

// backend/node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL2(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}

// backend/node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// backend/node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL2(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
var init_buildFullPath = () => {};

// backend/node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS((exports2) => {
  var parseUrl = require("url").parse;
  var DEFAULT_PORTS = {
    ftp: 21,
    gopher: 70,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  var stringEndsWith = String.prototype.endsWith || function(s) {
    return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
  };
  function getProxyForUrl(url2) {
    var parsedUrl = typeof url2 === "string" ? parseUrl(url2) : url2 || {};
    var proto = parsedUrl.protocol;
    var hostname = parsedUrl.host;
    var port = parsedUrl.port;
    if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
      return "";
    }
    proto = proto.split(":", 1)[0];
    hostname = hostname.replace(/:\d*$/, "");
    port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
    if (!shouldProxy(hostname, port)) {
      return "";
    }
    var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
    if (proxy && proxy.indexOf("://") === -1) {
      proxy = proto + "://" + proxy;
    }
    return proxy;
  }
  function shouldProxy(hostname, port) {
    var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
    if (!NO_PROXY) {
      return true;
    }
    if (NO_PROXY === "*") {
      return false;
    }
    return NO_PROXY.split(/[,\s]/).every(function(proxy) {
      if (!proxy) {
        return true;
      }
      var parsedProxy = proxy.match(/^(.+):(\d+)$/);
      var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
      var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
      if (parsedProxyPort && parsedProxyPort !== port) {
        return true;
      }
      if (!/^[.*]/.test(parsedProxyHostname)) {
        return hostname !== parsedProxyHostname;
      }
      if (parsedProxyHostname.charAt(0) === "*") {
        parsedProxyHostname = parsedProxyHostname.slice(1);
      }
      return !stringEndsWith.call(hostname, parsedProxyHostname);
    });
  }
  function getEnv(key) {
    return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
  }
  exports2.getProxyForUrl = getProxyForUrl;
});

// backend/node_modules/ms/index.js
var require_ms = __commonJS((exports2, module2) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module2.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str2) {
    str2 = String(str2);
    if (str2.length > 100) {
      return;
    }
    var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str2);
    if (!match2) {
      return;
    }
    var n = parseFloat(match2[1]);
    var type = (match2[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// backend/node_modules/debug/src/common.js
var require_common = __commonJS((exports2, module2) => {
  function setup(env2) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    Object.keys(env2).forEach(function(key) {
      createDebug[key] = env2[key];
    });
    createDebug.instances = [];
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      var hash = 0;
      for (var i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      var prevTime;
      function debug() {
        if (!debug.enabled) {
          return;
        }
        for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var self2 = debug;
        var curr = Number(new Date);
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match2, format) {
          if (match2 === "%%") {
            return match2;
          }
          index++;
          var formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            var val = args[index];
            match2 = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match2;
        });
        createDebug.formatArgs.call(self2, args);
        var logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = createDebug.enabled(namespace);
      debug.useColors = createDebug.useColors();
      debug.color = selectColor(namespace);
      debug.destroy = destroy;
      debug.extend = extend2;
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      createDebug.instances.push(debug);
      return debug;
    }
    function destroy() {
      var index = createDebug.instances.indexOf(this);
      if (index !== -1) {
        createDebug.instances.splice(index, 1);
        return true;
      }
      return false;
    }
    function extend2(namespace, delimiter) {
      return createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.names = [];
      createDebug.skips = [];
      var i;
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (i = 0;i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
      for (i = 0;i < createDebug.instances.length; i++) {
        var instance = createDebug.instances[i];
        instance.enabled = createDebug.enabled(instance.namespace);
      }
    }
    function disable() {
      createDebug.enable("");
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      var i;
      var len;
      for (i = 0, len = createDebug.skips.length;i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length;i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module2.exports = setup;
});

// backend/node_modules/debug/src/browser.js
var require_browser = __commonJS((exports2, module2) => {
  function _typeof(obj2) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj3) {
        return typeof obj3;
      };
    } else {
      _typeof = function _typeof(obj3) {
        return obj3 && typeof Symbol === "function" && obj3.constructor === Symbol && obj3 !== Symbol.prototype ? "symbol" : typeof obj3;
      };
    }
    return _typeof(obj2);
  }
  exports2.log = log2;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = localstorage();
  exports2.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    var c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, function(match2) {
      if (match2 === "%%") {
        return;
      }
      index++;
      if (match2 === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  function log2() {
    var _console;
    return (typeof console === "undefined" ? "undefined" : _typeof(console)) === "object" && console.log && (_console = console).log.apply(_console, arguments);
  }
  function save(namespaces) {
    try {
      if (namespaces) {
        exports2.storage.setItem("debug", namespaces);
      } else {
        exports2.storage.removeItem("debug");
      }
    } catch (error2) {}
  }
  function load() {
    var r;
    try {
      r = exports2.storage.getItem("debug");
    } catch (error2) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error2) {}
  }
  module2.exports = require_common()(exports2);
  var formatters2 = module2.exports.formatters;
  formatters2.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error2) {
      return "[UnexpectedJSONParseError]: " + error2.message;
    }
  };
});

// backend/node_modules/debug/src/node.js
var require_node = __commonJS((exports2, module2) => {
  var tty = require("tty");
  var util = require("util");
  exports2.init = init;
  exports2.log = log2;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.colors = [6, 2, 3, 4, 5, 1];
  try {
    supportsColor = (()=>{throw new Error("Cannot require module "+"supports-color");})();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports2.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];
    }
  } catch (error2) {}
  var supportsColor;
  exports2.inspectOpts = Object.keys(process.env).filter(function(key) {
    return /^debug_/i.test(key);
  }).reduce(function(obj2, key) {
    var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
      return k.toUpperCase();
    });
    var val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj2[prop] = val;
    return obj2;
  }, {});
  function useColors() {
    return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    var name = this.namespace, useColors2 = this.useColors;
    if (useColors2) {
      var c = this.color;
      var colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      var prefix = "  ".concat(colorCode, ";1m").concat(name, " \x1B[0m");
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports2.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log2() {
    return process.stderr.write(util.format.apply(util, arguments) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    var keys = Object.keys(exports2.inspectOpts);
    for (var i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
    }
  }
  module2.exports = require_common()(exports2);
  var formatters2 = module2.exports.formatters;
  formatters2.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split(`
`).map(function(str2) {
      return str2.trim();
    }).join(" ");
  };
  formatters2.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// backend/node_modules/debug/src/index.js
var require_src = __commonJS((exports2, module2) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module2.exports = require_browser();
  } else {
    module2.exports = require_node();
  }
});

// backend/node_modules/follow-redirects/debug.js
var require_debug2 = __commonJS((exports2, module2) => {
  var debug;
  module2.exports = function() {
    if (!debug) {
      try {
        debug = require_src()("follow-redirects");
      } catch (error2) {}
      if (typeof debug !== "function") {
        debug = function() {};
      }
    }
    debug.apply(null, arguments);
  };
});

// backend/node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS((exports2, module2) => {
  var url2 = require("url");
  var URL2 = url2.URL;
  var http = require("http");
  var https = require("https");
  var Writable = require("stream").Writable;
  var assert = require("assert");
  var debug = require_debug2();
  (function detectUnsupportedEnvironment() {
    var looksLikeNode = typeof process !== "undefined";
    var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
    var looksLikeV8 = isFunction2(Error.captureStackTrace);
    if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
      console.warn("The follow-redirects package should be excluded from browser builds.");
    }
  })();
  var useNativeURL = false;
  try {
    assert(new URL2(""));
  } catch (error2) {
    useNativeURL = error2.code === "ERR_INVALID_URL";
  }
  var preservedUrlFields = [
    "auth",
    "host",
    "hostname",
    "href",
    "path",
    "pathname",
    "port",
    "protocol",
    "query",
    "search",
    "hash"
  ];
  var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
  var eventHandlers = Object.create(null);
  events.forEach(function(event) {
    eventHandlers[event] = function(arg1, arg2, arg3) {
      this._redirectable.emit(event, arg1, arg2, arg3);
    };
  });
  var InvalidUrlError = createErrorType("ERR_INVALID_URL", "Invalid URL", TypeError);
  var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "Redirected request failed");
  var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded", RedirectionError);
  var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
  var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  var destroy = Writable.prototype.destroy || noop3;
  function RedirectableRequest(options, responseCallback) {
    Writable.call(this);
    this._sanitizeOptions(options);
    this._options = options;
    this._ended = false;
    this._ending = false;
    this._redirectCount = 0;
    this._redirects = [];
    this._requestBodyLength = 0;
    this._requestBodyBuffers = [];
    if (responseCallback) {
      this.on("response", responseCallback);
    }
    var self2 = this;
    this._onNativeResponse = function(response) {
      try {
        self2._processResponse(response);
      } catch (cause) {
        self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
      }
    };
    this._performRequest();
  }
  RedirectableRequest.prototype = Object.create(Writable.prototype);
  RedirectableRequest.prototype.abort = function() {
    destroyRequest(this._currentRequest);
    this._currentRequest.abort();
    this.emit("abort");
  };
  RedirectableRequest.prototype.destroy = function(error2) {
    destroyRequest(this._currentRequest, error2);
    destroy.call(this, error2);
    return this;
  };
  RedirectableRequest.prototype.write = function(data, encoding, callback) {
    if (this._ending) {
      throw new WriteAfterEndError;
    }
    if (!isString2(data) && !isBuffer2(data)) {
      throw new TypeError("data should be a string, Buffer or Uint8Array");
    }
    if (isFunction2(encoding)) {
      callback = encoding;
      encoding = null;
    }
    if (data.length === 0) {
      if (callback) {
        callback();
      }
      return;
    }
    if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
      this._requestBodyLength += data.length;
      this._requestBodyBuffers.push({ data, encoding });
      this._currentRequest.write(data, encoding, callback);
    } else {
      this.emit("error", new MaxBodyLengthExceededError);
      this.abort();
    }
  };
  RedirectableRequest.prototype.end = function(data, encoding, callback) {
    if (isFunction2(data)) {
      callback = data;
      data = encoding = null;
    } else if (isFunction2(encoding)) {
      callback = encoding;
      encoding = null;
    }
    if (!data) {
      this._ended = this._ending = true;
      this._currentRequest.end(null, null, callback);
    } else {
      var self2 = this;
      var currentRequest = this._currentRequest;
      this.write(data, encoding, function() {
        self2._ended = true;
        currentRequest.end(null, null, callback);
      });
      this._ending = true;
    }
  };
  RedirectableRequest.prototype.setHeader = function(name, value) {
    this._options.headers[name] = value;
    this._currentRequest.setHeader(name, value);
  };
  RedirectableRequest.prototype.removeHeader = function(name) {
    delete this._options.headers[name];
    this._currentRequest.removeHeader(name);
  };
  RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
    var self2 = this;
    function destroyOnTimeout(socket) {
      socket.setTimeout(msecs);
      socket.removeListener("timeout", socket.destroy);
      socket.addListener("timeout", socket.destroy);
    }
    function startTimer(socket) {
      if (self2._timeout) {
        clearTimeout(self2._timeout);
      }
      self2._timeout = setTimeout(function() {
        self2.emit("timeout");
        clearTimer();
      }, msecs);
      destroyOnTimeout(socket);
    }
    function clearTimer() {
      if (self2._timeout) {
        clearTimeout(self2._timeout);
        self2._timeout = null;
      }
      self2.removeListener("abort", clearTimer);
      self2.removeListener("error", clearTimer);
      self2.removeListener("response", clearTimer);
      self2.removeListener("close", clearTimer);
      if (callback) {
        self2.removeListener("timeout", callback);
      }
      if (!self2.socket) {
        self2._currentRequest.removeListener("socket", startTimer);
      }
    }
    if (callback) {
      this.on("timeout", callback);
    }
    if (this.socket) {
      startTimer(this.socket);
    } else {
      this._currentRequest.once("socket", startTimer);
    }
    this.on("socket", destroyOnTimeout);
    this.on("abort", clearTimer);
    this.on("error", clearTimer);
    this.on("response", clearTimer);
    this.on("close", clearTimer);
    return this;
  };
  [
    "flushHeaders",
    "getHeader",
    "setNoDelay",
    "setSocketKeepAlive"
  ].forEach(function(method) {
    RedirectableRequest.prototype[method] = function(a, b) {
      return this._currentRequest[method](a, b);
    };
  });
  ["aborted", "connection", "socket"].forEach(function(property) {
    Object.defineProperty(RedirectableRequest.prototype, property, {
      get: function() {
        return this._currentRequest[property];
      }
    });
  });
  RedirectableRequest.prototype._sanitizeOptions = function(options) {
    if (!options.headers) {
      options.headers = {};
    }
    if (options.host) {
      if (!options.hostname) {
        options.hostname = options.host;
      }
      delete options.host;
    }
    if (!options.pathname && options.path) {
      var searchPos = options.path.indexOf("?");
      if (searchPos < 0) {
        options.pathname = options.path;
      } else {
        options.pathname = options.path.substring(0, searchPos);
        options.search = options.path.substring(searchPos);
      }
    }
  };
  RedirectableRequest.prototype._performRequest = function() {
    var protocol = this._options.protocol;
    var nativeProtocol = this._options.nativeProtocols[protocol];
    if (!nativeProtocol) {
      throw new TypeError("Unsupported protocol " + protocol);
    }
    if (this._options.agents) {
      var scheme = protocol.slice(0, -1);
      this._options.agent = this._options.agents[scheme];
    }
    var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
    request._redirectable = this;
    for (var event of events) {
      request.on(event, eventHandlers[event]);
    }
    this._currentUrl = /^\//.test(this._options.path) ? url2.format(this._options) : this._options.path;
    if (this._isRedirect) {
      var i = 0;
      var self2 = this;
      var buffers = this._requestBodyBuffers;
      (function writeNext(error2) {
        if (request === self2._currentRequest) {
          if (error2) {
            self2.emit("error", error2);
          } else if (i < buffers.length) {
            var buffer = buffers[i++];
            if (!request.finished) {
              request.write(buffer.data, buffer.encoding, writeNext);
            }
          } else if (self2._ended) {
            request.end();
          }
        }
      })();
    }
  };
  RedirectableRequest.prototype._processResponse = function(response) {
    var statusCode = response.statusCode;
    if (this._options.trackRedirects) {
      this._redirects.push({
        url: this._currentUrl,
        headers: response.headers,
        statusCode
      });
    }
    var location = response.headers.location;
    if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
      response.responseUrl = this._currentUrl;
      response.redirects = this._redirects;
      this.emit("response", response);
      this._requestBodyBuffers = [];
      return;
    }
    destroyRequest(this._currentRequest);
    response.destroy();
    if (++this._redirectCount > this._options.maxRedirects) {
      throw new TooManyRedirectsError;
    }
    var requestHeaders;
    var beforeRedirect = this._options.beforeRedirect;
    if (beforeRedirect) {
      requestHeaders = Object.assign({
        Host: response.req.getHeader("host")
      }, this._options.headers);
    }
    var method = this._options.method;
    if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
      this._options.method = "GET";
      this._requestBodyBuffers = [];
      removeMatchingHeaders(/^content-/i, this._options.headers);
    }
    var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
    var currentUrlParts = parseUrl(this._currentUrl);
    var currentHost = currentHostHeader || currentUrlParts.host;
    var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url2.format(Object.assign(currentUrlParts, { host: currentHost }));
    var redirectUrl = resolveUrl(location, currentUrl);
    debug("redirecting to", redirectUrl.href);
    this._isRedirect = true;
    spreadUrlObject(redirectUrl, this._options);
    if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
      removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
    }
    if (isFunction2(beforeRedirect)) {
      var responseDetails = {
        headers: response.headers,
        statusCode
      };
      var requestDetails = {
        url: currentUrl,
        method,
        headers: requestHeaders
      };
      beforeRedirect(this._options, responseDetails, requestDetails);
      this._sanitizeOptions(this._options);
    }
    this._performRequest();
  };
  function wrap(protocols) {
    var exports3 = {
      maxRedirects: 21,
      maxBodyLength: 10 * 1024 * 1024
    };
    var nativeProtocols = {};
    Object.keys(protocols).forEach(function(scheme) {
      var protocol = scheme + ":";
      var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
      var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
      function request(input, options, callback) {
        if (isURL(input)) {
          input = spreadUrlObject(input);
        } else if (isString2(input)) {
          input = spreadUrlObject(parseUrl(input));
        } else {
          callback = options;
          options = validateUrl(input);
          input = { protocol };
        }
        if (isFunction2(options)) {
          callback = options;
          options = null;
        }
        options = Object.assign({
          maxRedirects: exports3.maxRedirects,
          maxBodyLength: exports3.maxBodyLength
        }, input, options);
        options.nativeProtocols = nativeProtocols;
        if (!isString2(options.host) && !isString2(options.hostname)) {
          options.hostname = "::1";
        }
        assert.equal(options.protocol, protocol, "protocol mismatch");
        debug("options", options);
        return new RedirectableRequest(options, callback);
      }
      function get(input, options, callback) {
        var wrappedRequest = wrappedProtocol.request(input, options, callback);
        wrappedRequest.end();
        return wrappedRequest;
      }
      Object.defineProperties(wrappedProtocol, {
        request: { value: request, configurable: true, enumerable: true, writable: true },
        get: { value: get, configurable: true, enumerable: true, writable: true }
      });
    });
    return exports3;
  }
  function noop3() {}
  function parseUrl(input) {
    var parsed;
    if (useNativeURL) {
      parsed = new URL2(input);
    } else {
      parsed = validateUrl(url2.parse(input));
      if (!isString2(parsed.protocol)) {
        throw new InvalidUrlError({ input });
      }
    }
    return parsed;
  }
  function resolveUrl(relative, base) {
    return useNativeURL ? new URL2(relative, base) : parseUrl(url2.resolve(base, relative));
  }
  function validateUrl(input) {
    if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
      throw new InvalidUrlError({ input: input.href || input });
    }
    if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
      throw new InvalidUrlError({ input: input.href || input });
    }
    return input;
  }
  function spreadUrlObject(urlObject, target) {
    var spread = target || {};
    for (var key of preservedUrlFields) {
      spread[key] = urlObject[key];
    }
    if (spread.hostname.startsWith("[")) {
      spread.hostname = spread.hostname.slice(1, -1);
    }
    if (spread.port !== "") {
      spread.port = Number(spread.port);
    }
    spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
    return spread;
  }
  function removeMatchingHeaders(regex, headers) {
    var lastValue;
    for (var header in headers) {
      if (regex.test(header)) {
        lastValue = headers[header];
        delete headers[header];
      }
    }
    return lastValue === null || typeof lastValue === "undefined" ? undefined : String(lastValue).trim();
  }
  function createErrorType(code, message, baseClass) {
    function CustomError(properties) {
      if (isFunction2(Error.captureStackTrace)) {
        Error.captureStackTrace(this, this.constructor);
      }
      Object.assign(this, properties || {});
      this.code = code;
      this.message = this.cause ? message + ": " + this.cause.message : message;
    }
    CustomError.prototype = new (baseClass || Error);
    Object.defineProperties(CustomError.prototype, {
      constructor: {
        value: CustomError,
        enumerable: false
      },
      name: {
        value: "Error [" + code + "]",
        enumerable: false
      }
    });
    return CustomError;
  }
  function destroyRequest(request, error2) {
    for (var event of events) {
      request.removeListener(event, eventHandlers[event]);
    }
    request.on("error", noop3);
    request.destroy(error2);
  }
  function isSubdomain(subdomain, domain) {
    assert(isString2(subdomain) && isString2(domain));
    var dot = subdomain.length - domain.length - 1;
    return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
  }
  function isString2(value) {
    return typeof value === "string" || value instanceof String;
  }
  function isFunction2(value) {
    return typeof value === "function";
  }
  function isBuffer2(value) {
    return typeof value === "object" && "length" in value;
  }
  function isURL(value) {
    return URL2 && value instanceof URL2;
  }
  module2.exports = wrap({ http, https });
  module2.exports.wrap = wrap;
});

// backend/node_modules/axios/lib/env/data.js
var VERSION2 = "1.13.2";

// backend/node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url2) {
  const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match2 && match2[1] || "";
}

// backend/node_modules/axios/lib/helpers/fromDataURI.js
function fromDataURI(uri, asBlob, options) {
  const _Blob = options && options.Blob || platform_default.classes.Blob;
  const protocol = parseProtocol(uri);
  if (asBlob === undefined && _Blob) {
    asBlob = true;
  }
  if (protocol === "data") {
    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
    const match2 = DATA_URL_PATTERN.exec(uri);
    if (!match2) {
      throw new AxiosError_default("Invalid URL", AxiosError_default.ERR_INVALID_URL);
    }
    const mime = match2[1];
    const isBase64 = match2[2];
    const body = match2[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError_default("Blob is not supported", AxiosError_default.ERR_NOT_SUPPORT);
      }
      return new _Blob([buffer], { type: mime });
    }
    return buffer;
  }
  throw new AxiosError_default("Unsupported protocol " + protocol, AxiosError_default.ERR_NOT_SUPPORT);
}
var DATA_URL_PATTERN;
var init_fromDataURI = __esm(() => {
  init_AxiosError();
  init_platform();
  DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
});

// backend/node_modules/axios/lib/helpers/AxiosTransformStream.js
var import_stream, kInternals, AxiosTransformStream, AxiosTransformStream_default;
var init_AxiosTransformStream = __esm(() => {
  init_utils();
  import_stream = __toESM(require("stream"));
  kInternals = Symbol("internals");
  AxiosTransformStream = class AxiosTransformStream extends import_stream.default.Transform {
    constructor(options) {
      options = utils_default.toFlatObject(options, {
        maxRate: 0,
        chunkSize: 64 * 1024,
        minChunkSize: 100,
        timeWindow: 500,
        ticksRate: 2,
        samplesCount: 15
      }, null, (prop, source) => {
        return !utils_default.isUndefined(source[prop]);
      });
      super({
        readableHighWaterMark: options.chunkSize
      });
      const internals = this[kInternals] = {
        timeWindow: options.timeWindow,
        chunkSize: options.chunkSize,
        maxRate: options.maxRate,
        minChunkSize: options.minChunkSize,
        bytesSeen: 0,
        isCaptured: false,
        notifiedBytesLoaded: 0,
        ts: Date.now(),
        bytes: 0,
        onReadCallback: null
      };
      this.on("newListener", (event) => {
        if (event === "progress") {
          if (!internals.isCaptured) {
            internals.isCaptured = true;
          }
        }
      });
    }
    _read(size) {
      const internals = this[kInternals];
      if (internals.onReadCallback) {
        internals.onReadCallback();
      }
      return super._read(size);
    }
    _transform(chunk, encoding, callback) {
      const internals = this[kInternals];
      const maxRate = internals.maxRate;
      const readableHighWaterMark = this.readableHighWaterMark;
      const timeWindow = internals.timeWindow;
      const divider = 1000 / timeWindow;
      const bytesThreshold = maxRate / divider;
      const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
      const pushChunk = (_chunk, _callback) => {
        const bytes = Buffer.byteLength(_chunk);
        internals.bytesSeen += bytes;
        internals.bytes += bytes;
        internals.isCaptured && this.emit("progress", internals.bytesSeen);
        if (this.push(_chunk)) {
          process.nextTick(_callback);
        } else {
          internals.onReadCallback = () => {
            internals.onReadCallback = null;
            process.nextTick(_callback);
          };
        }
      };
      const transformChunk = (_chunk, _callback) => {
        const chunkSize = Buffer.byteLength(_chunk);
        let chunkRemainder = null;
        let maxChunkSize = readableHighWaterMark;
        let bytesLeft;
        let passed = 0;
        if (maxRate) {
          const now = Date.now();
          if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
            internals.ts = now;
            bytesLeft = bytesThreshold - internals.bytes;
            internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
            passed = 0;
          }
          bytesLeft = bytesThreshold - internals.bytes;
        }
        if (maxRate) {
          if (bytesLeft <= 0) {
            return setTimeout(() => {
              _callback(null, _chunk);
            }, timeWindow - passed);
          }
          if (bytesLeft < maxChunkSize) {
            maxChunkSize = bytesLeft;
          }
        }
        if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
          chunkRemainder = _chunk.subarray(maxChunkSize);
          _chunk = _chunk.subarray(0, maxChunkSize);
        }
        pushChunk(_chunk, chunkRemainder ? () => {
          process.nextTick(_callback, null, chunkRemainder);
        } : _callback);
      };
      transformChunk(chunk, function transformNextChunk(err, _chunk) {
        if (err) {
          return callback(err);
        }
        if (_chunk) {
          transformChunk(_chunk, transformNextChunk);
        } else {
          callback(null);
        }
      });
    }
  };
  AxiosTransformStream_default = AxiosTransformStream;
});

// backend/node_modules/axios/lib/helpers/readBlob.js
var asyncIterator, readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream();
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer();
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
}, readBlob_default;
var init_readBlob = __esm(() => {
  ({ asyncIterator } = Symbol);
  readBlob_default = readBlob;
});

// backend/node_modules/axios/lib/helpers/formDataToStream.js
class FormDataPart {
  constructor(name, value) {
    const { escapeName } = this.constructor;
    const isStringValue = utils_default.isString(value);
    let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
    if (isStringValue) {
      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
    }
    this.headers = textEncoder.encode(headers + CRLF);
    this.contentLength = isStringValue ? value.byteLength : value.size;
    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
    this.name = name;
    this.value = value;
  }
  async* encode() {
    yield this.headers;
    const { value } = this;
    if (utils_default.isTypedArray(value)) {
      yield value;
    } else {
      yield* readBlob_default(value);
    }
    yield CRLF_BYTES;
  }
  static escapeName(name) {
    return String(name).replace(/[\r\n"]/g, (match2) => ({
      "\r": "%0D",
      "\n": "%0A",
      '"': "%22"
    })[match2]);
  }
}
var import_util, import_stream2, BOUNDARY_ALPHABET, textEncoder, CRLF = `\r
`, CRLF_BYTES, CRLF_BYTES_COUNT = 2, formDataToStream = (form, headersHandler, options) => {
  const {
    tag = "form-data-boundary",
    size = 25,
    boundary = tag + "-" + platform_default.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};
  if (!utils_default.isFormData(form)) {
    throw TypeError("FormData instance required");
  }
  if (boundary.length < 1 || boundary.length > 70) {
    throw Error("boundary must be 10-70 characters long");
  }
  const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
  const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF);
  let contentLength = footerBytes.byteLength;
  const parts = Array.from(form.entries()).map(([name, value]) => {
    const part = new FormDataPart(name, value);
    contentLength += part.size;
    return part;
  });
  contentLength += boundaryBytes.byteLength * parts.length;
  contentLength = utils_default.toFiniteNumber(contentLength);
  const computedHeaders = {
    "Content-Type": `multipart/form-data; boundary=${boundary}`
  };
  if (Number.isFinite(contentLength)) {
    computedHeaders["Content-Length"] = contentLength;
  }
  headersHandler && headersHandler(computedHeaders);
  return import_stream2.Readable.from(async function* () {
    for (const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }
    yield footerBytes;
  }());
}, formDataToStream_default;
var init_formDataToStream = __esm(() => {
  init_utils();
  init_readBlob();
  init_platform();
  import_util = __toESM(require("util"));
  import_stream2 = require("stream");
  BOUNDARY_ALPHABET = platform_default.ALPHABET.ALPHA_DIGIT + "-_";
  textEncoder = typeof TextEncoder === "function" ? new TextEncoder : new import_util.default.TextEncoder;
  CRLF_BYTES = textEncoder.encode(CRLF);
  formDataToStream_default = formDataToStream;
});

// backend/node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js
var import_stream3, ZlibHeaderTransformStream, ZlibHeaderTransformStream_default;
var init_ZlibHeaderTransformStream = __esm(() => {
  import_stream3 = __toESM(require("stream"));
  ZlibHeaderTransformStream = class ZlibHeaderTransformStream extends import_stream3.default.Transform {
    __transform(chunk, encoding, callback) {
      this.push(chunk);
      callback();
    }
    _transform(chunk, encoding, callback) {
      if (chunk.length !== 0) {
        this._transform = this.__transform;
        if (chunk[0] !== 120) {
          const header = Buffer.alloc(2);
          header[0] = 120;
          header[1] = 156;
          this.push(header, encoding);
        }
      }
      this.__transform(chunk, encoding, callback);
    }
  };
  ZlibHeaderTransformStream_default = ZlibHeaderTransformStream;
});

// backend/node_modules/axios/lib/helpers/callbackify.js
var callbackify = (fn, reducer) => {
  return utils_default.isAsyncFn(fn) ? function(...args) {
    const cb = args.pop();
    fn.apply(this, args).then((value) => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
}, callbackify_default;
var init_callbackify = __esm(() => {
  init_utils();
  callbackify_default = callbackify;
});

// backend/node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== undefined ? min : 1000;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}
var speedometer_default;
var init_speedometer = __esm(() => {
  speedometer_default = speedometer;
});

// backend/node_modules/axios/lib/helpers/throttle.js
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1000 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn(...args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
var throttle_default;
var init_throttle = __esm(() => {
  throttle_default = throttle;
});

// backend/node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return throttle_default((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
}, progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
}, asyncDecorator = (fn) => (...args) => utils_default.asap(() => fn(...args));
var init_progressEventReducer = __esm(() => {
  init_speedometer();
  init_throttle();
  init_utils();
});

// backend/node_modules/axios/lib/helpers/estimateDataURLDecodedBytes.js
function estimateDataURLDecodedBytes(url2) {
  if (!url2 || typeof url2 !== "string")
    return 0;
  if (!url2.startsWith("data:"))
    return 0;
  const comma = url2.indexOf(",");
  if (comma < 0)
    return 0;
  const meta = url2.slice(5, comma);
  const body = url2.slice(comma + 1);
  const isBase64 = /;base64/i.test(meta);
  if (isBase64) {
    let effectiveLen = body.length;
    const len = body.length;
    for (let i = 0;i < len; i++) {
      if (body.charCodeAt(i) === 37 && i + 2 < len) {
        const a = body.charCodeAt(i + 1);
        const b = body.charCodeAt(i + 2);
        const isHex = (a >= 48 && a <= 57 || a >= 65 && a <= 70 || a >= 97 && a <= 102) && (b >= 48 && b <= 57 || b >= 65 && b <= 70 || b >= 97 && b <= 102);
        if (isHex) {
          effectiveLen -= 2;
          i += 2;
        }
      }
    }
    let pad = 0;
    let idx = len - 1;
    const tailIsPct3D = (j) => j >= 2 && body.charCodeAt(j - 2) === 37 && body.charCodeAt(j - 1) === 51 && (body.charCodeAt(j) === 68 || body.charCodeAt(j) === 100);
    if (idx >= 0) {
      if (body.charCodeAt(idx) === 61) {
        pad++;
        idx--;
      } else if (tailIsPct3D(idx)) {
        pad++;
        idx -= 3;
      }
    }
    if (pad === 1 && idx >= 0) {
      if (body.charCodeAt(idx) === 61) {
        pad++;
      } else if (tailIsPct3D(idx)) {
        pad++;
      }
    }
    const groups = Math.floor(effectiveLen / 4);
    const bytes = groups * 3 - (pad || 0);
    return bytes > 0 ? bytes : 0;
  }
  return Buffer.byteLength(body, "utf8");
}

// backend/node_modules/axios/lib/adapters/http.js
class Http2Sessions {
  constructor() {
    this.sessions = Object.create(null);
  }
  getSession(authority, options) {
    options = Object.assign({
      sessionTimeout: 1000
    }, options);
    let authoritySessions = this.sessions[authority];
    if (authoritySessions) {
      let len = authoritySessions.length;
      for (let i = 0;i < len; i++) {
        const [sessionHandle, sessionOptions] = authoritySessions[i];
        if (!sessionHandle.destroyed && !sessionHandle.closed && import_util2.default.isDeepStrictEqual(sessionOptions, options)) {
          return sessionHandle;
        }
      }
    }
    const session = import_http2.default.connect(authority, options);
    let removed;
    const removeSession = () => {
      if (removed) {
        return;
      }
      removed = true;
      let entries = authoritySessions, len = entries.length, i = len;
      while (i--) {
        if (entries[i][0] === session) {
          if (len === 1) {
            delete this.sessions[authority];
          } else {
            entries.splice(i, 1);
          }
          return;
        }
      }
    };
    const originalRequestFn = session.request;
    const { sessionTimeout } = options;
    if (sessionTimeout != null) {
      let timer;
      let streamsCount = 0;
      session.request = function() {
        const stream4 = originalRequestFn.apply(this, arguments);
        streamsCount++;
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        stream4.once("close", () => {
          if (!--streamsCount) {
            timer = setTimeout(() => {
              timer = null;
              removeSession();
            }, sessionTimeout);
          }
        });
        return stream4;
      };
    }
    session.once("close", removeSession);
    let entry = [
      session,
      options
    ];
    authoritySessions ? authoritySessions.push(entry) : authoritySessions = this.sessions[authority] = [entry];
    return session;
  }
}
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = import_proxy_from_env.default.getProxyForUrl(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    if (proxy.username) {
      proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
    }
    if (proxy.auth) {
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
      }
      const base642 = Buffer.from(proxy.auth, "utf8").toString("base64");
      options.headers["Proxy-Authorization"] = "Basic " + base642;
    }
    options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
    }
  }
  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}
var import_proxy_from_env, import_http, import_https, import_http2, import_util2, import_follow_redirects, import_zlib, import_stream4, import_events, zlibOptions, brotliOptions, isBrotliSupported, httpFollow, httpsFollow, isHttps, supportedProtocols, flushOnFinish = (stream4, [throttled, flush]) => {
  stream4.on("end", flush).on("error", flush);
  return throttled;
}, http2Sessions, isHttpAdapterSupported, wrapAsync = (asyncExecutor) => {
  return new Promise((resolve, reject) => {
    let onDone;
    let isDone;
    const done = (value, isRejected) => {
      if (isDone)
        return;
      isDone = true;
      onDone && onDone(value, isRejected);
    };
    const _resolve = (value) => {
      done(value);
      resolve(value);
    };
    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    };
    asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
  });
}, resolveFamily = ({ address, family }) => {
  if (!utils_default.isString(address)) {
    throw TypeError("address must be a string");
  }
  return {
    address,
    family: family || (address.indexOf(".") < 0 ? 6 : 4)
  };
}, buildAddressEntry = (address, family) => resolveFamily(utils_default.isObject(address) ? address : { address, family }), http2Transport, http_default;
var init_http = __esm(() => {
  init_utils();
  init_settle();
  init_buildFullPath();
  init_buildURL();
  init_transitional();
  init_AxiosError();
  init_CanceledError();
  init_platform();
  init_fromDataURI();
  init_AxiosHeaders();
  init_AxiosTransformStream();
  init_formDataToStream();
  init_readBlob();
  init_ZlibHeaderTransformStream();
  init_callbackify();
  init_progressEventReducer();
  import_proxy_from_env = __toESM(require_proxy_from_env(), 1);
  import_http = __toESM(require("http"));
  import_https = __toESM(require("https"));
  import_http2 = __toESM(require("http2"));
  import_util2 = __toESM(require("util"));
  import_follow_redirects = __toESM(require_follow_redirects(), 1);
  import_zlib = __toESM(require("zlib"));
  import_stream4 = __toESM(require("stream"));
  import_events = require("events");
  zlibOptions = {
    flush: import_zlib.default.constants.Z_SYNC_FLUSH,
    finishFlush: import_zlib.default.constants.Z_SYNC_FLUSH
  };
  brotliOptions = {
    flush: import_zlib.default.constants.BROTLI_OPERATION_FLUSH,
    finishFlush: import_zlib.default.constants.BROTLI_OPERATION_FLUSH
  };
  isBrotliSupported = utils_default.isFunction(import_zlib.default.createBrotliDecompress);
  ({ http: httpFollow, https: httpsFollow } = import_follow_redirects.default);
  isHttps = /https:?/;
  supportedProtocols = platform_default.protocols.map((protocol) => {
    return protocol + ":";
  });
  http2Sessions = new Http2Sessions;
  isHttpAdapterSupported = typeof process !== "undefined" && utils_default.kindOf(process) === "process";
  http2Transport = {
    request(options, cb) {
      const authority = options.protocol + "//" + options.hostname + ":" + (options.port || 80);
      const { http2Options, headers } = options;
      const session = http2Sessions.getSession(authority, http2Options);
      const {
        HTTP2_HEADER_SCHEME,
        HTTP2_HEADER_METHOD,
        HTTP2_HEADER_PATH,
        HTTP2_HEADER_STATUS
      } = import_http2.default.constants;
      const http2Headers = {
        [HTTP2_HEADER_SCHEME]: options.protocol.replace(":", ""),
        [HTTP2_HEADER_METHOD]: options.method,
        [HTTP2_HEADER_PATH]: options.path
      };
      utils_default.forEach(headers, (header, name) => {
        name.charAt(0) !== ":" && (http2Headers[name] = header);
      });
      const req = session.request(http2Headers);
      req.once("response", (responseHeaders) => {
        const response = req;
        responseHeaders = Object.assign({}, responseHeaders);
        const status = responseHeaders[HTTP2_HEADER_STATUS];
        delete responseHeaders[HTTP2_HEADER_STATUS];
        response.headers = responseHeaders;
        response.statusCode = +status;
        cb(response);
      });
      return req;
    }
  };
  http_default = isHttpAdapterSupported && function httpAdapter(config) {
    return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
      let { data, lookup, family, httpVersion = 1, http2Options } = config;
      const { responseType, responseEncoding } = config;
      const method = config.method.toUpperCase();
      let isDone;
      let rejected = false;
      let req;
      httpVersion = +httpVersion;
      if (Number.isNaN(httpVersion)) {
        throw TypeError(`Invalid protocol version: '${config.httpVersion}' is not a number`);
      }
      if (httpVersion !== 1 && httpVersion !== 2) {
        throw TypeError(`Unsupported protocol version '${httpVersion}'`);
      }
      const isHttp2 = httpVersion === 2;
      if (lookup) {
        const _lookup = callbackify_default(lookup, (value) => utils_default.isArray(value) ? value : [value]);
        lookup = (hostname, opt, cb) => {
          _lookup(hostname, opt, (err, arg0, arg1) => {
            if (err) {
              return cb(err);
            }
            const addresses = utils_default.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
            opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
          });
        };
      }
      const abortEmitter = new import_events.EventEmitter;
      function abort(reason) {
        try {
          abortEmitter.emit("abort", !reason || reason.type ? new CanceledError_default(null, config, req) : reason);
        } catch (err) {
          console.warn("emit error", err);
        }
      }
      abortEmitter.once("abort", reject);
      const onFinished = () => {
        if (config.cancelToken) {
          config.cancelToken.unsubscribe(abort);
        }
        if (config.signal) {
          config.signal.removeEventListener("abort", abort);
        }
        abortEmitter.removeAllListeners();
      };
      if (config.cancelToken || config.signal) {
        config.cancelToken && config.cancelToken.subscribe(abort);
        if (config.signal) {
          config.signal.aborted ? abort() : config.signal.addEventListener("abort", abort);
        }
      }
      onDone((response, isRejected) => {
        isDone = true;
        if (isRejected) {
          rejected = true;
          onFinished();
          return;
        }
        const { data: data2 } = response;
        if (data2 instanceof import_stream4.default.Readable || data2 instanceof import_stream4.default.Duplex) {
          const offListeners = import_stream4.default.finished(data2, () => {
            offListeners();
            onFinished();
          });
        } else {
          onFinished();
        }
      });
      const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
      const parsed = new URL(fullPath, platform_default.hasBrowserEnv ? platform_default.origin : undefined);
      const protocol = parsed.protocol || supportedProtocols[0];
      if (protocol === "data:") {
        if (config.maxContentLength > -1) {
          const dataUrl = String(config.url || fullPath || "");
          const estimated = estimateDataURLDecodedBytes(dataUrl);
          if (estimated > config.maxContentLength) {
            return reject(new AxiosError_default("maxContentLength size of " + config.maxContentLength + " exceeded", AxiosError_default.ERR_BAD_RESPONSE, config));
          }
        }
        let convertedData;
        if (method !== "GET") {
          return settle(resolve, reject, {
            status: 405,
            statusText: "method not allowed",
            headers: {},
            config
          });
        }
        try {
          convertedData = fromDataURI(config.url, responseType === "blob", {
            Blob: config.env && config.env.Blob
          });
        } catch (err) {
          throw AxiosError_default.from(err, AxiosError_default.ERR_BAD_REQUEST, config);
        }
        if (responseType === "text") {
          convertedData = convertedData.toString(responseEncoding);
          if (!responseEncoding || responseEncoding === "utf8") {
            convertedData = utils_default.stripBOM(convertedData);
          }
        } else if (responseType === "stream") {
          convertedData = import_stream4.default.Readable.from(convertedData);
        }
        return settle(resolve, reject, {
          data: convertedData,
          status: 200,
          statusText: "OK",
          headers: new AxiosHeaders_default,
          config
        });
      }
      if (supportedProtocols.indexOf(protocol) === -1) {
        return reject(new AxiosError_default("Unsupported protocol " + protocol, AxiosError_default.ERR_BAD_REQUEST, config));
      }
      const headers = AxiosHeaders_default.from(config.headers).normalize();
      headers.set("User-Agent", "axios/" + VERSION2, false);
      const { onUploadProgress, onDownloadProgress } = config;
      const maxRate = config.maxRate;
      let maxUploadRate = undefined;
      let maxDownloadRate = undefined;
      if (utils_default.isSpecCompliantForm(data)) {
        const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
        data = formDataToStream_default(data, (formHeaders) => {
          headers.set(formHeaders);
        }, {
          tag: `axios-${VERSION2}-boundary`,
          boundary: userBoundary && userBoundary[1] || undefined
        });
      } else if (utils_default.isFormData(data) && utils_default.isFunction(data.getHeaders)) {
        headers.set(data.getHeaders());
        if (!headers.hasContentLength()) {
          try {
            const knownLength = await import_util2.default.promisify(data.getLength).call(data);
            Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
          } catch (e) {}
        }
      } else if (utils_default.isBlob(data) || utils_default.isFile(data)) {
        data.size && headers.setContentType(data.type || "application/octet-stream");
        headers.setContentLength(data.size || 0);
        data = import_stream4.default.Readable.from(readBlob_default(data));
      } else if (data && !utils_default.isStream(data)) {
        if (Buffer.isBuffer(data)) {} else if (utils_default.isArrayBuffer(data)) {
          data = Buffer.from(new Uint8Array(data));
        } else if (utils_default.isString(data)) {
          data = Buffer.from(data, "utf-8");
        } else {
          return reject(new AxiosError_default("Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream", AxiosError_default.ERR_BAD_REQUEST, config));
        }
        headers.setContentLength(data.length, false);
        if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
          return reject(new AxiosError_default("Request body larger than maxBodyLength limit", AxiosError_default.ERR_BAD_REQUEST, config));
        }
      }
      const contentLength = utils_default.toFiniteNumber(headers.getContentLength());
      if (utils_default.isArray(maxRate)) {
        maxUploadRate = maxRate[0];
        maxDownloadRate = maxRate[1];
      } else {
        maxUploadRate = maxDownloadRate = maxRate;
      }
      if (data && (onUploadProgress || maxUploadRate)) {
        if (!utils_default.isStream(data)) {
          data = import_stream4.default.Readable.from(data, { objectMode: false });
        }
        data = import_stream4.default.pipeline([data, new AxiosTransformStream_default({
          maxRate: utils_default.toFiniteNumber(maxUploadRate)
        })], utils_default.noop);
        onUploadProgress && data.on("progress", flushOnFinish(data, progressEventDecorator(contentLength, progressEventReducer(asyncDecorator(onUploadProgress), false, 3))));
      }
      let auth = undefined;
      if (config.auth) {
        const username = config.auth.username || "";
        const password = config.auth.password || "";
        auth = username + ":" + password;
      }
      if (!auth && parsed.username) {
        const urlUsername = parsed.username;
        const urlPassword = parsed.password;
        auth = urlUsername + ":" + urlPassword;
      }
      auth && headers.delete("authorization");
      let path2;
      try {
        path2 = buildURL(parsed.pathname + parsed.search, config.params, config.paramsSerializer).replace(/^\?/, "");
      } catch (err) {
        const customErr = new Error(err.message);
        customErr.config = config;
        customErr.url = config.url;
        customErr.exists = true;
        return reject(customErr);
      }
      headers.set("Accept-Encoding", "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""), false);
      const options = {
        path: path2,
        method,
        headers: headers.toJSON(),
        agents: { http: config.httpAgent, https: config.httpsAgent },
        auth,
        protocol,
        family,
        beforeRedirect: dispatchBeforeRedirect,
        beforeRedirects: {},
        http2Options
      };
      !utils_default.isUndefined(lookup) && (options.lookup = lookup);
      if (config.socketPath) {
        options.socketPath = config.socketPath;
      } else {
        options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
        options.port = parsed.port;
        setProxy(options, config.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
      }
      let transport;
      const isHttpsRequest = isHttps.test(options.protocol);
      options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
      if (isHttp2) {
        transport = http2Transport;
      } else {
        if (config.transport) {
          transport = config.transport;
        } else if (config.maxRedirects === 0) {
          transport = isHttpsRequest ? import_https.default : import_http.default;
        } else {
          if (config.maxRedirects) {
            options.maxRedirects = config.maxRedirects;
          }
          if (config.beforeRedirect) {
            options.beforeRedirects.config = config.beforeRedirect;
          }
          transport = isHttpsRequest ? httpsFollow : httpFollow;
        }
      }
      if (config.maxBodyLength > -1) {
        options.maxBodyLength = config.maxBodyLength;
      } else {
        options.maxBodyLength = Infinity;
      }
      if (config.insecureHTTPParser) {
        options.insecureHTTPParser = config.insecureHTTPParser;
      }
      req = transport.request(options, function handleResponse(res) {
        if (req.destroyed)
          return;
        const streams = [res];
        const responseLength = utils_default.toFiniteNumber(res.headers["content-length"]);
        if (onDownloadProgress || maxDownloadRate) {
          const transformStream = new AxiosTransformStream_default({
            maxRate: utils_default.toFiniteNumber(maxDownloadRate)
          });
          onDownloadProgress && transformStream.on("progress", flushOnFinish(transformStream, progressEventDecorator(responseLength, progressEventReducer(asyncDecorator(onDownloadProgress), true, 3))));
          streams.push(transformStream);
        }
        let responseStream = res;
        const lastRequest = res.req || req;
        if (config.decompress !== false && res.headers["content-encoding"]) {
          if (method === "HEAD" || res.statusCode === 204) {
            delete res.headers["content-encoding"];
          }
          switch ((res.headers["content-encoding"] || "").toLowerCase()) {
            case "gzip":
            case "x-gzip":
            case "compress":
            case "x-compress":
              streams.push(import_zlib.default.createUnzip(zlibOptions));
              delete res.headers["content-encoding"];
              break;
            case "deflate":
              streams.push(new ZlibHeaderTransformStream_default);
              streams.push(import_zlib.default.createUnzip(zlibOptions));
              delete res.headers["content-encoding"];
              break;
            case "br":
              if (isBrotliSupported) {
                streams.push(import_zlib.default.createBrotliDecompress(brotliOptions));
                delete res.headers["content-encoding"];
              }
          }
        }
        responseStream = streams.length > 1 ? import_stream4.default.pipeline(streams, utils_default.noop) : streams[0];
        const response = {
          status: res.statusCode,
          statusText: res.statusMessage,
          headers: new AxiosHeaders_default(res.headers),
          config,
          request: lastRequest
        };
        if (responseType === "stream") {
          response.data = responseStream;
          settle(resolve, reject, response);
        } else {
          const responseBuffer = [];
          let totalResponseBytes = 0;
          responseStream.on("data", function handleStreamData(chunk) {
            responseBuffer.push(chunk);
            totalResponseBytes += chunk.length;
            if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
              rejected = true;
              responseStream.destroy();
              abort(new AxiosError_default("maxContentLength size of " + config.maxContentLength + " exceeded", AxiosError_default.ERR_BAD_RESPONSE, config, lastRequest));
            }
          });
          responseStream.on("aborted", function handlerStreamAborted() {
            if (rejected) {
              return;
            }
            const err = new AxiosError_default("stream has been aborted", AxiosError_default.ERR_BAD_RESPONSE, config, lastRequest);
            responseStream.destroy(err);
            reject(err);
          });
          responseStream.on("error", function handleStreamError(err) {
            if (req.destroyed)
              return;
            reject(AxiosError_default.from(err, null, config, lastRequest));
          });
          responseStream.on("end", function handleStreamEnd() {
            try {
              let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
              if (responseType !== "arraybuffer") {
                responseData = responseData.toString(responseEncoding);
                if (!responseEncoding || responseEncoding === "utf8") {
                  responseData = utils_default.stripBOM(responseData);
                }
              }
              response.data = responseData;
            } catch (err) {
              return reject(AxiosError_default.from(err, null, config, response.request, response));
            }
            settle(resolve, reject, response);
          });
        }
        abortEmitter.once("abort", (err) => {
          if (!responseStream.destroyed) {
            responseStream.emit("error", err);
            responseStream.destroy();
          }
        });
      });
      abortEmitter.once("abort", (err) => {
        if (req.close) {
          req.close();
        } else {
          req.destroy(err);
        }
      });
      req.on("error", function handleRequestError(err) {
        reject(AxiosError_default.from(err, null, config, req));
      });
      req.on("socket", function handleRequestSocket(socket) {
        socket.setKeepAlive(true, 1000 * 60);
      });
      if (config.timeout) {
        const timeout = parseInt(config.timeout, 10);
        if (Number.isNaN(timeout)) {
          abort(new AxiosError_default("error trying to parse `config.timeout` to int", AxiosError_default.ERR_BAD_OPTION_VALUE, config, req));
          return;
        }
        req.setTimeout(timeout, function handleRequestTimeout() {
          if (isDone)
            return;
          let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = config.transitional || transitional_default;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          abort(new AxiosError_default(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED, config, req));
        });
      } else {
        req.setTimeout(0);
      }
      if (utils_default.isStream(data)) {
        let ended = false;
        let errored = false;
        data.on("end", () => {
          ended = true;
        });
        data.once("error", (err) => {
          errored = true;
          req.destroy(err);
        });
        data.on("close", () => {
          if (!ended && !errored) {
            abort(new CanceledError_default("Request stream has been aborted", config, req));
          }
        });
        data.pipe(req);
      } else {
        data && req.write(data);
        req.end();
      }
    });
  };
});

// backend/node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default;
var init_isURLSameOrigin = __esm(() => {
  init_platform();
  isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? ((origin2, isMSIE) => (url2) => {
    url2 = new URL(url2, platform_default.origin);
    return origin2.protocol === url2.protocol && origin2.host === url2.host && (isMSIE || origin2.port === url2.port);
  })(new URL(platform_default.origin), platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)) : () => true;
});

// backend/node_modules/axios/lib/helpers/cookies.js
var cookies_default;
var init_cookies = __esm(() => {
  init_utils();
  init_platform();
  cookies_default = platform_default.hasStandardBrowserEnv ? {
    write(name, value, expires, path2, domain, secure, sameSite) {
      if (typeof document === "undefined")
        return;
      const cookie = [`${name}=${encodeURIComponent(value)}`];
      if (utils_default.isNumber(expires)) {
        cookie.push(`expires=${new Date(expires).toUTCString()}`);
      }
      if (utils_default.isString(path2)) {
        cookie.push(`path=${path2}`);
      }
      if (utils_default.isString(domain)) {
        cookie.push(`domain=${domain}`);
      }
      if (secure === true) {
        cookie.push("secure");
      }
      if (utils_default.isString(sameSite)) {
        cookie.push(`SameSite=${sameSite}`);
      }
      document.cookie = cookie.join("; ");
    },
    read(name) {
      if (typeof document === "undefined")
        return null;
      const match2 = document.cookie.match(new RegExp("(?:^|; )" + name + "=([^;]*)"));
      return match2 ? decodeURIComponent(match2[1]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 86400000, "/");
    }
  } : {
    write() {},
    read() {
      return null;
    },
    remove() {}
  };
});

// backend/node_modules/axios/lib/core/mergeConfig.js
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, prop, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, prop, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(undefined, a, prop, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
  };
  utils_default.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
var init_mergeConfig = __esm(() => {
  init_utils();
  init_AxiosHeaders();
});

// backend/node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = (config) => {
  const newConfig = mergeConfig({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
  if (auth) {
    headers.set("Authorization", "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : "")));
  }
  if (utils_default.isFormData(data)) {
    if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(undefined);
    } else if (utils_default.isFunction(data.getHeaders)) {
      const formHeaders = data.getHeaders();
      const allowedHeaders = ["content-type", "content-length"];
      Object.entries(formHeaders).forEach(([key, val]) => {
        if (allowedHeaders.includes(key.toLowerCase())) {
          headers.set(key, val);
        }
      });
    }
  }
  if (platform_default.hasStandardBrowserEnv) {
    withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};
var init_resolveConfig = __esm(() => {
  init_platform();
  init_utils();
  init_isURLSameOrigin();
  init_cookies();
  init_buildFullPath();
  init_mergeConfig();
  init_AxiosHeaders();
  init_buildURL();
});

// backend/node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported, xhr_default;
var init_xhr = __esm(() => {
  init_utils();
  init_settle();
  init_transitional();
  init_AxiosError();
  init_CanceledError();
  init_platform();
  init_AxiosHeaders();
  init_progressEventReducer();
  init_resolveConfig();
  isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
  xhr_default = isXHRAdapterSupported && function(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      const _config = resolveConfig_default(config);
      let requestData = _config.data;
      const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
      let { responseType, onUploadProgress, onDownloadProgress } = _config;
      let onCanceled;
      let uploadThrottled, downloadThrottled;
      let flushUpload, flushDownload;
      function done() {
        flushUpload && flushUpload();
        flushDownload && flushDownload();
        _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
        _config.signal && _config.signal.removeEventListener("abort", onCanceled);
      }
      let request = new XMLHttpRequest;
      request.open(_config.method.toUpperCase(), _config.url, true);
      request.timeout = _config.timeout;
      function onloadend() {
        if (!request) {
          return;
        }
        const responseHeaders = AxiosHeaders_default.from("getAllResponseHeaders" in request && request.getAllResponseHeaders());
        const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
        const response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config,
          request
        };
        settle(function _resolve(value) {
          resolve(value);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request = null;
      }
      if ("onloadend" in request) {
        request.onloadend = onloadend;
      } else {
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
        request = null;
      };
      request.onerror = function handleError(event) {
        const msg = event && event.message ? event.message : "Network Error";
        const err = new AxiosError_default(msg, AxiosError_default.ERR_NETWORK, config, request);
        err.event = event || null;
        reject(err);
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional = _config.transitional || transitional_default;
        if (_config.timeoutErrorMessage) {
          timeoutErrorMessage = _config.timeoutErrorMessage;
        }
        reject(new AxiosError_default(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED, config, request));
        request = null;
      };
      requestData === undefined && requestHeaders.setContentType(null);
      if ("setRequestHeader" in request) {
        utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
          request.setRequestHeader(key, val);
        });
      }
      if (!utils_default.isUndefined(_config.withCredentials)) {
        request.withCredentials = !!_config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request.responseType = _config.responseType;
      }
      if (onDownloadProgress) {
        [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
        request.addEventListener("progress", downloadThrottled);
      }
      if (onUploadProgress && request.upload) {
        [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
        request.upload.addEventListener("progress", uploadThrottled);
        request.upload.addEventListener("loadend", flushUpload);
      }
      if (_config.cancelToken || _config.signal) {
        onCanceled = (cancel) => {
          if (!request) {
            return;
          }
          reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
          request.abort();
          request = null;
        };
        _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
        if (_config.signal) {
          _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
        }
      }
      const protocol = parseProtocol(_config.url);
      if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
        reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
        return;
      }
      request.send(requestData || null);
    });
  };
});

// backend/node_modules/axios/lib/helpers/composeSignals.js
var composeSignals = (signals, timeout) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController;
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils_default.asap(unsubscribe);
    return signal;
  }
}, composeSignals_default;
var init_composeSignals = __esm(() => {
  init_CanceledError();
  init_AxiosError();
  init_utils();
  composeSignals_default = composeSignals;
});

// backend/node_modules/axios/lib/helpers/trackStream.js
var streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
}, readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
}, readStream = async function* (stream4) {
  if (stream4[Symbol.asyncIterator]) {
    yield* stream4;
    return;
  }
  const reader = stream4.getReader();
  try {
    for (;; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
}, trackStream = (stream4, chunkSize, onProgress, onFinish) => {
  const iterator2 = readBytes(stream4, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator2.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator2.return();
    }
  }, {
    highWaterMark: 2
  });
};

// backend/node_modules/axios/lib/adapters/fetch.js
var DEFAULT_CHUNK_SIZE, isFunction2, globalFetchAPI, ReadableStream2, TextEncoder2, test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false;
  }
}, factory = (env2) => {
  env2 = utils_default.merge.call({
    skipUndefined: true
  }, globalFetchAPI, env2);
  const { fetch: envFetch, Request: Request2, Response: Response2 } = env2;
  const isFetchSupported = envFetch ? isFunction2(envFetch) : typeof fetch === "function";
  const isRequestSupported = isFunction2(Request2);
  const isResponseSupported = isFunction2(Response2);
  if (!isFetchSupported) {
    return false;
  }
  const isReadableStreamSupported = isFetchSupported && isFunction2(ReadableStream2);
  const encodeText = isFetchSupported && (typeof TextEncoder2 === "function" ? ((encoder) => (str2) => encoder.encode(str2))(new TextEncoder2) : async (str2) => new Uint8Array(await new Request2(str2).arrayBuffer()));
  const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
    let duplexAccessed = false;
    const hasContentType = new Request2(platform_default.origin, {
      body: new ReadableStream2,
      method: "POST",
      get duplex() {
        duplexAccessed = true;
        return "half";
      }
    }).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
  });
  const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response2("").body));
  const resolvers = {
    stream: supportsResponseStream && ((res) => res.body)
  };
  isFetchSupported && (() => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
      !resolvers[type] && (resolvers[type] = (res, config) => {
        let method = res && res[type];
        if (method) {
          return method.call(res);
        }
        throw new AxiosError_default(`Response type '${type}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config);
      });
    });
  })();
  const getBodyLength = async (body) => {
    if (body == null) {
      return 0;
    }
    if (utils_default.isBlob(body)) {
      return body.size;
    }
    if (utils_default.isSpecCompliantForm(body)) {
      const _request = new Request2(platform_default.origin, {
        method: "POST",
        body
      });
      return (await _request.arrayBuffer()).byteLength;
    }
    if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
      return body.byteLength;
    }
    if (utils_default.isURLSearchParams(body)) {
      body = body + "";
    }
    if (utils_default.isString(body)) {
      return (await encodeText(body)).byteLength;
    }
  };
  const resolveBodyLength = async (headers, body) => {
    const length = utils_default.toFiniteNumber(headers.getContentLength());
    return length == null ? getBodyLength(body) : length;
  };
  return async (config) => {
    let {
      url: url2,
      method,
      data,
      signal,
      cancelToken,
      timeout,
      onDownloadProgress,
      onUploadProgress,
      responseType,
      headers,
      withCredentials = "same-origin",
      fetchOptions
    } = resolveConfig_default(config);
    let _fetch = envFetch || fetch;
    responseType = responseType ? (responseType + "").toLowerCase() : "text";
    let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
    let request = null;
    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
    });
    let requestContentLength;
    try {
      if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
        let _request = new Request2(url2, {
          method: "POST",
          body: data,
          duplex: "half"
        });
        let contentTypeHeader;
        if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
          headers.setContentType(contentTypeHeader);
        }
        if (_request.body) {
          const [onProgress, flush] = progressEventDecorator(requestContentLength, progressEventReducer(asyncDecorator(onUploadProgress)));
          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
        }
      }
      if (!utils_default.isString(withCredentials)) {
        withCredentials = withCredentials ? "include" : "omit";
      }
      const isCredentialsSupported = isRequestSupported && "credentials" in Request2.prototype;
      const resolvedOptions = {
        ...fetchOptions,
        signal: composedSignal,
        method: method.toUpperCase(),
        headers: headers.normalize().toJSON(),
        body: data,
        duplex: "half",
        credentials: isCredentialsSupported ? withCredentials : undefined
      };
      request = isRequestSupported && new Request2(url2, resolvedOptions);
      let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url2, resolvedOptions));
      const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
      if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
        const options = {};
        ["status", "statusText", "headers"].forEach((prop) => {
          options[prop] = response[prop];
        });
        const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(responseContentLength, progressEventReducer(asyncDecorator(onDownloadProgress), true)) || [];
        response = new Response2(trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }), options);
      }
      responseType = responseType || "text";
      let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config);
      !isStreamResponse && unsubscribe && unsubscribe();
      return await new Promise((resolve, reject) => {
        settle(resolve, reject, {
          data: responseData,
          headers: AxiosHeaders_default.from(response.headers),
          status: response.status,
          statusText: response.statusText,
          config,
          request
        });
      });
    } catch (err) {
      unsubscribe && unsubscribe();
      if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
        throw Object.assign(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request), {
          cause: err.cause || err
        });
      }
      throw AxiosError_default.from(err, err && err.code, config, request);
    }
  };
}, seedCache, getFetch = (config) => {
  let env2 = config && config.env || {};
  const { fetch: fetch2, Request: Request2, Response: Response2 } = env2;
  const seeds = [
    Request2,
    Response2,
    fetch2
  ];
  let len = seeds.length, i = len, seed, target, map = seedCache;
  while (i--) {
    seed = seeds[i];
    target = map.get(seed);
    target === undefined && map.set(seed, target = i ? new Map : factory(env2));
    map = target;
  }
  return target;
}, adapter;
var init_fetch = __esm(() => {
  init_platform();
  init_utils();
  init_AxiosError();
  init_composeSignals();
  init_AxiosHeaders();
  init_progressEventReducer();
  init_resolveConfig();
  init_settle();
  DEFAULT_CHUNK_SIZE = 64 * 1024;
  ({ isFunction: isFunction2 } = utils_default);
  globalFetchAPI = (({ Request: Request2, Response: Response2 }) => ({
    Request: Request2,
    Response: Response2
  }))(utils_default.global);
  ({
    ReadableStream: ReadableStream2,
    TextEncoder: TextEncoder2
  } = utils_default.global);
  seedCache = new Map;
  adapter = getFetch();
});

// backend/node_modules/axios/lib/adapters/adapters.js
function getAdapter(adapters, config) {
  adapters = utils_default.isArray(adapters) ? adapters : [adapters];
  const { length } = adapters;
  let nameOrAdapter;
  let adapter2;
  const rejectedReasons = {};
  for (let i = 0;i < length; i++) {
    nameOrAdapter = adapters[i];
    let id;
    adapter2 = nameOrAdapter;
    if (!isResolvedHandle(nameOrAdapter)) {
      adapter2 = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
      if (adapter2 === undefined) {
        throw new AxiosError_default(`Unknown adapter '${id}'`);
      }
    }
    if (adapter2 && (utils_default.isFunction(adapter2) || (adapter2 = adapter2.get(config)))) {
      break;
    }
    rejectedReasons[id || "#" + i] = adapter2;
  }
  if (!adapter2) {
    const reasons = Object.entries(rejectedReasons).map(([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build"));
    let s = length ? reasons.length > 1 ? `since :
` + reasons.map(renderReason).join(`
`) : " " + renderReason(reasons[0]) : "as no adapter specified";
    throw new AxiosError_default(`There is no suitable adapter to dispatch the request ` + s, "ERR_NOT_SUPPORT");
  }
  return adapter2;
}
var knownAdapters, renderReason = (reason) => `- ${reason}`, isResolvedHandle = (adapter2) => utils_default.isFunction(adapter2) || adapter2 === null || adapter2 === false, adapters_default;
var init_adapters = __esm(() => {
  init_utils();
  init_http();
  init_xhr();
  init_fetch();
  init_AxiosError();
  knownAdapters = {
    http: http_default,
    xhr: xhr_default,
    fetch: {
      get: getFetch
    }
  };
  utils_default.forEach(knownAdapters, (fn, value) => {
    if (fn) {
      try {
        Object.defineProperty(fn, "name", { value });
      } catch (e) {}
      Object.defineProperty(fn, "adapterName", { value });
    }
  });
  adapters_default = {
    getAdapter,
    adapters: knownAdapters
  };
});

// backend/node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(config, config.transformRequest);
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter2 = adapters_default.getAdapter(config.adapter || defaults_default.adapter, config);
  return adapter2(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(config, config.transformResponse, response);
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(config, config.transformResponse, reason.response);
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
var init_dispatchRequest = __esm(() => {
  init_transformData();
  init_defaults();
  init_CanceledError();
  init_AxiosHeaders();
  init_adapters();
});

// backend/node_modules/axios/lib/helpers/validator.js
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validators, deprecatedWarnings, validator_default;
var init_validator = __esm(() => {
  init_AxiosError();
  validators = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
    validators[type] = function validator(thing) {
      return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
    };
  });
  deprecatedWarnings = {};
  validators.transitional = function transitional(validator, version, message) {
    function formatMessage(opt, desc) {
      return "[Axios v" + VERSION2 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return (value, opt, opts) => {
      if (validator === false) {
        throw new AxiosError_default(formatMessage(opt, " has been removed" + (version ? " in " + version : "")), AxiosError_default.ERR_DEPRECATED);
      }
      if (version && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
      }
      return validator ? validator(value, opt, opts) : true;
    };
  };
  validators.spelling = function spelling(correctSpelling) {
    return (value, opt) => {
      console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
      return true;
    };
  };
  validator_default = {
    assertOptions,
    validators
  };
});

// backend/node_modules/axios/lib/core/Axios.js
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager_default,
      response: new InterceptorManager_default
    };
  }
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error;
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += `
` + stack;
          }
        } catch (e) {}
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== undefined) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    if (config.allowAbsoluteUrls !== undefined) {} else if (this.defaults.allowAbsoluteUrls !== undefined) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }
    validator_default.assertOptions(config, {
      baseUrl: validators2.spelling("baseURL"),
      withXsrfToken: validators2.spelling("withXSRFToken")
    }, true);
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(headers.common, headers[config.method]);
    headers && utils_default.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (method) => {
      delete headers[method];
    });
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift(...requestInterceptorChain);
      chain.push(...responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error2) {
        onRejected.call(this, error2);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error2) {
      return Promise.reject(error2);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}
var validators2, Axios_default;
var init_Axios = __esm(() => {
  init_utils();
  init_buildURL();
  init_InterceptorManager();
  init_dispatchRequest();
  init_mergeConfig();
  init_buildFullPath();
  init_validator();
  init_AxiosHeaders();
  validators2 = validator_default.validators;
  utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios.prototype[method] = function(url2, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        url: url2,
        data: (config || {}).data
      }));
    };
  });
  utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url2, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url: url2,
          data
        }));
      };
    }
    Axios.prototype[method] = generateHTTPMethod();
    Axios.prototype[method + "Form"] = generateHTTPMethod(true);
  });
  Axios_default = Axios;
});

// backend/node_modules/axios/lib/cancel/CancelToken.js
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request);
      resolvePromise(token.reason);
    });
  }
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController;
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}
var CancelToken_default;
var init_CancelToken = __esm(() => {
  init_CanceledError();
  CancelToken_default = CancelToken;
});

// backend/node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// backend/node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}
var init_isAxiosError = __esm(() => {
  init_utils();
});

// backend/node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode, HttpStatusCode_default;
var init_HttpStatusCode = __esm(() => {
  HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511,
    WebServerIsDown: 521,
    ConnectionTimedOut: 522,
    OriginIsUnreachable: 523,
    TimeoutOccurred: 524,
    SslHandshakeFailed: 525,
    InvalidSslCertificate: 526
  };
  Object.entries(HttpStatusCode).forEach(([key, value]) => {
    HttpStatusCode[value] = key;
  });
  HttpStatusCode_default = HttpStatusCode;
});

// backend/node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios, axios_default;
var init_axios = __esm(() => {
  init_utils();
  init_Axios();
  init_mergeConfig();
  init_defaults();
  init_formDataToJSON();
  init_CanceledError();
  init_CancelToken();
  init_toFormData();
  init_AxiosError();
  init_isAxiosError();
  init_AxiosHeaders();
  init_adapters();
  init_HttpStatusCode();
  axios = createInstance(defaults_default);
  axios.Axios = Axios_default;
  axios.CanceledError = CanceledError_default;
  axios.CancelToken = CancelToken_default;
  axios.isCancel = isCancel;
  axios.VERSION = VERSION2;
  axios.toFormData = toFormData_default;
  axios.AxiosError = AxiosError_default;
  axios.Cancel = axios.CanceledError;
  axios.all = function all(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread;
  axios.isAxiosError = isAxiosError;
  axios.mergeConfig = mergeConfig;
  axios.AxiosHeaders = AxiosHeaders_default;
  axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
  axios.getAdapter = adapters_default.getAdapter;
  axios.HttpStatusCode = HttpStatusCode_default;
  axios.default = axios;
  axios_default = axios;
});

// backend/node_modules/axios/index.js
var init_axios2 = __esm(() => {
  init_axios();
});

// backend/src/services/huggingface.client.ts
var exports_huggingface_client = {};
__export(exports_huggingface_client, {
  generateWithHuggingFace: () => generateWithHuggingFace
});
async function generateWithHuggingFace(prompt) {
  if (!HUGGINGFACE_API_KEY) {
    return { success: false, error: "HuggingFace API key not configured" };
  }
  for (const model of ACTIVE_MODELS) {
    try {
      console.log(` Using model: ${model.name}`);
      const response = await axios_default.post(`https://api-inference.huggingface.co/models/${model.name}`, {
        inputs: prompt,
        parameters: {
          num_inference_steps: model.steps,
          guidance_scale: model.cfg,
          negative_prompt: "blurry, low quality, distorted, watermark, text, logo"
        }
      }, {
        headers: {
          Authorization: `Bearer ${HUGGINGFACE_API_KEY}`,
          "Content-Type": "application/json"
        },
        responseType: "arraybuffer",
        timeout: 120000
      });
      const imageBase64 = `data:image/png;base64,${Buffer.from(response.data).toString("base64")}`;
      console.log(` Generated with ${model.name}`);
      return { success: true, imageBase64, model: model.name };
    } catch (error2) {
      const status = error2.response?.status;
      if (status === 503) {
        console.log(` ${model.name} loading, waiting 10s...`);
        await new Promise((resolve) => setTimeout(resolve, 1e4));
        try {
          const retryResponse = await axios_default.post(`https://api-inference.huggingface.co/models/${model.name}`, { inputs: prompt, parameters: { num_inference_steps: model.steps, guidance_scale: model.cfg } }, {
            headers: { Authorization: `Bearer ${HUGGINGFACE_API_KEY}`, "Content-Type": "application/json" },
            responseType: "arraybuffer",
            timeout: 120000
          });
          const imageBase64 = `data:image/png;base64,${Buffer.from(retryResponse.data).toString("base64")}`;
          console.log(` Generated with ${model.name} after retry`);
          return { success: true, imageBase64, model: model.name };
        } catch (retryError) {
          console.log(` Retry failed for ${model.name}`);
          continue;
        }
      }
      console.log(` Model failed: ${model.name} (${status || error2.message})`);
      continue;
    }
  }
  return { success: false, error: "All HuggingFace models failed" };
}
var HUGGINGFACE_API_KEY, ACTIVE_MODELS;
var init_huggingface_client = __esm(() => {
  init_axios2();
  HUGGINGFACE_API_KEY = process.env.HUGGINGFACE_API_KEY || "";
  ACTIVE_MODELS = [
    { name: "Lykon/dreamshaper-8", steps: 25, cfg: 7 },
    { name: "SG161222/Realistic_Vision_V5.1_noVAE", steps: 30, cfg: 7.5 },
    { name: "stablediffusionapi/realistic-vision-v51", steps: 25, cfg: 7 }
  ];
});

// backend/src/services/stability.client.ts
var exports_stability_client = {};
__export(exports_stability_client, {
  generateWithStabilityAI: () => generateWithStabilityAI
});
async function generateWithStabilityAI(prompt) {
  if (!STABILITY_API_KEY) {
    return { success: false, error: "Stability API key not configured" };
  }
  try {
    console.log(` Using model: Stability AI Core`);
    const payload = {
      prompt,
      output_format: "png",
      aspect_ratio: "1:1"
    };
    const response = await axios_default.post("https://api.stability.ai/v2beta/stable-image/generate/core", payload, {
      headers: {
        Authorization: `Bearer ${STABILITY_API_KEY}`,
        Accept: "application/json"
      },
      timeout: 60000
    });
    if (response.data.image) {
      const imageBase642 = `data:image/png;base64,${response.data.image}`;
      console.log(` Generated with Stability AI Core`);
      return { success: true, imageBase64: imageBase642 };
    }
    const imageBase64 = `data:image/png;base64,${Buffer.from(response.data).toString("base64")}`;
    console.log(` Generated with Stability AI Core`);
    return { success: true, imageBase64 };
  } catch (error2) {
    const status = error2.response?.status;
    const detail = error2.response?.data?.message || error2.message;
    console.log(` Model failed: Stability AI Core (${status}: ${detail})`);
    return { success: false, error: detail };
  }
}
var STABILITY_API_KEY;
var init_stability_client = __esm(() => {
  init_axios2();
  STABILITY_API_KEY = process.env.STABILITY_API_KEY || "";
});

// backend/node_modules/node-telegram-bot-api/src/utils.js
var require_utils = __commonJS((exports2) => {
  var util3 = require("util");
  exports2.deprecate = (msg) => util3.deprecate(() => {}, msg, "node-telegram-bot-api")();
});

// backend/node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS((exports2, module2) => {
  var toStr = Object.prototype.toString;
  module2.exports = function isArguments(value) {
    var str2 = toStr.call(value);
    var isArgs = str2 === "[object Arguments]";
    if (!isArgs) {
      isArgs = str2 !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
    }
    return isArgs;
  };
});

// backend/node_modules/object-keys/implementation.js
var require_implementation2 = __commonJS((exports2, module2) => {
  var keysShim;
  if (!Object.keys) {
    has2 = Object.prototype.hasOwnProperty;
    toStr = Object.prototype.toString;
    isArgs = require_isArguments();
    isEnumerable = Object.prototype.propertyIsEnumerable;
    hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
    hasProtoEnumBug = isEnumerable.call(function() {}, "prototype");
    dontEnums = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ];
    equalsConstructorPrototype = function(o) {
      var ctor = o.constructor;
      return ctor && ctor.prototype === o;
    };
    excludedKeys = {
      $applicationCache: true,
      $console: true,
      $external: true,
      $frame: true,
      $frameElement: true,
      $frames: true,
      $innerHeight: true,
      $innerWidth: true,
      $onmozfullscreenchange: true,
      $onmozfullscreenerror: true,
      $outerHeight: true,
      $outerWidth: true,
      $pageXOffset: true,
      $pageYOffset: true,
      $parent: true,
      $scrollLeft: true,
      $scrollTop: true,
      $scrollX: true,
      $scrollY: true,
      $self: true,
      $webkitIndexedDB: true,
      $webkitStorageInfo: true,
      $window: true
    };
    hasAutomationEqualityBug = function() {
      if (typeof window === "undefined") {
        return false;
      }
      for (var k in window) {
        try {
          if (!excludedKeys["$" + k] && has2.call(window, k) && window[k] !== null && typeof window[k] === "object") {
            try {
              equalsConstructorPrototype(window[k]);
            } catch (e) {
              return true;
            }
          }
        } catch (e) {
          return true;
        }
      }
      return false;
    }();
    equalsConstructorPrototypeIfNotBuggy = function(o) {
      if (typeof window === "undefined" || !hasAutomationEqualityBug) {
        return equalsConstructorPrototype(o);
      }
      try {
        return equalsConstructorPrototype(o);
      } catch (e) {
        return false;
      }
    };
    keysShim = function keys(object) {
      var isObject2 = object !== null && typeof object === "object";
      var isFunction3 = toStr.call(object) === "[object Function]";
      var isArguments = isArgs(object);
      var isString2 = isObject2 && toStr.call(object) === "[object String]";
      var theKeys = [];
      if (!isObject2 && !isFunction3 && !isArguments) {
        throw new TypeError("Object.keys called on a non-object");
      }
      var skipProto = hasProtoEnumBug && isFunction3;
      if (isString2 && object.length > 0 && !has2.call(object, 0)) {
        for (var i = 0;i < object.length; ++i) {
          theKeys.push(String(i));
        }
      }
      if (isArguments && object.length > 0) {
        for (var j = 0;j < object.length; ++j) {
          theKeys.push(String(j));
        }
      } else {
        for (var name in object) {
          if (!(skipProto && name === "prototype") && has2.call(object, name)) {
            theKeys.push(String(name));
          }
        }
      }
      if (hasDontEnumBug) {
        var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
        for (var k = 0;k < dontEnums.length; ++k) {
          if (!(skipConstructor && dontEnums[k] === "constructor") && has2.call(object, dontEnums[k])) {
            theKeys.push(dontEnums[k]);
          }
        }
      }
      return theKeys;
    };
  }
  var has2;
  var toStr;
  var isArgs;
  var isEnumerable;
  var hasDontEnumBug;
  var hasProtoEnumBug;
  var dontEnums;
  var equalsConstructorPrototype;
  var excludedKeys;
  var hasAutomationEqualityBug;
  var equalsConstructorPrototypeIfNotBuggy;
  module2.exports = keysShim;
});

// backend/node_modules/object-keys/index.js
var require_object_keys = __commonJS((exports2, module2) => {
  var slice = Array.prototype.slice;
  var isArgs = require_isArguments();
  var origKeys = Object.keys;
  var keysShim = origKeys ? function keys(o) {
    return origKeys(o);
  } : require_implementation2();
  var originalKeys = Object.keys;
  keysShim.shim = function shimObjectKeys() {
    if (Object.keys) {
      var keysWorksWithArguments = function() {
        var args = Object.keys(arguments);
        return args && args.length === arguments.length;
      }(1, 2);
      if (!keysWorksWithArguments) {
        Object.keys = function keys(object) {
          if (isArgs(object)) {
            return originalKeys(slice.call(object));
          }
          return originalKeys(object);
        };
      }
    } else {
      Object.keys = keysShim;
    }
    return Object.keys || keysShim;
  };
  module2.exports = keysShim;
});

// backend/node_modules/define-data-property/index.js
var require_define_data_property = __commonJS((exports2, module2) => {
  var $defineProperty = require_es_define_property();
  var $SyntaxError = require_syntax();
  var $TypeError = require_type();
  var gopd = require_gopd();
  module2.exports = function defineDataProperty(obj2, property, value) {
    if (!obj2 || typeof obj2 !== "object" && typeof obj2 !== "function") {
      throw new $TypeError("`obj` must be an object or a function`");
    }
    if (typeof property !== "string" && typeof property !== "symbol") {
      throw new $TypeError("`property` must be a string or a symbol`");
    }
    if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
      throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
      throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
      throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
      throw new $TypeError("`loose`, if provided, must be a boolean");
    }
    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
    var nonWritable = arguments.length > 4 ? arguments[4] : null;
    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
    var loose = arguments.length > 6 ? arguments[6] : false;
    var desc = !!gopd && gopd(obj2, property);
    if ($defineProperty) {
      $defineProperty(obj2, property, {
        configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
        enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
        value,
        writable: nonWritable === null && desc ? desc.writable : !nonWritable
      });
    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
      obj2[property] = value;
    } else {
      throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
    }
  };
});

// backend/node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS((exports2, module2) => {
  var $defineProperty = require_es_define_property();
  var hasPropertyDescriptors = function hasPropertyDescriptors() {
    return !!$defineProperty;
  };
  hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    if (!$defineProperty) {
      return null;
    }
    try {
      return $defineProperty([], "length", { value: 1 }).length !== 1;
    } catch (e) {
      return true;
    }
  };
  module2.exports = hasPropertyDescriptors;
});

// backend/node_modules/define-properties/index.js
var require_define_properties = __commonJS((exports2, module2) => {
  var keys = require_object_keys();
  var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
  var toStr = Object.prototype.toString;
  var concat = Array.prototype.concat;
  var defineDataProperty = require_define_data_property();
  var isFunction3 = function(fn) {
    return typeof fn === "function" && toStr.call(fn) === "[object Function]";
  };
  var supportsDescriptors = require_has_property_descriptors()();
  var defineProperty = function(object, name, value, predicate) {
    if (name in object) {
      if (predicate === true) {
        if (object[name] === value) {
          return;
        }
      } else if (!isFunction3(predicate) || !predicate()) {
        return;
      }
    }
    if (supportsDescriptors) {
      defineDataProperty(object, name, value, true);
    } else {
      defineDataProperty(object, name, value);
    }
  };
  var defineProperties = function(object, map) {
    var predicates2 = arguments.length > 2 ? arguments[2] : {};
    var props = keys(map);
    if (hasSymbols) {
      props = concat.call(props, Object.getOwnPropertySymbols(map));
    }
    for (var i = 0;i < props.length; i += 1) {
      defineProperty(object, props[i], map[props[i]], predicates2[props[i]]);
    }
  };
  defineProperties.supportsDescriptors = !!supportsDescriptors;
  module2.exports = defineProperties;
});

// backend/node_modules/es-object-atoms/RequireObjectCoercible.js
var require_RequireObjectCoercible = __commonJS((exports2, module2) => {
  var $TypeError = require_type();
  module2.exports = function RequireObjectCoercible(value) {
    if (value == null) {
      throw new $TypeError(arguments.length > 0 && arguments[1] || "Cannot call method on " + value);
    }
    return value;
  };
});

// backend/node_modules/set-function-length/index.js
var require_set_function_length = __commonJS((exports2, module2) => {
  var GetIntrinsic = require_get_intrinsic();
  var define2 = require_define_data_property();
  var hasDescriptors = require_has_property_descriptors()();
  var gOPD = require_gopd();
  var $TypeError = require_type();
  var $floor = GetIntrinsic("%Math.floor%");
  module2.exports = function setFunctionLength(fn, length) {
    if (typeof fn !== "function") {
      throw new $TypeError("`fn` is not a function");
    }
    if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
      throw new $TypeError("`length` must be a positive 32-bit integer");
    }
    var loose = arguments.length > 2 && !!arguments[2];
    var functionLengthIsConfigurable = true;
    var functionLengthIsWritable = true;
    if ("length" in fn && gOPD) {
      var desc = gOPD(fn, "length");
      if (desc && !desc.configurable) {
        functionLengthIsConfigurable = false;
      }
      if (desc && !desc.writable) {
        functionLengthIsWritable = false;
      }
    }
    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
      if (hasDescriptors) {
        define2(fn, "length", length, true, true);
      } else {
        define2(fn, "length", length);
      }
    }
    return fn;
  };
});

// backend/node_modules/call-bind-apply-helpers/applyBind.js
var require_applyBind = __commonJS((exports2, module2) => {
  var bind2 = require_function_bind();
  var $apply = require_functionApply();
  var actualApply = require_actualApply();
  module2.exports = function applyBind() {
    return actualApply(bind2, $apply, arguments);
  };
});

// backend/node_modules/call-bind/index.js
var require_call_bind = __commonJS((exports2, module2) => {
  var setFunctionLength = require_set_function_length();
  var $defineProperty = require_es_define_property();
  var callBindBasic = require_call_bind_apply_helpers();
  var applyBind = require_applyBind();
  module2.exports = function callBind(originalFunction) {
    var func = callBindBasic(arguments);
    var adjustedLength = originalFunction.length - (arguments.length - 1);
    return setFunctionLength(func, 1 + (adjustedLength > 0 ? adjustedLength : 0), true);
  };
  if ($defineProperty) {
    $defineProperty(module2.exports, "apply", { value: applyBind });
  } else {
    module2.exports.apply = applyBind;
  }
});

// backend/node_modules/call-bound/index.js
var require_call_bound = __commonJS((exports2, module2) => {
  var GetIntrinsic = require_get_intrinsic();
  var callBindBasic = require_call_bind_apply_helpers();
  var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
  module2.exports = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = GetIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBindBasic([intrinsic]);
    }
    return intrinsic;
  };
});

// backend/node_modules/es-abstract/helpers/IsArray.js
var require_IsArray = __commonJS((exports2, module2) => {
  var GetIntrinsic = require_get_intrinsic();
  var $Array = GetIntrinsic("%Array%");
  var toStr = !$Array.isArray && require_call_bound()("Object.prototype.toString");
  module2.exports = $Array.isArray || function IsArray(argument) {
    return toStr(argument) === "[object Array]";
  };
});

// backend/node_modules/es-abstract/2024/IsArray.js
var require_IsArray2 = __commonJS((exports2, module2) => {
  module2.exports = require_IsArray();
});

// backend/node_modules/es-abstract/2024/Call.js
var require_Call = __commonJS((exports2, module2) => {
  var GetIntrinsic = require_get_intrinsic();
  var callBound = require_call_bound();
  var $TypeError = require_type();
  var IsArray = require_IsArray2();
  var $apply = GetIntrinsic("%Reflect.apply%", true) || callBound("Function.prototype.apply");
  module2.exports = function Call(F, V) {
    var argumentsList = arguments.length > 2 ? arguments[2] : [];
    if (!IsArray(argumentsList)) {
      throw new $TypeError("Assertion failed: optional `argumentsList`, if provided, must be a List");
    }
    return $apply(F, V, argumentsList);
  };
});

// backend/node_modules/object-inspect/util.inspect.js
var require_util_inspect = __commonJS((exports2, module2) => {
  module2.exports = require("util").inspect;
});

// backend/node_modules/object-inspect/index.js
var require_object_inspect = __commonJS((exports2, module2) => {
  var hasMap = typeof Map === "function" && Map.prototype;
  var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
  var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
  var mapForEach = hasMap && Map.prototype.forEach;
  var hasSet = typeof Set === "function" && Set.prototype;
  var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
  var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
  var setForEach = hasSet && Set.prototype.forEach;
  var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
  var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
  var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
  var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
  var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
  var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
  var booleanValueOf = Boolean.prototype.valueOf;
  var objectToString = Object.prototype.toString;
  var functionToString = Function.prototype.toString;
  var $match = String.prototype.match;
  var $slice = String.prototype.slice;
  var $replace = String.prototype.replace;
  var $toUpperCase = String.prototype.toUpperCase;
  var $toLowerCase = String.prototype.toLowerCase;
  var $test = RegExp.prototype.test;
  var $concat = Array.prototype.concat;
  var $join = Array.prototype.join;
  var $arrSlice = Array.prototype.slice;
  var $floor = Math.floor;
  var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
  var gOPS = Object.getOwnPropertySymbols;
  var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
  var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
  var toStringTag2 = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
    return O.__proto__;
  } : null);
  function addNumericSeparator(num, str2) {
    if (num === Infinity || num === -Infinity || num !== num || num && num > -1000 && num < 1000 || $test.call(/e/, str2)) {
      return str2;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === "number") {
      var int = num < 0 ? -$floor(-num) : $floor(num);
      if (int !== num) {
        var intStr = String(int);
        var dec = $slice.call(str2, intStr.length + 1);
        return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return $replace.call(str2, sepRegex, "$&_");
  }
  var utilInspect = require_util_inspect();
  var inspectCustom = utilInspect.custom;
  var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
  var quotes = {
    __proto__: null,
    double: '"',
    single: "'"
  };
  var quoteREs = {
    __proto__: null,
    double: /(["\\])/g,
    single: /(['\\])/g
  };
  module2.exports = function inspect_(obj2, options, depth, seen) {
    var opts = options || {};
    if (has2(opts, "quoteStyle") && !has2(quotes, opts.quoteStyle)) {
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (has2(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has2(opts, "customInspect") ? opts.customInspect : true;
    if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    }
    if (has2(opts, "indent") && opts.indent !== null && opts.indent !== "\t" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has2(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;
    if (typeof obj2 === "undefined") {
      return "undefined";
    }
    if (obj2 === null) {
      return "null";
    }
    if (typeof obj2 === "boolean") {
      return obj2 ? "true" : "false";
    }
    if (typeof obj2 === "string") {
      return inspectString(obj2, opts);
    }
    if (typeof obj2 === "number") {
      if (obj2 === 0) {
        return Infinity / obj2 > 0 ? "0" : "-0";
      }
      var str2 = String(obj2);
      return numericSeparator ? addNumericSeparator(obj2, str2) : str2;
    }
    if (typeof obj2 === "bigint") {
      var bigIntStr = String(obj2) + "n";
      return numericSeparator ? addNumericSeparator(obj2, bigIntStr) : bigIntStr;
    }
    var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
    if (typeof depth === "undefined") {
      depth = 0;
    }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj2 === "object") {
      return isArray3(obj2) ? "[Array]" : "[Object]";
    }
    var indent = getIndent(opts, depth);
    if (typeof seen === "undefined") {
      seen = [];
    } else if (indexOf(seen, obj2) >= 0) {
      return "[Circular]";
    }
    function inspect(value, from, noIndent) {
      if (from) {
        seen = $arrSlice.call(seen);
        seen.push(from);
      }
      if (noIndent) {
        var newOpts = {
          depth: opts.depth
        };
        if (has2(opts, "quoteStyle")) {
          newOpts.quoteStyle = opts.quoteStyle;
        }
        return inspect_(value, newOpts, depth + 1, seen);
      }
      return inspect_(value, opts, depth + 1, seen);
    }
    if (typeof obj2 === "function" && !isRegExp2(obj2)) {
      var name = nameOf(obj2);
      var keys = arrObjKeys(obj2, inspect);
      return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
    }
    if (isSymbol(obj2)) {
      var symString = hasShammedSymbols ? $replace.call(String(obj2), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj2);
      return typeof obj2 === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj2)) {
      var s = "<" + $toLowerCase.call(String(obj2.nodeName));
      var attrs = obj2.attributes || [];
      for (var i = 0;i < attrs.length; i++) {
        s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
      }
      s += ">";
      if (obj2.childNodes && obj2.childNodes.length) {
        s += "...";
      }
      s += "</" + $toLowerCase.call(String(obj2.nodeName)) + ">";
      return s;
    }
    if (isArray3(obj2)) {
      if (obj2.length === 0) {
        return "[]";
      }
      var xs = arrObjKeys(obj2, inspect);
      if (indent && !singleLineValues(xs)) {
        return "[" + indentedJoin(xs, indent) + "]";
      }
      return "[ " + $join.call(xs, ", ") + " ]";
    }
    if (isError(obj2)) {
      var parts = arrObjKeys(obj2, inspect);
      if (!("cause" in Error.prototype) && "cause" in obj2 && !isEnumerable.call(obj2, "cause")) {
        return "{ [" + String(obj2) + "] " + $join.call($concat.call("[cause]: " + inspect(obj2.cause), parts), ", ") + " }";
      }
      if (parts.length === 0) {
        return "[" + String(obj2) + "]";
      }
      return "{ [" + String(obj2) + "] " + $join.call(parts, ", ") + " }";
    }
    if (typeof obj2 === "object" && customInspect) {
      if (inspectSymbol && typeof obj2[inspectSymbol] === "function" && utilInspect) {
        return utilInspect(obj2, { depth: maxDepth - depth });
      } else if (customInspect !== "symbol" && typeof obj2.inspect === "function") {
        return obj2.inspect();
      }
    }
    if (isMap(obj2)) {
      var mapParts = [];
      if (mapForEach) {
        mapForEach.call(obj2, function(value, key) {
          mapParts.push(inspect(key, obj2, true) + " => " + inspect(value, obj2));
        });
      }
      return collectionOf("Map", mapSize.call(obj2), mapParts, indent);
    }
    if (isSet(obj2)) {
      var setParts = [];
      if (setForEach) {
        setForEach.call(obj2, function(value) {
          setParts.push(inspect(value, obj2));
        });
      }
      return collectionOf("Set", setSize.call(obj2), setParts, indent);
    }
    if (isWeakMap(obj2)) {
      return weakCollectionOf("WeakMap");
    }
    if (isWeakSet(obj2)) {
      return weakCollectionOf("WeakSet");
    }
    if (isWeakRef(obj2)) {
      return weakCollectionOf("WeakRef");
    }
    if (isNumber2(obj2)) {
      return markBoxed(inspect(Number(obj2)));
    }
    if (isBigInt(obj2)) {
      return markBoxed(inspect(bigIntValueOf.call(obj2)));
    }
    if (isBoolean2(obj2)) {
      return markBoxed(booleanValueOf.call(obj2));
    }
    if (isString2(obj2)) {
      return markBoxed(inspect(String(obj2)));
    }
    if (typeof window !== "undefined" && obj2 === window) {
      return "{ [object Window] }";
    }
    if (typeof globalThis !== "undefined" && obj2 === globalThis || typeof global !== "undefined" && obj2 === global) {
      return "{ [object globalThis] }";
    }
    if (!isDate2(obj2) && !isRegExp2(obj2)) {
      var ys = arrObjKeys(obj2, inspect);
      var isPlainObject2 = gPO ? gPO(obj2) === Object.prototype : obj2 instanceof Object || obj2.constructor === Object;
      var protoTag = obj2 instanceof Object ? "" : "null prototype";
      var stringTag = !isPlainObject2 && toStringTag2 && Object(obj2) === obj2 && toStringTag2 in obj2 ? $slice.call(toStr(obj2), 8, -1) : protoTag ? "Object" : "";
      var constructorTag = isPlainObject2 || typeof obj2.constructor !== "function" ? "" : obj2.constructor.name ? obj2.constructor.name + " " : "";
      var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
      if (ys.length === 0) {
        return tag + "{}";
      }
      if (indent) {
        return tag + "{" + indentedJoin(ys, indent) + "}";
      }
      return tag + "{ " + $join.call(ys, ", ") + " }";
    }
    return String(obj2);
  };
  function wrapQuotes(s, defaultStyle, opts) {
    var style = opts.quoteStyle || defaultStyle;
    var quoteChar = quotes[style];
    return quoteChar + s + quoteChar;
  }
  function quote(s) {
    return $replace.call(String(s), /"/g, "&quot;");
  }
  function canTrustToString(obj2) {
    return !toStringTag2 || !(typeof obj2 === "object" && ((toStringTag2 in obj2) || typeof obj2[toStringTag2] !== "undefined"));
  }
  function isArray3(obj2) {
    return toStr(obj2) === "[object Array]" && canTrustToString(obj2);
  }
  function isDate2(obj2) {
    return toStr(obj2) === "[object Date]" && canTrustToString(obj2);
  }
  function isRegExp2(obj2) {
    return toStr(obj2) === "[object RegExp]" && canTrustToString(obj2);
  }
  function isError(obj2) {
    return toStr(obj2) === "[object Error]" && canTrustToString(obj2);
  }
  function isString2(obj2) {
    return toStr(obj2) === "[object String]" && canTrustToString(obj2);
  }
  function isNumber2(obj2) {
    return toStr(obj2) === "[object Number]" && canTrustToString(obj2);
  }
  function isBoolean2(obj2) {
    return toStr(obj2) === "[object Boolean]" && canTrustToString(obj2);
  }
  function isSymbol(obj2) {
    if (hasShammedSymbols) {
      return obj2 && typeof obj2 === "object" && obj2 instanceof Symbol;
    }
    if (typeof obj2 === "symbol") {
      return true;
    }
    if (!obj2 || typeof obj2 !== "object" || !symToString) {
      return false;
    }
    try {
      symToString.call(obj2);
      return true;
    } catch (e) {}
    return false;
  }
  function isBigInt(obj2) {
    if (!obj2 || typeof obj2 !== "object" || !bigIntValueOf) {
      return false;
    }
    try {
      bigIntValueOf.call(obj2);
      return true;
    } catch (e) {}
    return false;
  }
  var hasOwn2 = Object.prototype.hasOwnProperty || function(key) {
    return key in this;
  };
  function has2(obj2, key) {
    return hasOwn2.call(obj2, key);
  }
  function toStr(obj2) {
    return objectToString.call(obj2);
  }
  function nameOf(f) {
    if (f.name) {
      return f.name;
    }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) {
      return m[1];
    }
    return null;
  }
  function indexOf(xs, x) {
    if (xs.indexOf) {
      return xs.indexOf(x);
    }
    for (var i = 0, l = xs.length;i < l; i++) {
      if (xs[i] === x) {
        return i;
      }
    }
    return -1;
  }
  function isMap(x) {
    if (!mapSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      mapSize.call(x);
      try {
        setSize.call(x);
      } catch (s) {
        return true;
      }
      return x instanceof Map;
    } catch (e) {}
    return false;
  }
  function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakMapHas.call(x, weakMapHas);
      try {
        weakSetHas.call(x, weakSetHas);
      } catch (s) {
        return true;
      }
      return x instanceof WeakMap;
    } catch (e) {}
    return false;
  }
  function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakRefDeref.call(x);
      return true;
    } catch (e) {}
    return false;
  }
  function isSet(x) {
    if (!setSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      setSize.call(x);
      try {
        mapSize.call(x);
      } catch (m) {
        return true;
      }
      return x instanceof Set;
    } catch (e) {}
    return false;
  }
  function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakSetHas.call(x, weakSetHas);
      try {
        weakMapHas.call(x, weakMapHas);
      } catch (s) {
        return true;
      }
      return x instanceof WeakSet;
    } catch (e) {}
    return false;
  }
  function isElement(x) {
    if (!x || typeof x !== "object") {
      return false;
    }
    if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
      return true;
    }
    return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
  }
  function inspectString(str2, opts) {
    if (str2.length > opts.maxStringLength) {
      var remaining = str2.length - opts.maxStringLength;
      var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
      return inspectString($slice.call(str2, 0, opts.maxStringLength), opts) + trailer;
    }
    var quoteRE = quoteREs[opts.quoteStyle || "single"];
    quoteRE.lastIndex = 0;
    var s = $replace.call($replace.call(str2, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, "single", opts);
  }
  function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[n];
    if (x) {
      return "\\" + x;
    }
    return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
  }
  function markBoxed(str2) {
    return "Object(" + str2 + ")";
  }
  function weakCollectionOf(type) {
    return type + " { ? }";
  }
  function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
    return type + " (" + size + ") {" + joinedEntries + "}";
  }
  function singleLineValues(xs) {
    for (var i = 0;i < xs.length; i++) {
      if (indexOf(xs[i], `
`) >= 0) {
        return false;
      }
    }
    return true;
  }
  function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === "\t") {
      baseIndent = "\t";
    } else if (typeof opts.indent === "number" && opts.indent > 0) {
      baseIndent = $join.call(Array(opts.indent + 1), " ");
    } else {
      return null;
    }
    return {
      base: baseIndent,
      prev: $join.call(Array(depth + 1), baseIndent)
    };
  }
  function indentedJoin(xs, indent) {
    if (xs.length === 0) {
      return "";
    }
    var lineJoiner = `
` + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, "," + lineJoiner) + `
` + indent.prev;
  }
  function arrObjKeys(obj2, inspect) {
    var isArr = isArray3(obj2);
    var xs = [];
    if (isArr) {
      xs.length = obj2.length;
      for (var i = 0;i < obj2.length; i++) {
        xs[i] = has2(obj2, i) ? inspect(obj2[i], obj2) : "";
      }
    }
    var syms = typeof gOPS === "function" ? gOPS(obj2) : [];
    var symMap;
    if (hasShammedSymbols) {
      symMap = {};
      for (var k = 0;k < syms.length; k++) {
        symMap["$" + syms[k]] = syms[k];
      }
    }
    for (var key in obj2) {
      if (!has2(obj2, key)) {
        continue;
      }
      if (isArr && String(Number(key)) === key && key < obj2.length) {
        continue;
      }
      if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
        continue;
      } else if ($test.call(/[^\w$]/, key)) {
        xs.push(inspect(key, obj2) + ": " + inspect(obj2[key], obj2));
      } else {
        xs.push(key + ": " + inspect(obj2[key], obj2));
      }
    }
    if (typeof gOPS === "function") {
      for (var j = 0;j < syms.length; j++) {
        if (isEnumerable.call(obj2, syms[j])) {
          xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj2[syms[j]], obj2));
        }
      }
    }
    return xs;
  }
});

// backend/node_modules/es-abstract/helpers/isPropertyKey.js
var require_isPropertyKey = __commonJS((exports2, module2) => {
  module2.exports = function isPropertyKey(argument) {
    return typeof argument === "string" || typeof argument === "symbol";
  };
});

// backend/node_modules/es-object-atoms/isObject.js
var require_isObject = __commonJS((exports2, module2) => {
  module2.exports = function isObject(x) {
    return !!x && (typeof x === "function" || typeof x === "object");
  };
});

// backend/node_modules/es-abstract/2024/Get.js
var require_Get = __commonJS((exports2, module2) => {
  var $TypeError = require_type();
  var inspect = require_object_inspect();
  var isPropertyKey = require_isPropertyKey();
  var isObject2 = require_isObject();
  module2.exports = function Get(O, P) {
    if (!isObject2(O)) {
      throw new $TypeError("Assertion failed: Type(O) is not Object");
    }
    if (!isPropertyKey(P)) {
      throw new $TypeError("Assertion failed: P is not a Property Key, got " + inspect(P));
    }
    return O[P];
  };
});

// backend/node_modules/is-callable/index.js
var require_is_callable = __commonJS((exports2, module2) => {
  var fnToStr = Function.prototype.toString;
  var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
  var badArrayLike;
  var isCallableMarker;
  if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
    try {
      badArrayLike = Object.defineProperty({}, "length", {
        get: function() {
          throw isCallableMarker;
        }
      });
      isCallableMarker = {};
      reflectApply(function() {
        throw 42;
      }, null, badArrayLike);
    } catch (_) {
      if (_ !== isCallableMarker) {
        reflectApply = null;
      }
    }
  } else {
    reflectApply = null;
  }
  var constructorRegex = /^\s*class\b/;
  var isES6ClassFn = function isES6ClassFunction(value) {
    try {
      var fnStr = fnToStr.call(value);
      return constructorRegex.test(fnStr);
    } catch (e) {
      return false;
    }
  };
  var tryFunctionObject = function tryFunctionToStr(value) {
    try {
      if (isES6ClassFn(value)) {
        return false;
      }
      fnToStr.call(value);
      return true;
    } catch (e) {
      return false;
    }
  };
  var toStr = Object.prototype.toString;
  var objectClass = "[object Object]";
  var fnClass = "[object Function]";
  var genClass = "[object GeneratorFunction]";
  var ddaClass = "[object HTMLAllCollection]";
  var ddaClass2 = "[object HTML document.all class]";
  var ddaClass3 = "[object HTMLCollection]";
  var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
  var isIE68 = !(0 in [,]);
  var isDDA = function isDocumentDotAll() {
    return false;
  };
  if (typeof document === "object") {
    all2 = document.all;
    if (toStr.call(all2) === toStr.call(document.all)) {
      isDDA = function isDocumentDotAll(value) {
        if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
          try {
            var str2 = toStr.call(value);
            return (str2 === ddaClass || str2 === ddaClass2 || str2 === ddaClass3 || str2 === objectClass) && value("") == null;
          } catch (e) {}
        }
        return false;
      };
    }
  }
  var all2;
  module2.exports = reflectApply ? function isCallable(value) {
    if (isDDA(value)) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    try {
      reflectApply(value, null, badArrayLike);
    } catch (e) {
      if (e !== isCallableMarker) {
        return false;
      }
    }
    return !isES6ClassFn(value) && tryFunctionObject(value);
  } : function isCallable(value) {
    if (isDDA(value)) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    if (hasToStringTag) {
      return tryFunctionObject(value);
    }
    if (isES6ClassFn(value)) {
      return false;
    }
    var strClass = toStr.call(value);
    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
      return false;
    }
    return tryFunctionObject(value);
  };
});

// backend/node_modules/es-abstract/2024/IsCallable.js
var require_IsCallable = __commonJS((exports2, module2) => {
  module2.exports = require_is_callable();
});

// backend/node_modules/math-intrinsics/constants/maxSafeInteger.js
var require_maxSafeInteger = __commonJS((exports2, module2) => {
  module2.exports = Number.MAX_SAFE_INTEGER || 9007199254740991;
});

// backend/node_modules/es-abstract/helpers/isPrimitive.js
var require_isPrimitive = __commonJS((exports2, module2) => {
  module2.exports = function isPrimitive(value) {
    return value === null || typeof value !== "function" && typeof value !== "object";
  };
});

// backend/node_modules/es-to-primitive/helpers/isPrimitive.js
var require_isPrimitive2 = __commonJS((exports2, module2) => {
  module2.exports = function isPrimitive(value) {
    return value === null || typeof value !== "function" && typeof value !== "object";
  };
});

// backend/node_modules/is-date-object/index.js
var require_is_date_object = __commonJS((exports2, module2) => {
  var callBound = require_call_bound();
  var getDay = callBound("Date.prototype.getDay");
  var tryDateObject = function tryDateGetDayCall(value) {
    try {
      getDay(value);
      return true;
    } catch (e) {
      return false;
    }
  };
  var toStr = callBound("Object.prototype.toString");
  var dateClass = "[object Date]";
  var hasToStringTag = require_shams2()();
  module2.exports = function isDateObject(value) {
    if (typeof value !== "object" || value === null) {
      return false;
    }
    return hasToStringTag ? tryDateObject(value) : toStr(value) === dateClass;
  };
});

// backend/node_modules/is-regex/index.js
var require_is_regex = __commonJS((exports2, module2) => {
  var callBound = require_call_bound();
  var hasToStringTag = require_shams2()();
  var hasOwn2 = require_hasown();
  var gOPD = require_gopd();
  var fn;
  if (hasToStringTag) {
    $exec = callBound("RegExp.prototype.exec");
    isRegexMarker = {};
    throwRegexMarker = function() {
      throw isRegexMarker;
    };
    badStringifier = {
      toString: throwRegexMarker,
      valueOf: throwRegexMarker
    };
    if (typeof Symbol.toPrimitive === "symbol") {
      badStringifier[Symbol.toPrimitive] = throwRegexMarker;
    }
    fn = function isRegex(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      var descriptor = gOPD(value, "lastIndex");
      var hasLastIndexDataProperty = descriptor && hasOwn2(descriptor, "value");
      if (!hasLastIndexDataProperty) {
        return false;
      }
      try {
        $exec(value, badStringifier);
      } catch (e) {
        return e === isRegexMarker;
      }
    };
  } else {
    $toString = callBound("Object.prototype.toString");
    regexClass = "[object RegExp]";
    fn = function isRegex(value) {
      if (!value || typeof value !== "object" && typeof value !== "function") {
        return false;
      }
      return $toString(value) === regexClass;
    };
  }
  var $exec;
  var isRegexMarker;
  var throwRegexMarker;
  var badStringifier;
  var $toString;
  var regexClass;
  module2.exports = fn;
});

// backend/node_modules/safe-regex-test/index.js
var require_safe_regex_test = __commonJS((exports2, module2) => {
  var callBound = require_call_bound();
  var isRegex = require_is_regex();
  var $exec = callBound("RegExp.prototype.exec");
  var $TypeError = require_type();
  module2.exports = function regexTester(regex) {
    if (!isRegex(regex)) {
      throw new $TypeError("`regex` must be a RegExp");
    }
    return function test(s) {
      return $exec(regex, s) !== null;
    };
  };
});

// backend/node_modules/is-symbol/index.js
var require_is_symbol = __commonJS((exports2, module2) => {
  var callBound = require_call_bound();
  var $toString = callBound("Object.prototype.toString");
  var hasSymbols = require_has_symbols()();
  var safeRegexTest = require_safe_regex_test();
  if (hasSymbols) {
    $symToStr = callBound("Symbol.prototype.toString");
    isSymString = safeRegexTest(/^Symbol\(.*\)$/);
    isSymbolObject = function isRealSymbolObject(value) {
      if (typeof value.valueOf() !== "symbol") {
        return false;
      }
      return isSymString($symToStr(value));
    };
    module2.exports = function isSymbol(value) {
      if (typeof value === "symbol") {
        return true;
      }
      if (!value || typeof value !== "object" || $toString(value) !== "[object Symbol]") {
        return false;
      }
      try {
        return isSymbolObject(value);
      } catch (e) {
        return false;
      }
    };
  } else {
    module2.exports = function isSymbol(value) {
      return false;
    };
  }
  var $symToStr;
  var isSymString;
  var isSymbolObject;
});

// backend/node_modules/es-to-primitive/es2015.js
var require_es2015 = __commonJS((exports2, module2) => {
  var hasSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "symbol";
  var isPrimitive = require_isPrimitive2();
  var isCallable = require_is_callable();
  var isDate2 = require_is_date_object();
  var isSymbol = require_is_symbol();
  var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
    if (typeof O === "undefined" || O === null) {
      throw new TypeError("Cannot call method on " + O);
    }
    if (typeof hint !== "string" || hint !== "number" && hint !== "string") {
      throw new TypeError('hint must be "string" or "number"');
    }
    var methodNames = hint === "string" ? ["toString", "valueOf"] : ["valueOf", "toString"];
    var method, result, i;
    for (i = 0;i < methodNames.length; ++i) {
      method = O[methodNames[i]];
      if (isCallable(method)) {
        result = method.call(O);
        if (isPrimitive(result)) {
          return result;
        }
      }
    }
    throw new TypeError("No default value");
  };
  var GetMethod = function GetMethod(O, P) {
    var func = O[P];
    if (func !== null && typeof func !== "undefined") {
      if (!isCallable(func)) {
        throw new TypeError(func + " returned for property " + String(P) + " of object " + O + " is not a function");
      }
      return func;
    }
    return;
  };
  module2.exports = function ToPrimitive(input) {
    if (isPrimitive(input)) {
      return input;
    }
    var hint = "default";
    if (arguments.length > 1) {
      if (arguments[1] === String) {
        hint = "string";
      } else if (arguments[1] === Number) {
        hint = "number";
      }
    }
    var exoticToPrim;
    if (hasSymbols) {
      if (Symbol.toPrimitive) {
        exoticToPrim = GetMethod(input, Symbol.toPrimitive);
      } else if (isSymbol(input)) {
        exoticToPrim = Symbol.prototype.valueOf;
      }
    }
    if (typeof exoticToPrim !== "undefined") {
      var result = exoticToPrim.call(input, hint);
      if (isPrimitive(result)) {
        return result;
      }
      throw new TypeError("unable to convert exotic object to primitive");
    }
    if (hint === "default" && (isDate2(input) || isSymbol(input))) {
      hint = "string";
    }
    return ordinaryToPrimitive(input, hint === "default" ? "number" : hint);
  };
});

// backend/node_modules/es-abstract/2024/ToPrimitive.js
var require_ToPrimitive = __commonJS((exports2, module2) => {
  var toPrimitive = require_es2015();
  module2.exports = function ToPrimitive(input) {
    if (arguments.length > 1) {
      return toPrimitive(input, arguments[1]);
    }
    return toPrimitive(input);
  };
});

// backend/node_modules/es-abstract/2024/ToString.js
var require_ToString = __commonJS((exports2, module2) => {
  var GetIntrinsic = require_get_intrinsic();
  var $String = GetIntrinsic("%String%");
  var $TypeError = require_type();
  module2.exports = function ToString(argument) {
    if (typeof argument === "symbol") {
      throw new $TypeError("Cannot convert a Symbol value to a string");
    }
    return $String(argument);
  };
});

// backend/node_modules/string.prototype.trim/implementation.js
var require_implementation3 = __commonJS((exports2, module2) => {
  var RequireObjectCoercible = require_RequireObjectCoercible();
  var ToString = require_ToString();
  var callBound = require_call_bound();
  var $replace = callBound("String.prototype.replace");
  var mvsIsWS = /^\s$/.test("");
  var leftWhitespace = mvsIsWS ? /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+/ : /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+/;
  var rightWhitespace = mvsIsWS ? /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+$/ : /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+$/;
  module2.exports = function trim() {
    var S = ToString(RequireObjectCoercible(this));
    return $replace($replace(S, leftWhitespace, ""), rightWhitespace, "");
  };
});

// backend/node_modules/string.prototype.trim/polyfill.js
var require_polyfill = __commonJS((exports2, module2) => {
  var implementation = require_implementation3();
  var zeroWidthSpace = "";
  var mongolianVowelSeparator = "";
  module2.exports = function getPolyfill() {
    if (String.prototype.trim && zeroWidthSpace.trim() === zeroWidthSpace && mongolianVowelSeparator.trim() === mongolianVowelSeparator && ("_" + mongolianVowelSeparator).trim() === "_" + mongolianVowelSeparator && (mongolianVowelSeparator + "_").trim() === mongolianVowelSeparator + "_") {
      return String.prototype.trim;
    }
    return implementation;
  };
});

// backend/node_modules/string.prototype.trim/shim.js
var require_shim = __commonJS((exports2, module2) => {
  var supportsDescriptors = require_has_property_descriptors()();
  var defineDataProperty = require_define_data_property();
  var getPolyfill = require_polyfill();
  module2.exports = function shimStringTrim() {
    var polyfill = getPolyfill();
    if (String.prototype.trim !== polyfill) {
      if (supportsDescriptors) {
        defineDataProperty(String.prototype, "trim", polyfill, true);
      } else {
        defineDataProperty(String.prototype, "trim", polyfill);
      }
    }
    return polyfill;
  };
});

// backend/node_modules/string.prototype.trim/index.js
var require_string_prototype = __commonJS((exports2, module2) => {
  var callBind = require_call_bind();
  var define2 = require_define_properties();
  var RequireObjectCoercible = require_RequireObjectCoercible();
  var implementation = require_implementation3();
  var getPolyfill = require_polyfill();
  var shim = require_shim();
  var bound = callBind(getPolyfill());
  var boundMethod = function trim(receiver2) {
    RequireObjectCoercible(receiver2);
    return bound(receiver2);
  };
  define2(boundMethod, {
    getPolyfill,
    implementation,
    shim
  });
  module2.exports = boundMethod;
});

// backend/node_modules/es-abstract/2024/StringToNumber.js
var require_StringToNumber = __commonJS((exports2, module2) => {
  var GetIntrinsic = require_get_intrinsic();
  var $RegExp = GetIntrinsic("%RegExp%");
  var $TypeError = require_type();
  var $parseInteger = GetIntrinsic("%parseInt%");
  var callBound = require_call_bound();
  var regexTester = require_safe_regex_test();
  var $strSlice = callBound("String.prototype.slice");
  var isBinary = regexTester(/^0b[01]+$/i);
  var isOctal = regexTester(/^0o[0-7]+$/i);
  var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);
  var nonWS = ["", "", ""].join("");
  var nonWSregex = new $RegExp("[" + nonWS + "]", "g");
  var hasNonWS = regexTester(nonWSregex);
  var $trim = require_string_prototype();
  module2.exports = function StringToNumber(argument) {
    if (typeof argument !== "string") {
      throw new $TypeError("Assertion failed: `argument` is not a String");
    }
    if (isBinary(argument)) {
      return +$parseInteger($strSlice(argument, 2), 2);
    }
    if (isOctal(argument)) {
      return +$parseInteger($strSlice(argument, 2), 8);
    }
    if (hasNonWS(argument) || isInvalidHexLiteral(argument)) {
      return NaN;
    }
    var trimmed = $trim(argument);
    if (trimmed !== argument) {
      return StringToNumber(trimmed);
    }
    return +argument;
  };
});

// backend/node_modules/es-abstract/2024/ToNumber.js
var require_ToNumber = __commonJS((exports2, module2) => {
  var GetIntrinsic = require_get_intrinsic();
  var $TypeError = require_type();
  var $Number = GetIntrinsic("%Number%");
  var isPrimitive = require_isPrimitive();
  var ToPrimitive = require_ToPrimitive();
  var StringToNumber = require_StringToNumber();
  module2.exports = function ToNumber(argument) {
    var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
    if (typeof value === "symbol") {
      throw new $TypeError("Cannot convert a Symbol value to a number");
    }
    if (typeof value === "bigint") {
      throw new $TypeError("Conversion from 'BigInt' to 'number' is not allowed.");
    }
    if (typeof value === "string") {
      return StringToNumber(value);
    }
    return +value;
  };
});

// backend/node_modules/es-abstract/2024/floor.js
var require_floor2 = __commonJS((exports2, module2) => {
  var $floor = require_floor();
  module2.exports = function floor(x) {
    if (typeof x === "bigint") {
      return x;
    }
    return $floor(x);
  };
});

// backend/node_modules/es-abstract/2024/truncate.js
var require_truncate = __commonJS((exports2, module2) => {
  var floor = require_floor2();
  var $TypeError = require_type();
  module2.exports = function truncate(x) {
    if (typeof x !== "number" && typeof x !== "bigint") {
      throw new $TypeError("argument must be a Number or a BigInt");
    }
    var result = x < 0 ? -floor(-x) : floor(x);
    return result === 0 ? 0 : result;
  };
});

// backend/node_modules/math-intrinsics/isFinite.js
var require_isFinite = __commonJS((exports2, module2) => {
  var $isNaN = require_isNaN();
  module2.exports = function isFinite(x) {
    return (typeof x === "number" || typeof x === "bigint") && !$isNaN(x) && x !== Infinity && x !== -Infinity;
  };
});

// backend/node_modules/es-abstract/2024/ToIntegerOrInfinity.js
var require_ToIntegerOrInfinity = __commonJS((exports2, module2) => {
  var ToNumber = require_ToNumber();
  var truncate = require_truncate();
  var $isNaN = require_isNaN();
  var $isFinite = require_isFinite();
  module2.exports = function ToIntegerOrInfinity(value) {
    var number = ToNumber(value);
    if ($isNaN(number) || number === 0) {
      return 0;
    }
    if (!$isFinite(number)) {
      return number;
    }
    return truncate(number);
  };
});

// backend/node_modules/es-abstract/2024/ToLength.js
var require_ToLength = __commonJS((exports2, module2) => {
  var MAX_SAFE_INTEGER = require_maxSafeInteger();
  var ToIntegerOrInfinity = require_ToIntegerOrInfinity();
  module2.exports = function ToLength(argument) {
    var len = ToIntegerOrInfinity(argument);
    if (len <= 0) {
      return 0;
    }
    if (len > MAX_SAFE_INTEGER) {
      return MAX_SAFE_INTEGER;
    }
    return len;
  };
});

// backend/node_modules/es-abstract/2024/LengthOfArrayLike.js
var require_LengthOfArrayLike = __commonJS((exports2, module2) => {
  var $TypeError = require_type();
  var isObject2 = require_isObject();
  var Get = require_Get();
  var ToLength = require_ToLength();
  module2.exports = function LengthOfArrayLike(obj2) {
    if (!isObject2(obj2)) {
      throw new $TypeError("Assertion failed: `obj` must be an Object");
    }
    return ToLength(Get(obj2, "length"));
  };
});

// backend/node_modules/es-abstract/2024/ToBoolean.js
var require_ToBoolean = __commonJS((exports2, module2) => {
  module2.exports = function ToBoolean(value) {
    return !!value;
  };
});

// backend/node_modules/es-object-atoms/ToObject.js
var require_ToObject = __commonJS((exports2, module2) => {
  var $Object = require_es_object_atoms();
  var RequireObjectCoercible = require_RequireObjectCoercible();
  module2.exports = function ToObject(value) {
    RequireObjectCoercible(value);
    return $Object(value);
  };
});

// backend/node_modules/array.prototype.findindex/implementation.js
var require_implementation4 = __commonJS((exports2, module2) => {
  var Call = require_Call();
  var Get = require_Get();
  var IsCallable = require_IsCallable();
  var LengthOfArrayLike = require_LengthOfArrayLike();
  var ToBoolean = require_ToBoolean();
  var ToObject = require_ToObject();
  var ToString = require_ToString();
  module2.exports = function findIndex(predicate) {
    var O = ToObject(this);
    var len = LengthOfArrayLike(O);
    if (!IsCallable(predicate)) {
      throw new TypeError("Array#findIndex: predicate must be a function");
    }
    var thisArg = arguments.length > 1 ? arguments[1] : undefined;
    var k = 0;
    while (k < len) {
      var Pk = ToString(k);
      var kValue = Get(O, Pk);
      var testResult = ToBoolean(Call(predicate, thisArg, [kValue, k, O]));
      if (testResult) {
        return k;
      }
      k += 1;
    }
    return -1;
  };
});

// backend/node_modules/array.prototype.findindex/polyfill.js
var require_polyfill2 = __commonJS((exports2, module2) => {
  var implementation = require_implementation4();
  module2.exports = function getPolyfill() {
    var implemented = Array.prototype.findIndex && [, 1].findIndex(function(item, idx) {
      return idx === 0;
    }) === 0;
    return implemented ? Array.prototype.findIndex : implementation;
  };
});

// backend/node_modules/es-shim-unscopables/index.js
var require_es_shim_unscopables = __commonJS((exports2, module2) => {
  var hasOwn2 = require_hasown();
  var hasUnscopables = typeof Symbol === "function" && typeof Symbol.unscopables === "symbol";
  var map = hasUnscopables && Array.prototype[Symbol.unscopables];
  var $TypeError = TypeError;
  module2.exports = function shimUnscopables(method) {
    if (typeof method !== "string" || !method) {
      throw new $TypeError("method must be a non-empty string");
    }
    if (!hasOwn2(Array.prototype, method)) {
      throw new $TypeError("method must be on Array.prototype");
    }
    if (hasUnscopables && map) {
      map[method] = true;
    }
  };
});

// backend/node_modules/array.prototype.findindex/shim.js
var require_shim2 = __commonJS((exports2, module2) => {
  var define2 = require_define_properties();
  var shimUnscopables = require_es_shim_unscopables();
  var getPolyfill = require_polyfill2();
  module2.exports = function shimFindIndex() {
    var polyfill = getPolyfill();
    define2(Array.prototype, { findIndex: polyfill }, {
      findIndex: function() {
        return Array.prototype.findIndex !== polyfill;
      }
    });
    shimUnscopables("findIndex");
    return polyfill;
  };
});

// backend/node_modules/array.prototype.findindex/index.js
var require_array_prototype = __commonJS((exports2, module2) => {
  var define2 = require_define_properties();
  var RequireObjectCoercible = require_RequireObjectCoercible();
  var callBind = require_call_bind();
  var callBound = require_call_bound();
  var implementation = require_implementation4();
  var getPolyfill = require_polyfill2();
  var shim = require_shim2();
  var $slice = callBound("Array.prototype.slice");
  var polyfill = callBind.apply(getPolyfill());
  var boundShim = function findIndex(array, predicate) {
    RequireObjectCoercible(array);
    var args = $slice(arguments, 1);
    return polyfill(array, args);
  };
  define2(boundShim, {
    getPolyfill,
    implementation,
    shim
  });
  module2.exports = boundShim;
});

// backend/node_modules/node-telegram-bot-api/lib/errors.js
var require_errors4 = __commonJS((exports2) => {
  var _createClass = function() {
    function defineProperties(target, props) {
      for (var i = 0;i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _possibleConstructorReturn(self2, call) {
    if (!self2) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && (typeof call === "object" || typeof call === "function") ? call : self2;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
    if (superClass)
      Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  exports2.BaseError = function(_Error) {
    _inherits(BaseError, _Error);
    function BaseError(code, message) {
      _classCallCheck(this, BaseError);
      var _this = _possibleConstructorReturn(this, (BaseError.__proto__ || Object.getPrototypeOf(BaseError)).call(this, code + ": " + message));
      _this.code = code;
      return _this;
    }
    _createClass(BaseError, [{
      key: "toJSON",
      value: function toJSON() {
        return {
          code: this.code,
          message: this.message
        };
      }
    }]);
    return BaseError;
  }(Error);
  exports2.FatalError = function(_exports$BaseError) {
    _inherits(FatalError, _exports$BaseError);
    function FatalError(data) {
      _classCallCheck(this, FatalError);
      var error2 = typeof data === "string" ? null : data;
      var message = error2 ? error2.message : data;
      var _this2 = _possibleConstructorReturn(this, (FatalError.__proto__ || Object.getPrototypeOf(FatalError)).call(this, "EFATAL", message));
      if (error2)
        _this2.stack = error2.stack;
      return _this2;
    }
    return FatalError;
  }(exports2.BaseError);
  exports2.ParseError = function(_exports$BaseError2) {
    _inherits(ParseError, _exports$BaseError2);
    function ParseError(message, response) {
      _classCallCheck(this, ParseError);
      var _this3 = _possibleConstructorReturn(this, (ParseError.__proto__ || Object.getPrototypeOf(ParseError)).call(this, "EPARSE", message));
      _this3.response = response;
      return _this3;
    }
    return ParseError;
  }(exports2.BaseError);
  exports2.TelegramError = function(_exports$BaseError3) {
    _inherits(TelegramError, _exports$BaseError3);
    function TelegramError(message, response) {
      _classCallCheck(this, TelegramError);
      var _this4 = _possibleConstructorReturn(this, (TelegramError.__proto__ || Object.getPrototypeOf(TelegramError)).call(this, "ETELEGRAM", message));
      _this4.response = response;
      return _this4;
    }
    return TelegramError;
  }(exports2.BaseError);
});

// backend/node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS((exports2, module2) => {
  if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
    module2.exports = { nextTick };
  } else {
    module2.exports = process;
  }
  function nextTick(fn, arg1, arg2, arg3) {
    if (typeof fn !== "function") {
      throw new TypeError('"callback" argument must be a function');
    }
    var len = arguments.length;
    var args, i;
    switch (len) {
      case 0:
      case 1:
        return process.nextTick(fn);
      case 2:
        return process.nextTick(function afterTickOne() {
          fn.call(null, arg1);
        });
      case 3:
        return process.nextTick(function afterTickTwo() {
          fn.call(null, arg1, arg2);
        });
      case 4:
        return process.nextTick(function afterTickThree() {
          fn.call(null, arg1, arg2, arg3);
        });
      default:
        args = new Array(len - 1);
        i = 0;
        while (i < args.length) {
          args[i++] = arguments[i];
        }
        return process.nextTick(function afterTick() {
          fn.apply(null, args);
        });
    }
  }
});

// backend/node_modules/isarray/index.js
var require_isarray = __commonJS((exports2, module2) => {
  var toString3 = {}.toString;
  module2.exports = Array.isArray || function(arr) {
    return toString3.call(arr) == "[object Array]";
  };
});

// backend/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS((exports2, module2) => {
  module2.exports = require("stream");
});

// backend/node_modules/readable-stream/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports2, module2) => {
  var buffer = require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module2.exports = buffer;
  } else {
    copyProps(buffer, exports2);
    exports2.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// backend/node_modules/core-util-is/lib/util.js
var require_util = __commonJS((exports2) => {
  function isArray3(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString(arg) === "[object Array]";
  }
  exports2.isArray = isArray3;
  function isBoolean2(arg) {
    return typeof arg === "boolean";
  }
  exports2.isBoolean = isBoolean2;
  function isNull(arg) {
    return arg === null;
  }
  exports2.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports2.isNullOrUndefined = isNullOrUndefined;
  function isNumber2(arg) {
    return typeof arg === "number";
  }
  exports2.isNumber = isNumber2;
  function isString2(arg) {
    return typeof arg === "string";
  }
  exports2.isString = isString2;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  exports2.isSymbol = isSymbol;
  function isUndefined2(arg) {
    return arg === undefined;
  }
  exports2.isUndefined = isUndefined2;
  function isRegExp2(re) {
    return objectToString(re) === "[object RegExp]";
  }
  exports2.isRegExp = isRegExp2;
  function isObject2(arg) {
    return typeof arg === "object" && arg !== null;
  }
  exports2.isObject = isObject2;
  function isDate2(d) {
    return objectToString(d) === "[object Date]";
  }
  exports2.isDate = isDate2;
  function isError(e) {
    return objectToString(e) === "[object Error]" || e instanceof Error;
  }
  exports2.isError = isError;
  function isFunction3(arg) {
    return typeof arg === "function";
  }
  exports2.isFunction = isFunction3;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
  }
  exports2.isPrimitive = isPrimitive;
  exports2.isBuffer = require("buffer").Buffer.isBuffer;
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
});

// backend/node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports2, module2) => {
  if (typeof Object.create === "function") {
    module2.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module2.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor;
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// backend/node_modules/inherits/inherits.js
var require_inherits = __commonJS((exports2, module2) => {
  try {
    util3 = require("util");
    if (typeof util3.inherits !== "function")
      throw "";
    module2.exports = util3.inherits;
  } catch (e) {
    module2.exports = require_inherits_browser();
  }
  var util3;
});

// backend/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS((exports2, module2) => {
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Buffer2 = require_safe_buffer().Buffer;
  var util3 = require("util");
  function copyBuffer(src, target, offset) {
    src.copy(target, offset);
  }
  module2.exports = function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    BufferList.prototype.push = function push(v) {
      var entry = { data: v, next: null };
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    };
    BufferList.prototype.unshift = function unshift(v) {
      var entry = { data: v, next: this.head };
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    };
    BufferList.prototype.shift = function shift() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function clear() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function join(s) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret = "" + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function concat(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      var ret = Buffer2.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
    return BufferList;
  }();
  if (util3 && util3.inspect && util3.inspect.custom) {
    module2.exports.prototype[util3.inspect.custom] = function() {
      var obj2 = util3.inspect({ length: this.length });
      return this.constructor.name + " " + obj2;
    };
  }
});

// backend/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS((exports2, module2) => {
  var pna = require_process_nextick_args();
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          pna.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          pna.nextTick(emitErrorNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, _this, err2);
        }
      } else if (cb) {
        cb(err2);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  module2.exports = {
    destroy,
    undestroy
  };
});

// backend/node_modules/util-deprecate/node.js
var require_node2 = __commonJS((exports2, module2) => {
  module2.exports = require("util").deprecate;
});

// backend/node_modules/readable-stream/lib/_stream_writable.js
var require__stream_writable = __commonJS((exports2, module2) => {
  var pna = require_process_nextick_args();
  module2.exports = Writable;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var asyncWrite = ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable.WritableState = WritableState;
  var util3 = Object.create(require_util());
  util3.inherits = require_inherits();
  var internalUtil = {
    deprecate: require_node2()
  };
  var Stream2 = require_stream();
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj2) {
    return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
  }
  var destroyImpl = require_destroy();
  util3.inherits(Writable, Stream2);
  function nop() {}
  function WritableState(options, stream4) {
    Duplex = Duplex || require__stream_duplex();
    options = options || {};
    var isDuplex = stream4 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0))
      this.highWaterMark = writableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream4, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.", "DEP0003")
      });
    } catch (_) {}
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require__stream_duplex();
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
      return new Writable(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream2.call(this);
  }
  Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream4, cb) {
    var er = new Error("write after end");
    stream4.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream4, state, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream4.emit("error", er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ended)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    var state = this._writableState;
    state.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream4, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream4, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream4, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev)
      stream4._writev(chunk, state.onwrite);
    else
      stream4._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream4, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream4, state);
      stream4._writableState.errorEmitted = true;
      stream4.emit("error", er);
    } else {
      cb(er);
      stream4._writableState.errorEmitted = true;
      stream4.emit("error", er);
      finishMaybe(stream4, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream4, er) {
    var state = stream4._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream4, state, sync, er, cb);
    else {
      var finished = needFinish(state);
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream4, state);
      }
      if (sync) {
        asyncWrite(afterWrite, stream4, state, finished, cb);
      } else {
        afterWrite(stream4, state, finished, cb);
      }
    }
  }
  function afterWrite(stream4, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream4, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream4, state);
  }
  function onwriteDrain(stream4, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream4.emit("drain");
    }
  }
  function clearBuffer(stream4, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream4._writev && entry && entry.next) {
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream4, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream4, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== undefined)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending)
      endWritable(this, state, cb);
  };
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream4, state) {
    stream4._final(function(err) {
      state.pendingcb--;
      if (err) {
        stream4.emit("error", err);
      }
      state.prefinished = true;
      stream4.emit("prefinish");
      finishMaybe(stream4, state);
    });
  }
  function prefinish(stream4, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream4._final === "function") {
        state.pendingcb++;
        state.finalCalled = true;
        pna.nextTick(callFinal, stream4, state);
      } else {
        state.prefinished = true;
        stream4.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream4, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream4, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream4.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream4, state, cb) {
    state.ending = true;
    finishMaybe(stream4, state);
    if (cb) {
      if (state.finished)
        pna.nextTick(cb);
      else
        stream4.once("finish", cb);
    }
    state.ended = true;
    stream4.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
      if (this._writableState === undefined) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
  };
});

// backend/node_modules/readable-stream/lib/_stream_duplex.js
var require__stream_duplex = __commonJS((exports2, module2) => {
  var pna = require_process_nextick_args();
  var objectKeys = Object.keys || function(obj2) {
    var keys2 = [];
    for (var key in obj2) {
      keys2.push(key);
    }
    return keys2;
  };
  module2.exports = Duplex;
  var util3 = Object.create(require_util());
  util3.inherits = require_inherits();
  var Readable2 = require__stream_readable();
  var Writable = require__stream_writable();
  util3.inherits(Duplex, Readable2);
  {
    keys = objectKeys(Writable.prototype);
    for (v = 0;v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  var keys;
  var method;
  var v;
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable2.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false)
      this.readable = false;
    if (options && options.writable === false)
      this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false)
      this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended)
      return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === undefined || this._writableState === undefined) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
  };
});

// backend/node_modules/string_decoder/node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS((exports2, module2) => {
  var buffer = require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module2.exports = buffer;
  } else {
    copyProps(buffer, exports2);
    exports2.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// backend/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS((exports2) => {
  var Buffer2 = require_safe_buffer2().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc)
      return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried)
            return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
      throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  exports2.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0)
      return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === undefined)
        return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length)
      return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127)
      return 0;
    else if (byte >> 5 === 6)
      return 2;
    else if (byte >> 4 === 14)
      return 3;
    else if (byte >> 3 === 30)
      return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i)
      return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2)
          nb = 0;
        else
          self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined)
      return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed)
      return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + "";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0)
      return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
});

// backend/node_modules/readable-stream/lib/_stream_readable.js
var require__stream_readable = __commonJS((exports2, module2) => {
  var pna = require_process_nextick_args();
  module2.exports = Readable2;
  var isArray3 = require_isarray();
  var Duplex;
  Readable2.ReadableState = ReadableState;
  var EE = require("events").EventEmitter;
  var EElistenerCount = function(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream2 = require_stream();
  var Buffer2 = require_safe_buffer().Buffer;
  var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj2) {
    return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
  }
  var util3 = Object.create(require_util());
  util3.inherits = require_inherits();
  var debugUtil = require("util");
  var debug = undefined;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function() {};
  }
  var BufferList = require_BufferList();
  var destroyImpl = require_destroy();
  var StringDecoder;
  util3.inherits(Readable2, Stream2);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (isArray3(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream4) {
    Duplex = Duplex || require__stream_duplex();
    options = options || {};
    var isDuplex = stream4 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0))
      this.highWaterMark = readableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList;
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable2(options) {
    Duplex = Duplex || require__stream_duplex();
    if (!(this instanceof Readable2))
      return new Readable2(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream2.call(this);
  }
  Object.defineProperty(Readable2.prototype, "destroyed", {
    get: function() {
      if (this._readableState === undefined) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable2.prototype.destroy = destroyImpl.destroy;
  Readable2.prototype._undestroy = destroyImpl.undestroy;
  Readable2.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
  };
  Readable2.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable2.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream4, chunk, encoding, addToFront, skipChunkCheck) {
    var state = stream4._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream4, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        stream4.emit("error", er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            stream4.emit("error", new Error("stream.unshift() after end event"));
          else
            addChunk(stream4, state, chunk, true);
        } else if (state.ended) {
          stream4.emit("error", new Error("stream.push() after EOF"));
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream4, state, chunk, false);
            else
              maybeReadMore(stream4, state);
          } else {
            addChunk(stream4, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
      }
    }
    return needMoreData(state);
  }
  function addChunk(stream4, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      stream4.emit("data", chunk);
      stream4.read(0);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream4);
    }
    maybeReadMore(stream4, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  }
  Readable2.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable2.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = require_string_decoder().StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable2.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = true;
      n = 0;
    } else {
      state.length -= n;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream4, state) {
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    emitReadable(stream4);
  }
  function emitReadable(stream4) {
    var state = stream4._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      if (state.sync)
        pna.nextTick(emitReadable_, stream4);
      else
        emitReadable_(stream4);
    }
  }
  function emitReadable_(stream4) {
    debug("emit readable");
    stream4.emit("readable");
    flow(stream4);
  }
  function maybeReadMore(stream4, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      pna.nextTick(maybeReadMore_, stream4, state);
    }
  }
  function maybeReadMore_(stream4, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug("maybeReadMore read 0");
      stream4.read(0);
      if (len === state.length)
        break;
      else
        len = state.length;
    }
    state.readingMore = false;
  }
  Readable2.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable2.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      pna.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    var increasedAwaitDrain = false;
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (ret === false && !increasedAwaitDrain) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable2.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = { hasUnpiped: false };
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i = 0;i < len; i++) {
        dests[i].emit("unpipe", this, { hasUnpiped: false });
      }
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable2.prototype.on = function(ev, fn) {
    var res = Stream2.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      var state = this._readableState;
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.emittedReadable = false;
        if (!state.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable2.prototype.addListener = Readable2.prototype.on;
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable2.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = true;
      resume(this, state);
    }
    return this;
  };
  function resume(stream4, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      pna.nextTick(resume_, stream4, state);
    }
  }
  function resume_(stream4, state) {
    if (!state.reading) {
      debug("resume read 0");
      stream4.read(0);
    }
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream4.emit("resume");
    flow(stream4);
    if (state.flowing && !state.reading)
      stream4.read(0);
  }
  Readable2.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream4) {
    var state = stream4._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream4.read() !== null) {}
  }
  Readable2.prototype.wrap = function(stream4) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream4.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream4.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === undefined))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream4.pause();
      }
    });
    for (var i in stream4) {
      if (this[i] === undefined && typeof stream4[i] === "function") {
        this[i] = function(method) {
          return function() {
            return stream4[method].apply(stream4, arguments);
          };
        }(i);
      }
    }
    for (var n = 0;n < kProxyEvents.length; n++) {
      stream4.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream4.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable2._fromList = fromList;
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.head.data;
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = fromListPartial(n, state.buffer, state.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str2 = p.data;
      var nb = n > str2.length ? str2.length : n;
      if (nb === str2.length)
        ret += str2;
      else
        ret += str2.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str2.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str2.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function endReadable(stream4) {
    var state = stream4._readableState;
    if (state.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted) {
      state.ended = true;
      pna.nextTick(endReadableNT, state, stream4);
    }
  }
  function endReadableNT(state, stream4) {
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream4.readable = false;
      stream4.emit("end");
    }
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length;i < l; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  }
});

// backend/node_modules/readable-stream/lib/_stream_transform.js
var require__stream_transform = __commonJS((exports2, module2) => {
  module2.exports = Transform;
  var Duplex = require__stream_duplex();
  var util3 = Object.create(require_util());
  util3.inherits = require_inherits();
  util3.inherits(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
      _this2.emit("close");
    });
  };
  function done(stream4, er, data) {
    if (er)
      return stream4.emit("error", er);
    if (data != null)
      stream4.push(data);
    if (stream4._writableState.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (stream4._transformState.transforming)
      throw new Error("Calling transform done when still transforming");
    return stream4.push(null);
  }
});

// backend/node_modules/readable-stream/lib/_stream_passthrough.js
var require__stream_passthrough = __commonJS((exports2, module2) => {
  module2.exports = PassThrough;
  var Transform = require__stream_transform();
  var util3 = Object.create(require_util());
  util3.inherits = require_inherits();
  util3.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// backend/node_modules/readable-stream/readable.js
var require_readable = __commonJS((exports2, module2) => {
  var Stream2 = require("stream");
  if (process.env.READABLE_STREAM === "disable" && Stream2) {
    module2.exports = Stream2;
    exports2 = module2.exports = Stream2.Readable;
    exports2.Readable = Stream2.Readable;
    exports2.Writable = Stream2.Writable;
    exports2.Duplex = Stream2.Duplex;
    exports2.Transform = Stream2.Transform;
    exports2.PassThrough = Stream2.PassThrough;
    exports2.Stream = Stream2;
  } else {
    exports2 = module2.exports = require__stream_readable();
    exports2.Stream = Stream2 || exports2;
    exports2.Readable = exports2;
    exports2.Writable = require__stream_writable();
    exports2.Duplex = require__stream_duplex();
    exports2.Transform = require__stream_transform();
    exports2.PassThrough = require__stream_passthrough();
  }
});

// backend/node_modules/readable-stream/duplex.js
var require_duplex = __commonJS((exports2, module2) => {
  module2.exports = require_readable().Duplex;
});

// backend/node_modules/safe-buffer/index.js
var require_safe_buffer3 = __commonJS((exports2, module2) => {
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module2.exports = buffer;
  } else {
    copyProps(buffer, exports2);
    exports2.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// backend/node_modules/bl/bl.js
var require_bl = __commonJS((exports2, module2) => {
  var DuplexStream = require_duplex();
  var util3 = require("util");
  var Buffer2 = require_safe_buffer3().Buffer;
  function BufferList(callback) {
    if (!(this instanceof BufferList))
      return new BufferList(callback);
    this._bufs = [];
    this.length = 0;
    if (typeof callback == "function") {
      this._callback = callback;
      var piper = function piper(err) {
        if (this._callback) {
          this._callback(err);
          this._callback = null;
        }
      }.bind(this);
      this.on("pipe", function onPipe(src) {
        src.on("error", piper);
      });
      this.on("unpipe", function onUnpipe(src) {
        src.removeListener("error", piper);
      });
    } else {
      this.append(callback);
    }
    DuplexStream.call(this);
  }
  util3.inherits(BufferList, DuplexStream);
  BufferList.prototype._offset = function _offset(offset) {
    var tot = 0, i = 0, _t;
    if (offset === 0)
      return [0, 0];
    for (;i < this._bufs.length; i++) {
      _t = tot + this._bufs[i].length;
      if (offset < _t || i == this._bufs.length - 1)
        return [i, offset - tot];
      tot = _t;
    }
  };
  BufferList.prototype.append = function append(buf) {
    var i = 0;
    if (Buffer2.isBuffer(buf)) {
      this._appendBuffer(buf);
    } else if (Array.isArray(buf)) {
      for (;i < buf.length; i++)
        this.append(buf[i]);
    } else if (buf instanceof BufferList) {
      for (;i < buf._bufs.length; i++)
        this.append(buf._bufs[i]);
    } else if (buf != null) {
      if (typeof buf == "number")
        buf = buf.toString();
      this._appendBuffer(Buffer2.from(buf));
    }
    return this;
  };
  BufferList.prototype._appendBuffer = function appendBuffer(buf) {
    this._bufs.push(buf);
    this.length += buf.length;
  };
  BufferList.prototype._write = function _write(buf, encoding, callback) {
    this._appendBuffer(buf);
    if (typeof callback == "function")
      callback();
  };
  BufferList.prototype._read = function _read(size) {
    if (!this.length)
      return this.push(null);
    size = Math.min(size, this.length);
    this.push(this.slice(0, size));
    this.consume(size);
  };
  BufferList.prototype.end = function end(chunk) {
    DuplexStream.prototype.end.call(this, chunk);
    if (this._callback) {
      this._callback(null, this.slice());
      this._callback = null;
    }
  };
  BufferList.prototype.get = function get(index) {
    return this.slice(index, index + 1)[0];
  };
  BufferList.prototype.slice = function slice(start, end) {
    if (typeof start == "number" && start < 0)
      start += this.length;
    if (typeof end == "number" && end < 0)
      end += this.length;
    return this.copy(null, 0, start, end);
  };
  BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
    if (typeof srcStart != "number" || srcStart < 0)
      srcStart = 0;
    if (typeof srcEnd != "number" || srcEnd > this.length)
      srcEnd = this.length;
    if (srcStart >= this.length)
      return dst || Buffer2.alloc(0);
    if (srcEnd <= 0)
      return dst || Buffer2.alloc(0);
    var copy = !!dst, off = this._offset(srcStart), len = srcEnd - srcStart, bytes = len, bufoff = copy && dstStart || 0, start = off[1], l, i;
    if (srcStart === 0 && srcEnd == this.length) {
      if (!copy) {
        return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
      }
      for (i = 0;i < this._bufs.length; i++) {
        this._bufs[i].copy(dst, bufoff);
        bufoff += this._bufs[i].length;
      }
      return dst;
    }
    if (bytes <= this._bufs[off[0]].length - start) {
      return copy ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
    }
    if (!copy)
      dst = Buffer2.allocUnsafe(len);
    for (i = off[0];i < this._bufs.length; i++) {
      l = this._bufs[i].length - start;
      if (bytes > l) {
        this._bufs[i].copy(dst, bufoff, start);
        bufoff += l;
      } else {
        this._bufs[i].copy(dst, bufoff, start, start + bytes);
        bufoff += l;
        break;
      }
      bytes -= l;
      if (start)
        start = 0;
    }
    if (dst.length > bufoff)
      return dst.slice(0, bufoff);
    return dst;
  };
  BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
    start = start || 0;
    end = end || this.length;
    if (start < 0)
      start += this.length;
    if (end < 0)
      end += this.length;
    var startOffset = this._offset(start), endOffset = this._offset(end), buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
    if (endOffset[1] == 0)
      buffers.pop();
    else
      buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
    if (startOffset[1] != 0)
      buffers[0] = buffers[0].slice(startOffset[1]);
    return new BufferList(buffers);
  };
  BufferList.prototype.toString = function toString(encoding, start, end) {
    return this.slice(start, end).toString(encoding);
  };
  BufferList.prototype.consume = function consume(bytes) {
    bytes = Math.trunc(bytes);
    if (Number.isNaN(bytes) || bytes <= 0)
      return this;
    while (this._bufs.length) {
      if (bytes >= this._bufs[0].length) {
        bytes -= this._bufs[0].length;
        this.length -= this._bufs[0].length;
        this._bufs.shift();
      } else {
        this._bufs[0] = this._bufs[0].slice(bytes);
        this.length -= bytes;
        break;
      }
    }
    return this;
  };
  BufferList.prototype.duplicate = function duplicate() {
    var i = 0, copy = new BufferList;
    for (;i < this._bufs.length; i++)
      copy.append(this._bufs[i]);
    return copy;
  };
  BufferList.prototype.destroy = function destroy() {
    this._bufs.length = 0;
    this.length = 0;
    this.push(null);
  };
  (function() {
    var methods = {
      readDoubleBE: 8,
      readDoubleLE: 8,
      readFloatBE: 4,
      readFloatLE: 4,
      readInt32BE: 4,
      readInt32LE: 4,
      readUInt32BE: 4,
      readUInt32LE: 4,
      readInt16BE: 2,
      readInt16LE: 2,
      readUInt16BE: 2,
      readUInt16LE: 2,
      readInt8: 1,
      readUInt8: 1
    };
    for (var m in methods) {
      (function(m2) {
        BufferList.prototype[m2] = function(offset) {
          return this.slice(offset, offset + methods[m2])[m2](0);
        };
      })(m);
    }
  })();
  module2.exports = BufferList;
});

// backend/node_modules/node-telegram-bot-api/lib/telegramWebHook.js
var require_telegramWebHook = __commonJS((exports2, module2) => {
  var _createClass = function() {
    function defineProperties(target, props) {
      for (var i = 0;i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var errors = require_errors4();
  var debug = require_src()("node-telegram-bot-api");
  var https2 = require("https");
  var http3 = require("http");
  var fs = require("fs");
  var bl = require_bl();
  var TelegramBotWebHook = function() {
    function TelegramBotWebHook2(bot) {
      _classCallCheck(this, TelegramBotWebHook2);
      this.bot = bot;
      this.options = typeof bot.options.webHook === "boolean" ? {} : bot.options.webHook;
      this.options.host = this.options.host || "0.0.0.0";
      this.options.port = this.options.port || 8443;
      this.options.https = this.options.https || {};
      this.options.healthEndpoint = this.options.healthEndpoint || "/healthz";
      this._healthRegex = new RegExp(this.options.healthEndpoint);
      this._webServer = null;
      this._open = false;
      this._requestListener = this._requestListener.bind(this);
      this._parseBody = this._parseBody.bind(this);
      if (this.options.key && this.options.cert) {
        debug("HTTPS WebHook enabled (by key/cert)");
        this.options.https.key = fs.readFileSync(this.options.key);
        this.options.https.cert = fs.readFileSync(this.options.cert);
        this._webServer = https2.createServer(this.options.https, this._requestListener);
      } else if (this.options.pfx) {
        debug("HTTPS WebHook enabled (by pfx)");
        this.options.https.pfx = fs.readFileSync(this.options.pfx);
        this._webServer = https2.createServer(this.options.https, this._requestListener);
      } else if (Object.keys(this.options.https).length) {
        debug("HTTPS WebHook enabled by (https)");
        this._webServer = https2.createServer(this.options.https, this._requestListener);
      } else {
        debug("HTTP WebHook enabled");
        this._webServer = http3.createServer(this._requestListener);
      }
    }
    _createClass(TelegramBotWebHook2, [{
      key: "open",
      value: function open() {
        var _this = this;
        if (this.isOpen()) {
          return Promise.resolve();
        }
        return new Promise(function(resolve, reject) {
          _this._webServer.listen(_this.options.port, _this.options.host, function() {
            debug("WebHook listening on port %s", _this.options.port);
            _this._open = true;
            return resolve();
          });
          _this._webServer.once("error", function(err) {
            reject(err);
          });
        });
      }
    }, {
      key: "close",
      value: function close() {
        var _this2 = this;
        if (!this.isOpen()) {
          return Promise.resolve();
        }
        return new Promise(function(resolve, reject) {
          _this2._webServer.close(function(error2) {
            if (error2)
              return reject(error2);
            _this2._open = false;
            return resolve();
          });
        });
      }
    }, {
      key: "isOpen",
      value: function isOpen() {
        return this._open;
      }
    }, {
      key: "_error",
      value: function _error(error2) {
        if (!this.bot.listeners("webhook_error").length) {
          return console.error("error: [webhook_error] %j", error2);
        }
        return this.bot.emit("webhook_error", error2);
      }
    }, {
      key: "_parseBody",
      value: function _parseBody(error2, body) {
        if (error2) {
          return this._error(new errors.FatalError(error2));
        }
        var data = undefined;
        try {
          data = JSON.parse(body.toString());
        } catch (parseError) {
          return this._error(new errors.ParseError(parseError.message));
        }
        return this.bot.processUpdate(data);
      }
    }, {
      key: "_requestListener",
      value: function _requestListener(req, res) {
        debug("WebHook request URL: %s", req.url);
        debug("WebHook request headers: %j", req.headers);
        if (req.url.indexOf(this.bot.token) !== -1) {
          if (req.method !== "POST") {
            debug("WebHook request isn't a POST");
            res.statusCode = 418;
            res.end();
          } else {
            req.pipe(bl(this._parseBody)).on("finish", function() {
              return res.end("OK");
            });
          }
        } else if (this._healthRegex.test(req.url)) {
          debug("WebHook health check passed");
          res.statusCode = 200;
          res.end("OK");
        } else {
          debug("WebHook request unauthorized");
          res.statusCode = 401;
          res.end();
        }
      }
    }]);
    return TelegramBotWebHook2;
  }();
  module2.exports = TelegramBotWebHook;
});

// backend/node_modules/node-telegram-bot-api/lib/utils.js
var require_utils2 = __commonJS((exports2) => {
  var util3 = require("util");
  exports2.deprecate = function(msg) {
    return util3.deprecate(function() {}, msg, "node-telegram-bot-api")();
  };
});

// backend/node_modules/node-telegram-bot-api/lib/telegramPolling.js
var require_telegramPolling = __commonJS((exports2, module2) => {
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  };
  var _createClass = function() {
    function defineProperties(target, props) {
      for (var i = 0;i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var errors = require_errors4();
  var debug = require_src()("node-telegram-bot-api");
  var deprecate = require_utils2().deprecate;
  var ANOTHER_WEB_HOOK_USED = 409;
  var TelegramBotPolling = function() {
    function TelegramBotPolling2(bot) {
      _classCallCheck(this, TelegramBotPolling2);
      this.bot = bot;
      this.options = typeof bot.options.polling === "boolean" ? {} : bot.options.polling;
      this.options.interval = typeof this.options.interval === "number" ? this.options.interval : 300;
      this.options.params = _typeof(this.options.params) === "object" ? this.options.params : {};
      this.options.params.offset = typeof this.options.params.offset === "number" ? this.options.params.offset : 0;
      this.options.params.timeout = typeof this.options.params.timeout === "number" ? this.options.params.timeout : 10;
      if (typeof this.options.timeout === "number") {
        deprecate("`options.polling.timeout` is deprecated. Use `options.polling.params` instead.");
        this.options.params.timeout = this.options.timeout;
      }
      this._lastUpdate = 0;
      this._lastRequest = null;
      this._abort = false;
      this._pollingTimeout = null;
    }
    _createClass(TelegramBotPolling2, [{
      key: "start",
      value: function start() {
        var _this = this;
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (this._lastRequest) {
          if (!options.restart) {
            return Promise.resolve();
          }
          return this.stop({
            cancel: true,
            reason: "Polling restart"
          }).then(function() {
            return _this._polling();
          });
        }
        return this._polling();
      }
    }, {
      key: "stop",
      value: function stop() {
        var _this2 = this;
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (!this._lastRequest) {
          return Promise.resolve();
        }
        var lastRequest = this._lastRequest;
        this._lastRequest = null;
        clearTimeout(this._pollingTimeout);
        if (options.cancel) {
          var reason = options.reason || "Polling stop";
          lastRequest.cancel(reason);
          return Promise.resolve();
        }
        this._abort = true;
        return lastRequest.finally(function() {
          _this2._abort = false;
        });
      }
    }, {
      key: "isPolling",
      value: function isPolling() {
        return !!this._lastRequest;
      }
    }, {
      key: "_error",
      value: function _error(error2) {
        if (!this.bot.listeners("polling_error").length) {
          return console.error("error: [polling_error] %j", error2);
        }
        return this.bot.emit("polling_error", error2);
      }
    }, {
      key: "_polling",
      value: function _polling() {
        var _this3 = this;
        this._lastRequest = this._getUpdates().then(function(updates) {
          _this3._lastUpdate = Date.now();
          debug("polling data %j", updates);
          updates.forEach(function(update) {
            _this3.options.params.offset = update.update_id + 1;
            debug("updated offset: %s", _this3.options.params.offset);
            try {
              _this3.bot.processUpdate(update);
            } catch (err) {
              err._processing = true;
              throw err;
            }
          });
          return null;
        }).catch(function(err) {
          debug("polling error: %s", err.message);
          if (!err._processing) {
            return _this3._error(err);
          }
          delete err._processing;
          if (!_this3.bot.options.badRejection) {
            return _this3._error(err);
          }
          var opts = {
            offset: _this3.options.params.offset,
            limit: 1,
            timeout: 0
          };
          return _this3.bot.getUpdates(opts).then(function() {
            return _this3._error(err);
          }).catch(function(requestErr) {
            var bugUrl = "https://github.com/yagop/node-telegram-bot-api/issues/36#issuecomment-268532067";
            console.error("error: Internal handling of The Offset Infinite Loop failed");
            console.error("error: Due to error '" + requestErr + "'");
            console.error("error: You may receive already-processed updates on app restart");
            console.error("error: Please see " + bugUrl + " for more information");
            return _this3.bot.emit("error", new errors.FatalError(err));
          });
        }).finally(function() {
          if (_this3._abort) {
            debug("Polling is aborted!");
          } else {
            debug("setTimeout for %s miliseconds", _this3.options.interval);
            _this3._pollingTimeout = setTimeout(function() {
              return _this3._polling();
            }, _this3.options.interval);
          }
        });
        return this._lastRequest;
      }
    }, {
      key: "_unsetWebHook",
      value: function _unsetWebHook() {
        debug("unsetting webhook");
        return this.bot._request("setWebHook");
      }
    }, {
      key: "_getUpdates",
      value: function _getUpdates() {
        var _this4 = this;
        debug("polling with options: %j", this.options.params);
        return this.bot.getUpdates(this.options.params).catch(function(err) {
          if (err.response && err.response.statusCode === ANOTHER_WEB_HOOK_USED) {
            return _this4._unsetWebHook().then(function() {
              return _this4.bot.getUpdates(_this4.options.params);
            });
          }
          throw err;
        });
      }
    }]);
    return TelegramBotPolling2;
  }();
  module2.exports = TelegramBotPolling;
});

// backend/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS((exports2, module2) => {
  var has2 = Object.prototype.hasOwnProperty;
  var prefix = "~";
  function Events() {}
  if (Object.create) {
    Events.prototype = Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events;
    else
      delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events;
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events = this._events) {
      if (has2.call(events, name))
        names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter2.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l);i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, undefined, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1);i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i = 0;i < length; i++) {
        if (listeners[i].once)
          this.removeListener(event, listeners[i].fn, undefined, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1);j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter2.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length;i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events;
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  if (typeof module2 !== "undefined") {
    module2.exports = EventEmitter2;
  }
});

// backend/node_modules/file-type/index.js
var require_file_type = __commonJS((exports2, module2) => {
  module2.exports = function(buf) {
    if (!(buf && buf.length > 1)) {
      return null;
    }
    if (buf[0] === 255 && buf[1] === 216 && buf[2] === 255) {
      return {
        ext: "jpg",
        mime: "image/jpeg"
      };
    }
    if (buf[0] === 137 && buf[1] === 80 && buf[2] === 78 && buf[3] === 71) {
      return {
        ext: "png",
        mime: "image/png"
      };
    }
    if (buf[0] === 71 && buf[1] === 73 && buf[2] === 70) {
      return {
        ext: "gif",
        mime: "image/gif"
      };
    }
    if (buf[8] === 87 && buf[9] === 69 && buf[10] === 66 && buf[11] === 80) {
      return {
        ext: "webp",
        mime: "image/webp"
      };
    }
    if (buf[0] === 70 && buf[1] === 76 && buf[2] === 73 && buf[3] === 70) {
      return {
        ext: "flif",
        mime: "image/flif"
      };
    }
    if ((buf[0] === 73 && buf[1] === 73 && buf[2] === 42 && buf[3] === 0 || buf[0] === 77 && buf[1] === 77 && buf[2] === 0 && buf[3] === 42) && buf[8] === 67 && buf[9] === 82) {
      return {
        ext: "cr2",
        mime: "image/x-canon-cr2"
      };
    }
    if (buf[0] === 73 && buf[1] === 73 && buf[2] === 42 && buf[3] === 0 || buf[0] === 77 && buf[1] === 77 && buf[2] === 0 && buf[3] === 42) {
      return {
        ext: "tif",
        mime: "image/tiff"
      };
    }
    if (buf[0] === 66 && buf[1] === 77) {
      return {
        ext: "bmp",
        mime: "image/bmp"
      };
    }
    if (buf[0] === 73 && buf[1] === 73 && buf[2] === 188) {
      return {
        ext: "jxr",
        mime: "image/vnd.ms-photo"
      };
    }
    if (buf[0] === 56 && buf[1] === 66 && buf[2] === 80 && buf[3] === 83) {
      return {
        ext: "psd",
        mime: "image/vnd.adobe.photoshop"
      };
    }
    if (buf[0] === 80 && buf[1] === 75 && buf[2] === 3 && buf[3] === 4 && buf[30] === 109 && buf[31] === 105 && buf[32] === 109 && buf[33] === 101 && buf[34] === 116 && buf[35] === 121 && buf[36] === 112 && buf[37] === 101 && buf[38] === 97 && buf[39] === 112 && buf[40] === 112 && buf[41] === 108 && buf[42] === 105 && buf[43] === 99 && buf[44] === 97 && buf[45] === 116 && buf[46] === 105 && buf[47] === 111 && buf[48] === 110 && buf[49] === 47 && buf[50] === 101 && buf[51] === 112 && buf[52] === 117 && buf[53] === 98 && buf[54] === 43 && buf[55] === 122 && buf[56] === 105 && buf[57] === 112) {
      return {
        ext: "epub",
        mime: "application/epub+zip"
      };
    }
    if (buf[0] === 80 && buf[1] === 75 && buf[2] === 3 && buf[3] === 4 && buf[30] === 77 && buf[31] === 69 && buf[32] === 84 && buf[33] === 65 && buf[34] === 45 && buf[35] === 73 && buf[36] === 78 && buf[37] === 70 && buf[38] === 47 && buf[39] === 109 && buf[40] === 111 && buf[41] === 122 && buf[42] === 105 && buf[43] === 108 && buf[44] === 108 && buf[45] === 97 && buf[46] === 46 && buf[47] === 114 && buf[48] === 115 && buf[49] === 97) {
      return {
        ext: "xpi",
        mime: "application/x-xpinstall"
      };
    }
    if (buf[0] === 80 && buf[1] === 75 && (buf[2] === 3 || buf[2] === 5 || buf[2] === 7) && (buf[3] === 4 || buf[3] === 6 || buf[3] === 8)) {
      return {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (buf[257] === 117 && buf[258] === 115 && buf[259] === 116 && buf[260] === 97 && buf[261] === 114) {
      return {
        ext: "tar",
        mime: "application/x-tar"
      };
    }
    if (buf[0] === 82 && buf[1] === 97 && buf[2] === 114 && buf[3] === 33 && buf[4] === 26 && buf[5] === 7 && (buf[6] === 0 || buf[6] === 1)) {
      return {
        ext: "rar",
        mime: "application/x-rar-compressed"
      };
    }
    if (buf[0] === 31 && buf[1] === 139 && buf[2] === 8) {
      return {
        ext: "gz",
        mime: "application/gzip"
      };
    }
    if (buf[0] === 66 && buf[1] === 90 && buf[2] === 104) {
      return {
        ext: "bz2",
        mime: "application/x-bzip2"
      };
    }
    if (buf[0] === 55 && buf[1] === 122 && buf[2] === 188 && buf[3] === 175 && buf[4] === 39 && buf[5] === 28) {
      return {
        ext: "7z",
        mime: "application/x-7z-compressed"
      };
    }
    if (buf[0] === 120 && buf[1] === 1) {
      return {
        ext: "dmg",
        mime: "application/x-apple-diskimage"
      };
    }
    if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0 && (buf[3] === 24 || buf[3] === 32) && buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112 || buf[0] === 51 && buf[1] === 103 && buf[2] === 112 && buf[3] === 53 || buf[0] === 0 && buf[1] === 0 && buf[2] === 0 && buf[3] === 28 && buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112 && buf[8] === 109 && buf[9] === 112 && buf[10] === 52 && buf[11] === 50 && buf[16] === 109 && buf[17] === 112 && buf[18] === 52 && buf[19] === 49 && buf[20] === 109 && buf[21] === 112 && buf[22] === 52 && buf[23] === 50 && buf[24] === 105 && buf[25] === 115 && buf[26] === 111 && buf[27] === 109 || buf[0] === 0 && buf[1] === 0 && buf[2] === 0 && buf[3] === 28 && buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112 && buf[8] === 105 && buf[9] === 115 && buf[10] === 111 && buf[11] === 109 || buf[0] === 0 && buf[1] === 0 && buf[2] === 0 && buf[3] === 28 && buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112 && buf[8] === 109 && buf[9] === 112 && buf[10] === 52 && buf[11] === 50 && buf[12] === 0 && buf[13] === 0 && buf[14] === 0 && buf[15] === 0) {
      return {
        ext: "mp4",
        mime: "video/mp4"
      };
    }
    if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0 && buf[3] === 28 && buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112 && buf[8] === 77 && buf[9] === 52 && buf[10] === 86) {
      return {
        ext: "m4v",
        mime: "video/x-m4v"
      };
    }
    if (buf[0] === 77 && buf[1] === 84 && buf[2] === 104 && buf[3] === 100) {
      return {
        ext: "mid",
        mime: "audio/midi"
      };
    }
    if (buf[31] === 109 && buf[32] === 97 && buf[33] === 116 && buf[34] === 114 && buf[35] === 111 && buf[36] === 115 && buf[37] === 107 && buf[38] === 97) {
      return {
        ext: "mkv",
        mime: "video/x-matroska"
      };
    }
    if (buf[0] === 26 && buf[1] === 69 && buf[2] === 223 && buf[3] === 163) {
      return {
        ext: "webm",
        mime: "video/webm"
      };
    }
    if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0 && buf[3] === 20 && buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112) {
      return {
        ext: "mov",
        mime: "video/quicktime"
      };
    }
    if (buf[0] === 82 && buf[1] === 73 && buf[2] === 70 && buf[3] === 70 && buf[8] === 65 && buf[9] === 86 && buf[10] === 73) {
      return {
        ext: "avi",
        mime: "video/x-msvideo"
      };
    }
    if (buf[0] === 48 && buf[1] === 38 && buf[2] === 178 && buf[3] === 117 && buf[4] === 142 && buf[5] === 102 && buf[6] === 207 && buf[7] === 17 && buf[8] === 166 && buf[9] === 217) {
      return {
        ext: "wmv",
        mime: "video/x-ms-wmv"
      };
    }
    if (buf[0] === 0 && buf[1] === 0 && buf[2] === 1 && buf[3].toString(16)[0] === "b") {
      return {
        ext: "mpg",
        mime: "video/mpeg"
      };
    }
    if (buf[0] === 73 && buf[1] === 68 && buf[2] === 51 || buf[0] === 255 && buf[1] === 251) {
      return {
        ext: "mp3",
        mime: "audio/mpeg"
      };
    }
    if (buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112 && buf[8] === 77 && buf[9] === 52 && buf[10] === 65 || buf[0] === 77 && buf[1] === 52 && buf[2] === 65 && buf[3] === 32) {
      return {
        ext: "m4a",
        mime: "audio/m4a"
      };
    }
    if (buf[28] === 79 && buf[29] === 112 && buf[30] === 117 && buf[31] === 115 && buf[32] === 72 && buf[33] === 101 && buf[34] === 97 && buf[35] === 100) {
      return {
        ext: "opus",
        mime: "audio/opus"
      };
    }
    if (buf[0] === 79 && buf[1] === 103 && buf[2] === 103 && buf[3] === 83) {
      return {
        ext: "ogg",
        mime: "audio/ogg"
      };
    }
    if (buf[0] === 102 && buf[1] === 76 && buf[2] === 97 && buf[3] === 67) {
      return {
        ext: "flac",
        mime: "audio/x-flac"
      };
    }
    if (buf[0] === 82 && buf[1] === 73 && buf[2] === 70 && buf[3] === 70 && buf[8] === 87 && buf[9] === 65 && buf[10] === 86 && buf[11] === 69) {
      return {
        ext: "wav",
        mime: "audio/x-wav"
      };
    }
    if (buf[0] === 35 && buf[1] === 33 && buf[2] === 65 && buf[3] === 77 && buf[4] === 82 && buf[5] === 10) {
      return {
        ext: "amr",
        mime: "audio/amr"
      };
    }
    if (buf[0] === 37 && buf[1] === 80 && buf[2] === 68 && buf[3] === 70) {
      return {
        ext: "pdf",
        mime: "application/pdf"
      };
    }
    if (buf[0] === 77 && buf[1] === 90) {
      return {
        ext: "exe",
        mime: "application/x-msdownload"
      };
    }
    if ((buf[0] === 67 || buf[0] === 70) && buf[1] === 87 && buf[2] === 83) {
      return {
        ext: "swf",
        mime: "application/x-shockwave-flash"
      };
    }
    if (buf[0] === 123 && buf[1] === 92 && buf[2] === 114 && buf[3] === 116 && buf[4] === 102) {
      return {
        ext: "rtf",
        mime: "application/rtf"
      };
    }
    if (buf[0] === 119 && buf[1] === 79 && buf[2] === 70 && buf[3] === 70 && (buf[4] === 0 && buf[5] === 1 && buf[6] === 0 && buf[7] === 0 || buf[4] === 79 && buf[5] === 84 && buf[6] === 84 && buf[7] === 79)) {
      return {
        ext: "woff",
        mime: "application/font-woff"
      };
    }
    if (buf[0] === 119 && buf[1] === 79 && buf[2] === 70 && buf[3] === 50 && (buf[4] === 0 && buf[5] === 1 && buf[6] === 0 && buf[7] === 0 || buf[4] === 79 && buf[5] === 84 && buf[6] === 84 && buf[7] === 79)) {
      return {
        ext: "woff2",
        mime: "application/font-woff"
      };
    }
    if (buf[34] === 76 && buf[35] === 80 && (buf[8] === 0 && buf[9] === 0 && buf[10] === 1 || buf[8] === 1 && buf[9] === 0 && buf[10] === 2 || buf[8] === 2 && buf[9] === 0 && buf[10] === 2)) {
      return {
        ext: "eot",
        mime: "application/octet-stream"
      };
    }
    if (buf[0] === 0 && buf[1] === 1 && buf[2] === 0 && buf[3] === 0 && buf[4] === 0) {
      return {
        ext: "ttf",
        mime: "application/font-sfnt"
      };
    }
    if (buf[0] === 79 && buf[1] === 84 && buf[2] === 84 && buf[3] === 79 && buf[4] === 0) {
      return {
        ext: "otf",
        mime: "application/font-sfnt"
      };
    }
    if (buf[0] === 0 && buf[1] === 0 && buf[2] === 1 && buf[3] === 0) {
      return {
        ext: "ico",
        mime: "image/x-icon"
      };
    }
    if (buf[0] === 70 && buf[1] === 76 && buf[2] === 86 && buf[3] === 1) {
      return {
        ext: "flv",
        mime: "video/x-flv"
      };
    }
    if (buf[0] === 37 && buf[1] === 33) {
      return {
        ext: "ps",
        mime: "application/postscript"
      };
    }
    if (buf[0] === 253 && buf[1] === 55 && buf[2] === 122 && buf[3] === 88 && buf[4] === 90 && buf[5] === 0) {
      return {
        ext: "xz",
        mime: "application/x-xz"
      };
    }
    if (buf[0] === 83 && buf[1] === 81 && buf[2] === 76 && buf[3] === 105) {
      return {
        ext: "sqlite",
        mime: "application/x-sqlite3"
      };
    }
    if (buf[0] === 78 && buf[1] === 69 && buf[2] === 83 && buf[3] === 26) {
      return {
        ext: "nes",
        mime: "application/x-nintendo-nes-rom"
      };
    }
    if (buf[0] === 67 && buf[1] === 114 && buf[2] === 50 && buf[3] === 52) {
      return {
        ext: "crx",
        mime: "application/x-google-chrome-extension"
      };
    }
    if (buf[0] === 77 && buf[1] === 83 && buf[2] === 67 && buf[3] === 70 || buf[0] === 73 && buf[1] === 83 && buf[2] === 99 && buf[3] === 40) {
      return {
        ext: "cab",
        mime: "application/vnd.ms-cab-compressed"
      };
    }
    if (buf[0] === 33 && buf[1] === 60 && buf[2] === 97 && buf[3] === 114 && buf[4] === 99 && buf[5] === 104 && buf[6] === 62 && buf[7] === 10 && buf[8] === 100 && buf[9] === 101 && buf[10] === 98 && buf[11] === 105 && buf[12] === 97 && buf[13] === 110 && buf[14] === 45 && buf[15] === 98 && buf[16] === 105 && buf[17] === 110 && buf[18] === 97 && buf[19] === 114 && buf[20] === 121) {
      return {
        ext: "deb",
        mime: "application/x-deb"
      };
    }
    if (buf[0] === 33 && buf[1] === 60 && buf[2] === 97 && buf[3] === 114 && buf[4] === 99 && buf[5] === 104 && buf[6] === 62) {
      return {
        ext: "ar",
        mime: "application/x-unix-archive"
      };
    }
    if (buf[0] === 237 && buf[1] === 171 && buf[2] === 238 && buf[3] === 219) {
      return {
        ext: "rpm",
        mime: "application/x-rpm"
      };
    }
    if (buf[0] === 31 && buf[1] === 160 || buf[0] === 31 && buf[1] === 157) {
      return {
        ext: "Z",
        mime: "application/x-compress"
      };
    }
    if (buf[0] === 76 && buf[1] === 90 && buf[2] === 73 && buf[3] === 80) {
      return {
        ext: "lz",
        mime: "application/x-lzip"
      };
    }
    if (buf[0] === 208 && buf[1] === 207 && buf[2] === 17 && buf[3] === 224 && buf[4] === 161 && buf[5] === 177 && buf[6] === 26 && buf[7] === 225) {
      return {
        ext: "msi",
        mime: "application/x-msi"
      };
    }
    return null;
  };
});

// backend/node_modules/bluebird/js/release/es5.js
var require_es5 = __commonJS((exports2, module2) => {
  var isES5 = function() {
    return this === undefined;
  }();
  if (isES5) {
    module2.exports = {
      freeze: Object.freeze,
      defineProperty: Object.defineProperty,
      getDescriptor: Object.getOwnPropertyDescriptor,
      keys: Object.keys,
      names: Object.getOwnPropertyNames,
      getPrototypeOf: Object.getPrototypeOf,
      isArray: Array.isArray,
      isES5,
      propertyIsWritable: function(obj2, prop) {
        var descriptor = Object.getOwnPropertyDescriptor(obj2, prop);
        return !!(!descriptor || descriptor.writable || descriptor.set);
      }
    };
  } else {
    has2 = {}.hasOwnProperty;
    str2 = {}.toString;
    proto = {}.constructor.prototype;
    ObjectKeys = function(o) {
      var ret = [];
      for (var key in o) {
        if (has2.call(o, key)) {
          ret.push(key);
        }
      }
      return ret;
    };
    ObjectGetDescriptor = function(o, key) {
      return { value: o[key] };
    };
    ObjectDefineProperty = function(o, key, desc) {
      o[key] = desc.value;
      return o;
    };
    ObjectFreeze = function(obj2) {
      return obj2;
    };
    ObjectGetPrototypeOf = function(obj2) {
      try {
        return Object(obj2).constructor.prototype;
      } catch (e) {
        return proto;
      }
    };
    ArrayIsArray = function(obj2) {
      try {
        return str2.call(obj2) === "[object Array]";
      } catch (e) {
        return false;
      }
    };
    module2.exports = {
      isArray: ArrayIsArray,
      keys: ObjectKeys,
      names: ObjectKeys,
      defineProperty: ObjectDefineProperty,
      getDescriptor: ObjectGetDescriptor,
      freeze: ObjectFreeze,
      getPrototypeOf: ObjectGetPrototypeOf,
      isES5,
      propertyIsWritable: function() {
        return true;
      }
    };
  }
  var has2;
  var str2;
  var proto;
  var ObjectKeys;
  var ObjectGetDescriptor;
  var ObjectDefineProperty;
  var ObjectFreeze;
  var ObjectGetPrototypeOf;
  var ArrayIsArray;
});

// backend/node_modules/bluebird/js/release/util.js
var require_util2 = __commonJS((exports2, module2) => {
  var es5 = require_es5();
  var canEvaluate = typeof navigator == "undefined";
  var errorObj = { e: {} };
  var tryCatchTarget;
  var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : exports2 !== undefined ? exports2 : null;
  function tryCatcher() {
    try {
      var target = tryCatchTarget;
      tryCatchTarget = null;
      return target.apply(this, arguments);
    } catch (e) {
      errorObj.e = e;
      return errorObj;
    }
  }
  function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
  }
  var inherits2 = function(Child, Parent) {
    var hasProp = {}.hasOwnProperty;
    function T() {
      this.constructor = Child;
      this.constructor$ = Parent;
      for (var propertyName in Parent.prototype) {
        if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
          this[propertyName + "$"] = Parent.prototype[propertyName];
        }
      }
    }
    T.prototype = Parent.prototype;
    Child.prototype = new T;
    return Child.prototype;
  };
  function isPrimitive(val) {
    return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
  }
  function isObject2(value) {
    return typeof value === "function" || typeof value === "object" && value !== null;
  }
  function maybeWrapAsError(maybeError) {
    if (!isPrimitive(maybeError))
      return maybeError;
    return new Error(safeToString(maybeError));
  }
  function withAppended(target, appendee) {
    var len = target.length;
    var ret2 = new Array(len + 1);
    var i;
    for (i = 0;i < len; ++i) {
      ret2[i] = target[i];
    }
    ret2[i] = appendee;
    return ret2;
  }
  function getDataPropertyOrDefault(obj2, key, defaultValue) {
    if (es5.isES5) {
      var desc = Object.getOwnPropertyDescriptor(obj2, key);
      if (desc != null) {
        return desc.get == null && desc.set == null ? desc.value : defaultValue;
      }
    } else {
      return {}.hasOwnProperty.call(obj2, key) ? obj2[key] : undefined;
    }
  }
  function notEnumerableProp(obj2, name, value) {
    if (isPrimitive(obj2))
      return obj2;
    var descriptor = {
      value,
      configurable: true,
      enumerable: false,
      writable: true
    };
    es5.defineProperty(obj2, name, descriptor);
    return obj2;
  }
  function thrower(r) {
    throw r;
  }
  var inheritedDataKeys = function() {
    var excludedPrototypes = [
      Array.prototype,
      Object.prototype,
      Function.prototype
    ];
    var isExcludedProto = function(val) {
      for (var i = 0;i < excludedPrototypes.length; ++i) {
        if (excludedPrototypes[i] === val) {
          return true;
        }
      }
      return false;
    };
    if (es5.isES5) {
      var getKeys = Object.getOwnPropertyNames;
      return function(obj2) {
        var ret2 = [];
        var visitedKeys = Object.create(null);
        while (obj2 != null && !isExcludedProto(obj2)) {
          var keys;
          try {
            keys = getKeys(obj2);
          } catch (e) {
            return ret2;
          }
          for (var i = 0;i < keys.length; ++i) {
            var key = keys[i];
            if (visitedKeys[key])
              continue;
            visitedKeys[key] = true;
            var desc = Object.getOwnPropertyDescriptor(obj2, key);
            if (desc != null && desc.get == null && desc.set == null) {
              ret2.push(key);
            }
          }
          obj2 = es5.getPrototypeOf(obj2);
        }
        return ret2;
      };
    } else {
      var hasProp = {}.hasOwnProperty;
      return function(obj2) {
        if (isExcludedProto(obj2))
          return [];
        var ret2 = [];
        enumeration:
          for (var key in obj2) {
            if (hasProp.call(obj2, key)) {
              ret2.push(key);
            } else {
              for (var i = 0;i < excludedPrototypes.length; ++i) {
                if (hasProp.call(excludedPrototypes[i], key)) {
                  continue enumeration;
                }
              }
              ret2.push(key);
            }
          }
        return ret2;
      };
    }
  }();
  var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
  function isClass(fn) {
    try {
      if (typeof fn === "function") {
        var keys = es5.names(fn.prototype);
        var hasMethods = es5.isES5 && keys.length > 1;
        var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
        var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
        if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
          return true;
        }
      }
      return false;
    } catch (e) {
      return false;
    }
  }
  function toFastProperties(obj) {
    function FakeConstructor() {}
    FakeConstructor.prototype = obj;
    var receiver = new FakeConstructor;
    function ic() {
      return typeof receiver.foo;
    }
    ic();
    ic();
    return obj;
    eval(obj);
  }
  var rident = /^[a-z$_][a-z$_0-9]*$/i;
  function isIdentifier(str2) {
    return rident.test(str2);
  }
  function filledRange(count, prefix, suffix) {
    var ret2 = new Array(count);
    for (var i = 0;i < count; ++i) {
      ret2[i] = prefix + i + suffix;
    }
    return ret2;
  }
  function safeToString(obj2) {
    try {
      return obj2 + "";
    } catch (e) {
      return "[no string representation]";
    }
  }
  function isError(obj2) {
    return obj2 instanceof Error || obj2 !== null && typeof obj2 === "object" && typeof obj2.message === "string" && typeof obj2.name === "string";
  }
  function markAsOriginatingFromRejection(e) {
    try {
      notEnumerableProp(e, "isOperational", true);
    } catch (ignore) {}
  }
  function originatesFromRejection(e) {
    if (e == null)
      return false;
    return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
  }
  function canAttachTrace(obj2) {
    return isError(obj2) && es5.propertyIsWritable(obj2, "stack");
  }
  var ensureErrorObject = function() {
    if (!("stack" in new Error)) {
      return function(value) {
        if (canAttachTrace(value))
          return value;
        try {
          throw new Error(safeToString(value));
        } catch (err) {
          return err;
        }
      };
    } else {
      return function(value) {
        if (canAttachTrace(value))
          return value;
        return new Error(safeToString(value));
      };
    }
  }();
  function classString(obj2) {
    return {}.toString.call(obj2);
  }
  function copyDescriptors(from, to, filter2) {
    var keys = es5.names(from);
    for (var i = 0;i < keys.length; ++i) {
      var key = keys[i];
      if (filter2(key)) {
        try {
          es5.defineProperty(to, key, es5.getDescriptor(from, key));
        } catch (ignore) {}
      }
    }
  }
  var asArray = function(v) {
    if (es5.isArray(v)) {
      return v;
    }
    return null;
  };
  if (typeof Symbol !== "undefined" && Symbol.iterator) {
    ArrayFrom = typeof Array.from === "function" ? function(v) {
      return Array.from(v);
    } : function(v) {
      var ret2 = [];
      var it = v[Symbol.iterator]();
      var itResult;
      while (!(itResult = it.next()).done) {
        ret2.push(itResult.value);
      }
      return ret2;
    };
    asArray = function(v) {
      if (es5.isArray(v)) {
        return v;
      } else if (v != null && typeof v[Symbol.iterator] === "function") {
        return ArrayFrom(v);
      }
      return null;
    };
  }
  var ArrayFrom;
  var isNode = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";
  var hasEnvVariables = typeof process !== "undefined" && typeof process.env !== "undefined";
  function env2(key) {
    return hasEnvVariables ? process.env[key] : undefined;
  }
  function getNativePromise() {
    if (typeof Promise === "function") {
      try {
        var promise = new Promise(function() {});
        if (classString(promise) === "[object Promise]") {
          return Promise;
        }
      } catch (e) {}
    }
  }
  var reflectHandler;
  function contextBind(ctx, cb) {
    if (ctx === null || typeof cb !== "function" || cb === reflectHandler) {
      return cb;
    }
    if (ctx.domain !== null) {
      cb = ctx.domain.bind(cb);
    }
    var async = ctx.async;
    if (async !== null) {
      var old = cb;
      cb = function() {
        var $_len = arguments.length + 2;
        var args = new Array($_len);
        for (var $_i = 2;$_i < $_len; ++$_i) {
          args[$_i] = arguments[$_i - 2];
        }
        args[0] = old;
        args[1] = this;
        return async.runInAsyncScope.apply(async, args);
      };
    }
    return cb;
  }
  var ret = {
    setReflectHandler: function(fn) {
      reflectHandler = fn;
    },
    isClass,
    isIdentifier,
    inheritedDataKeys,
    getDataPropertyOrDefault,
    thrower,
    isArray: es5.isArray,
    asArray,
    notEnumerableProp,
    isPrimitive,
    isObject: isObject2,
    isError,
    canEvaluate,
    errorObj,
    tryCatch,
    inherits: inherits2,
    withAppended,
    maybeWrapAsError,
    toFastProperties,
    filledRange,
    toString: safeToString,
    canAttachTrace,
    ensureErrorObject,
    originatesFromRejection,
    markAsOriginatingFromRejection,
    classString,
    copyDescriptors,
    isNode,
    hasEnvVariables,
    env: env2,
    global: globalObject,
    getNativePromise,
    contextBind
  };
  ret.isRecentNode = ret.isNode && function() {
    var version;
    if (process.versions && process.versions.node) {
      version = process.versions.node.split(".").map(Number);
    } else if (process.version) {
      version = process.version.split(".").map(Number);
    }
    return version[0] === 0 && version[1] > 10 || version[0] > 0;
  }();
  ret.nodeSupportsAsyncResource = ret.isNode && function() {
    var supportsAsync = false;
    try {
      var res = require("async_hooks").AsyncResource;
      supportsAsync = typeof res.prototype.runInAsyncScope === "function";
    } catch (e) {
      supportsAsync = false;
    }
    return supportsAsync;
  }();
  if (ret.isNode)
    ret.toFastProperties(process);
  try {
    throw new Error;
  } catch (e) {
    ret.lastLineError = e;
  }
  module2.exports = ret;
});

// backend/node_modules/bluebird/js/release/schedule.js
var require_schedule = __commonJS((exports2, module2) => {
  var util3 = require_util2();
  var schedule;
  var noAsyncScheduler = function() {
    throw new Error(`No async scheduler available

    See http://goo.gl/MqrFmX
`);
  };
  var NativePromise = util3.getNativePromise();
  if (util3.isNode && typeof MutationObserver === "undefined") {
    GlobalSetImmediate = global.setImmediate;
    ProcessNextTick = process.nextTick;
    schedule = util3.isRecentNode ? function(fn) {
      GlobalSetImmediate.call(global, fn);
    } : function(fn) {
      ProcessNextTick.call(process, fn);
    };
  } else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
    nativePromise = NativePromise.resolve();
    schedule = function(fn) {
      nativePromise.then(fn);
    };
  } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && (window.navigator.standalone || window.cordova)) && "classList" in document.documentElement) {
    schedule = function() {
      var div = document.createElement("div");
      var opts = { attributes: true };
      var toggleScheduled = false;
      var div2 = document.createElement("div");
      var o2 = new MutationObserver(function() {
        div.classList.toggle("foo");
        toggleScheduled = false;
      });
      o2.observe(div2, opts);
      var scheduleToggle = function() {
        if (toggleScheduled)
          return;
        toggleScheduled = true;
        div2.classList.toggle("foo");
      };
      return function schedule(fn) {
        var o = new MutationObserver(function() {
          o.disconnect();
          fn();
        });
        o.observe(div, opts);
        scheduleToggle();
      };
    }();
  } else if (typeof setImmediate !== "undefined") {
    schedule = function(fn) {
      setImmediate(fn);
    };
  } else if (typeof setTimeout !== "undefined") {
    schedule = function(fn) {
      setTimeout(fn, 0);
    };
  } else {
    schedule = noAsyncScheduler;
  }
  var GlobalSetImmediate;
  var ProcessNextTick;
  var nativePromise;
  module2.exports = schedule;
});

// backend/node_modules/bluebird/js/release/queue.js
var require_queue = __commonJS((exports2, module2) => {
  function arrayMove(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0;j < len; ++j) {
      dst[j + dstIndex] = src[j + srcIndex];
      src[j + srcIndex] = undefined;
    }
  }
  function Queue(capacity) {
    this._capacity = capacity;
    this._length = 0;
    this._front = 0;
  }
  Queue.prototype._willBeOverCapacity = function(size) {
    return this._capacity < size;
  };
  Queue.prototype._pushOne = function(arg) {
    var length = this.length();
    this._checkCapacity(length + 1);
    var i = this._front + length & this._capacity - 1;
    this[i] = arg;
    this._length = length + 1;
  };
  Queue.prototype.push = function(fn, receiver2, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) {
      this._pushOne(fn);
      this._pushOne(receiver2);
      this._pushOne(arg);
      return;
    }
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[j + 0 & wrapMask] = fn;
    this[j + 1 & wrapMask] = receiver2;
    this[j + 2 & wrapMask] = arg;
    this._length = length;
  };
  Queue.prototype.shift = function() {
    var front = this._front, ret = this[front];
    this[front] = undefined;
    this._front = front + 1 & this._capacity - 1;
    this._length--;
    return ret;
  };
  Queue.prototype.length = function() {
    return this._length;
  };
  Queue.prototype._checkCapacity = function(size) {
    if (this._capacity < size) {
      this._resizeTo(this._capacity << 1);
    }
  };
  Queue.prototype._resizeTo = function(capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    var moveItemsCount = front + length & oldCapacity - 1;
    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
  };
  module2.exports = Queue;
});

// backend/node_modules/bluebird/js/release/async.js
var require_async2 = __commonJS((exports2, module2) => {
  var firstLineError;
  try {
    throw new Error;
  } catch (e) {
    firstLineError = e;
  }
  var schedule = require_schedule();
  var Queue = require_queue();
  function Async() {
    this._customScheduler = false;
    this._isTickUsed = false;
    this._lateQueue = new Queue(16);
    this._normalQueue = new Queue(16);
    this._haveDrainedQueues = false;
    var self2 = this;
    this.drainQueues = function() {
      self2._drainQueues();
    };
    this._schedule = schedule;
  }
  Async.prototype.setScheduler = function(fn) {
    var prev = this._schedule;
    this._schedule = fn;
    this._customScheduler = true;
    return prev;
  };
  Async.prototype.hasCustomScheduler = function() {
    return this._customScheduler;
  };
  Async.prototype.haveItemsQueued = function() {
    return this._isTickUsed || this._haveDrainedQueues;
  };
  Async.prototype.fatalError = function(e, isNode) {
    if (isNode) {
      process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + `
`);
      process.exit(2);
    } else {
      this.throwLater(e);
    }
  };
  Async.prototype.throwLater = function(fn, arg) {
    if (arguments.length === 1) {
      arg = fn;
      fn = function() {
        throw arg;
      };
    }
    if (typeof setTimeout !== "undefined") {
      setTimeout(function() {
        fn(arg);
      }, 0);
    } else
      try {
        this._schedule(function() {
          fn(arg);
        });
      } catch (e) {
        throw new Error(`No async scheduler available

    See http://goo.gl/MqrFmX
`);
      }
  };
  function AsyncInvokeLater(fn, receiver2, arg) {
    this._lateQueue.push(fn, receiver2, arg);
    this._queueTick();
  }
  function AsyncInvoke(fn, receiver2, arg) {
    this._normalQueue.push(fn, receiver2, arg);
    this._queueTick();
  }
  function AsyncSettlePromises(promise) {
    this._normalQueue._pushOne(promise);
    this._queueTick();
  }
  Async.prototype.invokeLater = AsyncInvokeLater;
  Async.prototype.invoke = AsyncInvoke;
  Async.prototype.settlePromises = AsyncSettlePromises;
  function _drainQueue(queue) {
    while (queue.length() > 0) {
      _drainQueueStep(queue);
    }
  }
  function _drainQueueStep(queue) {
    var fn = queue.shift();
    if (typeof fn !== "function") {
      fn._settlePromises();
    } else {
      var receiver2 = queue.shift();
      var arg = queue.shift();
      fn.call(receiver2, arg);
    }
  }
  Async.prototype._drainQueues = function() {
    _drainQueue(this._normalQueue);
    this._reset();
    this._haveDrainedQueues = true;
    _drainQueue(this._lateQueue);
  };
  Async.prototype._queueTick = function() {
    if (!this._isTickUsed) {
      this._isTickUsed = true;
      this._schedule(this.drainQueues);
    }
  };
  Async.prototype._reset = function() {
    this._isTickUsed = false;
  };
  module2.exports = Async;
  module2.exports.firstLineError = firstLineError;
});

// backend/node_modules/bluebird/js/release/errors.js
var require_errors5 = __commonJS((exports2, module2) => {
  var es5 = require_es5();
  var Objectfreeze = es5.freeze;
  var util3 = require_util2();
  var inherits2 = util3.inherits;
  var notEnumerableProp = util3.notEnumerableProp;
  function subError(nameProperty, defaultMessage) {
    function SubError(message) {
      if (!(this instanceof SubError))
        return new SubError(message);
      notEnumerableProp(this, "message", typeof message === "string" ? message : defaultMessage);
      notEnumerableProp(this, "name", nameProperty);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        Error.call(this);
      }
    }
    inherits2(SubError, Error);
    return SubError;
  }
  var _TypeError;
  var _RangeError;
  var Warning = subError("Warning", "warning");
  var CancellationError = subError("CancellationError", "cancellation error");
  var TimeoutError = subError("TimeoutError", "timeout error");
  var AggregateError2 = subError("AggregateError", "aggregate error");
  try {
    _TypeError = TypeError;
    _RangeError = RangeError;
  } catch (e) {
    _TypeError = subError("TypeError", "type error");
    _RangeError = subError("RangeError", "range error");
  }
  var methods = ("join pop push shift unshift slice filter forEach some " + "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");
  for (i = 0;i < methods.length; ++i) {
    if (typeof Array.prototype[methods[i]] === "function") {
      AggregateError2.prototype[methods[i]] = Array.prototype[methods[i]];
    }
  }
  var i;
  es5.defineProperty(AggregateError2.prototype, "length", {
    value: 0,
    configurable: false,
    writable: true,
    enumerable: true
  });
  AggregateError2.prototype["isOperational"] = true;
  var level = 0;
  AggregateError2.prototype.toString = function() {
    var indent = Array(level * 4 + 1).join(" ");
    var ret = `
` + indent + "AggregateError of:" + `
`;
    level++;
    indent = Array(level * 4 + 1).join(" ");
    for (var i2 = 0;i2 < this.length; ++i2) {
      var str2 = this[i2] === this ? "[Circular AggregateError]" : this[i2] + "";
      var lines = str2.split(`
`);
      for (var j = 0;j < lines.length; ++j) {
        lines[j] = indent + lines[j];
      }
      str2 = lines.join(`
`);
      ret += str2 + `
`;
    }
    level--;
    return ret;
  };
  function OperationalError(message) {
    if (!(this instanceof OperationalError))
      return new OperationalError(message);
    notEnumerableProp(this, "name", "OperationalError");
    notEnumerableProp(this, "message", message);
    this.cause = message;
    this["isOperational"] = true;
    if (message instanceof Error) {
      notEnumerableProp(this, "message", message.message);
      notEnumerableProp(this, "stack", message.stack);
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
  inherits2(OperationalError, Error);
  var errorTypes = Error["__BluebirdErrorTypes__"];
  if (!errorTypes) {
    errorTypes = Objectfreeze({
      CancellationError,
      TimeoutError,
      OperationalError,
      RejectionError: OperationalError,
      AggregateError: AggregateError2
    });
    es5.defineProperty(Error, "__BluebirdErrorTypes__", {
      value: errorTypes,
      writable: false,
      enumerable: false,
      configurable: false
    });
  }
  module2.exports = {
    Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    Warning
  };
});

// backend/node_modules/bluebird/js/release/thenables.js
var require_thenables = __commonJS((exports2, module2) => {
  module2.exports = function(Promise2, INTERNAL) {
    var util3 = require_util2();
    var errorObj = util3.errorObj;
    var isObject2 = util3.isObject;
    function tryConvertToPromise(obj2, context) {
      if (isObject2(obj2)) {
        if (obj2 instanceof Promise2)
          return obj2;
        var then = getThen(obj2);
        if (then === errorObj) {
          if (context)
            context._pushContext();
          var ret = Promise2.reject(then.e);
          if (context)
            context._popContext();
          return ret;
        } else if (typeof then === "function") {
          if (isAnyBluebirdPromise(obj2)) {
            var ret = new Promise2(INTERNAL);
            obj2._then(ret._fulfill, ret._reject, undefined, ret, null);
            return ret;
          }
          return doThenable(obj2, then, context);
        }
      }
      return obj2;
    }
    function doGetThen(obj2) {
      return obj2.then;
    }
    function getThen(obj2) {
      try {
        return doGetThen(obj2);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    var hasProp = {}.hasOwnProperty;
    function isAnyBluebirdPromise(obj2) {
      try {
        return hasProp.call(obj2, "_promise0");
      } catch (e) {
        return false;
      }
    }
    function doThenable(x, then, context) {
      var promise = new Promise2(INTERNAL);
      var ret = promise;
      if (context)
        context._pushContext();
      promise._captureStackTrace();
      if (context)
        context._popContext();
      var synchronous = true;
      var result = util3.tryCatch(then).call(x, resolve, reject);
      synchronous = false;
      if (promise && result === errorObj) {
        promise._rejectCallback(result.e, true, true);
        promise = null;
      }
      function resolve(value) {
        if (!promise)
          return;
        promise._resolveCallback(value);
        promise = null;
      }
      function reject(reason) {
        if (!promise)
          return;
        promise._rejectCallback(reason, synchronous, true);
        promise = null;
      }
      return ret;
    }
    return tryConvertToPromise;
  };
});

// backend/node_modules/bluebird/js/release/promise_array.js
var require_promise_array = __commonJS((exports2, module2) => {
  module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
    var util3 = require_util2();
    var isArray3 = util3.isArray;
    function toResolutionValue(val) {
      switch (val) {
        case -2:
          return [];
        case -3:
          return {};
        case -6:
          return new Map;
      }
    }
    function PromiseArray(values2) {
      var promise = this._promise = new Promise2(INTERNAL);
      if (values2 instanceof Promise2) {
        promise._propagateFrom(values2, 3);
        values2.suppressUnhandledRejections();
      }
      promise._setOnCancel(this);
      this._values = values2;
      this._length = 0;
      this._totalResolved = 0;
      this._init(undefined, -2);
    }
    util3.inherits(PromiseArray, Proxyable);
    PromiseArray.prototype.length = function() {
      return this._length;
    };
    PromiseArray.prototype.promise = function() {
      return this._promise;
    };
    PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
      var values2 = tryConvertToPromise(this._values, this._promise);
      if (values2 instanceof Promise2) {
        values2 = values2._target();
        var bitField = values2._bitField;
        this._values = values2;
        if ((bitField & 50397184) === 0) {
          this._promise._setAsyncGuaranteed();
          return values2._then(init, this._reject, undefined, this, resolveValueIfEmpty);
        } else if ((bitField & 33554432) !== 0) {
          values2 = values2._value();
        } else if ((bitField & 16777216) !== 0) {
          return this._reject(values2._reason());
        } else {
          return this._cancel();
        }
      }
      values2 = util3.asArray(values2);
      if (values2 === null) {
        var err = apiRejection("expecting an array or an iterable object but got " + util3.classString(values2)).reason();
        this._promise._rejectCallback(err, false);
        return;
      }
      if (values2.length === 0) {
        if (resolveValueIfEmpty === -5) {
          this._resolveEmptyArray();
        } else {
          this._resolve(toResolutionValue(resolveValueIfEmpty));
        }
        return;
      }
      this._iterate(values2);
    };
    PromiseArray.prototype._iterate = function(values2) {
      var len = this.getActualLength(values2.length);
      this._length = len;
      this._values = this.shouldCopyValues() ? new Array(len) : this._values;
      var result = this._promise;
      var isResolved = false;
      var bitField = null;
      for (var i = 0;i < len; ++i) {
        var maybePromise = tryConvertToPromise(values2[i], result);
        if (maybePromise instanceof Promise2) {
          maybePromise = maybePromise._target();
          bitField = maybePromise._bitField;
        } else {
          bitField = null;
        }
        if (isResolved) {
          if (bitField !== null) {
            maybePromise.suppressUnhandledRejections();
          }
        } else if (bitField !== null) {
          if ((bitField & 50397184) === 0) {
            maybePromise._proxy(this, i);
            this._values[i] = maybePromise;
          } else if ((bitField & 33554432) !== 0) {
            isResolved = this._promiseFulfilled(maybePromise._value(), i);
          } else if ((bitField & 16777216) !== 0) {
            isResolved = this._promiseRejected(maybePromise._reason(), i);
          } else {
            isResolved = this._promiseCancelled(i);
          }
        } else {
          isResolved = this._promiseFulfilled(maybePromise, i);
        }
      }
      if (!isResolved)
        result._setAsyncGuaranteed();
    };
    PromiseArray.prototype._isResolved = function() {
      return this._values === null;
    };
    PromiseArray.prototype._resolve = function(value) {
      this._values = null;
      this._promise._fulfill(value);
    };
    PromiseArray.prototype._cancel = function() {
      if (this._isResolved() || !this._promise._isCancellable())
        return;
      this._values = null;
      this._promise._cancel();
    };
    PromiseArray.prototype._reject = function(reason) {
      this._values = null;
      this._promise._rejectCallback(reason, false);
    };
    PromiseArray.prototype._promiseFulfilled = function(value, index) {
      this._values[index] = value;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
      }
      return false;
    };
    PromiseArray.prototype._promiseCancelled = function() {
      this._cancel();
      return true;
    };
    PromiseArray.prototype._promiseRejected = function(reason) {
      this._totalResolved++;
      this._reject(reason);
      return true;
    };
    PromiseArray.prototype._resultCancelled = function() {
      if (this._isResolved())
        return;
      var values2 = this._values;
      this._cancel();
      if (values2 instanceof Promise2) {
        values2.cancel();
      } else {
        for (var i = 0;i < values2.length; ++i) {
          if (values2[i] instanceof Promise2) {
            values2[i].cancel();
          }
        }
      }
    };
    PromiseArray.prototype.shouldCopyValues = function() {
      return true;
    };
    PromiseArray.prototype.getActualLength = function(len) {
      return len;
    };
    return PromiseArray;
  };
});

// backend/node_modules/bluebird/js/release/context.js
var require_context = __commonJS((exports2, module2) => {
  module2.exports = function(Promise2) {
    var longStackTraces = false;
    var contextStack = [];
    Promise2.prototype._promiseCreated = function() {};
    Promise2.prototype._pushContext = function() {};
    Promise2.prototype._popContext = function() {
      return null;
    };
    Promise2._peekContext = Promise2.prototype._peekContext = function() {};
    function Context2() {
      this._trace = new Context2.CapturedTrace(peekContext());
    }
    Context2.prototype._pushContext = function() {
      if (this._trace !== undefined) {
        this._trace._promiseCreated = null;
        contextStack.push(this._trace);
      }
    };
    Context2.prototype._popContext = function() {
      if (this._trace !== undefined) {
        var trace = contextStack.pop();
        var ret = trace._promiseCreated;
        trace._promiseCreated = null;
        return ret;
      }
      return null;
    };
    function createContext() {
      if (longStackTraces)
        return new Context2;
    }
    function peekContext() {
      var lastIndex = contextStack.length - 1;
      if (lastIndex >= 0) {
        return contextStack[lastIndex];
      }
      return;
    }
    Context2.CapturedTrace = null;
    Context2.create = createContext;
    Context2.deactivateLongStackTraces = function() {};
    Context2.activateLongStackTraces = function() {
      var Promise_pushContext = Promise2.prototype._pushContext;
      var Promise_popContext = Promise2.prototype._popContext;
      var Promise_PeekContext = Promise2._peekContext;
      var Promise_peekContext = Promise2.prototype._peekContext;
      var Promise_promiseCreated = Promise2.prototype._promiseCreated;
      Context2.deactivateLongStackTraces = function() {
        Promise2.prototype._pushContext = Promise_pushContext;
        Promise2.prototype._popContext = Promise_popContext;
        Promise2._peekContext = Promise_PeekContext;
        Promise2.prototype._peekContext = Promise_peekContext;
        Promise2.prototype._promiseCreated = Promise_promiseCreated;
        longStackTraces = false;
      };
      longStackTraces = true;
      Promise2.prototype._pushContext = Context2.prototype._pushContext;
      Promise2.prototype._popContext = Context2.prototype._popContext;
      Promise2._peekContext = Promise2.prototype._peekContext = peekContext;
      Promise2.prototype._promiseCreated = function() {
        var ctx = this._peekContext();
        if (ctx && ctx._promiseCreated == null)
          ctx._promiseCreated = this;
      };
    };
    return Context2;
  };
});

// backend/node_modules/bluebird/js/release/debuggability.js
var require_debuggability = __commonJS((exports2, module2) => {
  module2.exports = function(Promise2, Context2, enableAsyncHooks, disableAsyncHooks) {
    var async = Promise2._async;
    var Warning = require_errors5().Warning;
    var util3 = require_util2();
    var es5 = require_es5();
    var canAttachTrace = util3.canAttachTrace;
    var unhandledRejectionHandled;
    var possiblyUnhandledRejection;
    var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
    var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
    var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
    var stackFramePattern = null;
    var formatStack = null;
    var indentStackFrames = false;
    var printWarning;
    var debugging = !!(util3.env("BLUEBIRD_DEBUG") != 0 && (util3.env("BLUEBIRD_DEBUG") || util3.env("NODE_ENV") === "development"));
    var warnings = !!(util3.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util3.env("BLUEBIRD_WARNINGS")));
    var longStackTraces = !!(util3.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util3.env("BLUEBIRD_LONG_STACK_TRACES")));
    var wForgottenReturn = util3.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util3.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
    var deferUnhandledRejectionCheck;
    (function() {
      var promises = [];
      function unhandledRejectionCheck() {
        for (var i = 0;i < promises.length; ++i) {
          promises[i]._notifyUnhandledRejection();
        }
        unhandledRejectionClear();
      }
      function unhandledRejectionClear() {
        promises.length = 0;
      }
      deferUnhandledRejectionCheck = function(promise) {
        promises.push(promise);
        setTimeout(unhandledRejectionCheck, 1);
      };
      es5.defineProperty(Promise2, "_unhandledRejectionCheck", {
        value: unhandledRejectionCheck
      });
      es5.defineProperty(Promise2, "_unhandledRejectionClear", {
        value: unhandledRejectionClear
      });
    })();
    Promise2.prototype.suppressUnhandledRejections = function() {
      var target = this._target();
      target._bitField = target._bitField & ~1048576 | 524288;
    };
    Promise2.prototype._ensurePossibleRejectionHandled = function() {
      if ((this._bitField & 524288) !== 0)
        return;
      this._setRejectionIsUnhandled();
      deferUnhandledRejectionCheck(this);
    };
    Promise2.prototype._notifyUnhandledRejectionIsHandled = function() {
      fireRejectionEvent("rejectionHandled", unhandledRejectionHandled, undefined, this);
    };
    Promise2.prototype._setReturnedNonUndefined = function() {
      this._bitField = this._bitField | 268435456;
    };
    Promise2.prototype._returnedNonUndefined = function() {
      return (this._bitField & 268435456) !== 0;
    };
    Promise2.prototype._notifyUnhandledRejection = function() {
      if (this._isRejectionUnhandled()) {
        var reason = this._settledValue();
        this._setUnhandledRejectionIsNotified();
        fireRejectionEvent("unhandledRejection", possiblyUnhandledRejection, reason, this);
      }
    };
    Promise2.prototype._setUnhandledRejectionIsNotified = function() {
      this._bitField = this._bitField | 262144;
    };
    Promise2.prototype._unsetUnhandledRejectionIsNotified = function() {
      this._bitField = this._bitField & ~262144;
    };
    Promise2.prototype._isUnhandledRejectionNotified = function() {
      return (this._bitField & 262144) > 0;
    };
    Promise2.prototype._setRejectionIsUnhandled = function() {
      this._bitField = this._bitField | 1048576;
    };
    Promise2.prototype._unsetRejectionIsUnhandled = function() {
      this._bitField = this._bitField & ~1048576;
      if (this._isUnhandledRejectionNotified()) {
        this._unsetUnhandledRejectionIsNotified();
        this._notifyUnhandledRejectionIsHandled();
      }
    };
    Promise2.prototype._isRejectionUnhandled = function() {
      return (this._bitField & 1048576) > 0;
    };
    Promise2.prototype._warn = function(message, shouldUseOwnTrace, promise) {
      return warn(message, shouldUseOwnTrace, promise || this);
    };
    Promise2.onPossiblyUnhandledRejection = function(fn) {
      var context = Promise2._getContext();
      possiblyUnhandledRejection = util3.contextBind(context, fn);
    };
    Promise2.onUnhandledRejectionHandled = function(fn) {
      var context = Promise2._getContext();
      unhandledRejectionHandled = util3.contextBind(context, fn);
    };
    var disableLongStackTraces = function() {};
    Promise2.longStackTraces = function() {
      if (async.haveItemsQueued() && !config.longStackTraces) {
        throw new Error(`cannot enable long stack traces after promises have been created

    See http://goo.gl/MqrFmX
`);
      }
      if (!config.longStackTraces && longStackTracesIsSupported()) {
        var Promise_captureStackTrace = Promise2.prototype._captureStackTrace;
        var Promise_attachExtraTrace = Promise2.prototype._attachExtraTrace;
        var Promise_dereferenceTrace = Promise2.prototype._dereferenceTrace;
        config.longStackTraces = true;
        disableLongStackTraces = function() {
          if (async.haveItemsQueued() && !config.longStackTraces) {
            throw new Error(`cannot enable long stack traces after promises have been created

    See http://goo.gl/MqrFmX
`);
          }
          Promise2.prototype._captureStackTrace = Promise_captureStackTrace;
          Promise2.prototype._attachExtraTrace = Promise_attachExtraTrace;
          Promise2.prototype._dereferenceTrace = Promise_dereferenceTrace;
          Context2.deactivateLongStackTraces();
          config.longStackTraces = false;
        };
        Promise2.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
        Promise2.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
        Promise2.prototype._dereferenceTrace = longStackTracesDereferenceTrace;
        Context2.activateLongStackTraces();
      }
    };
    Promise2.hasLongStackTraces = function() {
      return config.longStackTraces && longStackTracesIsSupported();
    };
    var legacyHandlers = {
      unhandledrejection: {
        before: function() {
          var ret = util3.global.onunhandledrejection;
          util3.global.onunhandledrejection = null;
          return ret;
        },
        after: function(fn) {
          util3.global.onunhandledrejection = fn;
        }
      },
      rejectionhandled: {
        before: function() {
          var ret = util3.global.onrejectionhandled;
          util3.global.onrejectionhandled = null;
          return ret;
        },
        after: function(fn) {
          util3.global.onrejectionhandled = fn;
        }
      }
    };
    var fireDomEvent = function() {
      var dispatch = function(legacy, e) {
        if (legacy) {
          var fn;
          try {
            fn = legacy.before();
            return !util3.global.dispatchEvent(e);
          } finally {
            legacy.after(fn);
          }
        } else {
          return !util3.global.dispatchEvent(e);
        }
      };
      try {
        if (typeof CustomEvent === "function") {
          var event = new CustomEvent("CustomEvent");
          util3.global.dispatchEvent(event);
          return function(name, event2) {
            name = name.toLowerCase();
            var eventData = {
              detail: event2,
              cancelable: true
            };
            var domEvent = new CustomEvent(name, eventData);
            es5.defineProperty(domEvent, "promise", { value: event2.promise });
            es5.defineProperty(domEvent, "reason", { value: event2.reason });
            return dispatch(legacyHandlers[name], domEvent);
          };
        } else if (typeof Event === "function") {
          var event = new Event("CustomEvent");
          util3.global.dispatchEvent(event);
          return function(name, event2) {
            name = name.toLowerCase();
            var domEvent = new Event(name, {
              cancelable: true
            });
            domEvent.detail = event2;
            es5.defineProperty(domEvent, "promise", { value: event2.promise });
            es5.defineProperty(domEvent, "reason", { value: event2.reason });
            return dispatch(legacyHandlers[name], domEvent);
          };
        } else {
          var event = document.createEvent("CustomEvent");
          event.initCustomEvent("testingtheevent", false, true, {});
          util3.global.dispatchEvent(event);
          return function(name, event2) {
            name = name.toLowerCase();
            var domEvent = document.createEvent("CustomEvent");
            domEvent.initCustomEvent(name, false, true, event2);
            return dispatch(legacyHandlers[name], domEvent);
          };
        }
      } catch (e) {}
      return function() {
        return false;
      };
    }();
    var fireGlobalEvent = function() {
      if (util3.isNode) {
        return function() {
          return process.emit.apply(process, arguments);
        };
      } else {
        if (!util3.global) {
          return function() {
            return false;
          };
        }
        return function(name) {
          var methodName = "on" + name.toLowerCase();
          var method = util3.global[methodName];
          if (!method)
            return false;
          method.apply(util3.global, [].slice.call(arguments, 1));
          return true;
        };
      }
    }();
    function generatePromiseLifecycleEventObject(name, promise) {
      return { promise };
    }
    var eventToObjectGenerator = {
      promiseCreated: generatePromiseLifecycleEventObject,
      promiseFulfilled: generatePromiseLifecycleEventObject,
      promiseRejected: generatePromiseLifecycleEventObject,
      promiseResolved: generatePromiseLifecycleEventObject,
      promiseCancelled: generatePromiseLifecycleEventObject,
      promiseChained: function(name, promise, child) {
        return { promise, child };
      },
      warning: function(name, warning) {
        return { warning };
      },
      unhandledRejection: function(name, reason, promise) {
        return { reason, promise };
      },
      rejectionHandled: generatePromiseLifecycleEventObject
    };
    var activeFireEvent = function(name) {
      var globalEventFired = false;
      try {
        globalEventFired = fireGlobalEvent.apply(null, arguments);
      } catch (e) {
        async.throwLater(e);
        globalEventFired = true;
      }
      var domEventFired = false;
      try {
        domEventFired = fireDomEvent(name, eventToObjectGenerator[name].apply(null, arguments));
      } catch (e) {
        async.throwLater(e);
        domEventFired = true;
      }
      return domEventFired || globalEventFired;
    };
    Promise2.config = function(opts) {
      opts = Object(opts);
      if ("longStackTraces" in opts) {
        if (opts.longStackTraces) {
          Promise2.longStackTraces();
        } else if (!opts.longStackTraces && Promise2.hasLongStackTraces()) {
          disableLongStackTraces();
        }
      }
      if ("warnings" in opts) {
        var warningsOption = opts.warnings;
        config.warnings = !!warningsOption;
        wForgottenReturn = config.warnings;
        if (util3.isObject(warningsOption)) {
          if ("wForgottenReturn" in warningsOption) {
            wForgottenReturn = !!warningsOption.wForgottenReturn;
          }
        }
      }
      if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
        if (async.haveItemsQueued()) {
          throw new Error("cannot enable cancellation after promises are in use");
        }
        Promise2.prototype._clearCancellationData = cancellationClearCancellationData;
        Promise2.prototype._propagateFrom = cancellationPropagateFrom;
        Promise2.prototype._onCancel = cancellationOnCancel;
        Promise2.prototype._setOnCancel = cancellationSetOnCancel;
        Promise2.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
        Promise2.prototype._execute = cancellationExecute;
        propagateFromFunction = cancellationPropagateFrom;
        config.cancellation = true;
      }
      if ("monitoring" in opts) {
        if (opts.monitoring && !config.monitoring) {
          config.monitoring = true;
          Promise2.prototype._fireEvent = activeFireEvent;
        } else if (!opts.monitoring && config.monitoring) {
          config.monitoring = false;
          Promise2.prototype._fireEvent = defaultFireEvent;
        }
      }
      if ("asyncHooks" in opts && util3.nodeSupportsAsyncResource) {
        var prev = config.asyncHooks;
        var cur = !!opts.asyncHooks;
        if (prev !== cur) {
          config.asyncHooks = cur;
          if (cur) {
            enableAsyncHooks();
          } else {
            disableAsyncHooks();
          }
        }
      }
      return Promise2;
    };
    function defaultFireEvent() {
      return false;
    }
    Promise2.prototype._fireEvent = defaultFireEvent;
    Promise2.prototype._execute = function(executor, resolve, reject) {
      try {
        executor(resolve, reject);
      } catch (e) {
        return e;
      }
    };
    Promise2.prototype._onCancel = function() {};
    Promise2.prototype._setOnCancel = function(handler) {};
    Promise2.prototype._attachCancellationCallback = function(onCancel) {};
    Promise2.prototype._captureStackTrace = function() {};
    Promise2.prototype._attachExtraTrace = function() {};
    Promise2.prototype._dereferenceTrace = function() {};
    Promise2.prototype._clearCancellationData = function() {};
    Promise2.prototype._propagateFrom = function(parent, flags) {};
    function cancellationExecute(executor, resolve, reject) {
      var promise = this;
      try {
        executor(resolve, reject, function(onCancel) {
          if (typeof onCancel !== "function") {
            throw new TypeError("onCancel must be a function, got: " + util3.toString(onCancel));
          }
          promise._attachCancellationCallback(onCancel);
        });
      } catch (e) {
        return e;
      }
    }
    function cancellationAttachCancellationCallback(onCancel) {
      if (!this._isCancellable())
        return this;
      var previousOnCancel = this._onCancel();
      if (previousOnCancel !== undefined) {
        if (util3.isArray(previousOnCancel)) {
          previousOnCancel.push(onCancel);
        } else {
          this._setOnCancel([previousOnCancel, onCancel]);
        }
      } else {
        this._setOnCancel(onCancel);
      }
    }
    function cancellationOnCancel() {
      return this._onCancelField;
    }
    function cancellationSetOnCancel(onCancel) {
      this._onCancelField = onCancel;
    }
    function cancellationClearCancellationData() {
      this._cancellationParent = undefined;
      this._onCancelField = undefined;
    }
    function cancellationPropagateFrom(parent, flags) {
      if ((flags & 1) !== 0) {
        this._cancellationParent = parent;
        var branchesRemainingToCancel = parent._branchesRemainingToCancel;
        if (branchesRemainingToCancel === undefined) {
          branchesRemainingToCancel = 0;
        }
        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
      }
      if ((flags & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
      }
    }
    function bindingPropagateFrom(parent, flags) {
      if ((flags & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
      }
    }
    var propagateFromFunction = bindingPropagateFrom;
    function boundValueFunction() {
      var ret = this._boundTo;
      if (ret !== undefined) {
        if (ret instanceof Promise2) {
          if (ret.isFulfilled()) {
            return ret.value();
          } else {
            return;
          }
        }
      }
      return ret;
    }
    function longStackTracesCaptureStackTrace() {
      this._trace = new CapturedTrace(this._peekContext());
    }
    function longStackTracesAttachExtraTrace(error2, ignoreSelf) {
      if (canAttachTrace(error2)) {
        var trace = this._trace;
        if (trace !== undefined) {
          if (ignoreSelf)
            trace = trace._parent;
        }
        if (trace !== undefined) {
          trace.attachExtraTrace(error2);
        } else if (!error2.__stackCleaned__) {
          var parsed = parseStackAndMessage(error2);
          util3.notEnumerableProp(error2, "stack", parsed.message + `
` + parsed.stack.join(`
`));
          util3.notEnumerableProp(error2, "__stackCleaned__", true);
        }
      }
    }
    function longStackTracesDereferenceTrace() {
      this._trace = undefined;
    }
    function checkForgottenReturns(returnValue, promiseCreated, name, promise, parent) {
      if (returnValue === undefined && promiseCreated !== null && wForgottenReturn) {
        if (parent !== undefined && parent._returnedNonUndefined())
          return;
        if ((promise._bitField & 65535) === 0)
          return;
        if (name)
          name = name + " ";
        var handlerLine = "";
        var creatorLine = "";
        if (promiseCreated._trace) {
          var traceLines = promiseCreated._trace.stack.split(`
`);
          var stack = cleanStack(traceLines);
          for (var i = stack.length - 1;i >= 0; --i) {
            var line = stack[i];
            if (!nodeFramePattern.test(line)) {
              var lineMatches = line.match(parseLinePattern);
              if (lineMatches) {
                handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
              }
              break;
            }
          }
          if (stack.length > 0) {
            var firstUserLine = stack[0];
            for (var i = 0;i < traceLines.length; ++i) {
              if (traceLines[i] === firstUserLine) {
                if (i > 0) {
                  creatorLine = `
` + traceLines[i - 1];
                }
                break;
              }
            }
          }
        }
        var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, " + "see http://goo.gl/rRqMUw" + creatorLine;
        promise._warn(msg, true, promiseCreated);
      }
    }
    function deprecated(name, replacement) {
      var message = name + " is deprecated and will be removed in a future version.";
      if (replacement)
        message += " Use " + replacement + " instead.";
      return warn(message);
    }
    function warn(message, shouldUseOwnTrace, promise) {
      if (!config.warnings)
        return;
      var warning = new Warning(message);
      var ctx;
      if (shouldUseOwnTrace) {
        promise._attachExtraTrace(warning);
      } else if (config.longStackTraces && (ctx = Promise2._peekContext())) {
        ctx.attachExtraTrace(warning);
      } else {
        var parsed = parseStackAndMessage(warning);
        warning.stack = parsed.message + `
` + parsed.stack.join(`
`);
      }
      if (!activeFireEvent("warning", warning)) {
        formatAndLogError(warning, "", true);
      }
    }
    function reconstructStack(message, stacks) {
      for (var i = 0;i < stacks.length - 1; ++i) {
        stacks[i].push("From previous event:");
        stacks[i] = stacks[i].join(`
`);
      }
      if (i < stacks.length) {
        stacks[i] = stacks[i].join(`
`);
      }
      return message + `
` + stacks.join(`
`);
    }
    function removeDuplicateOrEmptyJumps(stacks) {
      for (var i = 0;i < stacks.length; ++i) {
        if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
          stacks.splice(i, 1);
          i--;
        }
      }
    }
    function removeCommonRoots(stacks) {
      var current = stacks[0];
      for (var i = 1;i < stacks.length; ++i) {
        var prev = stacks[i];
        var currentLastIndex = current.length - 1;
        var currentLastLine = current[currentLastIndex];
        var commonRootMeetPoint = -1;
        for (var j = prev.length - 1;j >= 0; --j) {
          if (prev[j] === currentLastLine) {
            commonRootMeetPoint = j;
            break;
          }
        }
        for (var j = commonRootMeetPoint;j >= 0; --j) {
          var line = prev[j];
          if (current[currentLastIndex] === line) {
            current.pop();
            currentLastIndex--;
          } else {
            break;
          }
        }
        current = prev;
      }
    }
    function cleanStack(stack) {
      var ret = [];
      for (var i = 0;i < stack.length; ++i) {
        var line = stack[i];
        var isTraceLine = line === "    (No stack trace)" || stackFramePattern.test(line);
        var isInternalFrame = isTraceLine && shouldIgnore(line);
        if (isTraceLine && !isInternalFrame) {
          if (indentStackFrames && line.charAt(0) !== " ") {
            line = "    " + line;
          }
          ret.push(line);
        }
      }
      return ret;
    }
    function stackFramesAsArray(error2) {
      var stack = error2.stack.replace(/\s+$/g, "").split(`
`);
      for (var i = 0;i < stack.length; ++i) {
        var line = stack[i];
        if (line === "    (No stack trace)" || stackFramePattern.test(line)) {
          break;
        }
      }
      if (i > 0 && error2.name != "SyntaxError") {
        stack = stack.slice(i);
      }
      return stack;
    }
    function parseStackAndMessage(error2) {
      var stack = error2.stack;
      var message = error2.toString();
      stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error2) : ["    (No stack trace)"];
      return {
        message,
        stack: error2.name == "SyntaxError" ? stack : cleanStack(stack)
      };
    }
    function formatAndLogError(error2, title, isSoft) {
      if (typeof console !== "undefined") {
        var message;
        if (util3.isObject(error2)) {
          var stack = error2.stack;
          message = title + formatStack(stack, error2);
        } else {
          message = title + String(error2);
        }
        if (typeof printWarning === "function") {
          printWarning(message, isSoft);
        } else if (typeof console.log === "function" || typeof console.log === "object") {
          console.log(message);
        }
      }
    }
    function fireRejectionEvent(name, localHandler, reason, promise) {
      var localEventFired = false;
      try {
        if (typeof localHandler === "function") {
          localEventFired = true;
          if (name === "rejectionHandled") {
            localHandler(promise);
          } else {
            localHandler(reason, promise);
          }
        }
      } catch (e) {
        async.throwLater(e);
      }
      if (name === "unhandledRejection") {
        if (!activeFireEvent(name, reason, promise) && !localEventFired) {
          formatAndLogError(reason, "Unhandled rejection ");
        }
      } else {
        activeFireEvent(name, promise);
      }
    }
    function formatNonError(obj2) {
      var str2;
      if (typeof obj2 === "function") {
        str2 = "[function " + (obj2.name || "anonymous") + "]";
      } else {
        str2 = obj2 && typeof obj2.toString === "function" ? obj2.toString() : util3.toString(obj2);
        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
        if (ruselessToString.test(str2)) {
          try {
            var newStr = JSON.stringify(obj2);
            str2 = newStr;
          } catch (e) {}
        }
        if (str2.length === 0) {
          str2 = "(empty array)";
        }
      }
      return "(<" + snip(str2) + ">, no stack trace)";
    }
    function snip(str2) {
      var maxChars = 41;
      if (str2.length < maxChars) {
        return str2;
      }
      return str2.substr(0, maxChars - 3) + "...";
    }
    function longStackTracesIsSupported() {
      return typeof captureStackTrace === "function";
    }
    var shouldIgnore = function() {
      return false;
    };
    var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
    function parseLineInfo(line) {
      var matches = line.match(parseLineInfoRegex);
      if (matches) {
        return {
          fileName: matches[1],
          line: parseInt(matches[2], 10)
        };
      }
    }
    function setBounds(firstLineError, lastLineError) {
      if (!longStackTracesIsSupported())
        return;
      var firstStackLines = (firstLineError.stack || "").split(`
`);
      var lastStackLines = (lastLineError.stack || "").split(`
`);
      var firstIndex = -1;
      var lastIndex = -1;
      var firstFileName;
      var lastFileName;
      for (var i = 0;i < firstStackLines.length; ++i) {
        var result = parseLineInfo(firstStackLines[i]);
        if (result) {
          firstFileName = result.fileName;
          firstIndex = result.line;
          break;
        }
      }
      for (var i = 0;i < lastStackLines.length; ++i) {
        var result = parseLineInfo(lastStackLines[i]);
        if (result) {
          lastFileName = result.fileName;
          lastIndex = result.line;
          break;
        }
      }
      if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
        return;
      }
      shouldIgnore = function(line) {
        if (bluebirdFramePattern.test(line))
          return true;
        var info = parseLineInfo(line);
        if (info) {
          if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
            return true;
          }
        }
        return false;
      };
    }
    function CapturedTrace(parent) {
      this._parent = parent;
      this._promisesCreated = 0;
      var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
      captureStackTrace(this, CapturedTrace);
      if (length > 32)
        this.uncycle();
    }
    util3.inherits(CapturedTrace, Error);
    Context2.CapturedTrace = CapturedTrace;
    CapturedTrace.prototype.uncycle = function() {
      var length = this._length;
      if (length < 2)
        return;
      var nodes = [];
      var stackToIndex = {};
      for (var i = 0, node = this;node !== undefined; ++i) {
        nodes.push(node);
        node = node._parent;
      }
      length = this._length = i;
      for (var i = length - 1;i >= 0; --i) {
        var stack = nodes[i].stack;
        if (stackToIndex[stack] === undefined) {
          stackToIndex[stack] = i;
        }
      }
      for (var i = 0;i < length; ++i) {
        var currentStack = nodes[i].stack;
        var index = stackToIndex[currentStack];
        if (index !== undefined && index !== i) {
          if (index > 0) {
            nodes[index - 1]._parent = undefined;
            nodes[index - 1]._length = 1;
          }
          nodes[i]._parent = undefined;
          nodes[i]._length = 1;
          var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
          if (index < length - 1) {
            cycleEdgeNode._parent = nodes[index + 1];
            cycleEdgeNode._parent.uncycle();
            cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
          } else {
            cycleEdgeNode._parent = undefined;
            cycleEdgeNode._length = 1;
          }
          var currentChildLength = cycleEdgeNode._length + 1;
          for (var j = i - 2;j >= 0; --j) {
            nodes[j]._length = currentChildLength;
            currentChildLength++;
          }
          return;
        }
      }
    };
    CapturedTrace.prototype.attachExtraTrace = function(error2) {
      if (error2.__stackCleaned__)
        return;
      this.uncycle();
      var parsed = parseStackAndMessage(error2);
      var message = parsed.message;
      var stacks = [parsed.stack];
      var trace = this;
      while (trace !== undefined) {
        stacks.push(cleanStack(trace.stack.split(`
`)));
        trace = trace._parent;
      }
      removeCommonRoots(stacks);
      removeDuplicateOrEmptyJumps(stacks);
      util3.notEnumerableProp(error2, "stack", reconstructStack(message, stacks));
      util3.notEnumerableProp(error2, "__stackCleaned__", true);
    };
    var captureStackTrace = function stackDetection() {
      var v8stackFramePattern = /^\s*at\s*/;
      var v8stackFormatter = function(stack, error2) {
        if (typeof stack === "string")
          return stack;
        if (error2.name !== undefined && error2.message !== undefined) {
          return error2.toString();
        }
        return formatNonError(error2);
      };
      if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
        Error.stackTraceLimit += 6;
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        var captureStackTrace2 = Error.captureStackTrace;
        shouldIgnore = function(line) {
          return bluebirdFramePattern.test(line);
        };
        return function(receiver2, ignoreUntil) {
          Error.stackTraceLimit += 6;
          captureStackTrace2(receiver2, ignoreUntil);
          Error.stackTraceLimit -= 6;
        };
      }
      var err = new Error;
      if (typeof err.stack === "string" && err.stack.split(`
`)[0].indexOf("stackDetection@") >= 0) {
        stackFramePattern = /@/;
        formatStack = v8stackFormatter;
        indentStackFrames = true;
        return function captureStackTrace(o) {
          o.stack = new Error().stack;
        };
      }
      var hasStackAfterThrow;
      try {
        throw new Error;
      } catch (e) {
        hasStackAfterThrow = "stack" in e;
      }
      if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        return function captureStackTrace(o) {
          Error.stackTraceLimit += 6;
          try {
            throw new Error;
          } catch (e) {
            o.stack = e.stack;
          }
          Error.stackTraceLimit -= 6;
        };
      }
      formatStack = function(stack, error2) {
        if (typeof stack === "string")
          return stack;
        if ((typeof error2 === "object" || typeof error2 === "function") && error2.name !== undefined && error2.message !== undefined) {
          return error2.toString();
        }
        return formatNonError(error2);
      };
      return null;
    }([]);
    if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
      printWarning = function(message) {
        console.warn(message);
      };
      if (util3.isNode && process.stderr.isTTY) {
        printWarning = function(message, isSoft) {
          var color = isSoft ? "\x1B[33m" : "\x1B[31m";
          console.warn(color + message + `\x1B[0m
`);
        };
      } else if (!util3.isNode && typeof new Error().stack === "string") {
        printWarning = function(message, isSoft) {
          console.warn("%c" + message, isSoft ? "color: darkorange" : "color: red");
        };
      }
    }
    var config = {
      warnings,
      longStackTraces: false,
      cancellation: false,
      monitoring: false,
      asyncHooks: false
    };
    if (longStackTraces)
      Promise2.longStackTraces();
    return {
      asyncHooks: function() {
        return config.asyncHooks;
      },
      longStackTraces: function() {
        return config.longStackTraces;
      },
      warnings: function() {
        return config.warnings;
      },
      cancellation: function() {
        return config.cancellation;
      },
      monitoring: function() {
        return config.monitoring;
      },
      propagateFromFunction: function() {
        return propagateFromFunction;
      },
      boundValueFunction: function() {
        return boundValueFunction;
      },
      checkForgottenReturns,
      setBounds,
      warn,
      deprecated,
      CapturedTrace,
      fireDomEvent,
      fireGlobalEvent
    };
  };
});

// backend/node_modules/bluebird/js/release/catch_filter.js
var require_catch_filter = __commonJS((exports2, module2) => {
  module2.exports = function(NEXT_FILTER) {
    var util3 = require_util2();
    var getKeys = require_es5().keys;
    var tryCatch = util3.tryCatch;
    var errorObj = util3.errorObj;
    function catchFilter(instances, cb, promise) {
      return function(e) {
        var boundTo = promise._boundValue();
        predicateLoop:
          for (var i = 0;i < instances.length; ++i) {
            var item = instances[i];
            if (item === Error || item != null && item.prototype instanceof Error) {
              if (e instanceof item) {
                return tryCatch(cb).call(boundTo, e);
              }
            } else if (typeof item === "function") {
              var matchesPredicate = tryCatch(item).call(boundTo, e);
              if (matchesPredicate === errorObj) {
                return matchesPredicate;
              } else if (matchesPredicate) {
                return tryCatch(cb).call(boundTo, e);
              }
            } else if (util3.isObject(e)) {
              var keys = getKeys(item);
              for (var j = 0;j < keys.length; ++j) {
                var key = keys[j];
                if (item[key] != e[key]) {
                  continue predicateLoop;
                }
              }
              return tryCatch(cb).call(boundTo, e);
            }
          }
        return NEXT_FILTER;
      };
    }
    return catchFilter;
  };
});

// backend/node_modules/bluebird/js/release/finally.js
var require_finally = __commonJS((exports2, module2) => {
  module2.exports = function(Promise2, tryConvertToPromise, NEXT_FILTER) {
    var util3 = require_util2();
    var CancellationError = Promise2.CancellationError;
    var errorObj = util3.errorObj;
    var catchFilter = require_catch_filter()(NEXT_FILTER);
    function PassThroughHandlerContext(promise, type, handler) {
      this.promise = promise;
      this.type = type;
      this.handler = handler;
      this.called = false;
      this.cancelPromise = null;
    }
    PassThroughHandlerContext.prototype.isFinallyHandler = function() {
      return this.type === 0;
    };
    function FinallyHandlerCancelReaction(finallyHandler2) {
      this.finallyHandler = finallyHandler2;
    }
    FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
      checkCancel(this.finallyHandler);
    };
    function checkCancel(ctx, reason) {
      if (ctx.cancelPromise != null) {
        if (arguments.length > 1) {
          ctx.cancelPromise._reject(reason);
        } else {
          ctx.cancelPromise._cancel();
        }
        ctx.cancelPromise = null;
        return true;
      }
      return false;
    }
    function succeed() {
      return finallyHandler.call(this, this.promise._target()._settledValue());
    }
    function fail(reason) {
      if (checkCancel(this, reason))
        return;
      errorObj.e = reason;
      return errorObj;
    }
    function finallyHandler(reasonOrValue) {
      var promise = this.promise;
      var handler = this.handler;
      if (!this.called) {
        this.called = true;
        var ret = this.isFinallyHandler() ? handler.call(promise._boundValue()) : handler.call(promise._boundValue(), reasonOrValue);
        if (ret === NEXT_FILTER) {
          return ret;
        } else if (ret !== undefined) {
          promise._setReturnedNonUndefined();
          var maybePromise = tryConvertToPromise(ret, promise);
          if (maybePromise instanceof Promise2) {
            if (this.cancelPromise != null) {
              if (maybePromise._isCancelled()) {
                var reason = new CancellationError("late cancellation observer");
                promise._attachExtraTrace(reason);
                errorObj.e = reason;
                return errorObj;
              } else if (maybePromise.isPending()) {
                maybePromise._attachCancellationCallback(new FinallyHandlerCancelReaction(this));
              }
            }
            return maybePromise._then(succeed, fail, undefined, this, undefined);
          }
        }
      }
      if (promise.isRejected()) {
        checkCancel(this);
        errorObj.e = reasonOrValue;
        return errorObj;
      } else {
        checkCancel(this);
        return reasonOrValue;
      }
    }
    Promise2.prototype._passThrough = function(handler, type, success, fail2) {
      if (typeof handler !== "function")
        return this.then();
      return this._then(success, fail2, undefined, new PassThroughHandlerContext(this, type, handler), undefined);
    };
    Promise2.prototype.lastly = Promise2.prototype["finally"] = function(handler) {
      return this._passThrough(handler, 0, finallyHandler, finallyHandler);
    };
    Promise2.prototype.tap = function(handler) {
      return this._passThrough(handler, 1, finallyHandler);
    };
    Promise2.prototype.tapCatch = function(handlerOrPredicate) {
      var len = arguments.length;
      if (len === 1) {
        return this._passThrough(handlerOrPredicate, 1, undefined, finallyHandler);
      } else {
        var catchInstances = new Array(len - 1), j = 0, i;
        for (i = 0;i < len - 1; ++i) {
          var item = arguments[i];
          if (util3.isObject(item)) {
            catchInstances[j++] = item;
          } else {
            return Promise2.reject(new TypeError("tapCatch statement predicate: " + "expecting an object but got " + util3.classString(item)));
          }
        }
        catchInstances.length = j;
        var handler = arguments[i];
        return this._passThrough(catchFilter(catchInstances, handler, this), 1, undefined, finallyHandler);
      }
    };
    return PassThroughHandlerContext;
  };
});

// backend/node_modules/bluebird/js/release/nodeback.js
var require_nodeback = __commonJS((exports2, module2) => {
  var util3 = require_util2();
  var maybeWrapAsError = util3.maybeWrapAsError;
  var errors = require_errors5();
  var OperationalError = errors.OperationalError;
  var es5 = require_es5();
  function isUntypedError(obj2) {
    return obj2 instanceof Error && es5.getPrototypeOf(obj2) === Error.prototype;
  }
  var rErrorKey = /^(?:name|message|stack|cause)$/;
  function wrapAsOperationalError(obj2) {
    var ret;
    if (isUntypedError(obj2)) {
      ret = new OperationalError(obj2);
      ret.name = obj2.name;
      ret.message = obj2.message;
      ret.stack = obj2.stack;
      var keys = es5.keys(obj2);
      for (var i = 0;i < keys.length; ++i) {
        var key = keys[i];
        if (!rErrorKey.test(key)) {
          ret[key] = obj2[key];
        }
      }
      return ret;
    }
    util3.markAsOriginatingFromRejection(obj2);
    return obj2;
  }
  function nodebackForPromise(promise, multiArgs) {
    return function(err, value) {
      if (promise === null)
        return;
      if (err) {
        var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
        promise._attachExtraTrace(wrapped);
        promise._reject(wrapped);
      } else if (!multiArgs) {
        promise._fulfill(value);
      } else {
        var $_len = arguments.length;
        var args = new Array(Math.max($_len - 1, 0));
        for (var $_i = 1;$_i < $_len; ++$_i) {
          args[$_i - 1] = arguments[$_i];
        }
        promise._fulfill(args);
      }
      promise = null;
    };
  }
  module2.exports = nodebackForPromise;
});

// backend/node_modules/bluebird/js/release/method.js
var require_method = __commonJS((exports2, module2) => {
  module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, debug) {
    var util3 = require_util2();
    var tryCatch = util3.tryCatch;
    Promise2.method = function(fn) {
      if (typeof fn !== "function") {
        throw new Promise2.TypeError("expecting a function but got " + util3.classString(fn));
      }
      return function() {
        var ret = new Promise2(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value = tryCatch(fn).apply(this, arguments);
        var promiseCreated = ret._popContext();
        debug.checkForgottenReturns(value, promiseCreated, "Promise.method", ret);
        ret._resolveFromSyncValue(value);
        return ret;
      };
    };
    Promise2.attempt = Promise2["try"] = function(fn) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util3.classString(fn));
      }
      var ret = new Promise2(INTERNAL);
      ret._captureStackTrace();
      ret._pushContext();
      var value;
      if (arguments.length > 1) {
        debug.deprecated("calling Promise.try with more than 1 argument");
        var arg = arguments[1];
        var ctx = arguments[2];
        value = util3.isArray(arg) ? tryCatch(fn).apply(ctx, arg) : tryCatch(fn).call(ctx, arg);
      } else {
        value = tryCatch(fn)();
      }
      var promiseCreated = ret._popContext();
      debug.checkForgottenReturns(value, promiseCreated, "Promise.try", ret);
      ret._resolveFromSyncValue(value);
      return ret;
    };
    Promise2.prototype._resolveFromSyncValue = function(value) {
      if (value === util3.errorObj) {
        this._rejectCallback(value.e, false);
      } else {
        this._resolveCallback(value, true);
      }
    };
  };
});

// backend/node_modules/bluebird/js/release/bind.js
var require_bind = __commonJS((exports2, module2) => {
  module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, debug) {
    var calledBind = false;
    var rejectThis = function(_, e) {
      this._reject(e);
    };
    var targetRejected = function(e, context) {
      context.promiseRejectionQueued = true;
      context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
    };
    var bindingResolved = function(thisArg, context) {
      if ((this._bitField & 50397184) === 0) {
        this._resolveCallback(context.target);
      }
    };
    var bindingRejected = function(e, context) {
      if (!context.promiseRejectionQueued)
        this._reject(e);
    };
    Promise2.prototype.bind = function(thisArg) {
      if (!calledBind) {
        calledBind = true;
        Promise2.prototype._propagateFrom = debug.propagateFromFunction();
        Promise2.prototype._boundValue = debug.boundValueFunction();
      }
      var maybePromise = tryConvertToPromise(thisArg);
      var ret = new Promise2(INTERNAL);
      ret._propagateFrom(this, 1);
      var target = this._target();
      ret._setBoundTo(maybePromise);
      if (maybePromise instanceof Promise2) {
        var context = {
          promiseRejectionQueued: false,
          promise: ret,
          target,
          bindingPromise: maybePromise
        };
        target._then(INTERNAL, targetRejected, undefined, ret, context);
        maybePromise._then(bindingResolved, bindingRejected, undefined, ret, context);
        ret._setOnCancel(maybePromise);
      } else {
        ret._resolveCallback(target);
      }
      return ret;
    };
    Promise2.prototype._setBoundTo = function(obj2) {
      if (obj2 !== undefined) {
        this._bitField = this._bitField | 2097152;
        this._boundTo = obj2;
      } else {
        this._bitField = this._bitField & ~2097152;
      }
    };
    Promise2.prototype._isBound = function() {
      return (this._bitField & 2097152) === 2097152;
    };
    Promise2.bind = function(thisArg, value) {
      return Promise2.resolve(value).bind(thisArg);
    };
  };
});

// backend/node_modules/bluebird/js/release/cancel.js
var require_cancel = __commonJS((exports2, module2) => {
  module2.exports = function(Promise2, PromiseArray, apiRejection, debug) {
    var util3 = require_util2();
    var tryCatch = util3.tryCatch;
    var errorObj = util3.errorObj;
    var async = Promise2._async;
    Promise2.prototype["break"] = Promise2.prototype.cancel = function() {
      if (!debug.cancellation())
        return this._warn("cancellation is disabled");
      var promise = this;
      var child = promise;
      while (promise._isCancellable()) {
        if (!promise._cancelBy(child)) {
          if (child._isFollowing()) {
            child._followee().cancel();
          } else {
            child._cancelBranched();
          }
          break;
        }
        var parent = promise._cancellationParent;
        if (parent == null || !parent._isCancellable()) {
          if (promise._isFollowing()) {
            promise._followee().cancel();
          } else {
            promise._cancelBranched();
          }
          break;
        } else {
          if (promise._isFollowing())
            promise._followee().cancel();
          promise._setWillBeCancelled();
          child = promise;
          promise = parent;
        }
      }
    };
    Promise2.prototype._branchHasCancelled = function() {
      this._branchesRemainingToCancel--;
    };
    Promise2.prototype._enoughBranchesHaveCancelled = function() {
      return this._branchesRemainingToCancel === undefined || this._branchesRemainingToCancel <= 0;
    };
    Promise2.prototype._cancelBy = function(canceller) {
      if (canceller === this) {
        this._branchesRemainingToCancel = 0;
        this._invokeOnCancel();
        return true;
      } else {
        this._branchHasCancelled();
        if (this._enoughBranchesHaveCancelled()) {
          this._invokeOnCancel();
          return true;
        }
      }
      return false;
    };
    Promise2.prototype._cancelBranched = function() {
      if (this._enoughBranchesHaveCancelled()) {
        this._cancel();
      }
    };
    Promise2.prototype._cancel = function() {
      if (!this._isCancellable())
        return;
      this._setCancelled();
      async.invoke(this._cancelPromises, this, undefined);
    };
    Promise2.prototype._cancelPromises = function() {
      if (this._length() > 0)
        this._settlePromises();
    };
    Promise2.prototype._unsetOnCancel = function() {
      this._onCancelField = undefined;
    };
    Promise2.prototype._isCancellable = function() {
      return this.isPending() && !this._isCancelled();
    };
    Promise2.prototype.isCancellable = function() {
      return this.isPending() && !this.isCancelled();
    };
    Promise2.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
      if (util3.isArray(onCancelCallback)) {
        for (var i = 0;i < onCancelCallback.length; ++i) {
          this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
        }
      } else if (onCancelCallback !== undefined) {
        if (typeof onCancelCallback === "function") {
          if (!internalOnly) {
            var e = tryCatch(onCancelCallback).call(this._boundValue());
            if (e === errorObj) {
              this._attachExtraTrace(e.e);
              async.throwLater(e.e);
            }
          }
        } else {
          onCancelCallback._resultCancelled(this);
        }
      }
    };
    Promise2.prototype._invokeOnCancel = function() {
      var onCancelCallback = this._onCancel();
      this._unsetOnCancel();
      async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
    };
    Promise2.prototype._invokeInternalOnCancel = function() {
      if (this._isCancellable()) {
        this._doInvokeOnCancel(this._onCancel(), true);
        this._unsetOnCancel();
      }
    };
    Promise2.prototype._resultCancelled = function() {
      this.cancel();
    };
  };
});

// backend/node_modules/bluebird/js/release/direct_resolve.js
var require_direct_resolve = __commonJS((exports2, module2) => {
  module2.exports = function(Promise2) {
    function returner() {
      return this.value;
    }
    function thrower() {
      throw this.reason;
    }
    Promise2.prototype["return"] = Promise2.prototype.thenReturn = function(value) {
      if (value instanceof Promise2)
        value.suppressUnhandledRejections();
      return this._then(returner, undefined, undefined, { value }, undefined);
    };
    Promise2.prototype["throw"] = Promise2.prototype.thenThrow = function(reason) {
      return this._then(thrower, undefined, undefined, { reason }, undefined);
    };
    Promise2.prototype.catchThrow = function(reason) {
      if (arguments.length <= 1) {
        return this._then(undefined, thrower, undefined, { reason }, undefined);
      } else {
        var _reason = arguments[1];
        var handler = function() {
          throw _reason;
        };
        return this.caught(reason, handler);
      }
    };
    Promise2.prototype.catchReturn = function(value) {
      if (arguments.length <= 1) {
        if (value instanceof Promise2)
          value.suppressUnhandledRejections();
        return this._then(undefined, returner, undefined, { value }, undefined);
      } else {
        var _value = arguments[1];
        if (_value instanceof Promise2)
          _value.suppressUnhandledRejections();
        var handler = function() {
          return _value;
        };
        return this.caught(value, handler);
      }
    };
  };
});

// backend/node_modules/bluebird/js/release/synchronous_inspection.js
var require_synchronous_inspection = __commonJS((exports2, module2) => {
  module2.exports = function(Promise2) {
    function PromiseInspection(promise) {
      if (promise !== undefined) {
        promise = promise._target();
        this._bitField = promise._bitField;
        this._settledValueField = promise._isFateSealed() ? promise._settledValue() : undefined;
      } else {
        this._bitField = 0;
        this._settledValueField = undefined;
      }
    }
    PromiseInspection.prototype._settledValue = function() {
      return this._settledValueField;
    };
    var value = PromiseInspection.prototype.value = function() {
      if (!this.isFulfilled()) {
        throw new TypeError(`cannot get fulfillment value of a non-fulfilled promise

    See http://goo.gl/MqrFmX
`);
      }
      return this._settledValue();
    };
    var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
      if (!this.isRejected()) {
        throw new TypeError(`cannot get rejection reason of a non-rejected promise

    See http://goo.gl/MqrFmX
`);
      }
      return this._settledValue();
    };
    var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
      return (this._bitField & 33554432) !== 0;
    };
    var isRejected = PromiseInspection.prototype.isRejected = function() {
      return (this._bitField & 16777216) !== 0;
    };
    var isPending = PromiseInspection.prototype.isPending = function() {
      return (this._bitField & 50397184) === 0;
    };
    var isResolved = PromiseInspection.prototype.isResolved = function() {
      return (this._bitField & 50331648) !== 0;
    };
    PromiseInspection.prototype.isCancelled = function() {
      return (this._bitField & 8454144) !== 0;
    };
    Promise2.prototype.__isCancelled = function() {
      return (this._bitField & 65536) === 65536;
    };
    Promise2.prototype._isCancelled = function() {
      return this._target().__isCancelled();
    };
    Promise2.prototype.isCancelled = function() {
      return (this._target()._bitField & 8454144) !== 0;
    };
    Promise2.prototype.isPending = function() {
      return isPending.call(this._target());
    };
    Promise2.prototype.isRejected = function() {
      return isRejected.call(this._target());
    };
    Promise2.prototype.isFulfilled = function() {
      return isFulfilled.call(this._target());
    };
    Promise2.prototype.isResolved = function() {
      return isResolved.call(this._target());
    };
    Promise2.prototype.value = function() {
      return value.call(this._target());
    };
    Promise2.prototype.reason = function() {
      var target = this._target();
      target._unsetRejectionIsUnhandled();
      return reason.call(target);
    };
    Promise2.prototype._value = function() {
      return this._settledValue();
    };
    Promise2.prototype._reason = function() {
      this._unsetRejectionIsUnhandled();
      return this._settledValue();
    };
    Promise2.PromiseInspection = PromiseInspection;
  };
});

// backend/node_modules/bluebird/js/release/join.js
var require_join = __commonJS((exports2, module2) => {
  module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, INTERNAL, async) {
    var util3 = require_util2();
    var canEvaluate = util3.canEvaluate;
    var tryCatch = util3.tryCatch;
    var errorObj = util3.errorObj;
    var reject;
    if (true) {
      if (canEvaluate) {
        var thenCallback = function(i2) {
          return new Function("value", "holder", `                             
            'use strict';                                                    
            holder.pIndex = value;                                           
            holder.checkFulfillment(this);                                   
            `.replace(/Index/g, i2));
        };
        var promiseSetter = function(i2) {
          return new Function("promise", "holder", `                           
            'use strict';                                                    
            holder.pIndex = promise;                                         
            `.replace(/Index/g, i2));
        };
        var generateHolderClass = function(total) {
          var props = new Array(total);
          for (var i2 = 0;i2 < props.length; ++i2) {
            props[i2] = "this.p" + (i2 + 1);
          }
          var assignment = props.join(" = ") + " = null;";
          var cancellationCode = `var promise;
` + props.map(function(prop) {
            return `                                                         
                promise = ` + prop + `;                                      
                if (promise instanceof Promise) {                            
                    promise.cancel();                                        
                }                                                            
            `;
          }).join(`
`);
          var passedArguments = props.join(", ");
          var name = "Holder$" + total;
          var code = `return function(tryCatch, errorObj, Promise, async) {    
            'use strict';                                                    
            function [TheName](fn) {                                         
                [TheProperties]                                              
                this.fn = fn;                                                
                this.asyncNeeded = true;                                     
                this.now = 0;                                                
            }                                                                
                                                                             
            [TheName].prototype._callFunction = function(promise) {          
                promise._pushContext();                                      
                var ret = tryCatch(this.fn)([ThePassedArguments]);           
                promise._popContext();                                       
                if (ret === errorObj) {                                      
                    promise._rejectCallback(ret.e, false);                   
                } else {                                                     
                    promise._resolveCallback(ret);                           
                }                                                            
            };                                                               
                                                                             
            [TheName].prototype.checkFulfillment = function(promise) {       
                var now = ++this.now;                                        
                if (now === [TheTotal]) {                                    
                    if (this.asyncNeeded) {                                  
                        async.invoke(this._callFunction, this, promise);     
                    } else {                                                 
                        this._callFunction(promise);                         
                    }                                                        
                                                                             
                }                                                            
            };                                                               
                                                                             
            [TheName].prototype._resultCancelled = function() {              
                [CancellationCode]                                           
            };                                                               
                                                                             
            return [TheName];                                                
        }(tryCatch, errorObj, Promise, async);                               
        `;
          code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode);
          return new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch, errorObj, Promise2, async);
        };
        var holderClasses = [];
        var thenCallbacks = [];
        var promiseSetters = [];
        for (var i = 0;i < 8; ++i) {
          holderClasses.push(generateHolderClass(i + 1));
          thenCallbacks.push(thenCallback(i + 1));
          promiseSetters.push(promiseSetter(i + 1));
        }
        reject = function(reason) {
          this._reject(reason);
        };
      }
    }
    Promise2.join = function() {
      var last = arguments.length - 1;
      var fn;
      if (last > 0 && typeof arguments[last] === "function") {
        fn = arguments[last];
        if (true) {
          if (last <= 8 && canEvaluate) {
            var ret = new Promise2(INTERNAL);
            ret._captureStackTrace();
            var HolderClass = holderClasses[last - 1];
            var holder = new HolderClass(fn);
            var callbacks = thenCallbacks;
            for (var i2 = 0;i2 < last; ++i2) {
              var maybePromise = tryConvertToPromise(arguments[i2], ret);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                var bitField = maybePromise._bitField;
                if ((bitField & 50397184) === 0) {
                  maybePromise._then(callbacks[i2], reject, undefined, ret, holder);
                  promiseSetters[i2](maybePromise, holder);
                  holder.asyncNeeded = false;
                } else if ((bitField & 33554432) !== 0) {
                  callbacks[i2].call(ret, maybePromise._value(), holder);
                } else if ((bitField & 16777216) !== 0) {
                  ret._reject(maybePromise._reason());
                } else {
                  ret._cancel();
                }
              } else {
                callbacks[i2].call(ret, maybePromise, holder);
              }
            }
            if (!ret._isFateSealed()) {
              if (holder.asyncNeeded) {
                var context = Promise2._getContext();
                holder.fn = util3.contextBind(context, holder.fn);
              }
              ret._setAsyncGuaranteed();
              ret._setOnCancel(holder);
            }
            return ret;
          }
        }
      }
      var $_len = arguments.length;
      var args = new Array($_len);
      for (var $_i = 0;$_i < $_len; ++$_i) {
        args[$_i] = arguments[$_i];
      }
      if (fn)
        args.pop();
      var ret = new PromiseArray(args).promise();
      return fn !== undefined ? ret.spread(fn) : ret;
    };
  };
});

// backend/node_modules/bluebird/js/release/call_get.js
var require_call_get = __commonJS((exports2, module2) => {
  var cr = Object.create;
  if (cr) {
    callerCache = cr(null);
    getterCache = cr(null);
    callerCache[" size"] = getterCache[" size"] = 0;
  }
  var callerCache;
  var getterCache;
  module2.exports = function(Promise2) {
    var util3 = require_util2();
    var canEvaluate = util3.canEvaluate;
    var isIdentifier = util3.isIdentifier;
    var getMethodCaller;
    var getGetter;
    if (true) {
      var makeMethodCaller = function(methodName) {
        return new Function("ensureMethod", `                                    
        return function(obj) {                                               
            'use strict'                                                     
            var len = this.length;                                           
            ensureMethod(obj, 'methodName');                                 
            switch(len) {                                                    
                case 1: return obj.methodName(this[0]);                      
                case 2: return obj.methodName(this[0], this[1]);             
                case 3: return obj.methodName(this[0], this[1], this[2]);    
                case 0: return obj.methodName();                             
                default:                                                     
                    return obj.methodName.apply(obj, this);                  
            }                                                                
        };                                                                   
        `.replace(/methodName/g, methodName))(ensureMethod);
      };
      var makeGetter = function(propertyName) {
        return new Function("obj", `                                             
        'use strict';                                                        
        return obj.propertyName;                                             
        `.replace("propertyName", propertyName));
      };
      var getCompiled = function(name, compiler, cache) {
        var ret = cache[name];
        if (typeof ret !== "function") {
          if (!isIdentifier(name)) {
            return null;
          }
          ret = compiler(name);
          cache[name] = ret;
          cache[" size"]++;
          if (cache[" size"] > 512) {
            var keys = Object.keys(cache);
            for (var i = 0;i < 256; ++i)
              delete cache[keys[i]];
            cache[" size"] = keys.length - 256;
          }
        }
        return ret;
      };
      getMethodCaller = function(name) {
        return getCompiled(name, makeMethodCaller, callerCache);
      };
      getGetter = function(name) {
        return getCompiled(name, makeGetter, getterCache);
      };
    }
    function ensureMethod(obj2, methodName) {
      var fn;
      if (obj2 != null)
        fn = obj2[methodName];
      if (typeof fn !== "function") {
        var message = "Object " + util3.classString(obj2) + " has no method '" + util3.toString(methodName) + "'";
        throw new Promise2.TypeError(message);
      }
      return fn;
    }
    function caller(obj2) {
      var methodName = this.pop();
      var fn = ensureMethod(obj2, methodName);
      return fn.apply(obj2, this);
    }
    Promise2.prototype.call = function(methodName) {
      var $_len = arguments.length;
      var args = new Array(Math.max($_len - 1, 0));
      for (var $_i = 1;$_i < $_len; ++$_i) {
        args[$_i - 1] = arguments[$_i];
      }
      if (true) {
        if (canEvaluate) {
          var maybeCaller = getMethodCaller(methodName);
          if (maybeCaller !== null) {
            return this._then(maybeCaller, undefined, undefined, args, undefined);
          }
        }
      }
      args.push(methodName);
      return this._then(caller, undefined, undefined, args, undefined);
    };
    function namedGetter(obj2) {
      return obj2[this];
    }
    function indexedGetter(obj2) {
      var index = +this;
      if (index < 0)
        index = Math.max(0, index + obj2.length);
      return obj2[index];
    }
    Promise2.prototype.get = function(propertyName) {
      var isIndex = typeof propertyName === "number";
      var getter;
      if (!isIndex) {
        if (canEvaluate) {
          var maybeGetter = getGetter(propertyName);
          getter = maybeGetter !== null ? maybeGetter : namedGetter;
        } else {
          getter = namedGetter;
        }
      } else {
        getter = indexedGetter;
      }
      return this._then(getter, undefined, undefined, propertyName, undefined);
    };
  };
});

// backend/node_modules/bluebird/js/release/generators.js
var require_generators = __commonJS((exports2, module2) => {
  module2.exports = function(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {
    var errors = require_errors5();
    var TypeError2 = errors.TypeError;
    var util3 = require_util2();
    var errorObj = util3.errorObj;
    var tryCatch = util3.tryCatch;
    var yieldHandlers = [];
    function promiseFromYieldHandler(value, yieldHandlers2, traceParent) {
      for (var i = 0;i < yieldHandlers2.length; ++i) {
        traceParent._pushContext();
        var result = tryCatch(yieldHandlers2[i])(value);
        traceParent._popContext();
        if (result === errorObj) {
          traceParent._pushContext();
          var ret = Promise2.reject(errorObj.e);
          traceParent._popContext();
          return ret;
        }
        var maybePromise = tryConvertToPromise(result, traceParent);
        if (maybePromise instanceof Promise2)
          return maybePromise;
      }
      return null;
    }
    function PromiseSpawn(generatorFunction, receiver2, yieldHandler, stack) {
      if (debug.cancellation()) {
        var internal = new Promise2(INTERNAL);
        var _finallyPromise = this._finallyPromise = new Promise2(INTERNAL);
        this._promise = internal.lastly(function() {
          return _finallyPromise;
        });
        internal._captureStackTrace();
        internal._setOnCancel(this);
      } else {
        var promise = this._promise = new Promise2(INTERNAL);
        promise._captureStackTrace();
      }
      this._stack = stack;
      this._generatorFunction = generatorFunction;
      this._receiver = receiver2;
      this._generator = undefined;
      this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
      this._yieldedPromise = null;
      this._cancellationPhase = false;
    }
    util3.inherits(PromiseSpawn, Proxyable);
    PromiseSpawn.prototype._isResolved = function() {
      return this._promise === null;
    };
    PromiseSpawn.prototype._cleanup = function() {
      this._promise = this._generator = null;
      if (debug.cancellation() && this._finallyPromise !== null) {
        this._finallyPromise._fulfill();
        this._finallyPromise = null;
      }
    };
    PromiseSpawn.prototype._promiseCancelled = function() {
      if (this._isResolved())
        return;
      var implementsReturn = typeof this._generator["return"] !== "undefined";
      var result;
      if (!implementsReturn) {
        var reason = new Promise2.CancellationError("generator .return() sentinel");
        Promise2.coroutine.returnSentinel = reason;
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        result = tryCatch(this._generator["throw"]).call(this._generator, reason);
        this._promise._popContext();
      } else {
        this._promise._pushContext();
        result = tryCatch(this._generator["return"]).call(this._generator, undefined);
        this._promise._popContext();
      }
      this._cancellationPhase = true;
      this._yieldedPromise = null;
      this._continue(result);
    };
    PromiseSpawn.prototype._promiseFulfilled = function(value) {
      this._yieldedPromise = null;
      this._promise._pushContext();
      var result = tryCatch(this._generator.next).call(this._generator, value);
      this._promise._popContext();
      this._continue(result);
    };
    PromiseSpawn.prototype._promiseRejected = function(reason) {
      this._yieldedPromise = null;
      this._promise._attachExtraTrace(reason);
      this._promise._pushContext();
      var result = tryCatch(this._generator["throw"]).call(this._generator, reason);
      this._promise._popContext();
      this._continue(result);
    };
    PromiseSpawn.prototype._resultCancelled = function() {
      if (this._yieldedPromise instanceof Promise2) {
        var promise = this._yieldedPromise;
        this._yieldedPromise = null;
        promise.cancel();
      }
    };
    PromiseSpawn.prototype.promise = function() {
      return this._promise;
    };
    PromiseSpawn.prototype._run = function() {
      this._generator = this._generatorFunction.call(this._receiver);
      this._receiver = this._generatorFunction = undefined;
      this._promiseFulfilled(undefined);
    };
    PromiseSpawn.prototype._continue = function(result) {
      var promise = this._promise;
      if (result === errorObj) {
        this._cleanup();
        if (this._cancellationPhase) {
          return promise.cancel();
        } else {
          return promise._rejectCallback(result.e, false);
        }
      }
      var value = result.value;
      if (result.done === true) {
        this._cleanup();
        if (this._cancellationPhase) {
          return promise.cancel();
        } else {
          return promise._resolveCallback(value);
        }
      } else {
        var maybePromise = tryConvertToPromise(value, this._promise);
        if (!(maybePromise instanceof Promise2)) {
          maybePromise = promiseFromYieldHandler(maybePromise, this._yieldHandlers, this._promise);
          if (maybePromise === null) {
            this._promiseRejected(new TypeError2(`A value %s was yielded that could not be treated as a promise

    See http://goo.gl/MqrFmX

`.replace("%s", String(value)) + `From coroutine:
` + this._stack.split(`
`).slice(1, -7).join(`
`)));
            return;
          }
        }
        maybePromise = maybePromise._target();
        var bitField = maybePromise._bitField;
        if ((bitField & 50397184) === 0) {
          this._yieldedPromise = maybePromise;
          maybePromise._proxy(this, null);
        } else if ((bitField & 33554432) !== 0) {
          Promise2._async.invoke(this._promiseFulfilled, this, maybePromise._value());
        } else if ((bitField & 16777216) !== 0) {
          Promise2._async.invoke(this._promiseRejected, this, maybePromise._reason());
        } else {
          this._promiseCancelled();
        }
      }
    };
    Promise2.coroutine = function(generatorFunction, options) {
      if (typeof generatorFunction !== "function") {
        throw new TypeError2(`generatorFunction must be a function

    See http://goo.gl/MqrFmX
`);
      }
      var yieldHandler = Object(options).yieldHandler;
      var PromiseSpawn$ = PromiseSpawn;
      var stack = new Error().stack;
      return function() {
        var generator = generatorFunction.apply(this, arguments);
        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler, stack);
        var ret = spawn.promise();
        spawn._generator = generator;
        spawn._promiseFulfilled(undefined);
        return ret;
      };
    };
    Promise2.coroutine.addYieldHandler = function(fn) {
      if (typeof fn !== "function") {
        throw new TypeError2("expecting a function but got " + util3.classString(fn));
      }
      yieldHandlers.push(fn);
    };
    Promise2.spawn = function(generatorFunction) {
      debug.deprecated("Promise.spawn()", "Promise.coroutine()");
      if (typeof generatorFunction !== "function") {
        return apiRejection(`generatorFunction must be a function

    See http://goo.gl/MqrFmX
`);
      }
      var spawn = new PromiseSpawn(generatorFunction, this);
      var ret = spawn.promise();
      spawn._run(Promise2.spawn);
      return ret;
    };
  };
});

// backend/node_modules/bluebird/js/release/map.js
var require_map = __commonJS((exports2, module2) => {
  module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
    var util3 = require_util2();
    var tryCatch = util3.tryCatch;
    var errorObj = util3.errorObj;
    var async = Promise2._async;
    function MappingPromiseArray(promises, fn, limit2, _filter) {
      this.constructor$(promises);
      this._promise._captureStackTrace();
      var context = Promise2._getContext();
      this._callback = util3.contextBind(context, fn);
      this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
      this._limit = limit2;
      this._inFlight = 0;
      this._queue = [];
      async.invoke(this._asyncInit, this, undefined);
      if (util3.isArray(promises)) {
        for (var i = 0;i < promises.length; ++i) {
          var maybePromise = promises[i];
          if (maybePromise instanceof Promise2) {
            maybePromise.suppressUnhandledRejections();
          }
        }
      }
    }
    util3.inherits(MappingPromiseArray, PromiseArray);
    MappingPromiseArray.prototype._asyncInit = function() {
      this._init$(undefined, -2);
    };
    MappingPromiseArray.prototype._init = function() {};
    MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
      var values2 = this._values;
      var length = this.length();
      var preservedValues = this._preservedValues;
      var limit2 = this._limit;
      if (index < 0) {
        index = index * -1 - 1;
        values2[index] = value;
        if (limit2 >= 1) {
          this._inFlight--;
          this._drainQueue();
          if (this._isResolved())
            return true;
        }
      } else {
        if (limit2 >= 1 && this._inFlight >= limit2) {
          values2[index] = value;
          this._queue.push(index);
          return false;
        }
        if (preservedValues !== null)
          preservedValues[index] = value;
        var promise = this._promise;
        var callback = this._callback;
        var receiver2 = promise._boundValue();
        promise._pushContext();
        var ret = tryCatch(callback).call(receiver2, value, index, length);
        var promiseCreated = promise._popContext();
        debug.checkForgottenReturns(ret, promiseCreated, preservedValues !== null ? "Promise.filter" : "Promise.map", promise);
        if (ret === errorObj) {
          this._reject(ret.e);
          return true;
        }
        var maybePromise = tryConvertToPromise(ret, this._promise);
        if (maybePromise instanceof Promise2) {
          maybePromise = maybePromise._target();
          var bitField = maybePromise._bitField;
          if ((bitField & 50397184) === 0) {
            if (limit2 >= 1)
              this._inFlight++;
            values2[index] = maybePromise;
            maybePromise._proxy(this, (index + 1) * -1);
            return false;
          } else if ((bitField & 33554432) !== 0) {
            ret = maybePromise._value();
          } else if ((bitField & 16777216) !== 0) {
            this._reject(maybePromise._reason());
            return true;
          } else {
            this._cancel();
            return true;
          }
        }
        values2[index] = ret;
      }
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= length) {
        if (preservedValues !== null) {
          this._filter(values2, preservedValues);
        } else {
          this._resolve(values2);
        }
        return true;
      }
      return false;
    };
    MappingPromiseArray.prototype._drainQueue = function() {
      var queue = this._queue;
      var limit2 = this._limit;
      var values2 = this._values;
      while (queue.length > 0 && this._inFlight < limit2) {
        if (this._isResolved())
          return;
        var index = queue.pop();
        this._promiseFulfilled(values2[index], index);
      }
    };
    MappingPromiseArray.prototype._filter = function(booleans, values2) {
      var len = values2.length;
      var ret = new Array(len);
      var j = 0;
      for (var i = 0;i < len; ++i) {
        if (booleans[i])
          ret[j++] = values2[i];
      }
      ret.length = j;
      this._resolve(ret);
    };
    MappingPromiseArray.prototype.preservedValues = function() {
      return this._preservedValues;
    };
    function map(promises, fn, options, _filter) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util3.classString(fn));
      }
      var limit2 = 0;
      if (options !== undefined) {
        if (typeof options === "object" && options !== null) {
          if (typeof options.concurrency !== "number") {
            return Promise2.reject(new TypeError("'concurrency' must be a number but it is " + util3.classString(options.concurrency)));
          }
          limit2 = options.concurrency;
        } else {
          return Promise2.reject(new TypeError("options argument must be an object but it is " + util3.classString(options)));
        }
      }
      limit2 = typeof limit2 === "number" && isFinite(limit2) && limit2 >= 1 ? limit2 : 0;
      return new MappingPromiseArray(promises, fn, limit2, _filter).promise();
    }
    Promise2.prototype.map = function(fn, options) {
      return map(this, fn, options, null);
    };
    Promise2.map = function(promises, fn, options, _filter) {
      return map(promises, fn, options, _filter);
    };
  };
});

// backend/node_modules/bluebird/js/release/nodeify.js
var require_nodeify = __commonJS((exports2, module2) => {
  module2.exports = function(Promise2) {
    var util3 = require_util2();
    var async = Promise2._async;
    var tryCatch = util3.tryCatch;
    var errorObj = util3.errorObj;
    function spreadAdapter(val, nodeback) {
      var promise = this;
      if (!util3.isArray(val))
        return successAdapter.call(promise, val, nodeback);
      var ret = tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
      if (ret === errorObj) {
        async.throwLater(ret.e);
      }
    }
    function successAdapter(val, nodeback) {
      var promise = this;
      var receiver2 = promise._boundValue();
      var ret = val === undefined ? tryCatch(nodeback).call(receiver2, null) : tryCatch(nodeback).call(receiver2, null, val);
      if (ret === errorObj) {
        async.throwLater(ret.e);
      }
    }
    function errorAdapter(reason, nodeback) {
      var promise = this;
      if (!reason) {
        var newReason = new Error(reason + "");
        newReason.cause = reason;
        reason = newReason;
      }
      var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
      if (ret === errorObj) {
        async.throwLater(ret.e);
      }
    }
    Promise2.prototype.asCallback = Promise2.prototype.nodeify = function(nodeback, options) {
      if (typeof nodeback == "function") {
        var adapter2 = successAdapter;
        if (options !== undefined && Object(options).spread) {
          adapter2 = spreadAdapter;
        }
        this._then(adapter2, errorAdapter, undefined, this, nodeback);
      }
      return this;
    };
  };
});

// backend/node_modules/bluebird/js/release/promisify.js
var require_promisify = __commonJS((exports2, module2) => {
  module2.exports = function(Promise2, INTERNAL) {
    var THIS = {};
    var util3 = require_util2();
    var nodebackForPromise = require_nodeback();
    var withAppended = util3.withAppended;
    var maybeWrapAsError = util3.maybeWrapAsError;
    var canEvaluate = util3.canEvaluate;
    var TypeError2 = require_errors5().TypeError;
    var defaultSuffix = "Async";
    var defaultPromisified = { __isPromisified__: true };
    var noCopyProps = [
      "arity",
      "length",
      "name",
      "arguments",
      "caller",
      "callee",
      "prototype",
      "__isPromisified__"
    ];
    var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
    var defaultFilter = function(name) {
      return util3.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
    };
    function propsFilter(key) {
      return !noCopyPropsPattern.test(key);
    }
    function isPromisified(fn) {
      try {
        return fn.__isPromisified__ === true;
      } catch (e) {
        return false;
      }
    }
    function hasPromisified(obj2, key, suffix) {
      var val = util3.getDataPropertyOrDefault(obj2, key + suffix, defaultPromisified);
      return val ? isPromisified(val) : false;
    }
    function checkValid(ret, suffix, suffixRegexp) {
      for (var i = 0;i < ret.length; i += 2) {
        var key = ret[i];
        if (suffixRegexp.test(key)) {
          var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
          for (var j = 0;j < ret.length; j += 2) {
            if (ret[j] === keyWithoutAsyncSuffix) {
              throw new TypeError2(`Cannot promisify an API that has normal methods with '%s'-suffix

    See http://goo.gl/MqrFmX
`.replace("%s", suffix));
            }
          }
        }
      }
    }
    function promisifiableMethods(obj2, suffix, suffixRegexp, filter2) {
      var keys = util3.inheritedDataKeys(obj2);
      var ret = [];
      for (var i = 0;i < keys.length; ++i) {
        var key = keys[i];
        var value = obj2[key];
        var passesDefaultFilter = filter2 === defaultFilter ? true : defaultFilter(key, value, obj2);
        if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj2, key, suffix) && filter2(key, value, obj2, passesDefaultFilter)) {
          ret.push(key, value);
        }
      }
      checkValid(ret, suffix, suffixRegexp);
      return ret;
    }
    var escapeIdentRegex = function(str2) {
      return str2.replace(/([$])/, "\\$");
    };
    var makeNodePromisifiedEval;
    if (true) {
      var switchCaseArgumentOrder = function(likelyArgumentCount) {
        var ret = [likelyArgumentCount];
        var min = Math.max(0, likelyArgumentCount - 1 - 3);
        for (var i = likelyArgumentCount - 1;i >= min; --i) {
          ret.push(i);
        }
        for (var i = likelyArgumentCount + 1;i <= 3; ++i) {
          ret.push(i);
        }
        return ret;
      };
      var argumentSequence = function(argumentCount) {
        return util3.filledRange(argumentCount, "_arg", "");
      };
      var parameterDeclaration = function(parameterCount2) {
        return util3.filledRange(Math.max(parameterCount2, 3), "_arg", "");
      };
      var parameterCount = function(fn) {
        if (typeof fn.length === "number") {
          return Math.max(Math.min(fn.length, 1023 + 1), 0);
        }
        return 0;
      };
      makeNodePromisifiedEval = function(callback, receiver2, originalName, fn, _, multiArgs) {
        var newParameterCount = Math.max(0, parameterCount(fn) - 1);
        var argumentOrder = switchCaseArgumentOrder(newParameterCount);
        var shouldProxyThis = typeof callback === "string" || receiver2 === THIS;
        function generateCallForArgumentCount(count) {
          var args = argumentSequence(count).join(", ");
          var comma = count > 0 ? ", " : "";
          var ret;
          if (shouldProxyThis) {
            ret = `ret = callback.call(this, {{args}}, nodeback); break;
`;
          } else {
            ret = receiver2 === undefined ? `ret = callback({{args}}, nodeback); break;
` : `ret = callback.call(receiver, {{args}}, nodeback); break;
`;
          }
          return ret.replace("{{args}}", args).replace(", ", comma);
        }
        function generateArgumentSwitchCase() {
          var ret = "";
          for (var i = 0;i < argumentOrder.length; ++i) {
            ret += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
          }
          ret += `                                                             
        default:                                                             
            var args = new Array(len + 1);                                   
            var i = 0;                                                       
            for (var i = 0; i < len; ++i) {                                  
               args[i] = arguments[i];                                       
            }                                                                
            args[i] = nodeback;                                              
            [CodeForCall]                                                    
            break;                                                           
        `.replace("[CodeForCall]", shouldProxyThis ? `ret = callback.apply(this, args);
` : `ret = callback.apply(receiver, args);
`);
          return ret;
        }
        var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
        var body = `'use strict';                                                
        var ret = function (Parameters) {                                    
            'use strict';                                                    
            var len = arguments.length;                                      
            var promise = new Promise(INTERNAL);                             
            promise._captureStackTrace();                                    
            var nodeback = nodebackForPromise(promise, ` + multiArgs + `);   
            var ret;                                                         
            var callback = tryCatch([GetFunctionCode]);                      
            switch(len) {                                                    
                [CodeForSwitchCase]                                          
            }                                                                
            if (ret === errorObj) {                                          
                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
            }                                                                
            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     
            return promise;                                                  
        };                                                                   
        notEnumerableProp(ret, '__isPromisified__', true);                   
        return ret;                                                          
    `.replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode);
        body = body.replace("Parameters", parameterDeclaration(newParameterCount));
        return new Function("Promise", "fn", "receiver", "withAppended", "maybeWrapAsError", "nodebackForPromise", "tryCatch", "errorObj", "notEnumerableProp", "INTERNAL", body)(Promise2, fn, receiver2, withAppended, maybeWrapAsError, nodebackForPromise, util3.tryCatch, util3.errorObj, util3.notEnumerableProp, INTERNAL);
      };
    }
    function makeNodePromisifiedClosure(callback, receiver2, _, fn, __, multiArgs) {
      var defaultThis = function() {
        return this;
      }();
      var method = callback;
      if (typeof method === "string") {
        callback = fn;
      }
      function promisified() {
        var _receiver = receiver2;
        if (receiver2 === THIS)
          _receiver = this;
        var promise = new Promise2(INTERNAL);
        promise._captureStackTrace();
        var cb = typeof method === "string" && this !== defaultThis ? this[method] : callback;
        var fn2 = nodebackForPromise(promise, multiArgs);
        try {
          cb.apply(_receiver, withAppended(arguments, fn2));
        } catch (e) {
          promise._rejectCallback(maybeWrapAsError(e), true, true);
        }
        if (!promise._isFateSealed())
          promise._setAsyncGuaranteed();
        return promise;
      }
      util3.notEnumerableProp(promisified, "__isPromisified__", true);
      return promisified;
    }
    var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
    function promisifyAll(obj2, suffix, filter2, promisifier, multiArgs) {
      var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
      var methods = promisifiableMethods(obj2, suffix, suffixRegexp, filter2);
      for (var i = 0, len = methods.length;i < len; i += 2) {
        var key = methods[i];
        var fn = methods[i + 1];
        var promisifiedKey = key + suffix;
        if (promisifier === makeNodePromisified) {
          obj2[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
        } else {
          var promisified = promisifier(fn, function() {
            return makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
          });
          util3.notEnumerableProp(promisified, "__isPromisified__", true);
          obj2[promisifiedKey] = promisified;
        }
      }
      util3.toFastProperties(obj2);
      return obj2;
    }
    function promisify(callback, receiver2, multiArgs) {
      return makeNodePromisified(callback, receiver2, undefined, callback, null, multiArgs);
    }
    Promise2.promisify = function(fn, options) {
      if (typeof fn !== "function") {
        throw new TypeError2("expecting a function but got " + util3.classString(fn));
      }
      if (isPromisified(fn)) {
        return fn;
      }
      options = Object(options);
      var receiver2 = options.context === undefined ? THIS : options.context;
      var multiArgs = !!options.multiArgs;
      var ret = promisify(fn, receiver2, multiArgs);
      util3.copyDescriptors(fn, ret, propsFilter);
      return ret;
    };
    Promise2.promisifyAll = function(target, options) {
      if (typeof target !== "function" && typeof target !== "object") {
        throw new TypeError2(`the target of promisifyAll must be an object or a function

    See http://goo.gl/MqrFmX
`);
      }
      options = Object(options);
      var multiArgs = !!options.multiArgs;
      var suffix = options.suffix;
      if (typeof suffix !== "string")
        suffix = defaultSuffix;
      var filter2 = options.filter;
      if (typeof filter2 !== "function")
        filter2 = defaultFilter;
      var promisifier = options.promisifier;
      if (typeof promisifier !== "function")
        promisifier = makeNodePromisified;
      if (!util3.isIdentifier(suffix)) {
        throw new RangeError(`suffix must be a valid identifier

    See http://goo.gl/MqrFmX
`);
      }
      var keys = util3.inheritedDataKeys(target);
      for (var i = 0;i < keys.length; ++i) {
        var value = target[keys[i]];
        if (keys[i] !== "constructor" && util3.isClass(value)) {
          promisifyAll(value.prototype, suffix, filter2, promisifier, multiArgs);
          promisifyAll(value, suffix, filter2, promisifier, multiArgs);
        }
      }
      return promisifyAll(target, suffix, filter2, promisifier, multiArgs);
    };
  };
});

// backend/node_modules/bluebird/js/release/props.js
var require_props = __commonJS((exports2, module2) => {
  module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, apiRejection) {
    var util3 = require_util2();
    var isObject2 = util3.isObject;
    var es5 = require_es5();
    var Es6Map;
    if (typeof Map === "function")
      Es6Map = Map;
    var mapToEntries = function() {
      var index = 0;
      var size = 0;
      function extractEntry(value, key) {
        this[index] = value;
        this[index + size] = key;
        index++;
      }
      return function mapToEntries(map) {
        size = map.size;
        index = 0;
        var ret = new Array(map.size * 2);
        map.forEach(extractEntry, ret);
        return ret;
      };
    }();
    var entriesToMap = function(entries) {
      var ret = new Es6Map;
      var length = entries.length / 2 | 0;
      for (var i = 0;i < length; ++i) {
        var key = entries[length + i];
        var value = entries[i];
        ret.set(key, value);
      }
      return ret;
    };
    function PropertiesPromiseArray(obj2) {
      var isMap = false;
      var entries;
      if (Es6Map !== undefined && obj2 instanceof Es6Map) {
        entries = mapToEntries(obj2);
        isMap = true;
      } else {
        var keys = es5.keys(obj2);
        var len = keys.length;
        entries = new Array(len * 2);
        for (var i = 0;i < len; ++i) {
          var key = keys[i];
          entries[i] = obj2[key];
          entries[i + len] = key;
        }
      }
      this.constructor$(entries);
      this._isMap = isMap;
      this._init$(undefined, isMap ? -6 : -3);
    }
    util3.inherits(PropertiesPromiseArray, PromiseArray);
    PropertiesPromiseArray.prototype._init = function() {};
    PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
      this._values[index] = value;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        var val;
        if (this._isMap) {
          val = entriesToMap(this._values);
        } else {
          val = {};
          var keyOffset = this.length();
          for (var i = 0, len = this.length();i < len; ++i) {
            val[this._values[i + keyOffset]] = this._values[i];
          }
        }
        this._resolve(val);
        return true;
      }
      return false;
    };
    PropertiesPromiseArray.prototype.shouldCopyValues = function() {
      return false;
    };
    PropertiesPromiseArray.prototype.getActualLength = function(len) {
      return len >> 1;
    };
    function props(promises) {
      var ret;
      var castValue = tryConvertToPromise(promises);
      if (!isObject2(castValue)) {
        return apiRejection(`cannot await properties of a non-object

    See http://goo.gl/MqrFmX
`);
      } else if (castValue instanceof Promise2) {
        ret = castValue._then(Promise2.props, undefined, undefined, undefined, undefined);
      } else {
        ret = new PropertiesPromiseArray(castValue).promise();
      }
      if (castValue instanceof Promise2) {
        ret._propagateFrom(castValue, 2);
      }
      return ret;
    }
    Promise2.prototype.props = function() {
      return props(this);
    };
    Promise2.props = function(promises) {
      return props(promises);
    };
  };
});

// backend/node_modules/bluebird/js/release/race.js
var require_race = __commonJS((exports2, module2) => {
  module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
    var util3 = require_util2();
    var raceLater = function(promise) {
      return promise.then(function(array) {
        return race(array, promise);
      });
    };
    function race(promises, parent) {
      var maybePromise = tryConvertToPromise(promises);
      if (maybePromise instanceof Promise2) {
        return raceLater(maybePromise);
      } else {
        promises = util3.asArray(promises);
        if (promises === null)
          return apiRejection("expecting an array or an iterable object but got " + util3.classString(promises));
      }
      var ret = new Promise2(INTERNAL);
      if (parent !== undefined) {
        ret._propagateFrom(parent, 3);
      }
      var fulfill = ret._fulfill;
      var reject = ret._reject;
      for (var i = 0, len = promises.length;i < len; ++i) {
        var val = promises[i];
        if (val === undefined && !(i in promises)) {
          continue;
        }
        Promise2.cast(val)._then(fulfill, reject, undefined, ret, null);
      }
      return ret;
    }
    Promise2.race = function(promises) {
      return race(promises, undefined);
    };
    Promise2.prototype.race = function() {
      return race(this, undefined);
    };
  };
});

// backend/node_modules/bluebird/js/release/reduce.js
var require_reduce = __commonJS((exports2, module2) => {
  module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
    var util3 = require_util2();
    var tryCatch = util3.tryCatch;
    function ReductionPromiseArray(promises, fn, initialValue, _each) {
      this.constructor$(promises);
      var context = Promise2._getContext();
      this._fn = util3.contextBind(context, fn);
      if (initialValue !== undefined) {
        initialValue = Promise2.resolve(initialValue);
        initialValue._attachCancellationCallback(this);
      }
      this._initialValue = initialValue;
      this._currentCancellable = null;
      if (_each === INTERNAL) {
        this._eachValues = Array(this._length);
      } else if (_each === 0) {
        this._eachValues = null;
      } else {
        this._eachValues = undefined;
      }
      this._promise._captureStackTrace();
      this._init$(undefined, -5);
    }
    util3.inherits(ReductionPromiseArray, PromiseArray);
    ReductionPromiseArray.prototype._gotAccum = function(accum) {
      if (this._eachValues !== undefined && this._eachValues !== null && accum !== INTERNAL) {
        this._eachValues.push(accum);
      }
    };
    ReductionPromiseArray.prototype._eachComplete = function(value) {
      if (this._eachValues !== null) {
        this._eachValues.push(value);
      }
      return this._eachValues;
    };
    ReductionPromiseArray.prototype._init = function() {};
    ReductionPromiseArray.prototype._resolveEmptyArray = function() {
      this._resolve(this._eachValues !== undefined ? this._eachValues : this._initialValue);
    };
    ReductionPromiseArray.prototype.shouldCopyValues = function() {
      return false;
    };
    ReductionPromiseArray.prototype._resolve = function(value) {
      this._promise._resolveCallback(value);
      this._values = null;
    };
    ReductionPromiseArray.prototype._resultCancelled = function(sender) {
      if (sender === this._initialValue)
        return this._cancel();
      if (this._isResolved())
        return;
      this._resultCancelled$();
      if (this._currentCancellable instanceof Promise2) {
        this._currentCancellable.cancel();
      }
      if (this._initialValue instanceof Promise2) {
        this._initialValue.cancel();
      }
    };
    ReductionPromiseArray.prototype._iterate = function(values2) {
      this._values = values2;
      var value;
      var i;
      var length = values2.length;
      if (this._initialValue !== undefined) {
        value = this._initialValue;
        i = 0;
      } else {
        value = Promise2.resolve(values2[0]);
        i = 1;
      }
      this._currentCancellable = value;
      for (var j = i;j < length; ++j) {
        var maybePromise = values2[j];
        if (maybePromise instanceof Promise2) {
          maybePromise.suppressUnhandledRejections();
        }
      }
      if (!value.isRejected()) {
        for (;i < length; ++i) {
          var ctx = {
            accum: null,
            value: values2[i],
            index: i,
            length,
            array: this
          };
          value = value._then(gotAccum, undefined, undefined, ctx, undefined);
          if ((i & 127) === 0) {
            value._setNoAsyncGuarantee();
          }
        }
      }
      if (this._eachValues !== undefined) {
        value = value._then(this._eachComplete, undefined, undefined, this, undefined);
      }
      value._then(completed, completed, undefined, value, this);
    };
    Promise2.prototype.reduce = function(fn, initialValue) {
      return reduce(this, fn, initialValue, null);
    };
    Promise2.reduce = function(promises, fn, initialValue, _each) {
      return reduce(promises, fn, initialValue, _each);
    };
    function completed(valueOrReason, array) {
      if (this.isFulfilled()) {
        array._resolve(valueOrReason);
      } else {
        array._reject(valueOrReason);
      }
    }
    function reduce(promises, fn, initialValue, _each) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util3.classString(fn));
      }
      var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
      return array.promise();
    }
    function gotAccum(accum) {
      this.accum = accum;
      this.array._gotAccum(accum);
      var value = tryConvertToPromise(this.value, this.array._promise);
      if (value instanceof Promise2) {
        this.array._currentCancellable = value;
        return value._then(gotValue, undefined, undefined, this, undefined);
      } else {
        return gotValue.call(this, value);
      }
    }
    function gotValue(value) {
      var array = this.array;
      var promise = array._promise;
      var fn = tryCatch(array._fn);
      promise._pushContext();
      var ret;
      if (array._eachValues !== undefined) {
        ret = fn.call(promise._boundValue(), value, this.index, this.length);
      } else {
        ret = fn.call(promise._boundValue(), this.accum, value, this.index, this.length);
      }
      if (ret instanceof Promise2) {
        array._currentCancellable = ret;
      }
      var promiseCreated = promise._popContext();
      debug.checkForgottenReturns(ret, promiseCreated, array._eachValues !== undefined ? "Promise.each" : "Promise.reduce", promise);
      return ret;
    }
  };
});

// backend/node_modules/bluebird/js/release/settle.js
var require_settle = __commonJS((exports2, module2) => {
  module2.exports = function(Promise2, PromiseArray, debug) {
    var PromiseInspection = Promise2.PromiseInspection;
    var util3 = require_util2();
    function SettledPromiseArray(values2) {
      this.constructor$(values2);
    }
    util3.inherits(SettledPromiseArray, PromiseArray);
    SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
      this._values[index] = inspection;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
      }
      return false;
    };
    SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
      var ret = new PromiseInspection;
      ret._bitField = 33554432;
      ret._settledValueField = value;
      return this._promiseResolved(index, ret);
    };
    SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
      var ret = new PromiseInspection;
      ret._bitField = 16777216;
      ret._settledValueField = reason;
      return this._promiseResolved(index, ret);
    };
    Promise2.settle = function(promises) {
      debug.deprecated(".settle()", ".reflect()");
      return new SettledPromiseArray(promises).promise();
    };
    Promise2.allSettled = function(promises) {
      return new SettledPromiseArray(promises).promise();
    };
    Promise2.prototype.settle = function() {
      return Promise2.settle(this);
    };
  };
});

// backend/node_modules/bluebird/js/release/some.js
var require_some = __commonJS((exports2, module2) => {
  module2.exports = function(Promise2, PromiseArray, apiRejection) {
    var util3 = require_util2();
    var RangeError2 = require_errors5().RangeError;
    var AggregateError2 = require_errors5().AggregateError;
    var isArray3 = util3.isArray;
    var CANCELLATION = {};
    function SomePromiseArray(values2) {
      this.constructor$(values2);
      this._howMany = 0;
      this._unwrap = false;
      this._initialized = false;
    }
    util3.inherits(SomePromiseArray, PromiseArray);
    SomePromiseArray.prototype._init = function() {
      if (!this._initialized) {
        return;
      }
      if (this._howMany === 0) {
        this._resolve([]);
        return;
      }
      this._init$(undefined, -5);
      var isArrayResolved = isArray3(this._values);
      if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
        this._reject(this._getRangeError(this.length()));
      }
    };
    SomePromiseArray.prototype.init = function() {
      this._initialized = true;
      this._init();
    };
    SomePromiseArray.prototype.setUnwrap = function() {
      this._unwrap = true;
    };
    SomePromiseArray.prototype.howMany = function() {
      return this._howMany;
    };
    SomePromiseArray.prototype.setHowMany = function(count) {
      this._howMany = count;
    };
    SomePromiseArray.prototype._promiseFulfilled = function(value) {
      this._addFulfilled(value);
      if (this._fulfilled() === this.howMany()) {
        this._values.length = this.howMany();
        if (this.howMany() === 1 && this._unwrap) {
          this._resolve(this._values[0]);
        } else {
          this._resolve(this._values);
        }
        return true;
      }
      return false;
    };
    SomePromiseArray.prototype._promiseRejected = function(reason) {
      this._addRejected(reason);
      return this._checkOutcome();
    };
    SomePromiseArray.prototype._promiseCancelled = function() {
      if (this._values instanceof Promise2 || this._values == null) {
        return this._cancel();
      }
      this._addRejected(CANCELLATION);
      return this._checkOutcome();
    };
    SomePromiseArray.prototype._checkOutcome = function() {
      if (this.howMany() > this._canPossiblyFulfill()) {
        var e = new AggregateError2;
        for (var i = this.length();i < this._values.length; ++i) {
          if (this._values[i] !== CANCELLATION) {
            e.push(this._values[i]);
          }
        }
        if (e.length > 0) {
          this._reject(e);
        } else {
          this._cancel();
        }
        return true;
      }
      return false;
    };
    SomePromiseArray.prototype._fulfilled = function() {
      return this._totalResolved;
    };
    SomePromiseArray.prototype._rejected = function() {
      return this._values.length - this.length();
    };
    SomePromiseArray.prototype._addRejected = function(reason) {
      this._values.push(reason);
    };
    SomePromiseArray.prototype._addFulfilled = function(value) {
      this._values[this._totalResolved++] = value;
    };
    SomePromiseArray.prototype._canPossiblyFulfill = function() {
      return this.length() - this._rejected();
    };
    SomePromiseArray.prototype._getRangeError = function(count) {
      var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
      return new RangeError2(message);
    };
    SomePromiseArray.prototype._resolveEmptyArray = function() {
      this._reject(this._getRangeError(0));
    };
    function some(promises, howMany) {
      if ((howMany | 0) !== howMany || howMany < 0) {
        return apiRejection(`expecting a positive integer

    See http://goo.gl/MqrFmX
`);
      }
      var ret = new SomePromiseArray(promises);
      var promise = ret.promise();
      ret.setHowMany(howMany);
      ret.init();
      return promise;
    }
    Promise2.some = function(promises, howMany) {
      return some(promises, howMany);
    };
    Promise2.prototype.some = function(howMany) {
      return some(this, howMany);
    };
    Promise2._SomePromiseArray = SomePromiseArray;
  };
});

// backend/node_modules/bluebird/js/release/timers.js
var require_timers = __commonJS((exports2, module2) => {
  module2.exports = function(Promise2, INTERNAL, debug) {
    var util3 = require_util2();
    var TimeoutError = Promise2.TimeoutError;
    function HandleWrapper(handle) {
      this.handle = handle;
    }
    HandleWrapper.prototype._resultCancelled = function() {
      clearTimeout(this.handle);
    };
    var afterValue = function(value) {
      return delay(+this).thenReturn(value);
    };
    var delay = Promise2.delay = function(ms, value) {
      var ret;
      var handle;
      if (value !== undefined) {
        ret = Promise2.resolve(value)._then(afterValue, null, null, ms, undefined);
        if (debug.cancellation() && value instanceof Promise2) {
          ret._setOnCancel(value);
        }
      } else {
        ret = new Promise2(INTERNAL);
        handle = setTimeout(function() {
          ret._fulfill();
        }, +ms);
        if (debug.cancellation()) {
          ret._setOnCancel(new HandleWrapper(handle));
        }
        ret._captureStackTrace();
      }
      ret._setAsyncGuaranteed();
      return ret;
    };
    Promise2.prototype.delay = function(ms) {
      return delay(ms, this);
    };
    var afterTimeout = function(promise, message, parent) {
      var err;
      if (typeof message !== "string") {
        if (message instanceof Error) {
          err = message;
        } else {
          err = new TimeoutError("operation timed out");
        }
      } else {
        err = new TimeoutError(message);
      }
      util3.markAsOriginatingFromRejection(err);
      promise._attachExtraTrace(err);
      promise._reject(err);
      if (parent != null) {
        parent.cancel();
      }
    };
    function successClear(value) {
      clearTimeout(this.handle);
      return value;
    }
    function failureClear(reason) {
      clearTimeout(this.handle);
      throw reason;
    }
    Promise2.prototype.timeout = function(ms, message) {
      ms = +ms;
      var ret, parent;
      var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
        if (ret.isPending()) {
          afterTimeout(ret, message, parent);
        }
      }, ms));
      if (debug.cancellation()) {
        parent = this.then();
        ret = parent._then(successClear, failureClear, undefined, handleWrapper, undefined);
        ret._setOnCancel(handleWrapper);
      } else {
        ret = this._then(successClear, failureClear, undefined, handleWrapper, undefined);
      }
      return ret;
    };
  };
});

// backend/node_modules/bluebird/js/release/using.js
var require_using = __commonJS((exports2, module2) => {
  module2.exports = function(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug) {
    var util3 = require_util2();
    var TypeError2 = require_errors5().TypeError;
    var inherits2 = require_util2().inherits;
    var errorObj = util3.errorObj;
    var tryCatch = util3.tryCatch;
    var NULL2 = {};
    function thrower(e) {
      setTimeout(function() {
        throw e;
      }, 0);
    }
    function castPreservingDisposable(thenable) {
      var maybePromise = tryConvertToPromise(thenable);
      if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
        maybePromise._setDisposable(thenable._getDisposer());
      }
      return maybePromise;
    }
    function dispose(resources, inspection) {
      var i = 0;
      var len = resources.length;
      var ret = new Promise2(INTERNAL);
      function iterator2() {
        if (i >= len)
          return ret._fulfill();
        var maybePromise = castPreservingDisposable(resources[i++]);
        if (maybePromise instanceof Promise2 && maybePromise._isDisposable()) {
          try {
            maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise);
          } catch (e) {
            return thrower(e);
          }
          if (maybePromise instanceof Promise2) {
            return maybePromise._then(iterator2, thrower, null, null, null);
          }
        }
        iterator2();
      }
      iterator2();
      return ret;
    }
    function Disposer(data, promise, context) {
      this._data = data;
      this._promise = promise;
      this._context = context;
    }
    Disposer.prototype.data = function() {
      return this._data;
    };
    Disposer.prototype.promise = function() {
      return this._promise;
    };
    Disposer.prototype.resource = function() {
      if (this.promise().isFulfilled()) {
        return this.promise().value();
      }
      return NULL2;
    };
    Disposer.prototype.tryDispose = function(inspection) {
      var resource = this.resource();
      var context = this._context;
      if (context !== undefined)
        context._pushContext();
      var ret = resource !== NULL2 ? this.doDispose(resource, inspection) : null;
      if (context !== undefined)
        context._popContext();
      this._promise._unsetDisposable();
      this._data = null;
      return ret;
    };
    Disposer.isDisposer = function(d) {
      return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
    };
    function FunctionDisposer(fn, promise, context) {
      this.constructor$(fn, promise, context);
    }
    inherits2(FunctionDisposer, Disposer);
    FunctionDisposer.prototype.doDispose = function(resource, inspection) {
      var fn = this.data();
      return fn.call(resource, resource, inspection);
    };
    function maybeUnwrapDisposer(value) {
      if (Disposer.isDisposer(value)) {
        this.resources[this.index]._setDisposable(value);
        return value.promise();
      }
      return value;
    }
    function ResourceList(length) {
      this.length = length;
      this.promise = null;
      this[length - 1] = null;
    }
    ResourceList.prototype._resultCancelled = function() {
      var len = this.length;
      for (var i = 0;i < len; ++i) {
        var item = this[i];
        if (item instanceof Promise2) {
          item.cancel();
        }
      }
    };
    Promise2.using = function() {
      var len = arguments.length;
      if (len < 2)
        return apiRejection("you must pass at least 2 arguments to Promise.using");
      var fn = arguments[len - 1];
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util3.classString(fn));
      }
      var input;
      var spreadArgs = true;
      if (len === 2 && Array.isArray(arguments[0])) {
        input = arguments[0];
        len = input.length;
        spreadArgs = false;
      } else {
        input = arguments;
        len--;
      }
      var resources = new ResourceList(len);
      for (var i = 0;i < len; ++i) {
        var resource = input[i];
        if (Disposer.isDisposer(resource)) {
          var disposer = resource;
          resource = resource.promise();
          resource._setDisposable(disposer);
        } else {
          var maybePromise = tryConvertToPromise(resource);
          if (maybePromise instanceof Promise2) {
            resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
              resources,
              index: i
            }, undefined);
          }
        }
        resources[i] = resource;
      }
      var reflectedResources = new Array(resources.length);
      for (var i = 0;i < reflectedResources.length; ++i) {
        reflectedResources[i] = Promise2.resolve(resources[i]).reflect();
      }
      var resultPromise = Promise2.all(reflectedResources).then(function(inspections) {
        for (var i2 = 0;i2 < inspections.length; ++i2) {
          var inspection = inspections[i2];
          if (inspection.isRejected()) {
            errorObj.e = inspection.error();
            return errorObj;
          } else if (!inspection.isFulfilled()) {
            resultPromise.cancel();
            return;
          }
          inspections[i2] = inspection.value();
        }
        promise._pushContext();
        fn = tryCatch(fn);
        var ret = spreadArgs ? fn.apply(undefined, inspections) : fn(inspections);
        var promiseCreated = promise._popContext();
        debug.checkForgottenReturns(ret, promiseCreated, "Promise.using", promise);
        return ret;
      });
      var promise = resultPromise.lastly(function() {
        var inspection = new Promise2.PromiseInspection(resultPromise);
        return dispose(resources, inspection);
      });
      resources.promise = promise;
      promise._setOnCancel(resources);
      return promise;
    };
    Promise2.prototype._setDisposable = function(disposer) {
      this._bitField = this._bitField | 131072;
      this._disposer = disposer;
    };
    Promise2.prototype._isDisposable = function() {
      return (this._bitField & 131072) > 0;
    };
    Promise2.prototype._getDisposer = function() {
      return this._disposer;
    };
    Promise2.prototype._unsetDisposable = function() {
      this._bitField = this._bitField & ~131072;
      this._disposer = undefined;
    };
    Promise2.prototype.disposer = function(fn) {
      if (typeof fn === "function") {
        return new FunctionDisposer(fn, this, createContext());
      }
      throw new TypeError2;
    };
  };
});

// backend/node_modules/bluebird/js/release/any.js
var require_any = __commonJS((exports2, module2) => {
  module2.exports = function(Promise2) {
    var SomePromiseArray = Promise2._SomePromiseArray;
    function any(promises) {
      var ret = new SomePromiseArray(promises);
      var promise = ret.promise();
      ret.setHowMany(1);
      ret.setUnwrap();
      ret.init();
      return promise;
    }
    Promise2.any = function(promises) {
      return any(promises);
    };
    Promise2.prototype.any = function() {
      return any(this);
    };
  };
});

// backend/node_modules/bluebird/js/release/each.js
var require_each = __commonJS((exports2, module2) => {
  module2.exports = function(Promise2, INTERNAL) {
    var PromiseReduce = Promise2.reduce;
    var PromiseAll = Promise2.all;
    function promiseAllThis() {
      return PromiseAll(this);
    }
    function PromiseMapSeries(promises, fn) {
      return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
    }
    Promise2.prototype.each = function(fn) {
      return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, undefined, undefined, this, undefined);
    };
    Promise2.prototype.mapSeries = function(fn) {
      return PromiseReduce(this, fn, INTERNAL, INTERNAL);
    };
    Promise2.each = function(promises, fn) {
      return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, undefined, undefined, promises, undefined);
    };
    Promise2.mapSeries = PromiseMapSeries;
  };
});

// backend/node_modules/bluebird/js/release/filter.js
var require_filter = __commonJS((exports2, module2) => {
  module2.exports = function(Promise2, INTERNAL) {
    var PromiseMap = Promise2.map;
    Promise2.prototype.filter = function(fn, options) {
      return PromiseMap(this, fn, options, INTERNAL);
    };
    Promise2.filter = function(promises, fn, options) {
      return PromiseMap(promises, fn, options, INTERNAL);
    };
  };
});

// backend/node_modules/bluebird/js/release/promise.js
var require_promise = __commonJS((exports2, module2) => {
  module2.exports = function() {
    var makeSelfResolutionError = function() {
      return new TypeError2(`circular promise resolution chain

    See http://goo.gl/MqrFmX
`);
    };
    var reflectHandler = function() {
      return new Promise2.PromiseInspection(this._target());
    };
    var apiRejection = function(msg) {
      return Promise2.reject(new TypeError2(msg));
    };
    function Proxyable() {}
    var UNDEFINED_BINDING = {};
    var util3 = require_util2();
    util3.setReflectHandler(reflectHandler);
    var getDomain = function() {
      var domain = process.domain;
      if (domain === undefined) {
        return null;
      }
      return domain;
    };
    var getContextDefault = function() {
      return null;
    };
    var getContextDomain = function() {
      return {
        domain: getDomain(),
        async: null
      };
    };
    var AsyncResource = util3.isNode && util3.nodeSupportsAsyncResource ? require("async_hooks").AsyncResource : null;
    var getContextAsyncHooks = function() {
      return {
        domain: getDomain(),
        async: new AsyncResource("Bluebird::Promise")
      };
    };
    var getContext = util3.isNode ? getContextDomain : getContextDefault;
    util3.notEnumerableProp(Promise2, "_getContext", getContext);
    var enableAsyncHooks = function() {
      getContext = getContextAsyncHooks;
      util3.notEnumerableProp(Promise2, "_getContext", getContextAsyncHooks);
    };
    var disableAsyncHooks = function() {
      getContext = getContextDomain;
      util3.notEnumerableProp(Promise2, "_getContext", getContextDomain);
    };
    var es5 = require_es5();
    var Async = require_async2();
    var async = new Async;
    es5.defineProperty(Promise2, "_async", { value: async });
    var errors = require_errors5();
    var TypeError2 = Promise2.TypeError = errors.TypeError;
    Promise2.RangeError = errors.RangeError;
    var CancellationError = Promise2.CancellationError = errors.CancellationError;
    Promise2.TimeoutError = errors.TimeoutError;
    Promise2.OperationalError = errors.OperationalError;
    Promise2.RejectionError = errors.OperationalError;
    Promise2.AggregateError = errors.AggregateError;
    var INTERNAL = function() {};
    var APPLY = {};
    var NEXT_FILTER = {};
    var tryConvertToPromise = require_thenables()(Promise2, INTERNAL);
    var PromiseArray = require_promise_array()(Promise2, INTERNAL, tryConvertToPromise, apiRejection, Proxyable);
    var Context2 = require_context()(Promise2);
    var createContext = Context2.create;
    var debug = require_debuggability()(Promise2, Context2, enableAsyncHooks, disableAsyncHooks);
    var CapturedTrace = debug.CapturedTrace;
    var PassThroughHandlerContext = require_finally()(Promise2, tryConvertToPromise, NEXT_FILTER);
    var catchFilter = require_catch_filter()(NEXT_FILTER);
    var nodebackForPromise = require_nodeback();
    var errorObj = util3.errorObj;
    var tryCatch = util3.tryCatch;
    function check(self2, executor) {
      if (self2 == null || self2.constructor !== Promise2) {
        throw new TypeError2(`the promise constructor cannot be invoked directly

    See http://goo.gl/MqrFmX
`);
      }
      if (typeof executor !== "function") {
        throw new TypeError2("expecting a function but got " + util3.classString(executor));
      }
    }
    function Promise2(executor) {
      if (executor !== INTERNAL) {
        check(this, executor);
      }
      this._bitField = 0;
      this._fulfillmentHandler0 = undefined;
      this._rejectionHandler0 = undefined;
      this._promise0 = undefined;
      this._receiver0 = undefined;
      this._resolveFromExecutor(executor);
      this._promiseCreated();
      this._fireEvent("promiseCreated", this);
    }
    Promise2.prototype.toString = function() {
      return "[object Promise]";
    };
    Promise2.prototype.caught = Promise2.prototype["catch"] = function(fn) {
      var len = arguments.length;
      if (len > 1) {
        var catchInstances = new Array(len - 1), j = 0, i;
        for (i = 0;i < len - 1; ++i) {
          var item = arguments[i];
          if (util3.isObject(item)) {
            catchInstances[j++] = item;
          } else {
            return apiRejection("Catch statement predicate: " + "expecting an object but got " + util3.classString(item));
          }
        }
        catchInstances.length = j;
        fn = arguments[i];
        if (typeof fn !== "function") {
          throw new TypeError2("The last argument to .catch() " + "must be a function, got " + util3.toString(fn));
        }
        return this.then(undefined, catchFilter(catchInstances, fn, this));
      }
      return this.then(undefined, fn);
    };
    Promise2.prototype.reflect = function() {
      return this._then(reflectHandler, reflectHandler, undefined, this, undefined);
    };
    Promise2.prototype.then = function(didFulfill, didReject) {
      if (debug.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
        var msg = ".then() only accepts functions but was passed: " + util3.classString(didFulfill);
        if (arguments.length > 1) {
          msg += ", " + util3.classString(didReject);
        }
        this._warn(msg);
      }
      return this._then(didFulfill, didReject, undefined, undefined, undefined);
    };
    Promise2.prototype.done = function(didFulfill, didReject) {
      var promise = this._then(didFulfill, didReject, undefined, undefined, undefined);
      promise._setIsFinal();
    };
    Promise2.prototype.spread = function(fn) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util3.classString(fn));
      }
      return this.all()._then(fn, undefined, undefined, APPLY, undefined);
    };
    Promise2.prototype.toJSON = function() {
      var ret = {
        isFulfilled: false,
        isRejected: false,
        fulfillmentValue: undefined,
        rejectionReason: undefined
      };
      if (this.isFulfilled()) {
        ret.fulfillmentValue = this.value();
        ret.isFulfilled = true;
      } else if (this.isRejected()) {
        ret.rejectionReason = this.reason();
        ret.isRejected = true;
      }
      return ret;
    };
    Promise2.prototype.all = function() {
      if (arguments.length > 0) {
        this._warn(".all() was passed arguments but it does not take any");
      }
      return new PromiseArray(this).promise();
    };
    Promise2.prototype.error = function(fn) {
      return this.caught(util3.originatesFromRejection, fn);
    };
    Promise2.getNewLibraryCopy = module2.exports;
    Promise2.is = function(val) {
      return val instanceof Promise2;
    };
    Promise2.fromNode = Promise2.fromCallback = function(fn) {
      var ret = new Promise2(INTERNAL);
      ret._captureStackTrace();
      var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
      var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
      if (result === errorObj) {
        ret._rejectCallback(result.e, true);
      }
      if (!ret._isFateSealed())
        ret._setAsyncGuaranteed();
      return ret;
    };
    Promise2.all = function(promises) {
      return new PromiseArray(promises).promise();
    };
    Promise2.cast = function(obj2) {
      var ret = tryConvertToPromise(obj2);
      if (!(ret instanceof Promise2)) {
        ret = new Promise2(INTERNAL);
        ret._captureStackTrace();
        ret._setFulfilled();
        ret._rejectionHandler0 = obj2;
      }
      return ret;
    };
    Promise2.resolve = Promise2.fulfilled = Promise2.cast;
    Promise2.reject = Promise2.rejected = function(reason) {
      var ret = new Promise2(INTERNAL);
      ret._captureStackTrace();
      ret._rejectCallback(reason, true);
      return ret;
    };
    Promise2.setScheduler = function(fn) {
      if (typeof fn !== "function") {
        throw new TypeError2("expecting a function but got " + util3.classString(fn));
      }
      return async.setScheduler(fn);
    };
    Promise2.prototype._then = function(didFulfill, didReject, _, receiver2, internalData) {
      var haveInternalData = internalData !== undefined;
      var promise = haveInternalData ? internalData : new Promise2(INTERNAL);
      var target = this._target();
      var bitField = target._bitField;
      if (!haveInternalData) {
        promise._propagateFrom(this, 3);
        promise._captureStackTrace();
        if (receiver2 === undefined && (this._bitField & 2097152) !== 0) {
          if (!((bitField & 50397184) === 0)) {
            receiver2 = this._boundValue();
          } else {
            receiver2 = target === this ? undefined : this._boundTo;
          }
        }
        this._fireEvent("promiseChained", this, promise);
      }
      var context = getContext();
      if (!((bitField & 50397184) === 0)) {
        var handler, value, settler = target._settlePromiseCtx;
        if ((bitField & 33554432) !== 0) {
          value = target._rejectionHandler0;
          handler = didFulfill;
        } else if ((bitField & 16777216) !== 0) {
          value = target._fulfillmentHandler0;
          handler = didReject;
          target._unsetRejectionIsUnhandled();
        } else {
          settler = target._settlePromiseLateCancellationObserver;
          value = new CancellationError("late cancellation observer");
          target._attachExtraTrace(value);
          handler = didReject;
        }
        async.invoke(settler, target, {
          handler: util3.contextBind(context, handler),
          promise,
          receiver: receiver2,
          value
        });
      } else {
        target._addCallbacks(didFulfill, didReject, promise, receiver2, context);
      }
      return promise;
    };
    Promise2.prototype._length = function() {
      return this._bitField & 65535;
    };
    Promise2.prototype._isFateSealed = function() {
      return (this._bitField & 117506048) !== 0;
    };
    Promise2.prototype._isFollowing = function() {
      return (this._bitField & 67108864) === 67108864;
    };
    Promise2.prototype._setLength = function(len) {
      this._bitField = this._bitField & -65536 | len & 65535;
    };
    Promise2.prototype._setFulfilled = function() {
      this._bitField = this._bitField | 33554432;
      this._fireEvent("promiseFulfilled", this);
    };
    Promise2.prototype._setRejected = function() {
      this._bitField = this._bitField | 16777216;
      this._fireEvent("promiseRejected", this);
    };
    Promise2.prototype._setFollowing = function() {
      this._bitField = this._bitField | 67108864;
      this._fireEvent("promiseResolved", this);
    };
    Promise2.prototype._setIsFinal = function() {
      this._bitField = this._bitField | 4194304;
    };
    Promise2.prototype._isFinal = function() {
      return (this._bitField & 4194304) > 0;
    };
    Promise2.prototype._unsetCancelled = function() {
      this._bitField = this._bitField & ~65536;
    };
    Promise2.prototype._setCancelled = function() {
      this._bitField = this._bitField | 65536;
      this._fireEvent("promiseCancelled", this);
    };
    Promise2.prototype._setWillBeCancelled = function() {
      this._bitField = this._bitField | 8388608;
    };
    Promise2.prototype._setAsyncGuaranteed = function() {
      if (async.hasCustomScheduler())
        return;
      var bitField = this._bitField;
      this._bitField = bitField | (bitField & 536870912) >> 2 ^ 134217728;
    };
    Promise2.prototype._setNoAsyncGuarantee = function() {
      this._bitField = (this._bitField | 536870912) & ~134217728;
    };
    Promise2.prototype._receiverAt = function(index) {
      var ret = index === 0 ? this._receiver0 : this[index * 4 - 4 + 3];
      if (ret === UNDEFINED_BINDING) {
        return;
      } else if (ret === undefined && this._isBound()) {
        return this._boundValue();
      }
      return ret;
    };
    Promise2.prototype._promiseAt = function(index) {
      return this[index * 4 - 4 + 2];
    };
    Promise2.prototype._fulfillmentHandlerAt = function(index) {
      return this[index * 4 - 4 + 0];
    };
    Promise2.prototype._rejectionHandlerAt = function(index) {
      return this[index * 4 - 4 + 1];
    };
    Promise2.prototype._boundValue = function() {};
    Promise2.prototype._migrateCallback0 = function(follower) {
      var bitField = follower._bitField;
      var fulfill = follower._fulfillmentHandler0;
      var reject = follower._rejectionHandler0;
      var promise = follower._promise0;
      var receiver2 = follower._receiverAt(0);
      if (receiver2 === undefined)
        receiver2 = UNDEFINED_BINDING;
      this._addCallbacks(fulfill, reject, promise, receiver2, null);
    };
    Promise2.prototype._migrateCallbackAt = function(follower, index) {
      var fulfill = follower._fulfillmentHandlerAt(index);
      var reject = follower._rejectionHandlerAt(index);
      var promise = follower._promiseAt(index);
      var receiver2 = follower._receiverAt(index);
      if (receiver2 === undefined)
        receiver2 = UNDEFINED_BINDING;
      this._addCallbacks(fulfill, reject, promise, receiver2, null);
    };
    Promise2.prototype._addCallbacks = function(fulfill, reject, promise, receiver2, context) {
      var index = this._length();
      if (index >= 65535 - 4) {
        index = 0;
        this._setLength(0);
      }
      if (index === 0) {
        this._promise0 = promise;
        this._receiver0 = receiver2;
        if (typeof fulfill === "function") {
          this._fulfillmentHandler0 = util3.contextBind(context, fulfill);
        }
        if (typeof reject === "function") {
          this._rejectionHandler0 = util3.contextBind(context, reject);
        }
      } else {
        var base = index * 4 - 4;
        this[base + 2] = promise;
        this[base + 3] = receiver2;
        if (typeof fulfill === "function") {
          this[base + 0] = util3.contextBind(context, fulfill);
        }
        if (typeof reject === "function") {
          this[base + 1] = util3.contextBind(context, reject);
        }
      }
      this._setLength(index + 1);
      return index;
    };
    Promise2.prototype._proxy = function(proxyable, arg) {
      this._addCallbacks(undefined, undefined, arg, proxyable, null);
    };
    Promise2.prototype._resolveCallback = function(value, shouldBind) {
      if ((this._bitField & 117506048) !== 0)
        return;
      if (value === this)
        return this._rejectCallback(makeSelfResolutionError(), false);
      var maybePromise = tryConvertToPromise(value, this);
      if (!(maybePromise instanceof Promise2))
        return this._fulfill(value);
      if (shouldBind)
        this._propagateFrom(maybePromise, 2);
      var promise = maybePromise._target();
      if (promise === this) {
        this._reject(makeSelfResolutionError());
        return;
      }
      var bitField = promise._bitField;
      if ((bitField & 50397184) === 0) {
        var len = this._length();
        if (len > 0)
          promise._migrateCallback0(this);
        for (var i = 1;i < len; ++i) {
          promise._migrateCallbackAt(this, i);
        }
        this._setFollowing();
        this._setLength(0);
        this._setFollowee(maybePromise);
      } else if ((bitField & 33554432) !== 0) {
        this._fulfill(promise._value());
      } else if ((bitField & 16777216) !== 0) {
        this._reject(promise._reason());
      } else {
        var reason = new CancellationError("late cancellation observer");
        promise._attachExtraTrace(reason);
        this._reject(reason);
      }
    };
    Promise2.prototype._rejectCallback = function(reason, synchronous, ignoreNonErrorWarnings) {
      var trace = util3.ensureErrorObject(reason);
      var hasStack = trace === reason;
      if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
        var message = "a promise was rejected with a non-error: " + util3.classString(reason);
        this._warn(message, true);
      }
      this._attachExtraTrace(trace, synchronous ? hasStack : false);
      this._reject(reason);
    };
    Promise2.prototype._resolveFromExecutor = function(executor) {
      if (executor === INTERNAL)
        return;
      var promise = this;
      this._captureStackTrace();
      this._pushContext();
      var synchronous = true;
      var r = this._execute(executor, function(value) {
        promise._resolveCallback(value);
      }, function(reason) {
        promise._rejectCallback(reason, synchronous);
      });
      synchronous = false;
      this._popContext();
      if (r !== undefined) {
        promise._rejectCallback(r, true);
      }
    };
    Promise2.prototype._settlePromiseFromHandler = function(handler, receiver2, value, promise) {
      var bitField = promise._bitField;
      if ((bitField & 65536) !== 0)
        return;
      promise._pushContext();
      var x;
      if (receiver2 === APPLY) {
        if (!value || typeof value.length !== "number") {
          x = errorObj;
          x.e = new TypeError2("cannot .spread() a non-array: " + util3.classString(value));
        } else {
          x = tryCatch(handler).apply(this._boundValue(), value);
        }
      } else {
        x = tryCatch(handler).call(receiver2, value);
      }
      var promiseCreated = promise._popContext();
      bitField = promise._bitField;
      if ((bitField & 65536) !== 0)
        return;
      if (x === NEXT_FILTER) {
        promise._reject(value);
      } else if (x === errorObj) {
        promise._rejectCallback(x.e, false);
      } else {
        debug.checkForgottenReturns(x, promiseCreated, "", promise, this);
        promise._resolveCallback(x);
      }
    };
    Promise2.prototype._target = function() {
      var ret = this;
      while (ret._isFollowing())
        ret = ret._followee();
      return ret;
    };
    Promise2.prototype._followee = function() {
      return this._rejectionHandler0;
    };
    Promise2.prototype._setFollowee = function(promise) {
      this._rejectionHandler0 = promise;
    };
    Promise2.prototype._settlePromise = function(promise, handler, receiver2, value) {
      var isPromise = promise instanceof Promise2;
      var bitField = this._bitField;
      var asyncGuaranteed = (bitField & 134217728) !== 0;
      if ((bitField & 65536) !== 0) {
        if (isPromise)
          promise._invokeInternalOnCancel();
        if (receiver2 instanceof PassThroughHandlerContext && receiver2.isFinallyHandler()) {
          receiver2.cancelPromise = promise;
          if (tryCatch(handler).call(receiver2, value) === errorObj) {
            promise._reject(errorObj.e);
          }
        } else if (handler === reflectHandler) {
          promise._fulfill(reflectHandler.call(receiver2));
        } else if (receiver2 instanceof Proxyable) {
          receiver2._promiseCancelled(promise);
        } else if (isPromise || promise instanceof PromiseArray) {
          promise._cancel();
        } else {
          receiver2.cancel();
        }
      } else if (typeof handler === "function") {
        if (!isPromise) {
          handler.call(receiver2, value, promise);
        } else {
          if (asyncGuaranteed)
            promise._setAsyncGuaranteed();
          this._settlePromiseFromHandler(handler, receiver2, value, promise);
        }
      } else if (receiver2 instanceof Proxyable) {
        if (!receiver2._isResolved()) {
          if ((bitField & 33554432) !== 0) {
            receiver2._promiseFulfilled(value, promise);
          } else {
            receiver2._promiseRejected(value, promise);
          }
        }
      } else if (isPromise) {
        if (asyncGuaranteed)
          promise._setAsyncGuaranteed();
        if ((bitField & 33554432) !== 0) {
          promise._fulfill(value);
        } else {
          promise._reject(value);
        }
      }
    };
    Promise2.prototype._settlePromiseLateCancellationObserver = function(ctx) {
      var handler = ctx.handler;
      var promise = ctx.promise;
      var receiver2 = ctx.receiver;
      var value = ctx.value;
      if (typeof handler === "function") {
        if (!(promise instanceof Promise2)) {
          handler.call(receiver2, value, promise);
        } else {
          this._settlePromiseFromHandler(handler, receiver2, value, promise);
        }
      } else if (promise instanceof Promise2) {
        promise._reject(value);
      }
    };
    Promise2.prototype._settlePromiseCtx = function(ctx) {
      this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
    };
    Promise2.prototype._settlePromise0 = function(handler, value, bitField) {
      var promise = this._promise0;
      var receiver2 = this._receiverAt(0);
      this._promise0 = undefined;
      this._receiver0 = undefined;
      this._settlePromise(promise, handler, receiver2, value);
    };
    Promise2.prototype._clearCallbackDataAtIndex = function(index) {
      var base = index * 4 - 4;
      this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = undefined;
    };
    Promise2.prototype._fulfill = function(value) {
      var bitField = this._bitField;
      if ((bitField & 117506048) >>> 16)
        return;
      if (value === this) {
        var err = makeSelfResolutionError();
        this._attachExtraTrace(err);
        return this._reject(err);
      }
      this._setFulfilled();
      this._rejectionHandler0 = value;
      if ((bitField & 65535) > 0) {
        if ((bitField & 134217728) !== 0) {
          this._settlePromises();
        } else {
          async.settlePromises(this);
        }
        this._dereferenceTrace();
      }
    };
    Promise2.prototype._reject = function(reason) {
      var bitField = this._bitField;
      if ((bitField & 117506048) >>> 16)
        return;
      this._setRejected();
      this._fulfillmentHandler0 = reason;
      if (this._isFinal()) {
        return async.fatalError(reason, util3.isNode);
      }
      if ((bitField & 65535) > 0) {
        async.settlePromises(this);
      } else {
        this._ensurePossibleRejectionHandled();
      }
    };
    Promise2.prototype._fulfillPromises = function(len, value) {
      for (var i = 1;i < len; i++) {
        var handler = this._fulfillmentHandlerAt(i);
        var promise = this._promiseAt(i);
        var receiver2 = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise, handler, receiver2, value);
      }
    };
    Promise2.prototype._rejectPromises = function(len, reason) {
      for (var i = 1;i < len; i++) {
        var handler = this._rejectionHandlerAt(i);
        var promise = this._promiseAt(i);
        var receiver2 = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise, handler, receiver2, reason);
      }
    };
    Promise2.prototype._settlePromises = function() {
      var bitField = this._bitField;
      var len = bitField & 65535;
      if (len > 0) {
        if ((bitField & 16842752) !== 0) {
          var reason = this._fulfillmentHandler0;
          this._settlePromise0(this._rejectionHandler0, reason, bitField);
          this._rejectPromises(len, reason);
        } else {
          var value = this._rejectionHandler0;
          this._settlePromise0(this._fulfillmentHandler0, value, bitField);
          this._fulfillPromises(len, value);
        }
        this._setLength(0);
      }
      this._clearCancellationData();
    };
    Promise2.prototype._settledValue = function() {
      var bitField = this._bitField;
      if ((bitField & 33554432) !== 0) {
        return this._rejectionHandler0;
      } else if ((bitField & 16777216) !== 0) {
        return this._fulfillmentHandler0;
      }
    };
    if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
      es5.defineProperty(Promise2.prototype, Symbol.toStringTag, {
        get: function() {
          return "Object";
        }
      });
    }
    function deferResolve(v) {
      this.promise._resolveCallback(v);
    }
    function deferReject(v) {
      this.promise._rejectCallback(v, false);
    }
    Promise2.defer = Promise2.pending = function() {
      debug.deprecated("Promise.defer", "new Promise");
      var promise = new Promise2(INTERNAL);
      return {
        promise,
        resolve: deferResolve,
        reject: deferReject
      };
    };
    util3.notEnumerableProp(Promise2, "_makeSelfResolutionError", makeSelfResolutionError);
    require_method()(Promise2, INTERNAL, tryConvertToPromise, apiRejection, debug);
    require_bind()(Promise2, INTERNAL, tryConvertToPromise, debug);
    require_cancel()(Promise2, PromiseArray, apiRejection, debug);
    require_direct_resolve()(Promise2);
    require_synchronous_inspection()(Promise2);
    require_join()(Promise2, PromiseArray, tryConvertToPromise, INTERNAL, async);
    Promise2.Promise = Promise2;
    Promise2.version = "3.7.2";
    require_call_get()(Promise2);
    require_generators()(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
    require_map()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
    require_nodeify()(Promise2);
    require_promisify()(Promise2, INTERNAL);
    require_props()(Promise2, PromiseArray, tryConvertToPromise, apiRejection);
    require_race()(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
    require_reduce()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
    require_settle()(Promise2, PromiseArray, debug);
    require_some()(Promise2, PromiseArray, apiRejection);
    require_timers()(Promise2, INTERNAL, debug);
    require_using()(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
    require_any()(Promise2);
    require_each()(Promise2, INTERNAL);
    require_filter()(Promise2, INTERNAL);
    util3.toFastProperties(Promise2);
    util3.toFastProperties(Promise2.prototype);
    function fillTypes(value) {
      var p = new Promise2(INTERNAL);
      p._fulfillmentHandler0 = value;
      p._rejectionHandler0 = value;
      p._promise0 = value;
      p._receiver0 = value;
    }
    fillTypes({ a: 1 });
    fillTypes({ b: 2 });
    fillTypes({ c: 3 });
    fillTypes(1);
    fillTypes(function() {});
    fillTypes(undefined);
    fillTypes(false);
    fillTypes(new Promise2(INTERNAL));
    debug.setBounds(Async.firstLineError, util3.lastLineError);
    return Promise2;
  };
});

// backend/node_modules/bluebird/js/release/bluebird.js
var require_bluebird = __commonJS((exports2, module2) => {
  var old;
  if (typeof Promise !== "undefined")
    old = Promise;
  function noConflict() {
    try {
      if (Promise === bluebird)
        Promise = old;
    } catch (e) {}
    return bluebird;
  }
  var bluebird = require_promise()();
  bluebird.noConflict = noConflict;
  module2.exports = bluebird;
});

// backend/node_modules/request-promise-core/lib/errors.js
var require_errors6 = __commonJS((exports2, module2) => {
  function RequestError(cause, options, response) {
    this.name = "RequestError";
    this.message = String(cause);
    this.cause = cause;
    this.error = cause;
    this.options = options;
    this.response = response;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this);
    }
  }
  RequestError.prototype = Object.create(Error.prototype);
  RequestError.prototype.constructor = RequestError;
  function StatusCodeError(statusCode, body, options, response) {
    this.name = "StatusCodeError";
    this.statusCode = statusCode;
    this.message = statusCode + " - " + (JSON && JSON.stringify ? JSON.stringify(body) : body);
    this.error = body;
    this.options = options;
    this.response = response;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this);
    }
  }
  StatusCodeError.prototype = Object.create(Error.prototype);
  StatusCodeError.prototype.constructor = StatusCodeError;
  function TransformError(cause, options, response) {
    this.name = "TransformError";
    this.message = String(cause);
    this.cause = cause;
    this.error = cause;
    this.options = options;
    this.response = response;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this);
    }
  }
  TransformError.prototype = Object.create(Error.prototype);
  TransformError.prototype.constructor = TransformError;
  module2.exports = {
    RequestError,
    StatusCodeError,
    TransformError
  };
});

// backend/node_modules/lodash/_freeGlobal.js
var require__freeGlobal = __commonJS((exports2, module2) => {
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  module2.exports = freeGlobal;
});

// backend/node_modules/lodash/_root.js
var require__root = __commonJS((exports2, module2) => {
  var freeGlobal = require__freeGlobal();
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  module2.exports = root;
});

// backend/node_modules/lodash/_Symbol.js
var require__Symbol = __commonJS((exports2, module2) => {
  var root = require__root();
  var Symbol2 = root.Symbol;
  module2.exports = Symbol2;
});

// backend/node_modules/lodash/_getRawTag.js
var require__getRawTag = __commonJS((exports2, module2) => {
  var Symbol2 = require__Symbol();
  var objectProto = Object.prototype;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined;
  function getRawTag(value) {
    var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  module2.exports = getRawTag;
});

// backend/node_modules/lodash/_objectToString.js
var require__objectToString = __commonJS((exports2, module2) => {
  var objectProto = Object.prototype;
  var nativeObjectToString = objectProto.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  module2.exports = objectToString;
});

// backend/node_modules/lodash/_baseGetTag.js
var require__baseGetTag = __commonJS((exports2, module2) => {
  var Symbol2 = require__Symbol();
  var getRawTag = require__getRawTag();
  var objectToString = require__objectToString();
  var nullTag = "[object Null]";
  var undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined;
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  module2.exports = baseGetTag;
});

// backend/node_modules/lodash/isObject.js
var require_isObject2 = __commonJS((exports2, module2) => {
  function isObject2(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  module2.exports = isObject2;
});

// backend/node_modules/lodash/isFunction.js
var require_isFunction = __commonJS((exports2, module2) => {
  var baseGetTag = require__baseGetTag();
  var isObject2 = require_isObject2();
  var asyncTag = "[object AsyncFunction]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var proxyTag = "[object Proxy]";
  function isFunction3(value) {
    if (!isObject2(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  module2.exports = isFunction3;
});

// backend/node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS((exports2, module2) => {
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  module2.exports = isObjectLike;
});

// backend/node_modules/lodash/isArray.js
var require_isArray = __commonJS((exports2, module2) => {
  var isArray3 = Array.isArray;
  module2.exports = isArray3;
});

// backend/node_modules/lodash/isString.js
var require_isString = __commonJS((exports2, module2) => {
  var baseGetTag = require__baseGetTag();
  var isArray3 = require_isArray();
  var isObjectLike = require_isObjectLike();
  var stringTag = "[object String]";
  function isString2(value) {
    return typeof value == "string" || !isArray3(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
  }
  module2.exports = isString2;
});

// backend/node_modules/lodash/isUndefined.js
var require_isUndefined = __commonJS((exports2, module2) => {
  function isUndefined2(value) {
    return value === undefined;
  }
  module2.exports = isUndefined2;
});

// backend/node_modules/request-promise-core/lib/plumbing.js
var require_plumbing = __commonJS((exports2, module2) => {
  var errors = require_errors6();
  var isFunction3 = require_isFunction();
  var isObjectLike = require_isObjectLike();
  var isString2 = require_isString();
  var isUndefined2 = require_isUndefined();
  module2.exports = function(options) {
    var errorText = "Please verify options";
    if (!isObjectLike(options)) {
      throw new TypeError(errorText);
    }
    if (!isFunction3(options.PromiseImpl)) {
      throw new TypeError(errorText + ".PromiseImpl");
    }
    if (!isUndefined2(options.constructorMixin) && !isFunction3(options.constructorMixin)) {
      throw new TypeError(errorText + ".PromiseImpl");
    }
    var PromiseImpl = options.PromiseImpl;
    var constructorMixin = options.constructorMixin;
    var plumbing = {};
    plumbing.init = function(requestOptions) {
      var self2 = this;
      self2._rp_promise = new PromiseImpl(function(resolve, reject) {
        self2._rp_resolve = resolve;
        self2._rp_reject = reject;
        if (constructorMixin) {
          constructorMixin.apply(self2, arguments);
        }
      });
      self2._rp_callbackOrig = requestOptions.callback;
      requestOptions.callback = self2.callback = function RP$callback(err, response, body) {
        plumbing.callback.call(self2, err, response, body);
      };
      if (isString2(requestOptions.method)) {
        requestOptions.method = requestOptions.method.toUpperCase();
      }
      requestOptions.transform = requestOptions.transform || plumbing.defaultTransformations[requestOptions.method];
      self2._rp_options = requestOptions;
      self2._rp_options.simple = requestOptions.simple !== false;
      self2._rp_options.resolveWithFullResponse = requestOptions.resolveWithFullResponse === true;
      self2._rp_options.transform2xxOnly = requestOptions.transform2xxOnly === true;
    };
    plumbing.defaultTransformations = {
      HEAD: function(body, response, resolveWithFullResponse) {
        return resolveWithFullResponse ? response : response.headers;
      }
    };
    plumbing.callback = function(err, response, body) {
      var self2 = this;
      var origCallbackThrewException = false, thrownException = null;
      if (isFunction3(self2._rp_callbackOrig)) {
        try {
          self2._rp_callbackOrig.apply(self2, arguments);
        } catch (e) {
          origCallbackThrewException = true;
          thrownException = e;
        }
      }
      var is2xx = !err && /^2/.test("" + response.statusCode);
      if (err) {
        self2._rp_reject(new errors.RequestError(err, self2._rp_options, response));
      } else if (self2._rp_options.simple && !is2xx) {
        if (isFunction3(self2._rp_options.transform) && self2._rp_options.transform2xxOnly === false) {
          new PromiseImpl(function(resolve) {
            resolve(self2._rp_options.transform(body, response, self2._rp_options.resolveWithFullResponse));
          }).then(function(transformedResponse) {
            self2._rp_reject(new errors.StatusCodeError(response.statusCode, body, self2._rp_options, transformedResponse));
          }).catch(function(transformErr) {
            self2._rp_reject(new errors.TransformError(transformErr, self2._rp_options, response));
          });
        } else {
          self2._rp_reject(new errors.StatusCodeError(response.statusCode, body, self2._rp_options, response));
        }
      } else {
        if (isFunction3(self2._rp_options.transform) && (is2xx || self2._rp_options.transform2xxOnly === false)) {
          new PromiseImpl(function(resolve) {
            resolve(self2._rp_options.transform(body, response, self2._rp_options.resolveWithFullResponse));
          }).then(function(transformedResponse) {
            self2._rp_resolve(transformedResponse);
          }).catch(function(transformErr) {
            self2._rp_reject(new errors.TransformError(transformErr, self2._rp_options, response));
          });
        } else if (self2._rp_options.resolveWithFullResponse) {
          self2._rp_resolve(response);
        } else {
          self2._rp_resolve(body);
        }
      }
      if (origCallbackThrewException) {
        throw thrownException;
      }
    };
    plumbing.exposePromiseMethod = function(exposeTo, bindTo, promisePropertyKey, methodToExpose, exposeAs) {
      exposeAs = exposeAs || methodToExpose;
      if (exposeAs in exposeTo) {
        throw new Error('Unable to expose method "' + exposeAs + '"');
      }
      exposeTo[exposeAs] = function RP$exposed() {
        var self2 = bindTo || this;
        return self2[promisePropertyKey][methodToExpose].apply(self2[promisePropertyKey], arguments);
      };
    };
    plumbing.exposePromise = function(exposeTo, bindTo, promisePropertyKey, exposeAs) {
      exposeAs = exposeAs || "promise";
      if (exposeAs in exposeTo) {
        throw new Error('Unable to expose method "' + exposeAs + '"');
      }
      exposeTo[exposeAs] = function RP$promise() {
        var self2 = bindTo || this;
        return self2[promisePropertyKey];
      };
    };
    return plumbing;
  };
});

// backend/node_modules/request-promise-core/configure/request2.js
var require_request2 = __commonJS((exports2, module2) => {
  var core = require_plumbing();
  var isArray3 = require_isArray();
  var isFunction3 = require_isFunction();
  var isObjectLike = require_isObjectLike();
  module2.exports = function(options) {
    var errorText = "Please verify options";
    if (!isObjectLike(options)) {
      throw new TypeError(errorText);
    }
    if (!isFunction3(options.request)) {
      throw new TypeError(errorText + ".request");
    }
    if (!isArray3(options.expose) || options.expose.length === 0) {
      throw new TypeError(errorText + ".expose");
    }
    var plumbing = core({
      PromiseImpl: options.PromiseImpl,
      constructorMixin: options.constructorMixin
    });
    var originalInit = options.request.Request.prototype.init;
    options.request.Request.prototype.init = function RP$initInterceptor(requestOptions) {
      if (isObjectLike(requestOptions) && !this._callback && !this._rp_promise) {
        plumbing.init.call(this, requestOptions);
      }
      return originalInit.apply(this, arguments);
    };
    var thenExposed = false;
    for (var i = 0;i < options.expose.length; i += 1) {
      var method = options.expose[i];
      plumbing[method === "promise" ? "exposePromise" : "exposePromiseMethod"](options.request.Request.prototype, null, "_rp_promise", method);
      if (method === "then") {
        thenExposed = true;
      }
    }
    if (!thenExposed) {
      throw new Error('Please expose "then"');
    }
  };
});

// backend/node_modules/stealthy-require/lib/index.js
var require_lib2 = __commonJS((exports2, module2) => {
  var isNative = /\.node$/;
  function forEach2(obj2, callback) {
    for (var key in obj2) {
      if (!Object.prototype.hasOwnProperty.call(obj2, key)) {
        continue;
      }
      callback(key);
    }
  }
  function assign(target, source) {
    forEach2(source, function(key) {
      target[key] = source[key];
    });
    return target;
  }
  function clearCache(requireCache) {
    forEach2(requireCache, function(resolvedPath) {
      if (!isNative.test(resolvedPath)) {
        delete requireCache[resolvedPath];
      }
    });
  }
  module2.exports = function(requireCache, callback, callbackForModulesToKeep, module3) {
    var originalCache = assign({}, requireCache);
    clearCache(requireCache);
    if (callbackForModulesToKeep) {
      var originalModuleChildren = module3.children ? module3.children.slice() : false;
      callbackForModulesToKeep();
      var modulesToKeep = [];
      forEach2(requireCache, function(key) {
        modulesToKeep.push(key);
      });
      clearCache(requireCache);
      if (module3.children) {
        module3.children = originalModuleChildren;
      }
      for (var i = 0;i < modulesToKeep.length; i += 1) {
        if (originalCache[modulesToKeep[i]]) {
          requireCache[modulesToKeep[i]] = originalCache[modulesToKeep[i]];
        }
      }
    }
    var freshModule = callback();
    var stealthCache = callbackForModulesToKeep ? assign({}, requireCache) : false;
    clearCache(requireCache);
    if (callbackForModulesToKeep) {
      for (var k = 0;k < modulesToKeep.length; k += 1) {
        if (stealthCache[modulesToKeep[k]]) {
          requireCache[modulesToKeep[k]] = stealthCache[modulesToKeep[k]];
        }
      }
    }
    assign(requireCache, originalCache);
    return freshModule;
  };
});

// backend/node_modules/extend/index.js
var require_extend = __commonJS((exports2, module2) => {
  var hasOwn2 = Object.prototype.hasOwnProperty;
  var toStr = Object.prototype.toString;
  var defineProperty = Object.defineProperty;
  var gOPD = Object.getOwnPropertyDescriptor;
  var isArray3 = function isArray(arr) {
    if (typeof Array.isArray === "function") {
      return Array.isArray(arr);
    }
    return toStr.call(arr) === "[object Array]";
  };
  var isPlainObject2 = function isPlainObject(obj2) {
    if (!obj2 || toStr.call(obj2) !== "[object Object]") {
      return false;
    }
    var hasOwnConstructor = hasOwn2.call(obj2, "constructor");
    var hasIsPrototypeOf = obj2.constructor && obj2.constructor.prototype && hasOwn2.call(obj2.constructor.prototype, "isPrototypeOf");
    if (obj2.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
      return false;
    }
    var key;
    for (key in obj2) {}
    return typeof key === "undefined" || hasOwn2.call(obj2, key);
  };
  var setProperty = function setProperty(target, options) {
    if (defineProperty && options.name === "__proto__") {
      defineProperty(target, options.name, {
        enumerable: true,
        configurable: true,
        value: options.newValue,
        writable: true
      });
    } else {
      target[options.name] = options.newValue;
    }
  };
  var getProperty = function getProperty(obj2, name) {
    if (name === "__proto__") {
      if (!hasOwn2.call(obj2, name)) {
        return;
      } else if (gOPD) {
        return gOPD(obj2, name).value;
      }
    }
    return obj2[name];
  };
  module2.exports = function extend() {
    var options, name, src, copy, copyIsArray, clone;
    var target = arguments[0];
    var i = 1;
    var length = arguments.length;
    var deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[1] || {};
      i = 2;
    }
    if (target == null || typeof target !== "object" && typeof target !== "function") {
      target = {};
    }
    for (;i < length; ++i) {
      options = arguments[i];
      if (options != null) {
        for (name in options) {
          src = getProperty(target, name);
          copy = getProperty(options, name);
          if (target !== copy) {
            if (deep && copy && (isPlainObject2(copy) || (copyIsArray = isArray3(copy)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && isArray3(src) ? src : [];
              } else {
                clone = src && isPlainObject2(src) ? src : {};
              }
              setProperty(target, { name, newValue: extend(deep, clone, copy) });
            } else if (typeof copy !== "undefined") {
              setProperty(target, { name, newValue: copy });
            }
          }
        }
      }
    }
    return target;
  };
});

// backend/node_modules/tough-cookie/dist/pathMatch.js
var require_pathMatch = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.pathMatch = pathMatch;
  function pathMatch(reqPath, cookiePath) {
    if (cookiePath === reqPath) {
      return true;
    }
    const idx = reqPath.indexOf(cookiePath);
    if (idx === 0) {
      if (cookiePath[cookiePath.length - 1] === "/") {
        return true;
      }
      if (reqPath.startsWith(cookiePath) && reqPath[cookiePath.length] === "/") {
        return true;
      }
    }
    return false;
  }
});

// backend/node_modules/tldts/dist/cjs/index.js
var require_cjs2 = __commonJS((exports2) => {
  function shareSameDomainSuffix(hostname, vhost) {
    if (hostname.endsWith(vhost)) {
      return hostname.length === vhost.length || hostname[hostname.length - vhost.length - 1] === ".";
    }
    return false;
  }
  function extractDomainWithSuffix(hostname, publicSuffix) {
    const publicSuffixIndex = hostname.length - publicSuffix.length - 2;
    const lastDotBeforeSuffixIndex = hostname.lastIndexOf(".", publicSuffixIndex);
    if (lastDotBeforeSuffixIndex === -1) {
      return hostname;
    }
    return hostname.slice(lastDotBeforeSuffixIndex + 1);
  }
  function getDomain$1(suffix, hostname, options) {
    if (options.validHosts !== null) {
      const validHosts = options.validHosts;
      for (const vhost of validHosts) {
        if (shareSameDomainSuffix(hostname, vhost)) {
          return vhost;
        }
      }
    }
    let numberOfLeadingDots = 0;
    if (hostname.startsWith(".")) {
      while (numberOfLeadingDots < hostname.length && hostname[numberOfLeadingDots] === ".") {
        numberOfLeadingDots += 1;
      }
    }
    if (suffix.length === hostname.length - numberOfLeadingDots) {
      return null;
    }
    return extractDomainWithSuffix(hostname, suffix);
  }
  function getDomainWithoutSuffix$1(domain, suffix) {
    return domain.slice(0, -suffix.length - 1);
  }
  function extractHostname(url2, urlIsValidHostname) {
    let start = 0;
    let end = url2.length;
    let hasUpper = false;
    if (!urlIsValidHostname) {
      if (url2.startsWith("data:")) {
        return null;
      }
      while (start < url2.length && url2.charCodeAt(start) <= 32) {
        start += 1;
      }
      while (end > start + 1 && url2.charCodeAt(end - 1) <= 32) {
        end -= 1;
      }
      if (url2.charCodeAt(start) === 47 && url2.charCodeAt(start + 1) === 47) {
        start += 2;
      } else {
        const indexOfProtocol = url2.indexOf(":/", start);
        if (indexOfProtocol !== -1) {
          const protocolSize = indexOfProtocol - start;
          const c0 = url2.charCodeAt(start);
          const c1 = url2.charCodeAt(start + 1);
          const c2 = url2.charCodeAt(start + 2);
          const c3 = url2.charCodeAt(start + 3);
          const c4 = url2.charCodeAt(start + 4);
          if (protocolSize === 5 && c0 === 104 && c1 === 116 && c2 === 116 && c3 === 112 && c4 === 115)
            ;
          else if (protocolSize === 4 && c0 === 104 && c1 === 116 && c2 === 116 && c3 === 112)
            ;
          else if (protocolSize === 3 && c0 === 119 && c1 === 115 && c2 === 115)
            ;
          else if (protocolSize === 2 && c0 === 119 && c1 === 115)
            ;
          else {
            for (let i = start;i < indexOfProtocol; i += 1) {
              const lowerCaseCode = url2.charCodeAt(i) | 32;
              if (!(lowerCaseCode >= 97 && lowerCaseCode <= 122 || lowerCaseCode >= 48 && lowerCaseCode <= 57 || lowerCaseCode === 46 || lowerCaseCode === 45 || lowerCaseCode === 43)) {
                return null;
              }
            }
          }
          start = indexOfProtocol + 2;
          while (url2.charCodeAt(start) === 47) {
            start += 1;
          }
        }
      }
      let indexOfIdentifier = -1;
      let indexOfClosingBracket = -1;
      let indexOfPort = -1;
      for (let i = start;i < end; i += 1) {
        const code = url2.charCodeAt(i);
        if (code === 35 || code === 47 || code === 63) {
          end = i;
          break;
        } else if (code === 64) {
          indexOfIdentifier = i;
        } else if (code === 93) {
          indexOfClosingBracket = i;
        } else if (code === 58) {
          indexOfPort = i;
        } else if (code >= 65 && code <= 90) {
          hasUpper = true;
        }
      }
      if (indexOfIdentifier !== -1 && indexOfIdentifier > start && indexOfIdentifier < end) {
        start = indexOfIdentifier + 1;
      }
      if (url2.charCodeAt(start) === 91) {
        if (indexOfClosingBracket !== -1) {
          return url2.slice(start + 1, indexOfClosingBracket).toLowerCase();
        }
        return null;
      } else if (indexOfPort !== -1 && indexOfPort > start && indexOfPort < end) {
        end = indexOfPort;
      }
    }
    while (end > start + 1 && url2.charCodeAt(end - 1) === 46) {
      end -= 1;
    }
    const hostname = start !== 0 || end !== url2.length ? url2.slice(start, end) : url2;
    if (hasUpper) {
      return hostname.toLowerCase();
    }
    return hostname;
  }
  function isProbablyIpv4(hostname) {
    if (hostname.length < 7) {
      return false;
    }
    if (hostname.length > 15) {
      return false;
    }
    let numberOfDots = 0;
    for (let i = 0;i < hostname.length; i += 1) {
      const code = hostname.charCodeAt(i);
      if (code === 46) {
        numberOfDots += 1;
      } else if (code < 48 || code > 57) {
        return false;
      }
    }
    return numberOfDots === 3 && hostname.charCodeAt(0) !== 46 && hostname.charCodeAt(hostname.length - 1) !== 46;
  }
  function isProbablyIpv6(hostname) {
    if (hostname.length < 3) {
      return false;
    }
    let start = hostname.startsWith("[") ? 1 : 0;
    let end = hostname.length;
    if (hostname[end - 1] === "]") {
      end -= 1;
    }
    if (end - start > 39) {
      return false;
    }
    let hasColon = false;
    for (;start < end; start += 1) {
      const code = hostname.charCodeAt(start);
      if (code === 58) {
        hasColon = true;
      } else if (!(code >= 48 && code <= 57 || code >= 97 && code <= 102 || code >= 65 && code <= 90)) {
        return false;
      }
    }
    return hasColon;
  }
  function isIp(hostname) {
    return isProbablyIpv6(hostname) || isProbablyIpv4(hostname);
  }
  function isValidAscii(code) {
    return code >= 97 && code <= 122 || code >= 48 && code <= 57 || code > 127;
  }
  function isValidHostname(hostname) {
    if (hostname.length > 255) {
      return false;
    }
    if (hostname.length === 0) {
      return false;
    }
    if (!isValidAscii(hostname.charCodeAt(0)) && hostname.charCodeAt(0) !== 46 && hostname.charCodeAt(0) !== 95) {
      return false;
    }
    let lastDotIndex = -1;
    let lastCharCode = -1;
    const len = hostname.length;
    for (let i = 0;i < len; i += 1) {
      const code = hostname.charCodeAt(i);
      if (code === 46) {
        if (i - lastDotIndex > 64 || lastCharCode === 46 || lastCharCode === 45 || lastCharCode === 95) {
          return false;
        }
        lastDotIndex = i;
      } else if (!(isValidAscii(code) || code === 45 || code === 95)) {
        return false;
      }
      lastCharCode = code;
    }
    return len - lastDotIndex - 1 <= 63 && lastCharCode !== 45;
  }
  function setDefaultsImpl({ allowIcannDomains = true, allowPrivateDomains = false, detectIp = true, extractHostname: extractHostname2 = true, mixedInputs = true, validHosts = null, validateHostname = true }) {
    return {
      allowIcannDomains,
      allowPrivateDomains,
      detectIp,
      extractHostname: extractHostname2,
      mixedInputs,
      validHosts,
      validateHostname
    };
  }
  var DEFAULT_OPTIONS = setDefaultsImpl({});
  function setDefaults(options) {
    if (options === undefined) {
      return DEFAULT_OPTIONS;
    }
    return setDefaultsImpl(options);
  }
  function getSubdomain$1(hostname, domain) {
    if (domain.length === hostname.length) {
      return "";
    }
    return hostname.slice(0, -domain.length - 1);
  }
  function getEmptyResult() {
    return {
      domain: null,
      domainWithoutSuffix: null,
      hostname: null,
      isIcann: null,
      isIp: null,
      isPrivate: null,
      publicSuffix: null,
      subdomain: null
    };
  }
  function resetResult(result) {
    result.domain = null;
    result.domainWithoutSuffix = null;
    result.hostname = null;
    result.isIcann = null;
    result.isIp = null;
    result.isPrivate = null;
    result.publicSuffix = null;
    result.subdomain = null;
  }
  function parseImpl(url2, step, suffixLookup2, partialOptions, result) {
    const options = setDefaults(partialOptions);
    if (typeof url2 !== "string") {
      return result;
    }
    if (!options.extractHostname) {
      result.hostname = url2;
    } else if (options.mixedInputs) {
      result.hostname = extractHostname(url2, isValidHostname(url2));
    } else {
      result.hostname = extractHostname(url2, false);
    }
    if (step === 0 || result.hostname === null) {
      return result;
    }
    if (options.detectIp) {
      result.isIp = isIp(result.hostname);
      if (result.isIp) {
        return result;
      }
    }
    if (options.validateHostname && options.extractHostname && !isValidHostname(result.hostname)) {
      result.hostname = null;
      return result;
    }
    suffixLookup2(result.hostname, options, result);
    if (step === 2 || result.publicSuffix === null) {
      return result;
    }
    result.domain = getDomain$1(result.publicSuffix, result.hostname, options);
    if (step === 3 || result.domain === null) {
      return result;
    }
    result.subdomain = getSubdomain$1(result.hostname, result.domain);
    if (step === 4) {
      return result;
    }
    result.domainWithoutSuffix = getDomainWithoutSuffix$1(result.domain, result.publicSuffix);
    return result;
  }
  function fastPathLookup(hostname, options, out) {
    if (!options.allowPrivateDomains && hostname.length > 3) {
      const last = hostname.length - 1;
      const c3 = hostname.charCodeAt(last);
      const c2 = hostname.charCodeAt(last - 1);
      const c1 = hostname.charCodeAt(last - 2);
      const c0 = hostname.charCodeAt(last - 3);
      if (c3 === 109 && c2 === 111 && c1 === 99 && c0 === 46) {
        out.isIcann = true;
        out.isPrivate = false;
        out.publicSuffix = "com";
        return true;
      } else if (c3 === 103 && c2 === 114 && c1 === 111 && c0 === 46) {
        out.isIcann = true;
        out.isPrivate = false;
        out.publicSuffix = "org";
        return true;
      } else if (c3 === 117 && c2 === 100 && c1 === 101 && c0 === 46) {
        out.isIcann = true;
        out.isPrivate = false;
        out.publicSuffix = "edu";
        return true;
      } else if (c3 === 118 && c2 === 111 && c1 === 103 && c0 === 46) {
        out.isIcann = true;
        out.isPrivate = false;
        out.publicSuffix = "gov";
        return true;
      } else if (c3 === 116 && c2 === 101 && c1 === 110 && c0 === 46) {
        out.isIcann = true;
        out.isPrivate = false;
        out.publicSuffix = "net";
        return true;
      } else if (c3 === 101 && c2 === 100 && c1 === 46) {
        out.isIcann = true;
        out.isPrivate = false;
        out.publicSuffix = "de";
        return true;
      }
    }
    return false;
  }
  var exceptions = function() {
    const _0 = [1, {}], _1 = [2, {}], _2 = [0, { city: _0 }];
    const exceptions2 = [0, { ck: [0, { www: _0 }], jp: [0, { kawasaki: _2, kitakyushu: _2, kobe: _2, nagoya: _2, sapporo: _2, sendai: _2, yokohama: _2 }], dev: [0, { hrsn: [0, { psl: [0, { wc: [0, { ignored: _1, sub: [0, { ignored: _1 }] }] }] }] }] }];
    return exceptions2;
  }();
  var rules = function() {
    const _3 = [1, {}], _4 = [2, {}], _5 = [1, { com: _3, edu: _3, gov: _3, net: _3, org: _3 }], _6 = [1, { com: _3, edu: _3, gov: _3, mil: _3, net: _3, org: _3 }], _7 = [0, { "*": _4 }], _8 = [2, { s: _7 }], _9 = [0, { relay: _4 }], _10 = [2, { id: _4 }], _11 = [1, { gov: _3 }], _12 = [0, { "transfer-webapp": _4 }], _13 = [0, { notebook: _4, studio: _4 }], _14 = [0, { labeling: _4, notebook: _4, studio: _4 }], _15 = [0, { notebook: _4 }], _16 = [0, { labeling: _4, notebook: _4, "notebook-fips": _4, studio: _4 }], _17 = [0, { notebook: _4, "notebook-fips": _4, studio: _4, "studio-fips": _4 }], _18 = [0, { "*": _3 }], _19 = [1, { co: _4 }], _20 = [0, { objects: _4 }], _21 = [2, { nodes: _4 }], _22 = [0, { my: _7 }], _23 = [0, { s3: _4, "s3-accesspoint": _4, "s3-website": _4 }], _24 = [0, { s3: _4, "s3-accesspoint": _4 }], _25 = [0, { direct: _4 }], _26 = [0, { "webview-assets": _4 }], _27 = [0, { vfs: _4, "webview-assets": _4 }], _28 = [0, { "execute-api": _4, "emrappui-prod": _4, "emrnotebooks-prod": _4, "emrstudio-prod": _4, dualstack: _23, s3: _4, "s3-accesspoint": _4, "s3-object-lambda": _4, "s3-website": _4, "aws-cloud9": _26, cloud9: _27 }], _29 = [0, { "execute-api": _4, "emrappui-prod": _4, "emrnotebooks-prod": _4, "emrstudio-prod": _4, dualstack: _24, s3: _4, "s3-accesspoint": _4, "s3-object-lambda": _4, "s3-website": _4, "aws-cloud9": _26, cloud9: _27 }], _30 = [0, { "execute-api": _4, "emrappui-prod": _4, "emrnotebooks-prod": _4, "emrstudio-prod": _4, dualstack: _23, s3: _4, "s3-accesspoint": _4, "s3-object-lambda": _4, "s3-website": _4, "analytics-gateway": _4, "aws-cloud9": _26, cloud9: _27 }], _31 = [0, { "execute-api": _4, "emrappui-prod": _4, "emrnotebooks-prod": _4, "emrstudio-prod": _4, dualstack: _23, s3: _4, "s3-accesspoint": _4, "s3-object-lambda": _4, "s3-website": _4 }], _32 = [0, { s3: _4, "s3-accesspoint": _4, "s3-accesspoint-fips": _4, "s3-fips": _4, "s3-website": _4 }], _33 = [0, { "execute-api": _4, "emrappui-prod": _4, "emrnotebooks-prod": _4, "emrstudio-prod": _4, dualstack: _32, s3: _4, "s3-accesspoint": _4, "s3-accesspoint-fips": _4, "s3-fips": _4, "s3-object-lambda": _4, "s3-website": _4, "aws-cloud9": _26, cloud9: _27 }], _34 = [0, { "execute-api": _4, "emrappui-prod": _4, "emrnotebooks-prod": _4, "emrstudio-prod": _4, dualstack: _32, s3: _4, "s3-accesspoint": _4, "s3-accesspoint-fips": _4, "s3-deprecated": _4, "s3-fips": _4, "s3-object-lambda": _4, "s3-website": _4, "analytics-gateway": _4, "aws-cloud9": _26, cloud9: _27 }], _35 = [0, { s3: _4, "s3-accesspoint": _4, "s3-accesspoint-fips": _4, "s3-fips": _4 }], _36 = [0, { "execute-api": _4, "emrappui-prod": _4, "emrnotebooks-prod": _4, "emrstudio-prod": _4, dualstack: _35, s3: _4, "s3-accesspoint": _4, "s3-accesspoint-fips": _4, "s3-fips": _4, "s3-object-lambda": _4, "s3-website": _4 }], _37 = [0, { auth: _4 }], _38 = [0, { auth: _4, "auth-fips": _4 }], _39 = [0, { "auth-fips": _4 }], _40 = [0, { apps: _4 }], _41 = [0, { paas: _4 }], _42 = [2, { eu: _4 }], _43 = [0, { app: _4 }], _44 = [0, { site: _4 }], _45 = [1, { com: _3, edu: _3, net: _3, org: _3 }], _46 = [0, { j: _4 }], _47 = [0, { dyn: _4 }], _48 = [1, { co: _3, com: _3, edu: _3, gov: _3, net: _3, org: _3 }], _49 = [0, { p: _4 }], _50 = [0, { user: _4 }], _51 = [0, { shop: _4 }], _52 = [0, { cdn: _4 }], _53 = [0, { cust: _4, reservd: _4 }], _54 = [0, { cust: _4 }], _55 = [0, { s3: _4 }], _56 = [1, { biz: _3, com: _3, edu: _3, gov: _3, info: _3, net: _3, org: _3 }], _57 = [0, { ipfs: _4 }], _58 = [1, { framer: _4 }], _59 = [0, { forgot: _4 }], _60 = [1, { gs: _3 }], _61 = [0, { nes: _3 }], _62 = [1, { k12: _3, cc: _3, lib: _3 }], _63 = [1, { cc: _3, lib: _3 }];
    const rules2 = [0, { ac: [1, { com: _3, edu: _3, gov: _3, mil: _3, net: _3, org: _3, drr: _4, feedback: _4, forms: _4 }], ad: _3, ae: [1, { ac: _3, co: _3, gov: _3, mil: _3, net: _3, org: _3, sch: _3 }], aero: [1, { airline: _3, airport: _3, "accident-investigation": _3, "accident-prevention": _3, aerobatic: _3, aeroclub: _3, aerodrome: _3, agents: _3, "air-surveillance": _3, "air-traffic-control": _3, aircraft: _3, airtraffic: _3, ambulance: _3, association: _3, author: _3, ballooning: _3, broker: _3, caa: _3, cargo: _3, catering: _3, certification: _3, championship: _3, charter: _3, civilaviation: _3, club: _3, conference: _3, consultant: _3, consulting: _3, control: _3, council: _3, crew: _3, design: _3, dgca: _3, educator: _3, emergency: _3, engine: _3, engineer: _3, entertainment: _3, equipment: _3, exchange: _3, express: _3, federation: _3, flight: _3, freight: _3, fuel: _3, gliding: _3, government: _3, groundhandling: _3, group: _3, hanggliding: _3, homebuilt: _3, insurance: _3, journal: _3, journalist: _3, leasing: _3, logistics: _3, magazine: _3, maintenance: _3, marketplace: _3, media: _3, microlight: _3, modelling: _3, navigation: _3, parachuting: _3, paragliding: _3, "passenger-association": _3, pilot: _3, press: _3, production: _3, recreation: _3, repbody: _3, res: _3, research: _3, rotorcraft: _3, safety: _3, scientist: _3, services: _3, show: _3, skydiving: _3, software: _3, student: _3, taxi: _3, trader: _3, trading: _3, trainer: _3, union: _3, workinggroup: _3, works: _3 }], af: _5, ag: [1, { co: _3, com: _3, net: _3, nom: _3, org: _3, obj: _4 }], ai: [1, { com: _3, net: _3, off: _3, org: _3, uwu: _4, framer: _4 }], al: _6, am: [1, { co: _3, com: _3, commune: _3, net: _3, org: _3, radio: _4 }], ao: [1, { co: _3, ed: _3, edu: _3, gov: _3, gv: _3, it: _3, og: _3, org: _3, pb: _3 }], aq: _3, ar: [1, { bet: _3, com: _3, coop: _3, edu: _3, gob: _3, gov: _3, int: _3, mil: _3, musica: _3, mutual: _3, net: _3, org: _3, seg: _3, senasa: _3, tur: _3 }], arpa: [1, { e164: _3, home: _3, "in-addr": _3, ip6: _3, iris: _3, uri: _3, urn: _3 }], as: _11, asia: [1, { cloudns: _4, daemon: _4, dix: _4 }], at: [1, { ac: [1, { sth: _3 }], co: _3, gv: _3, or: _3, funkfeuer: [0, { wien: _4 }], futurecms: [0, { "*": _4, ex: _7, in: _7 }], futurehosting: _4, futuremailing: _4, ortsinfo: [0, { ex: _7, kunden: _7 }], biz: _4, info: _4, "123webseite": _4, priv: _4, myspreadshop: _4, "12hp": _4, "2ix": _4, "4lima": _4, "lima-city": _4 }], au: [1, { asn: _3, com: [1, { cloudlets: [0, { mel: _4 }], myspreadshop: _4 }], edu: [1, { act: _3, catholic: _3, nsw: [1, { schools: _3 }], nt: _3, qld: _3, sa: _3, tas: _3, vic: _3, wa: _3 }], gov: [1, { qld: _3, sa: _3, tas: _3, vic: _3, wa: _3 }], id: _3, net: _3, org: _3, conf: _3, oz: _3, act: _3, nsw: _3, nt: _3, qld: _3, sa: _3, tas: _3, vic: _3, wa: _3 }], aw: [1, { com: _3 }], ax: _3, az: [1, { biz: _3, co: _3, com: _3, edu: _3, gov: _3, info: _3, int: _3, mil: _3, name: _3, net: _3, org: _3, pp: _3, pro: _3 }], ba: [1, { com: _3, edu: _3, gov: _3, mil: _3, net: _3, org: _3, rs: _4 }], bb: [1, { biz: _3, co: _3, com: _3, edu: _3, gov: _3, info: _3, net: _3, org: _3, store: _3, tv: _3 }], bd: _18, be: [1, { ac: _3, cloudns: _4, webhosting: _4, interhostsolutions: [0, { cloud: _4 }], kuleuven: [0, { ezproxy: _4 }], "123website": _4, myspreadshop: _4, transurl: _7 }], bf: _11, bg: [1, { "0": _3, "1": _3, "2": _3, "3": _3, "4": _3, "5": _3, "6": _3, "7": _3, "8": _3, "9": _3, a: _3, b: _3, c: _3, d: _3, e: _3, f: _3, g: _3, h: _3, i: _3, j: _3, k: _3, l: _3, m: _3, n: _3, o: _3, p: _3, q: _3, r: _3, s: _3, t: _3, u: _3, v: _3, w: _3, x: _3, y: _3, z: _3, barsy: _4 }], bh: _5, bi: [1, { co: _3, com: _3, edu: _3, or: _3, org: _3 }], biz: [1, { activetrail: _4, "cloud-ip": _4, cloudns: _4, jozi: _4, dyndns: _4, "for-better": _4, "for-more": _4, "for-some": _4, "for-the": _4, selfip: _4, webhop: _4, orx: _4, mmafan: _4, myftp: _4, "no-ip": _4, dscloud: _4 }], bj: [1, { africa: _3, agro: _3, architectes: _3, assur: _3, avocats: _3, co: _3, com: _3, eco: _3, econo: _3, edu: _3, info: _3, loisirs: _3, money: _3, net: _3, org: _3, ote: _3, restaurant: _3, resto: _3, tourism: _3, univ: _3 }], bm: _5, bn: [1, { com: _3, edu: _3, gov: _3, net: _3, org: _3, co: _4 }], bo: [1, { com: _3, edu: _3, gob: _3, int: _3, mil: _3, net: _3, org: _3, tv: _3, web: _3, academia: _3, agro: _3, arte: _3, blog: _3, bolivia: _3, ciencia: _3, cooperativa: _3, democracia: _3, deporte: _3, ecologia: _3, economia: _3, empresa: _3, indigena: _3, industria: _3, info: _3, medicina: _3, movimiento: _3, musica: _3, natural: _3, nombre: _3, noticias: _3, patria: _3, plurinacional: _3, politica: _3, profesional: _3, pueblo: _3, revista: _3, salud: _3, tecnologia: _3, tksat: _3, transporte: _3, wiki: _3 }], br: [1, { "9guacu": _3, abc: _3, adm: _3, adv: _3, agr: _3, aju: _3, am: _3, anani: _3, aparecida: _3, app: _3, arq: _3, art: _3, ato: _3, b: _3, barueri: _3, belem: _3, bet: _3, bhz: _3, bib: _3, bio: _3, blog: _3, bmd: _3, boavista: _3, bsb: _3, campinagrande: _3, campinas: _3, caxias: _3, cim: _3, cng: _3, cnt: _3, com: [1, { simplesite: _4 }], contagem: _3, coop: _3, coz: _3, cri: _3, cuiaba: _3, curitiba: _3, def: _3, des: _3, det: _3, dev: _3, ecn: _3, eco: _3, edu: _3, emp: _3, enf: _3, eng: _3, esp: _3, etc: _3, eti: _3, far: _3, feira: _3, flog: _3, floripa: _3, fm: _3, fnd: _3, fortal: _3, fot: _3, foz: _3, fst: _3, g12: _3, geo: _3, ggf: _3, goiania: _3, gov: [1, { ac: _3, al: _3, am: _3, ap: _3, ba: _3, ce: _3, df: _3, es: _3, go: _3, ma: _3, mg: _3, ms: _3, mt: _3, pa: _3, pb: _3, pe: _3, pi: _3, pr: _3, rj: _3, rn: _3, ro: _3, rr: _3, rs: _3, sc: _3, se: _3, sp: _3, to: _3 }], gru: _3, imb: _3, ind: _3, inf: _3, jab: _3, jampa: _3, jdf: _3, joinville: _3, jor: _3, jus: _3, leg: [1, { ac: _4, al: _4, am: _4, ap: _4, ba: _4, ce: _4, df: _4, es: _4, go: _4, ma: _4, mg: _4, ms: _4, mt: _4, pa: _4, pb: _4, pe: _4, pi: _4, pr: _4, rj: _4, rn: _4, ro: _4, rr: _4, rs: _4, sc: _4, se: _4, sp: _4, to: _4 }], leilao: _3, lel: _3, log: _3, londrina: _3, macapa: _3, maceio: _3, manaus: _3, maringa: _3, mat: _3, med: _3, mil: _3, morena: _3, mp: _3, mus: _3, natal: _3, net: _3, niteroi: _3, nom: _18, not: _3, ntr: _3, odo: _3, ong: _3, org: _3, osasco: _3, palmas: _3, poa: _3, ppg: _3, pro: _3, psc: _3, psi: _3, pvh: _3, qsl: _3, radio: _3, rec: _3, recife: _3, rep: _3, ribeirao: _3, rio: _3, riobranco: _3, riopreto: _3, salvador: _3, sampa: _3, santamaria: _3, santoandre: _3, saobernardo: _3, saogonca: _3, seg: _3, sjc: _3, slg: _3, slz: _3, sorocaba: _3, srv: _3, taxi: _3, tc: _3, tec: _3, teo: _3, the: _3, tmp: _3, trd: _3, tur: _3, tv: _3, udi: _3, vet: _3, vix: _3, vlog: _3, wiki: _3, zlg: _3 }], bs: [1, { com: _3, edu: _3, gov: _3, net: _3, org: _3, we: _4 }], bt: _5, bv: _3, bw: [1, { ac: _3, co: _3, gov: _3, net: _3, org: _3 }], by: [1, { gov: _3, mil: _3, com: _3, of: _3, mediatech: _4 }], bz: [1, { co: _3, com: _3, edu: _3, gov: _3, net: _3, org: _3, za: _4, mydns: _4, gsj: _4 }], ca: [1, { ab: _3, bc: _3, mb: _3, nb: _3, nf: _3, nl: _3, ns: _3, nt: _3, nu: _3, on: _3, pe: _3, qc: _3, sk: _3, yk: _3, gc: _3, barsy: _4, awdev: _7, co: _4, "no-ip": _4, myspreadshop: _4, box: _4 }], cat: _3, cc: [1, { cleverapps: _4, cloudns: _4, ftpaccess: _4, "game-server": _4, myphotos: _4, scrapping: _4, twmail: _4, csx: _4, fantasyleague: _4, spawn: [0, { instances: _4 }] }], cd: _11, cf: _3, cg: _3, ch: [1, { square7: _4, cloudns: _4, cloudscale: [0, { cust: _4, lpg: _20, rma: _20 }], flow: [0, { ae: [0, { alp1: _4 }], appengine: _4 }], "linkyard-cloud": _4, gotdns: _4, dnsking: _4, "123website": _4, myspreadshop: _4, firenet: [0, { "*": _4, svc: _7 }], "12hp": _4, "2ix": _4, "4lima": _4, "lima-city": _4 }], ci: [1, { ac: _3, "xn--aroport-bya": _3, "aroport": _3, asso: _3, co: _3, com: _3, ed: _3, edu: _3, go: _3, gouv: _3, int: _3, net: _3, or: _3, org: _3 }], ck: _18, cl: [1, { co: _3, gob: _3, gov: _3, mil: _3, cloudns: _4 }], cm: [1, { co: _3, com: _3, gov: _3, net: _3 }], cn: [1, { ac: _3, com: [1, { amazonaws: [0, { "cn-north-1": [0, { "execute-api": _4, "emrappui-prod": _4, "emrnotebooks-prod": _4, "emrstudio-prod": _4, dualstack: _23, s3: _4, "s3-accesspoint": _4, "s3-deprecated": _4, "s3-object-lambda": _4, "s3-website": _4 }], "cn-northwest-1": [0, { "execute-api": _4, "emrappui-prod": _4, "emrnotebooks-prod": _4, "emrstudio-prod": _4, dualstack: _24, s3: _4, "s3-accesspoint": _4, "s3-object-lambda": _4, "s3-website": _4 }], compute: _7, airflow: [0, { "cn-north-1": _7, "cn-northwest-1": _7 }], eb: [0, { "cn-north-1": _4, "cn-northwest-1": _4 }], elb: _7 }], sagemaker: [0, { "cn-north-1": _13, "cn-northwest-1": _13 }] }], edu: _3, gov: _3, mil: _3, net: _3, org: _3, "xn--55qx5d": _3, "": _3, "xn--od0alg": _3, "": _3, "xn--io0a7i": _3, "": _3, ah: _3, bj: _3, cq: _3, fj: _3, gd: _3, gs: _3, gx: _3, gz: _3, ha: _3, hb: _3, he: _3, hi: _3, hk: _3, hl: _3, hn: _3, jl: _3, js: _3, jx: _3, ln: _3, mo: _3, nm: _3, nx: _3, qh: _3, sc: _3, sd: _3, sh: [1, { as: _4 }], sn: _3, sx: _3, tj: _3, tw: _3, xj: _3, xz: _3, yn: _3, zj: _3, "canva-apps": _4, canvasite: _22, myqnapcloud: _4, quickconnect: _25 }], co: [1, { com: _3, edu: _3, gov: _3, mil: _3, net: _3, nom: _3, org: _3, carrd: _4, crd: _4, otap: _7, leadpages: _4, lpages: _4, mypi: _4, xmit: _7, firewalledreplit: _10, repl: _10, supabase: _4 }], com: [1, { a2hosted: _4, cpserver: _4, adobeaemcloud: [2, { dev: _7 }], africa: _4, airkitapps: _4, "airkitapps-au": _4, aivencloud: _4, alibabacloudcs: _4, kasserver: _4, amazonaws: [0, { "af-south-1": _28, "ap-east-1": _29, "ap-northeast-1": _30, "ap-northeast-2": _30, "ap-northeast-3": _28, "ap-south-1": _30, "ap-south-2": _31, "ap-southeast-1": _30, "ap-southeast-2": _30, "ap-southeast-3": _31, "ap-southeast-4": _31, "ap-southeast-5": [0, { "execute-api": _4, dualstack: _23, s3: _4, "s3-accesspoint": _4, "s3-deprecated": _4, "s3-object-lambda": _4, "s3-website": _4 }], "ca-central-1": _33, "ca-west-1": [0, { "execute-api": _4, "emrappui-prod": _4, "emrnotebooks-prod": _4, "emrstudio-prod": _4, dualstack: _32, s3: _4, "s3-accesspoint": _4, "s3-accesspoint-fips": _4, "s3-fips": _4, "s3-object-lambda": _4, "s3-website": _4 }], "eu-central-1": _30, "eu-central-2": _31, "eu-north-1": _29, "eu-south-1": _28, "eu-south-2": _31, "eu-west-1": [0, { "execute-api": _4, "emrappui-prod": _4, "emrnotebooks-prod": _4, "emrstudio-prod": _4, dualstack: _23, s3: _4, "s3-accesspoint": _4, "s3-deprecated": _4, "s3-object-lambda": _4, "s3-website": _4, "analytics-gateway": _4, "aws-cloud9": _26, cloud9: _27 }], "eu-west-2": _29, "eu-west-3": _28, "il-central-1": [0, { "execute-api": _4, "emrappui-prod": _4, "emrnotebooks-prod": _4, "emrstudio-prod": _4, dualstack: _23, s3: _4, "s3-accesspoint": _4, "s3-object-lambda": _4, "s3-website": _4, "aws-cloud9": _26, cloud9: [0, { vfs: _4 }] }], "me-central-1": _31, "me-south-1": _29, "sa-east-1": _28, "us-east-1": [2, { "execute-api": _4, "emrappui-prod": _4, "emrnotebooks-prod": _4, "emrstudio-prod": _4, dualstack: _32, s3: _4, "s3-accesspoint": _4, "s3-accesspoint-fips": _4, "s3-deprecated": _4, "s3-fips": _4, "s3-object-lambda": _4, "s3-website": _4, "analytics-gateway": _4, "aws-cloud9": _26, cloud9: _27 }], "us-east-2": _34, "us-gov-east-1": _36, "us-gov-west-1": _36, "us-west-1": _33, "us-west-2": _34, compute: _7, "compute-1": _7, airflow: [0, { "af-south-1": _7, "ap-east-1": _7, "ap-northeast-1": _7, "ap-northeast-2": _7, "ap-northeast-3": _7, "ap-south-1": _7, "ap-south-2": _7, "ap-southeast-1": _7, "ap-southeast-2": _7, "ap-southeast-3": _7, "ap-southeast-4": _7, "ca-central-1": _7, "ca-west-1": _7, "eu-central-1": _7, "eu-central-2": _7, "eu-north-1": _7, "eu-south-1": _7, "eu-south-2": _7, "eu-west-1": _7, "eu-west-2": _7, "eu-west-3": _7, "il-central-1": _7, "me-central-1": _7, "me-south-1": _7, "sa-east-1": _7, "us-east-1": _7, "us-east-2": _7, "us-west-1": _7, "us-west-2": _7 }], s3: _4, "s3-1": _4, "s3-ap-east-1": _4, "s3-ap-northeast-1": _4, "s3-ap-northeast-2": _4, "s3-ap-northeast-3": _4, "s3-ap-south-1": _4, "s3-ap-southeast-1": _4, "s3-ap-southeast-2": _4, "s3-ca-central-1": _4, "s3-eu-central-1": _4, "s3-eu-north-1": _4, "s3-eu-west-1": _4, "s3-eu-west-2": _4, "s3-eu-west-3": _4, "s3-external-1": _4, "s3-fips-us-gov-east-1": _4, "s3-fips-us-gov-west-1": _4, "s3-global": [0, { accesspoint: [0, { mrap: _4 }] }], "s3-me-south-1": _4, "s3-sa-east-1": _4, "s3-us-east-2": _4, "s3-us-gov-east-1": _4, "s3-us-gov-west-1": _4, "s3-us-west-1": _4, "s3-us-west-2": _4, "s3-website-ap-northeast-1": _4, "s3-website-ap-southeast-1": _4, "s3-website-ap-southeast-2": _4, "s3-website-eu-west-1": _4, "s3-website-sa-east-1": _4, "s3-website-us-east-1": _4, "s3-website-us-gov-west-1": _4, "s3-website-us-west-1": _4, "s3-website-us-west-2": _4, elb: _7 }], amazoncognito: [0, { "af-south-1": _37, "ap-east-1": _37, "ap-northeast-1": _37, "ap-northeast-2": _37, "ap-northeast-3": _37, "ap-south-1": _37, "ap-south-2": _37, "ap-southeast-1": _37, "ap-southeast-2": _37, "ap-southeast-3": _37, "ap-southeast-4": _37, "ap-southeast-5": _37, "ca-central-1": _37, "ca-west-1": _37, "eu-central-1": _37, "eu-central-2": _37, "eu-north-1": _37, "eu-south-1": _37, "eu-south-2": _37, "eu-west-1": _37, "eu-west-2": _37, "eu-west-3": _37, "il-central-1": _37, "me-central-1": _37, "me-south-1": _37, "sa-east-1": _37, "us-east-1": _38, "us-east-2": _38, "us-gov-east-1": _39, "us-gov-west-1": _39, "us-west-1": _38, "us-west-2": _38 }], amplifyapp: _4, awsapprunner: _7, awsapps: _4, elasticbeanstalk: [2, { "af-south-1": _4, "ap-east-1": _4, "ap-northeast-1": _4, "ap-northeast-2": _4, "ap-northeast-3": _4, "ap-south-1": _4, "ap-southeast-1": _4, "ap-southeast-2": _4, "ap-southeast-3": _4, "ca-central-1": _4, "eu-central-1": _4, "eu-north-1": _4, "eu-south-1": _4, "eu-west-1": _4, "eu-west-2": _4, "eu-west-3": _4, "il-central-1": _4, "me-south-1": _4, "sa-east-1": _4, "us-east-1": _4, "us-east-2": _4, "us-gov-east-1": _4, "us-gov-west-1": _4, "us-west-1": _4, "us-west-2": _4 }], awsglobalaccelerator: _4, siiites: _4, appspacehosted: _4, appspaceusercontent: _4, "on-aptible": _4, myasustor: _4, "balena-devices": _4, boutir: _4, bplaced: _4, cafjs: _4, "canva-apps": _4, "cdn77-storage": _4, br: _4, cn: _4, de: _4, eu: _4, jpn: _4, mex: _4, ru: _4, sa: _4, uk: _4, us: _4, za: _4, "clever-cloud": [0, { services: _7 }], dnsabr: _4, "ip-ddns": _4, jdevcloud: _4, wpdevcloud: _4, "cf-ipfs": _4, "cloudflare-ipfs": _4, trycloudflare: _4, co: _4, devinapps: _7, builtwithdark: _4, datadetect: [0, { demo: _4, instance: _4 }], dattolocal: _4, dattorelay: _4, dattoweb: _4, mydatto: _4, digitaloceanspaces: _7, discordsays: _4, discordsez: _4, drayddns: _4, dreamhosters: _4, durumis: _4, mydrobo: _4, blogdns: _4, cechire: _4, dnsalias: _4, dnsdojo: _4, doesntexist: _4, dontexist: _4, doomdns: _4, "dyn-o-saur": _4, dynalias: _4, "dyndns-at-home": _4, "dyndns-at-work": _4, "dyndns-blog": _4, "dyndns-free": _4, "dyndns-home": _4, "dyndns-ip": _4, "dyndns-mail": _4, "dyndns-office": _4, "dyndns-pics": _4, "dyndns-remote": _4, "dyndns-server": _4, "dyndns-web": _4, "dyndns-wiki": _4, "dyndns-work": _4, "est-a-la-maison": _4, "est-a-la-masion": _4, "est-le-patron": _4, "est-mon-blogueur": _4, "from-ak": _4, "from-al": _4, "from-ar": _4, "from-ca": _4, "from-ct": _4, "from-dc": _4, "from-de": _4, "from-fl": _4, "from-ga": _4, "from-hi": _4, "from-ia": _4, "from-id": _4, "from-il": _4, "from-in": _4, "from-ks": _4, "from-ky": _4, "from-ma": _4, "from-md": _4, "from-mi": _4, "from-mn": _4, "from-mo": _4, "from-ms": _4, "from-mt": _4, "from-nc": _4, "from-nd": _4, "from-ne": _4, "from-nh": _4, "from-nj": _4, "from-nm": _4, "from-nv": _4, "from-oh": _4, "from-ok": _4, "from-or": _4, "from-pa": _4, "from-pr": _4, "from-ri": _4, "from-sc": _4, "from-sd": _4, "from-tn": _4, "from-tx": _4, "from-ut": _4, "from-va": _4, "from-vt": _4, "from-wa": _4, "from-wi": _4, "from-wv": _4, "from-wy": _4, getmyip: _4, gotdns: _4, "hobby-site": _4, homelinux: _4, homeunix: _4, iamallama: _4, "is-a-anarchist": _4, "is-a-blogger": _4, "is-a-bookkeeper": _4, "is-a-bulls-fan": _4, "is-a-caterer": _4, "is-a-chef": _4, "is-a-conservative": _4, "is-a-cpa": _4, "is-a-cubicle-slave": _4, "is-a-democrat": _4, "is-a-designer": _4, "is-a-doctor": _4, "is-a-financialadvisor": _4, "is-a-geek": _4, "is-a-green": _4, "is-a-guru": _4, "is-a-hard-worker": _4, "is-a-hunter": _4, "is-a-landscaper": _4, "is-a-lawyer": _4, "is-a-liberal": _4, "is-a-libertarian": _4, "is-a-llama": _4, "is-a-musician": _4, "is-a-nascarfan": _4, "is-a-nurse": _4, "is-a-painter": _4, "is-a-personaltrainer": _4, "is-a-photographer": _4, "is-a-player": _4, "is-a-republican": _4, "is-a-rockstar": _4, "is-a-socialist": _4, "is-a-student": _4, "is-a-teacher": _4, "is-a-techie": _4, "is-a-therapist": _4, "is-an-accountant": _4, "is-an-actor": _4, "is-an-actress": _4, "is-an-anarchist": _4, "is-an-artist": _4, "is-an-engineer": _4, "is-an-entertainer": _4, "is-certified": _4, "is-gone": _4, "is-into-anime": _4, "is-into-cars": _4, "is-into-cartoons": _4, "is-into-games": _4, "is-leet": _4, "is-not-certified": _4, "is-slick": _4, "is-uberleet": _4, "is-with-theband": _4, "isa-geek": _4, "isa-hockeynut": _4, issmarterthanyou: _4, "likes-pie": _4, likescandy: _4, "neat-url": _4, "saves-the-whales": _4, selfip: _4, "sells-for-less": _4, "sells-for-u": _4, servebbs: _4, "simple-url": _4, "space-to-rent": _4, "teaches-yoga": _4, writesthisblog: _4, ddnsfree: _4, ddnsgeek: _4, giize: _4, gleeze: _4, kozow: _4, loseyourip: _4, ooguy: _4, theworkpc: _4, mytuleap: _4, "tuleap-partners": _4, encoreapi: _4, evennode: [0, { "eu-1": _4, "eu-2": _4, "eu-3": _4, "eu-4": _4, "us-1": _4, "us-2": _4, "us-3": _4, "us-4": _4 }], onfabrica: _4, "fastly-edge": _4, "fastly-terrarium": _4, "fastvps-server": _4, mydobiss: _4, firebaseapp: _4, fldrv: _4, forgeblocks: _4, framercanvas: _4, "freebox-os": _4, freeboxos: _4, freemyip: _4, aliases121: _4, gentapps: _4, gentlentapis: _4, githubusercontent: _4, "0emm": _7, appspot: [2, { r: _7 }], blogspot: _4, codespot: _4, googleapis: _4, googlecode: _4, pagespeedmobilizer: _4, withgoogle: _4, withyoutube: _4, grayjayleagues: _4, hatenablog: _4, hatenadiary: _4, herokuapp: _4, gr: _4, smushcdn: _4, wphostedmail: _4, wpmucdn: _4, pixolino: _4, "apps-1and1": _4, "live-website": _4, dopaas: _4, "hosted-by-previder": _41, hosteur: [0, { "rag-cloud": _4, "rag-cloud-ch": _4 }], "ik-server": [0, { jcloud: _4, "jcloud-ver-jpc": _4 }], jelastic: [0, { demo: _4 }], massivegrid: _41, wafaicloud: [0, { jed: _4, ryd: _4 }], webadorsite: _4, joyent: [0, { cns: _7 }], lpusercontent: _4, linode: [0, { members: _4, nodebalancer: _7 }], linodeobjects: _7, linodeusercontent: [0, { ip: _4 }], localtonet: _4, lovableproject: _4, barsycenter: _4, barsyonline: _4, modelscape: _4, mwcloudnonprod: _4, polyspace: _4, mazeplay: _4, miniserver: _4, atmeta: _4, fbsbx: _40, meteorapp: _42, routingthecloud: _4, mydbserver: _4, hostedpi: _4, "mythic-beasts": [0, { caracal: _4, customer: _4, fentiger: _4, lynx: _4, ocelot: _4, oncilla: _4, onza: _4, sphinx: _4, vs: _4, x: _4, yali: _4 }], nospamproxy: [0, { cloud: [2, { o365: _4 }] }], "4u": _4, nfshost: _4, "3utilities": _4, blogsyte: _4, ciscofreak: _4, damnserver: _4, ddnsking: _4, ditchyourip: _4, dnsiskinky: _4, dynns: _4, geekgalaxy: _4, "health-carereform": _4, homesecuritymac: _4, homesecuritypc: _4, myactivedirectory: _4, mysecuritycamera: _4, myvnc: _4, "net-freaks": _4, onthewifi: _4, point2this: _4, quicksytes: _4, securitytactics: _4, servebeer: _4, servecounterstrike: _4, serveexchange: _4, serveftp: _4, servegame: _4, servehalflife: _4, servehttp: _4, servehumour: _4, serveirc: _4, servemp3: _4, servep2p: _4, servepics: _4, servequake: _4, servesarcasm: _4, stufftoread: _4, unusualperson: _4, workisboring: _4, myiphost: _4, observableusercontent: [0, { static: _4 }], simplesite: _4, orsites: _4, operaunite: _4, "customer-oci": [0, { "*": _4, oci: _7, ocp: _7, ocs: _7 }], oraclecloudapps: _7, oraclegovcloudapps: _7, "authgear-staging": _4, authgearapps: _4, skygearapp: _4, outsystemscloud: _4, ownprovider: _4, pgfog: _4, pagexl: _4, gotpantheon: _4, paywhirl: _7, upsunapp: _4, "postman-echo": _4, prgmr: [0, { xen: _4 }], pythonanywhere: _42, qa2: _4, "alpha-myqnapcloud": _4, "dev-myqnapcloud": _4, mycloudnas: _4, mynascloud: _4, myqnapcloud: _4, qualifioapp: _4, ladesk: _4, qbuser: _4, quipelements: _7, rackmaze: _4, "readthedocs-hosted": _4, rhcloud: _4, onrender: _4, render: _43, "subsc-pay": _4, "180r": _4, dojin: _4, sakuratan: _4, sakuraweb: _4, x0: _4, code: [0, { builder: _7, "dev-builder": _7, "stg-builder": _7 }], salesforce: [0, { platform: [0, { "code-builder-stg": [0, { test: [0, { "001": _7 }] }] }] }], logoip: _4, scrysec: _4, "firewall-gateway": _4, myshopblocks: _4, myshopify: _4, shopitsite: _4, "1kapp": _4, appchizi: _4, applinzi: _4, sinaapp: _4, vipsinaapp: _4, streamlitapp: _4, "try-snowplow": _4, "playstation-cloud": _4, myspreadshop: _4, "w-corp-staticblitz": _4, "w-credentialless-staticblitz": _4, "w-staticblitz": _4, "stackhero-network": _4, stdlib: [0, { api: _4 }], strapiapp: [2, { media: _4 }], "streak-link": _4, streaklinks: _4, streakusercontent: _4, "temp-dns": _4, dsmynas: _4, familyds: _4, mytabit: _4, taveusercontent: _4, "tb-hosting": _44, reservd: _4, thingdustdata: _4, "townnews-staging": _4, typeform: [0, { pro: _4 }], hk: _4, it: _4, "deus-canvas": _4, vultrobjects: _7, wafflecell: _4, hotelwithflight: _4, "reserve-online": _4, cprapid: _4, pleskns: _4, remotewd: _4, wiardweb: [0, { pages: _4 }], wixsite: _4, wixstudio: _4, messwithdns: _4, "woltlab-demo": _4, wpenginepowered: [2, { js: _4 }], xnbay: [2, { u2: _4, "u2-local": _4 }], yolasite: _4 }], coop: _3, cr: [1, { ac: _3, co: _3, ed: _3, fi: _3, go: _3, or: _3, sa: _3 }], cu: [1, { com: _3, edu: _3, gob: _3, inf: _3, nat: _3, net: _3, org: _3 }], cv: [1, { com: _3, edu: _3, id: _3, int: _3, net: _3, nome: _3, org: _3, publ: _3 }], cw: _45, cx: [1, { gov: _3, cloudns: _4, ath: _4, info: _4, assessments: _4, calculators: _4, funnels: _4, paynow: _4, quizzes: _4, researched: _4, tests: _4 }], cy: [1, { ac: _3, biz: _3, com: [1, { scaleforce: _46 }], ekloges: _3, gov: _3, ltd: _3, mil: _3, net: _3, org: _3, press: _3, pro: _3, tm: _3 }], cz: [1, { contentproxy9: [0, { rsc: _4 }], realm: _4, e4: _4, co: _4, metacentrum: [0, { cloud: _7, custom: _4 }], muni: [0, { cloud: [0, { flt: _4, usr: _4 }] }] }], de: [1, { bplaced: _4, square7: _4, com: _4, cosidns: _47, dnsupdater: _4, "dynamisches-dns": _4, "internet-dns": _4, "l-o-g-i-n": _4, ddnss: [2, { dyn: _4, dyndns: _4 }], "dyn-ip24": _4, dyndns1: _4, "home-webserver": [2, { dyn: _4 }], "myhome-server": _4, dnshome: _4, fuettertdasnetz: _4, isteingeek: _4, istmein: _4, lebtimnetz: _4, leitungsen: _4, traeumtgerade: _4, frusky: _7, goip: _4, "xn--gnstigbestellen-zvb": _4, "gnstigbestellen": _4, "xn--gnstigliefern-wob": _4, "gnstigliefern": _4, "hs-heilbronn": [0, { it: [0, { pages: _4, "pages-research": _4 }] }], "dyn-berlin": _4, "in-berlin": _4, "in-brb": _4, "in-butter": _4, "in-dsl": _4, "in-vpn": _4, iservschule: _4, "mein-iserv": _4, schulplattform: _4, schulserver: _4, "test-iserv": _4, keymachine: _4, "git-repos": _4, "lcube-server": _4, "svn-repos": _4, barsy: _4, webspaceconfig: _4, "123webseite": _4, rub: _4, "ruhr-uni-bochum": [2, { noc: [0, { io: _4 }] }], logoip: _4, "firewall-gateway": _4, "my-gateway": _4, "my-router": _4, spdns: _4, speedpartner: [0, { customer: _4 }], myspreadshop: _4, "taifun-dns": _4, "12hp": _4, "2ix": _4, "4lima": _4, "lima-city": _4, "dd-dns": _4, "dray-dns": _4, draydns: _4, "dyn-vpn": _4, dynvpn: _4, "mein-vigor": _4, "my-vigor": _4, "my-wan": _4, "syno-ds": _4, "synology-diskstation": _4, "synology-ds": _4, uberspace: _7, "virtual-user": _4, virtualuser: _4, "community-pro": _4, diskussionsbereich: _4 }], dj: _3, dk: [1, { biz: _4, co: _4, firm: _4, reg: _4, store: _4, "123hjemmeside": _4, myspreadshop: _4 }], dm: _48, do: [1, { art: _3, com: _3, edu: _3, gob: _3, gov: _3, mil: _3, net: _3, org: _3, sld: _3, web: _3 }], dz: [1, { art: _3, asso: _3, com: _3, edu: _3, gov: _3, net: _3, org: _3, pol: _3, soc: _3, tm: _3 }], ec: [1, { com: _3, edu: _3, fin: _3, gob: _3, gov: _3, info: _3, k12: _3, med: _3, mil: _3, net: _3, org: _3, pro: _3, base: _4, official: _4 }], edu: [1, { rit: [0, { "git-pages": _4 }] }], ee: [1, { aip: _3, com: _3, edu: _3, fie: _3, gov: _3, lib: _3, med: _3, org: _3, pri: _3, riik: _3 }], eg: [1, { ac: _3, com: _3, edu: _3, eun: _3, gov: _3, info: _3, me: _3, mil: _3, name: _3, net: _3, org: _3, sci: _3, sport: _3, tv: _3 }], er: _18, es: [1, { com: _3, edu: _3, gob: _3, nom: _3, org: _3, "123miweb": _4, myspreadshop: _4 }], et: [1, { biz: _3, com: _3, edu: _3, gov: _3, info: _3, name: _3, net: _3, org: _3 }], eu: [1, { airkitapps: _4, cloudns: _4, dogado: [0, { jelastic: _4 }], barsy: _4, spdns: _4, transurl: _7, diskstation: _4 }], fi: [1, { aland: _3, dy: _4, "xn--hkkinen-5wa": _4, "hkkinen": _4, iki: _4, cloudplatform: [0, { fi: _4 }], datacenter: [0, { demo: _4, paas: _4 }], kapsi: _4, "123kotisivu": _4, myspreadshop: _4 }], fj: [1, { ac: _3, biz: _3, com: _3, gov: _3, info: _3, mil: _3, name: _3, net: _3, org: _3, pro: _3 }], fk: _18, fm: [1, { com: _3, edu: _3, net: _3, org: _3, radio: _4, user: _7 }], fo: _3, fr: [1, { asso: _3, com: _3, gouv: _3, nom: _3, prd: _3, tm: _3, avoues: _3, cci: _3, greta: _3, "huissier-justice": _3, "en-root": _4, "fbx-os": _4, fbxos: _4, "freebox-os": _4, freeboxos: _4, goupile: _4, "123siteweb": _4, "on-web": _4, "chirurgiens-dentistes-en-france": _4, dedibox: _4, aeroport: _4, avocat: _4, chambagri: _4, "chirurgiens-dentistes": _4, "experts-comptables": _4, medecin: _4, notaires: _4, pharmacien: _4, port: _4, veterinaire: _4, myspreadshop: _4, ynh: _4 }], ga: _3, gb: _3, gd: [1, { edu: _3, gov: _3 }], ge: [1, { com: _3, edu: _3, gov: _3, net: _3, org: _3, pvt: _3, school: _3 }], gf: _3, gg: [1, { co: _3, net: _3, org: _3, botdash: _4, kaas: _4, stackit: _4, panel: [2, { daemon: _4 }] }], gh: [1, { com: _3, edu: _3, gov: _3, mil: _3, org: _3 }], gi: [1, { com: _3, edu: _3, gov: _3, ltd: _3, mod: _3, org: _3 }], gl: [1, { co: _3, com: _3, edu: _3, net: _3, org: _3, biz: _4 }], gm: _3, gn: [1, { ac: _3, com: _3, edu: _3, gov: _3, net: _3, org: _3 }], gov: _3, gp: [1, { asso: _3, com: _3, edu: _3, mobi: _3, net: _3, org: _3 }], gq: _3, gr: [1, { com: _3, edu: _3, gov: _3, net: _3, org: _3, barsy: _4, simplesite: _4 }], gs: _3, gt: [1, { com: _3, edu: _3, gob: _3, ind: _3, mil: _3, net: _3, org: _3 }], gu: [1, { com: _3, edu: _3, gov: _3, guam: _3, info: _3, net: _3, org: _3, web: _3 }], gw: _3, gy: _48, hk: [1, { com: _3, edu: _3, gov: _3, idv: _3, net: _3, org: _3, "xn--ciqpn": _3, "": _3, "xn--gmqw5a": _3, "": _3, "xn--55qx5d": _3, "": _3, "xn--mxtq1m": _3, "": _3, "xn--lcvr32d": _3, "": _3, "xn--wcvs22d": _3, "": _3, "xn--gmq050i": _3, "": _3, "xn--uc0atv": _3, "": _3, "xn--uc0ay4a": _3, "": _3, "xn--od0alg": _3, "": _3, "xn--zf0avx": _3, "": _3, "xn--mk0axi": _3, "": _3, "xn--tn0ag": _3, "": _3, "xn--od0aq3b": _3, "": _3, "xn--io0a7i": _3, "": _3, inc: _4, ltd: _4 }], hm: _3, hn: [1, { com: _3, edu: _3, gob: _3, mil: _3, net: _3, org: _3 }], hr: [1, { com: _3, from: _3, iz: _3, name: _3, brendly: _51 }], ht: [1, { adult: _3, art: _3, asso: _3, com: _3, coop: _3, edu: _3, firm: _3, gouv: _3, info: _3, med: _3, net: _3, org: _3, perso: _3, pol: _3, pro: _3, rel: _3, shop: _3, rt: _4 }], hu: [1, { "2000": _3, agrar: _3, bolt: _3, casino: _3, city: _3, co: _3, erotica: _3, erotika: _3, film: _3, forum: _3, games: _3, hotel: _3, info: _3, ingatlan: _3, jogasz: _3, konyvelo: _3, lakas: _3, media: _3, news: _3, org: _3, priv: _3, reklam: _3, sex: _3, shop: _3, sport: _3, suli: _3, szex: _3, tm: _3, tozsde: _3, utazas: _3, video: _3 }], id: [1, { ac: _3, biz: _3, co: _3, desa: _3, go: _3, mil: _3, my: _3, net: _3, or: _3, ponpes: _3, sch: _3, web: _3, zone: _4 }], ie: [1, { gov: _3, myspreadshop: _4 }], il: [1, { ac: _3, co: [1, { ravpage: _4, mytabit: _4, tabitorder: _4 }], gov: _3, idf: _3, k12: _3, muni: _3, net: _3, org: _3 }], "xn--4dbrk0ce": [1, { "xn--4dbgdty6c": _3, "xn--5dbhl8d": _3, "xn--8dbq2a": _3, "xn--hebda8b": _3 }], "": [1, { "": _3, "": _3, "": _3, "": _3 }], im: [1, { ac: _3, co: [1, { ltd: _3, plc: _3 }], com: _3, net: _3, org: _3, tt: _3, tv: _3 }], in: [1, { "5g": _3, "6g": _3, ac: _3, ai: _3, am: _3, bihar: _3, biz: _3, business: _3, ca: _3, cn: _3, co: _3, com: _3, coop: _3, cs: _3, delhi: _3, dr: _3, edu: _3, er: _3, firm: _3, gen: _3, gov: _3, gujarat: _3, ind: _3, info: _3, int: _3, internet: _3, io: _3, me: _3, mil: _3, net: _3, nic: _3, org: _3, pg: _3, post: _3, pro: _3, res: _3, travel: _3, tv: _3, uk: _3, up: _3, us: _3, cloudns: _4, barsy: _4, web: _4, supabase: _4 }], info: [1, { cloudns: _4, "dynamic-dns": _4, "barrel-of-knowledge": _4, "barrell-of-knowledge": _4, dyndns: _4, "for-our": _4, "groks-the": _4, "groks-this": _4, "here-for-more": _4, knowsitall: _4, selfip: _4, webhop: _4, barsy: _4, mayfirst: _4, mittwald: _4, mittwaldserver: _4, typo3server: _4, dvrcam: _4, ilovecollege: _4, "no-ip": _4, forumz: _4, nsupdate: _4, dnsupdate: _4, "v-info": _4 }], int: [1, { eu: _3 }], io: [1, { "2038": _4, co: _3, com: _3, edu: _3, gov: _3, mil: _3, net: _3, nom: _3, org: _3, "on-acorn": _7, myaddr: _4, apigee: _4, "b-data": _4, beagleboard: _4, bitbucket: _4, bluebite: _4, boxfuse: _4, brave: _8, browsersafetymark: _4, bubble: _52, bubbleapps: _4, bigv: [0, { uk0: _4 }], cleverapps: _4, cloudbeesusercontent: _4, dappnode: [0, { dyndns: _4 }], darklang: _4, definima: _4, dedyn: _4, "fh-muenster": _4, shw: _4, forgerock: [0, { id: _4 }], github: _4, gitlab: _4, lolipop: _4, "hasura-app": _4, hostyhosting: _4, hypernode: _4, moonscale: _7, beebyte: _41, beebyteapp: [0, { sekd1: _4 }], jele: _4, webthings: _4, loginline: _4, barsy: _4, azurecontainer: _7, ngrok: [2, { ap: _4, au: _4, eu: _4, in: _4, jp: _4, sa: _4, us: _4 }], nodeart: [0, { stage: _4 }], pantheonsite: _4, pstmn: [2, { mock: _4 }], protonet: _4, qcx: [2, { sys: _7 }], qoto: _4, vaporcloud: _4, myrdbx: _4, "rb-hosting": _44, "on-k3s": _7, "on-rio": _7, readthedocs: _4, resindevice: _4, resinstaging: [0, { devices: _4 }], hzc: _4, sandcats: _4, scrypted: [0, { client: _4 }], "mo-siemens": _4, lair: _40, stolos: _7, musician: _4, utwente: _4, edugit: _4, telebit: _4, thingdust: [0, { dev: _53, disrec: _53, prod: _54, testing: _53 }], tickets: _4, webflow: _4, webflowtest: _4, editorx: _4, wixstudio: _4, basicserver: _4, virtualserver: _4 }], iq: _6, ir: [1, { ac: _3, co: _3, gov: _3, id: _3, net: _3, org: _3, sch: _3, "xn--mgba3a4f16a": _3, "": _3, "xn--mgba3a4fra": _3, "": _3, arvanedge: _4 }], is: _3, it: [1, { edu: _3, gov: _3, abr: _3, abruzzo: _3, "aosta-valley": _3, aostavalley: _3, bas: _3, basilicata: _3, cal: _3, calabria: _3, cam: _3, campania: _3, "emilia-romagna": _3, emiliaromagna: _3, emr: _3, "friuli-v-giulia": _3, "friuli-ve-giulia": _3, "friuli-vegiulia": _3, "friuli-venezia-giulia": _3, "friuli-veneziagiulia": _3, "friuli-vgiulia": _3, "friuliv-giulia": _3, "friulive-giulia": _3, friulivegiulia: _3, "friulivenezia-giulia": _3, friuliveneziagiulia: _3, friulivgiulia: _3, fvg: _3, laz: _3, lazio: _3, lig: _3, liguria: _3, lom: _3, lombardia: _3, lombardy: _3, lucania: _3, mar: _3, marche: _3, mol: _3, molise: _3, piedmont: _3, piemonte: _3, pmn: _3, pug: _3, puglia: _3, sar: _3, sardegna: _3, sardinia: _3, sic: _3, sicilia: _3, sicily: _3, taa: _3, tos: _3, toscana: _3, "trentin-sud-tirol": _3, "xn--trentin-sd-tirol-rzb": _3, "trentin-sd-tirol": _3, "trentin-sudtirol": _3, "xn--trentin-sdtirol-7vb": _3, "trentin-sdtirol": _3, "trentin-sued-tirol": _3, "trentin-suedtirol": _3, trentino: _3, "trentino-a-adige": _3, "trentino-aadige": _3, "trentino-alto-adige": _3, "trentino-altoadige": _3, "trentino-s-tirol": _3, "trentino-stirol": _3, "trentino-sud-tirol": _3, "xn--trentino-sd-tirol-c3b": _3, "trentino-sd-tirol": _3, "trentino-sudtirol": _3, "xn--trentino-sdtirol-szb": _3, "trentino-sdtirol": _3, "trentino-sued-tirol": _3, "trentino-suedtirol": _3, "trentinoa-adige": _3, trentinoaadige: _3, "trentinoalto-adige": _3, trentinoaltoadige: _3, "trentinos-tirol": _3, trentinostirol: _3, "trentinosud-tirol": _3, "xn--trentinosd-tirol-rzb": _3, "trentinosd-tirol": _3, trentinosudtirol: _3, "xn--trentinosdtirol-7vb": _3, "trentinosdtirol": _3, "trentinosued-tirol": _3, trentinosuedtirol: _3, "trentinsud-tirol": _3, "xn--trentinsd-tirol-6vb": _3, "trentinsd-tirol": _3, trentinsudtirol: _3, "xn--trentinsdtirol-nsb": _3, "trentinsdtirol": _3, "trentinsued-tirol": _3, trentinsuedtirol: _3, tuscany: _3, umb: _3, umbria: _3, "val-d-aosta": _3, "val-daosta": _3, "vald-aosta": _3, valdaosta: _3, "valle-aosta": _3, "valle-d-aosta": _3, "valle-daosta": _3, valleaosta: _3, "valled-aosta": _3, valledaosta: _3, "vallee-aoste": _3, "xn--valle-aoste-ebb": _3, "valle-aoste": _3, "vallee-d-aoste": _3, "xn--valle-d-aoste-ehb": _3, "valle-d-aoste": _3, valleeaoste: _3, "xn--valleaoste-e7a": _3, "valleaoste": _3, valleedaoste: _3, "xn--valledaoste-ebb": _3, "valledaoste": _3, vao: _3, vda: _3, ven: _3, veneto: _3, ag: _3, agrigento: _3, al: _3, alessandria: _3, "alto-adige": _3, altoadige: _3, an: _3, ancona: _3, "andria-barletta-trani": _3, "andria-trani-barletta": _3, andriabarlettatrani: _3, andriatranibarletta: _3, ao: _3, aosta: _3, aoste: _3, ap: _3, aq: _3, aquila: _3, ar: _3, arezzo: _3, "ascoli-piceno": _3, ascolipiceno: _3, asti: _3, at: _3, av: _3, avellino: _3, ba: _3, balsan: _3, "balsan-sudtirol": _3, "xn--balsan-sdtirol-nsb": _3, "balsan-sdtirol": _3, "balsan-suedtirol": _3, bari: _3, "barletta-trani-andria": _3, barlettatraniandria: _3, belluno: _3, benevento: _3, bergamo: _3, bg: _3, bi: _3, biella: _3, bl: _3, bn: _3, bo: _3, bologna: _3, bolzano: _3, "bolzano-altoadige": _3, bozen: _3, "bozen-sudtirol": _3, "xn--bozen-sdtirol-2ob": _3, "bozen-sdtirol": _3, "bozen-suedtirol": _3, br: _3, brescia: _3, brindisi: _3, bs: _3, bt: _3, bulsan: _3, "bulsan-sudtirol": _3, "xn--bulsan-sdtirol-nsb": _3, "bulsan-sdtirol": _3, "bulsan-suedtirol": _3, bz: _3, ca: _3, cagliari: _3, caltanissetta: _3, "campidano-medio": _3, campidanomedio: _3, campobasso: _3, "carbonia-iglesias": _3, carboniaiglesias: _3, "carrara-massa": _3, carraramassa: _3, caserta: _3, catania: _3, catanzaro: _3, cb: _3, ce: _3, "cesena-forli": _3, "xn--cesena-forl-mcb": _3, "cesena-forl": _3, cesenaforli: _3, "xn--cesenaforl-i8a": _3, "cesenaforl": _3, ch: _3, chieti: _3, ci: _3, cl: _3, cn: _3, co: _3, como: _3, cosenza: _3, cr: _3, cremona: _3, crotone: _3, cs: _3, ct: _3, cuneo: _3, cz: _3, "dell-ogliastra": _3, dellogliastra: _3, en: _3, enna: _3, fc: _3, fe: _3, fermo: _3, ferrara: _3, fg: _3, fi: _3, firenze: _3, florence: _3, fm: _3, foggia: _3, "forli-cesena": _3, "xn--forl-cesena-fcb": _3, "forl-cesena": _3, forlicesena: _3, "xn--forlcesena-c8a": _3, "forlcesena": _3, fr: _3, frosinone: _3, ge: _3, genoa: _3, genova: _3, go: _3, gorizia: _3, gr: _3, grosseto: _3, "iglesias-carbonia": _3, iglesiascarbonia: _3, im: _3, imperia: _3, is: _3, isernia: _3, kr: _3, "la-spezia": _3, laquila: _3, laspezia: _3, latina: _3, lc: _3, le: _3, lecce: _3, lecco: _3, li: _3, livorno: _3, lo: _3, lodi: _3, lt: _3, lu: _3, lucca: _3, macerata: _3, mantova: _3, "massa-carrara": _3, massacarrara: _3, matera: _3, mb: _3, mc: _3, me: _3, "medio-campidano": _3, mediocampidano: _3, messina: _3, mi: _3, milan: _3, milano: _3, mn: _3, mo: _3, modena: _3, monza: _3, "monza-brianza": _3, "monza-e-della-brianza": _3, monzabrianza: _3, monzaebrianza: _3, monzaedellabrianza: _3, ms: _3, mt: _3, na: _3, naples: _3, napoli: _3, no: _3, novara: _3, nu: _3, nuoro: _3, og: _3, ogliastra: _3, "olbia-tempio": _3, olbiatempio: _3, or: _3, oristano: _3, ot: _3, pa: _3, padova: _3, padua: _3, palermo: _3, parma: _3, pavia: _3, pc: _3, pd: _3, pe: _3, perugia: _3, "pesaro-urbino": _3, pesarourbino: _3, pescara: _3, pg: _3, pi: _3, piacenza: _3, pisa: _3, pistoia: _3, pn: _3, po: _3, pordenone: _3, potenza: _3, pr: _3, prato: _3, pt: _3, pu: _3, pv: _3, pz: _3, ra: _3, ragusa: _3, ravenna: _3, rc: _3, re: _3, "reggio-calabria": _3, "reggio-emilia": _3, reggiocalabria: _3, reggioemilia: _3, rg: _3, ri: _3, rieti: _3, rimini: _3, rm: _3, rn: _3, ro: _3, roma: _3, rome: _3, rovigo: _3, sa: _3, salerno: _3, sassari: _3, savona: _3, si: _3, siena: _3, siracusa: _3, so: _3, sondrio: _3, sp: _3, sr: _3, ss: _3, "xn--sdtirol-n2a": _3, "sdtirol": _3, suedtirol: _3, sv: _3, ta: _3, taranto: _3, te: _3, "tempio-olbia": _3, tempioolbia: _3, teramo: _3, terni: _3, tn: _3, to: _3, torino: _3, tp: _3, tr: _3, "trani-andria-barletta": _3, "trani-barletta-andria": _3, traniandriabarletta: _3, tranibarlettaandria: _3, trapani: _3, trento: _3, treviso: _3, trieste: _3, ts: _3, turin: _3, tv: _3, ud: _3, udine: _3, "urbino-pesaro": _3, urbinopesaro: _3, va: _3, varese: _3, vb: _3, vc: _3, ve: _3, venezia: _3, venice: _3, verbania: _3, vercelli: _3, verona: _3, vi: _3, "vibo-valentia": _3, vibovalentia: _3, vicenza: _3, viterbo: _3, vr: _3, vs: _3, vt: _3, vv: _3, "12chars": _4, ibxos: _4, iliadboxos: _4, neen: [0, { jc: _4 }], "123homepage": _4, "16-b": _4, "32-b": _4, "64-b": _4, myspreadshop: _4, syncloud: _4 }], je: [1, { co: _3, net: _3, org: _3, of: _4 }], jm: _18, jo: [1, { agri: _3, ai: _3, com: _3, edu: _3, eng: _3, fm: _3, gov: _3, mil: _3, net: _3, org: _3, per: _3, phd: _3, sch: _3, tv: _3 }], jobs: _3, jp: [1, { ac: _3, ad: _3, co: _3, ed: _3, go: _3, gr: _3, lg: _3, ne: [1, { aseinet: _50, gehirn: _4, ivory: _4, "mail-box": _4, mints: _4, mokuren: _4, opal: _4, sakura: _4, sumomo: _4, topaz: _4 }], or: _3, aichi: [1, { aisai: _3, ama: _3, anjo: _3, asuke: _3, chiryu: _3, chita: _3, fuso: _3, gamagori: _3, handa: _3, hazu: _3, hekinan: _3, higashiura: _3, ichinomiya: _3, inazawa: _3, inuyama: _3, isshiki: _3, iwakura: _3, kanie: _3, kariya: _3, kasugai: _3, kira: _3, kiyosu: _3, komaki: _3, konan: _3, kota: _3, mihama: _3, miyoshi: _3, nishio: _3, nisshin: _3, obu: _3, oguchi: _3, oharu: _3, okazaki: _3, owariasahi: _3, seto: _3, shikatsu: _3, shinshiro: _3, shitara: _3, tahara: _3, takahama: _3, tobishima: _3, toei: _3, togo: _3, tokai: _3, tokoname: _3, toyoake: _3, toyohashi: _3, toyokawa: _3, toyone: _3, toyota: _3, tsushima: _3, yatomi: _3 }], akita: [1, { akita: _3, daisen: _3, fujisato: _3, gojome: _3, hachirogata: _3, happou: _3, higashinaruse: _3, honjo: _3, honjyo: _3, ikawa: _3, kamikoani: _3, kamioka: _3, katagami: _3, kazuno: _3, kitaakita: _3, kosaka: _3, kyowa: _3, misato: _3, mitane: _3, moriyoshi: _3, nikaho: _3, noshiro: _3, odate: _3, oga: _3, ogata: _3, semboku: _3, yokote: _3, yurihonjo: _3 }], aomori: [1, { aomori: _3, gonohe: _3, hachinohe: _3, hashikami: _3, hiranai: _3, hirosaki: _3, itayanagi: _3, kuroishi: _3, misawa: _3, mutsu: _3, nakadomari: _3, noheji: _3, oirase: _3, owani: _3, rokunohe: _3, sannohe: _3, shichinohe: _3, shingo: _3, takko: _3, towada: _3, tsugaru: _3, tsuruta: _3 }], chiba: [1, { abiko: _3, asahi: _3, chonan: _3, chosei: _3, choshi: _3, chuo: _3, funabashi: _3, futtsu: _3, hanamigawa: _3, ichihara: _3, ichikawa: _3, ichinomiya: _3, inzai: _3, isumi: _3, kamagaya: _3, kamogawa: _3, kashiwa: _3, katori: _3, katsuura: _3, kimitsu: _3, kisarazu: _3, kozaki: _3, kujukuri: _3, kyonan: _3, matsudo: _3, midori: _3, mihama: _3, minamiboso: _3, mobara: _3, mutsuzawa: _3, nagara: _3, nagareyama: _3, narashino: _3, narita: _3, noda: _3, oamishirasato: _3, omigawa: _3, onjuku: _3, otaki: _3, sakae: _3, sakura: _3, shimofusa: _3, shirako: _3, shiroi: _3, shisui: _3, sodegaura: _3, sosa: _3, tako: _3, tateyama: _3, togane: _3, tohnosho: _3, tomisato: _3, urayasu: _3, yachimata: _3, yachiyo: _3, yokaichiba: _3, yokoshibahikari: _3, yotsukaido: _3 }], ehime: [1, { ainan: _3, honai: _3, ikata: _3, imabari: _3, iyo: _3, kamijima: _3, kihoku: _3, kumakogen: _3, masaki: _3, matsuno: _3, matsuyama: _3, namikata: _3, niihama: _3, ozu: _3, saijo: _3, seiyo: _3, shikokuchuo: _3, tobe: _3, toon: _3, uchiko: _3, uwajima: _3, yawatahama: _3 }], fukui: [1, { echizen: _3, eiheiji: _3, fukui: _3, ikeda: _3, katsuyama: _3, mihama: _3, minamiechizen: _3, obama: _3, ohi: _3, ono: _3, sabae: _3, sakai: _3, takahama: _3, tsuruga: _3, wakasa: _3 }], fukuoka: [1, { ashiya: _3, buzen: _3, chikugo: _3, chikuho: _3, chikujo: _3, chikushino: _3, chikuzen: _3, chuo: _3, dazaifu: _3, fukuchi: _3, hakata: _3, higashi: _3, hirokawa: _3, hisayama: _3, iizuka: _3, inatsuki: _3, kaho: _3, kasuga: _3, kasuya: _3, kawara: _3, keisen: _3, koga: _3, kurate: _3, kurogi: _3, kurume: _3, minami: _3, miyako: _3, miyama: _3, miyawaka: _3, mizumaki: _3, munakata: _3, nakagawa: _3, nakama: _3, nishi: _3, nogata: _3, ogori: _3, okagaki: _3, okawa: _3, oki: _3, omuta: _3, onga: _3, onojo: _3, oto: _3, saigawa: _3, sasaguri: _3, shingu: _3, shinyoshitomi: _3, shonai: _3, soeda: _3, sue: _3, tachiarai: _3, tagawa: _3, takata: _3, toho: _3, toyotsu: _3, tsuiki: _3, ukiha: _3, umi: _3, usui: _3, yamada: _3, yame: _3, yanagawa: _3, yukuhashi: _3 }], fukushima: [1, { aizubange: _3, aizumisato: _3, aizuwakamatsu: _3, asakawa: _3, bandai: _3, date: _3, fukushima: _3, furudono: _3, futaba: _3, hanawa: _3, higashi: _3, hirata: _3, hirono: _3, iitate: _3, inawashiro: _3, ishikawa: _3, iwaki: _3, izumizaki: _3, kagamiishi: _3, kaneyama: _3, kawamata: _3, kitakata: _3, kitashiobara: _3, koori: _3, koriyama: _3, kunimi: _3, miharu: _3, mishima: _3, namie: _3, nango: _3, nishiaizu: _3, nishigo: _3, okuma: _3, omotego: _3, ono: _3, otama: _3, samegawa: _3, shimogo: _3, shirakawa: _3, showa: _3, soma: _3, sukagawa: _3, taishin: _3, tamakawa: _3, tanagura: _3, tenei: _3, yabuki: _3, yamato: _3, yamatsuri: _3, yanaizu: _3, yugawa: _3 }], gifu: [1, { anpachi: _3, ena: _3, gifu: _3, ginan: _3, godo: _3, gujo: _3, hashima: _3, hichiso: _3, hida: _3, higashishirakawa: _3, ibigawa: _3, ikeda: _3, kakamigahara: _3, kani: _3, kasahara: _3, kasamatsu: _3, kawaue: _3, kitagata: _3, mino: _3, minokamo: _3, mitake: _3, mizunami: _3, motosu: _3, nakatsugawa: _3, ogaki: _3, sakahogi: _3, seki: _3, sekigahara: _3, shirakawa: _3, tajimi: _3, takayama: _3, tarui: _3, toki: _3, tomika: _3, wanouchi: _3, yamagata: _3, yaotsu: _3, yoro: _3 }], gunma: [1, { annaka: _3, chiyoda: _3, fujioka: _3, higashiagatsuma: _3, isesaki: _3, itakura: _3, kanna: _3, kanra: _3, katashina: _3, kawaba: _3, kiryu: _3, kusatsu: _3, maebashi: _3, meiwa: _3, midori: _3, minakami: _3, naganohara: _3, nakanojo: _3, nanmoku: _3, numata: _3, oizumi: _3, ora: _3, ota: _3, shibukawa: _3, shimonita: _3, shinto: _3, showa: _3, takasaki: _3, takayama: _3, tamamura: _3, tatebayashi: _3, tomioka: _3, tsukiyono: _3, tsumagoi: _3, ueno: _3, yoshioka: _3 }], hiroshima: [1, { asaminami: _3, daiwa: _3, etajima: _3, fuchu: _3, fukuyama: _3, hatsukaichi: _3, higashihiroshima: _3, hongo: _3, jinsekikogen: _3, kaita: _3, kui: _3, kumano: _3, kure: _3, mihara: _3, miyoshi: _3, naka: _3, onomichi: _3, osakikamijima: _3, otake: _3, saka: _3, sera: _3, seranishi: _3, shinichi: _3, shobara: _3, takehara: _3 }], hokkaido: [1, { abashiri: _3, abira: _3, aibetsu: _3, akabira: _3, akkeshi: _3, asahikawa: _3, ashibetsu: _3, ashoro: _3, assabu: _3, atsuma: _3, bibai: _3, biei: _3, bifuka: _3, bihoro: _3, biratori: _3, chippubetsu: _3, chitose: _3, date: _3, ebetsu: _3, embetsu: _3, eniwa: _3, erimo: _3, esan: _3, esashi: _3, fukagawa: _3, fukushima: _3, furano: _3, furubira: _3, haboro: _3, hakodate: _3, hamatonbetsu: _3, hidaka: _3, higashikagura: _3, higashikawa: _3, hiroo: _3, hokuryu: _3, hokuto: _3, honbetsu: _3, horokanai: _3, horonobe: _3, ikeda: _3, imakane: _3, ishikari: _3, iwamizawa: _3, iwanai: _3, kamifurano: _3, kamikawa: _3, kamishihoro: _3, kamisunagawa: _3, kamoenai: _3, kayabe: _3, kembuchi: _3, kikonai: _3, kimobetsu: _3, kitahiroshima: _3, kitami: _3, kiyosato: _3, koshimizu: _3, kunneppu: _3, kuriyama: _3, kuromatsunai: _3, kushiro: _3, kutchan: _3, kyowa: _3, mashike: _3, matsumae: _3, mikasa: _3, minamifurano: _3, mombetsu: _3, moseushi: _3, mukawa: _3, muroran: _3, naie: _3, nakagawa: _3, nakasatsunai: _3, nakatombetsu: _3, nanae: _3, nanporo: _3, nayoro: _3, nemuro: _3, niikappu: _3, niki: _3, nishiokoppe: _3, noboribetsu: _3, numata: _3, obihiro: _3, obira: _3, oketo: _3, okoppe: _3, otaru: _3, otobe: _3, otofuke: _3, otoineppu: _3, oumu: _3, ozora: _3, pippu: _3, rankoshi: _3, rebun: _3, rikubetsu: _3, rishiri: _3, rishirifuji: _3, saroma: _3, sarufutsu: _3, shakotan: _3, shari: _3, shibecha: _3, shibetsu: _3, shikabe: _3, shikaoi: _3, shimamaki: _3, shimizu: _3, shimokawa: _3, shinshinotsu: _3, shintoku: _3, shiranuka: _3, shiraoi: _3, shiriuchi: _3, sobetsu: _3, sunagawa: _3, taiki: _3, takasu: _3, takikawa: _3, takinoue: _3, teshikaga: _3, tobetsu: _3, tohma: _3, tomakomai: _3, tomari: _3, toya: _3, toyako: _3, toyotomi: _3, toyoura: _3, tsubetsu: _3, tsukigata: _3, urakawa: _3, urausu: _3, uryu: _3, utashinai: _3, wakkanai: _3, wassamu: _3, yakumo: _3, yoichi: _3 }], hyogo: [1, { aioi: _3, akashi: _3, ako: _3, amagasaki: _3, aogaki: _3, asago: _3, ashiya: _3, awaji: _3, fukusaki: _3, goshiki: _3, harima: _3, himeji: _3, ichikawa: _3, inagawa: _3, itami: _3, kakogawa: _3, kamigori: _3, kamikawa: _3, kasai: _3, kasuga: _3, kawanishi: _3, miki: _3, minamiawaji: _3, nishinomiya: _3, nishiwaki: _3, ono: _3, sanda: _3, sannan: _3, sasayama: _3, sayo: _3, shingu: _3, shinonsen: _3, shiso: _3, sumoto: _3, taishi: _3, taka: _3, takarazuka: _3, takasago: _3, takino: _3, tamba: _3, tatsuno: _3, toyooka: _3, yabu: _3, yashiro: _3, yoka: _3, yokawa: _3 }], ibaraki: [1, { ami: _3, asahi: _3, bando: _3, chikusei: _3, daigo: _3, fujishiro: _3, hitachi: _3, hitachinaka: _3, hitachiomiya: _3, hitachiota: _3, ibaraki: _3, ina: _3, inashiki: _3, itako: _3, iwama: _3, joso: _3, kamisu: _3, kasama: _3, kashima: _3, kasumigaura: _3, koga: _3, miho: _3, mito: _3, moriya: _3, naka: _3, namegata: _3, oarai: _3, ogawa: _3, omitama: _3, ryugasaki: _3, sakai: _3, sakuragawa: _3, shimodate: _3, shimotsuma: _3, shirosato: _3, sowa: _3, suifu: _3, takahagi: _3, tamatsukuri: _3, tokai: _3, tomobe: _3, tone: _3, toride: _3, tsuchiura: _3, tsukuba: _3, uchihara: _3, ushiku: _3, yachiyo: _3, yamagata: _3, yawara: _3, yuki: _3 }], ishikawa: [1, { anamizu: _3, hakui: _3, hakusan: _3, kaga: _3, kahoku: _3, kanazawa: _3, kawakita: _3, komatsu: _3, nakanoto: _3, nanao: _3, nomi: _3, nonoichi: _3, noto: _3, shika: _3, suzu: _3, tsubata: _3, tsurugi: _3, uchinada: _3, wajima: _3 }], iwate: [1, { fudai: _3, fujisawa: _3, hanamaki: _3, hiraizumi: _3, hirono: _3, ichinohe: _3, ichinoseki: _3, iwaizumi: _3, iwate: _3, joboji: _3, kamaishi: _3, kanegasaki: _3, karumai: _3, kawai: _3, kitakami: _3, kuji: _3, kunohe: _3, kuzumaki: _3, miyako: _3, mizusawa: _3, morioka: _3, ninohe: _3, noda: _3, ofunato: _3, oshu: _3, otsuchi: _3, rikuzentakata: _3, shiwa: _3, shizukuishi: _3, sumita: _3, tanohata: _3, tono: _3, yahaba: _3, yamada: _3 }], kagawa: [1, { ayagawa: _3, higashikagawa: _3, kanonji: _3, kotohira: _3, manno: _3, marugame: _3, mitoyo: _3, naoshima: _3, sanuki: _3, tadotsu: _3, takamatsu: _3, tonosho: _3, uchinomi: _3, utazu: _3, zentsuji: _3 }], kagoshima: [1, { akune: _3, amami: _3, hioki: _3, isa: _3, isen: _3, izumi: _3, kagoshima: _3, kanoya: _3, kawanabe: _3, kinko: _3, kouyama: _3, makurazaki: _3, matsumoto: _3, minamitane: _3, nakatane: _3, nishinoomote: _3, satsumasendai: _3, soo: _3, tarumizu: _3, yusui: _3 }], kanagawa: [1, { aikawa: _3, atsugi: _3, ayase: _3, chigasaki: _3, ebina: _3, fujisawa: _3, hadano: _3, hakone: _3, hiratsuka: _3, isehara: _3, kaisei: _3, kamakura: _3, kiyokawa: _3, matsuda: _3, minamiashigara: _3, miura: _3, nakai: _3, ninomiya: _3, odawara: _3, oi: _3, oiso: _3, sagamihara: _3, samukawa: _3, tsukui: _3, yamakita: _3, yamato: _3, yokosuka: _3, yugawara: _3, zama: _3, zushi: _3 }], kochi: [1, { aki: _3, geisei: _3, hidaka: _3, higashitsuno: _3, ino: _3, kagami: _3, kami: _3, kitagawa: _3, kochi: _3, mihara: _3, motoyama: _3, muroto: _3, nahari: _3, nakamura: _3, nankoku: _3, nishitosa: _3, niyodogawa: _3, ochi: _3, okawa: _3, otoyo: _3, otsuki: _3, sakawa: _3, sukumo: _3, susaki: _3, tosa: _3, tosashimizu: _3, toyo: _3, tsuno: _3, umaji: _3, yasuda: _3, yusuhara: _3 }], kumamoto: [1, { amakusa: _3, arao: _3, aso: _3, choyo: _3, gyokuto: _3, kamiamakusa: _3, kikuchi: _3, kumamoto: _3, mashiki: _3, mifune: _3, minamata: _3, minamioguni: _3, nagasu: _3, nishihara: _3, oguni: _3, ozu: _3, sumoto: _3, takamori: _3, uki: _3, uto: _3, yamaga: _3, yamato: _3, yatsushiro: _3 }], kyoto: [1, { ayabe: _3, fukuchiyama: _3, higashiyama: _3, ide: _3, ine: _3, joyo: _3, kameoka: _3, kamo: _3, kita: _3, kizu: _3, kumiyama: _3, kyotamba: _3, kyotanabe: _3, kyotango: _3, maizuru: _3, minami: _3, minamiyamashiro: _3, miyazu: _3, muko: _3, nagaokakyo: _3, nakagyo: _3, nantan: _3, oyamazaki: _3, sakyo: _3, seika: _3, tanabe: _3, uji: _3, ujitawara: _3, wazuka: _3, yamashina: _3, yawata: _3 }], mie: [1, { asahi: _3, inabe: _3, ise: _3, kameyama: _3, kawagoe: _3, kiho: _3, kisosaki: _3, kiwa: _3, komono: _3, kumano: _3, kuwana: _3, matsusaka: _3, meiwa: _3, mihama: _3, minamiise: _3, misugi: _3, miyama: _3, nabari: _3, shima: _3, suzuka: _3, tado: _3, taiki: _3, taki: _3, tamaki: _3, toba: _3, tsu: _3, udono: _3, ureshino: _3, watarai: _3, yokkaichi: _3 }], miyagi: [1, { furukawa: _3, higashimatsushima: _3, ishinomaki: _3, iwanuma: _3, kakuda: _3, kami: _3, kawasaki: _3, marumori: _3, matsushima: _3, minamisanriku: _3, misato: _3, murata: _3, natori: _3, ogawara: _3, ohira: _3, onagawa: _3, osaki: _3, rifu: _3, semine: _3, shibata: _3, shichikashuku: _3, shikama: _3, shiogama: _3, shiroishi: _3, tagajo: _3, taiwa: _3, tome: _3, tomiya: _3, wakuya: _3, watari: _3, yamamoto: _3, zao: _3 }], miyazaki: [1, { aya: _3, ebino: _3, gokase: _3, hyuga: _3, kadogawa: _3, kawaminami: _3, kijo: _3, kitagawa: _3, kitakata: _3, kitaura: _3, kobayashi: _3, kunitomi: _3, kushima: _3, mimata: _3, miyakonojo: _3, miyazaki: _3, morotsuka: _3, nichinan: _3, nishimera: _3, nobeoka: _3, saito: _3, shiiba: _3, shintomi: _3, takaharu: _3, takanabe: _3, takazaki: _3, tsuno: _3 }], nagano: [1, { achi: _3, agematsu: _3, anan: _3, aoki: _3, asahi: _3, azumino: _3, chikuhoku: _3, chikuma: _3, chino: _3, fujimi: _3, hakuba: _3, hara: _3, hiraya: _3, iida: _3, iijima: _3, iiyama: _3, iizuna: _3, ikeda: _3, ikusaka: _3, ina: _3, karuizawa: _3, kawakami: _3, kiso: _3, kisofukushima: _3, kitaaiki: _3, komagane: _3, komoro: _3, matsukawa: _3, matsumoto: _3, miasa: _3, minamiaiki: _3, minamimaki: _3, minamiminowa: _3, minowa: _3, miyada: _3, miyota: _3, mochizuki: _3, nagano: _3, nagawa: _3, nagiso: _3, nakagawa: _3, nakano: _3, nozawaonsen: _3, obuse: _3, ogawa: _3, okaya: _3, omachi: _3, omi: _3, ookuwa: _3, ooshika: _3, otaki: _3, otari: _3, sakae: _3, sakaki: _3, saku: _3, sakuho: _3, shimosuwa: _3, shinanomachi: _3, shiojiri: _3, suwa: _3, suzaka: _3, takagi: _3, takamori: _3, takayama: _3, tateshina: _3, tatsuno: _3, togakushi: _3, togura: _3, tomi: _3, ueda: _3, wada: _3, yamagata: _3, yamanouchi: _3, yasaka: _3, yasuoka: _3 }], nagasaki: [1, { chijiwa: _3, futsu: _3, goto: _3, hasami: _3, hirado: _3, iki: _3, isahaya: _3, kawatana: _3, kuchinotsu: _3, matsuura: _3, nagasaki: _3, obama: _3, omura: _3, oseto: _3, saikai: _3, sasebo: _3, seihi: _3, shimabara: _3, shinkamigoto: _3, togitsu: _3, tsushima: _3, unzen: _3 }], nara: [1, { ando: _3, gose: _3, heguri: _3, higashiyoshino: _3, ikaruga: _3, ikoma: _3, kamikitayama: _3, kanmaki: _3, kashiba: _3, kashihara: _3, katsuragi: _3, kawai: _3, kawakami: _3, kawanishi: _3, koryo: _3, kurotaki: _3, mitsue: _3, miyake: _3, nara: _3, nosegawa: _3, oji: _3, ouda: _3, oyodo: _3, sakurai: _3, sango: _3, shimoichi: _3, shimokitayama: _3, shinjo: _3, soni: _3, takatori: _3, tawaramoto: _3, tenkawa: _3, tenri: _3, uda: _3, yamatokoriyama: _3, yamatotakada: _3, yamazoe: _3, yoshino: _3 }], niigata: [1, { aga: _3, agano: _3, gosen: _3, itoigawa: _3, izumozaki: _3, joetsu: _3, kamo: _3, kariwa: _3, kashiwazaki: _3, minamiuonuma: _3, mitsuke: _3, muika: _3, murakami: _3, myoko: _3, nagaoka: _3, niigata: _3, ojiya: _3, omi: _3, sado: _3, sanjo: _3, seiro: _3, seirou: _3, sekikawa: _3, shibata: _3, tagami: _3, tainai: _3, tochio: _3, tokamachi: _3, tsubame: _3, tsunan: _3, uonuma: _3, yahiko: _3, yoita: _3, yuzawa: _3 }], oita: [1, { beppu: _3, bungoono: _3, bungotakada: _3, hasama: _3, hiji: _3, himeshima: _3, hita: _3, kamitsue: _3, kokonoe: _3, kuju: _3, kunisaki: _3, kusu: _3, oita: _3, saiki: _3, taketa: _3, tsukumi: _3, usa: _3, usuki: _3, yufu: _3 }], okayama: [1, { akaiwa: _3, asakuchi: _3, bizen: _3, hayashima: _3, ibara: _3, kagamino: _3, kasaoka: _3, kibichuo: _3, kumenan: _3, kurashiki: _3, maniwa: _3, misaki: _3, nagi: _3, niimi: _3, nishiawakura: _3, okayama: _3, satosho: _3, setouchi: _3, shinjo: _3, shoo: _3, soja: _3, takahashi: _3, tamano: _3, tsuyama: _3, wake: _3, yakage: _3 }], okinawa: [1, { aguni: _3, ginowan: _3, ginoza: _3, gushikami: _3, haebaru: _3, higashi: _3, hirara: _3, iheya: _3, ishigaki: _3, ishikawa: _3, itoman: _3, izena: _3, kadena: _3, kin: _3, kitadaito: _3, kitanakagusuku: _3, kumejima: _3, kunigami: _3, minamidaito: _3, motobu: _3, nago: _3, naha: _3, nakagusuku: _3, nakijin: _3, nanjo: _3, nishihara: _3, ogimi: _3, okinawa: _3, onna: _3, shimoji: _3, taketomi: _3, tarama: _3, tokashiki: _3, tomigusuku: _3, tonaki: _3, urasoe: _3, uruma: _3, yaese: _3, yomitan: _3, yonabaru: _3, yonaguni: _3, zamami: _3 }], osaka: [1, { abeno: _3, chihayaakasaka: _3, chuo: _3, daito: _3, fujiidera: _3, habikino: _3, hannan: _3, higashiosaka: _3, higashisumiyoshi: _3, higashiyodogawa: _3, hirakata: _3, ibaraki: _3, ikeda: _3, izumi: _3, izumiotsu: _3, izumisano: _3, kadoma: _3, kaizuka: _3, kanan: _3, kashiwara: _3, katano: _3, kawachinagano: _3, kishiwada: _3, kita: _3, kumatori: _3, matsubara: _3, minato: _3, minoh: _3, misaki: _3, moriguchi: _3, neyagawa: _3, nishi: _3, nose: _3, osakasayama: _3, sakai: _3, sayama: _3, sennan: _3, settsu: _3, shijonawate: _3, shimamoto: _3, suita: _3, tadaoka: _3, taishi: _3, tajiri: _3, takaishi: _3, takatsuki: _3, tondabayashi: _3, toyonaka: _3, toyono: _3, yao: _3 }], saga: [1, { ariake: _3, arita: _3, fukudomi: _3, genkai: _3, hamatama: _3, hizen: _3, imari: _3, kamimine: _3, kanzaki: _3, karatsu: _3, kashima: _3, kitagata: _3, kitahata: _3, kiyama: _3, kouhoku: _3, kyuragi: _3, nishiarita: _3, ogi: _3, omachi: _3, ouchi: _3, saga: _3, shiroishi: _3, taku: _3, tara: _3, tosu: _3, yoshinogari: _3 }], saitama: [1, { arakawa: _3, asaka: _3, chichibu: _3, fujimi: _3, fujimino: _3, fukaya: _3, hanno: _3, hanyu: _3, hasuda: _3, hatogaya: _3, hatoyama: _3, hidaka: _3, higashichichibu: _3, higashimatsuyama: _3, honjo: _3, ina: _3, iruma: _3, iwatsuki: _3, kamiizumi: _3, kamikawa: _3, kamisato: _3, kasukabe: _3, kawagoe: _3, kawaguchi: _3, kawajima: _3, kazo: _3, kitamoto: _3, koshigaya: _3, kounosu: _3, kuki: _3, kumagaya: _3, matsubushi: _3, minano: _3, misato: _3, miyashiro: _3, miyoshi: _3, moroyama: _3, nagatoro: _3, namegawa: _3, niiza: _3, ogano: _3, ogawa: _3, ogose: _3, okegawa: _3, omiya: _3, otaki: _3, ranzan: _3, ryokami: _3, saitama: _3, sakado: _3, satte: _3, sayama: _3, shiki: _3, shiraoka: _3, soka: _3, sugito: _3, toda: _3, tokigawa: _3, tokorozawa: _3, tsurugashima: _3, urawa: _3, warabi: _3, yashio: _3, yokoze: _3, yono: _3, yorii: _3, yoshida: _3, yoshikawa: _3, yoshimi: _3 }], shiga: [1, { aisho: _3, gamo: _3, higashiomi: _3, hikone: _3, koka: _3, konan: _3, kosei: _3, koto: _3, kusatsu: _3, maibara: _3, moriyama: _3, nagahama: _3, nishiazai: _3, notogawa: _3, omihachiman: _3, otsu: _3, ritto: _3, ryuoh: _3, takashima: _3, takatsuki: _3, torahime: _3, toyosato: _3, yasu: _3 }], shimane: [1, { akagi: _3, ama: _3, gotsu: _3, hamada: _3, higashiizumo: _3, hikawa: _3, hikimi: _3, izumo: _3, kakinoki: _3, masuda: _3, matsue: _3, misato: _3, nishinoshima: _3, ohda: _3, okinoshima: _3, okuizumo: _3, shimane: _3, tamayu: _3, tsuwano: _3, unnan: _3, yakumo: _3, yasugi: _3, yatsuka: _3 }], shizuoka: [1, { arai: _3, atami: _3, fuji: _3, fujieda: _3, fujikawa: _3, fujinomiya: _3, fukuroi: _3, gotemba: _3, haibara: _3, hamamatsu: _3, higashiizu: _3, ito: _3, iwata: _3, izu: _3, izunokuni: _3, kakegawa: _3, kannami: _3, kawanehon: _3, kawazu: _3, kikugawa: _3, kosai: _3, makinohara: _3, matsuzaki: _3, minamiizu: _3, mishima: _3, morimachi: _3, nishiizu: _3, numazu: _3, omaezaki: _3, shimada: _3, shimizu: _3, shimoda: _3, shizuoka: _3, susono: _3, yaizu: _3, yoshida: _3 }], tochigi: [1, { ashikaga: _3, bato: _3, haga: _3, ichikai: _3, iwafune: _3, kaminokawa: _3, kanuma: _3, karasuyama: _3, kuroiso: _3, mashiko: _3, mibu: _3, moka: _3, motegi: _3, nasu: _3, nasushiobara: _3, nikko: _3, nishikata: _3, nogi: _3, ohira: _3, ohtawara: _3, oyama: _3, sakura: _3, sano: _3, shimotsuke: _3, shioya: _3, takanezawa: _3, tochigi: _3, tsuga: _3, ujiie: _3, utsunomiya: _3, yaita: _3 }], tokushima: [1, { aizumi: _3, anan: _3, ichiba: _3, itano: _3, kainan: _3, komatsushima: _3, matsushige: _3, mima: _3, minami: _3, miyoshi: _3, mugi: _3, nakagawa: _3, naruto: _3, sanagochi: _3, shishikui: _3, tokushima: _3, wajiki: _3 }], tokyo: [1, { adachi: _3, akiruno: _3, akishima: _3, aogashima: _3, arakawa: _3, bunkyo: _3, chiyoda: _3, chofu: _3, chuo: _3, edogawa: _3, fuchu: _3, fussa: _3, hachijo: _3, hachioji: _3, hamura: _3, higashikurume: _3, higashimurayama: _3, higashiyamato: _3, hino: _3, hinode: _3, hinohara: _3, inagi: _3, itabashi: _3, katsushika: _3, kita: _3, kiyose: _3, kodaira: _3, koganei: _3, kokubunji: _3, komae: _3, koto: _3, kouzushima: _3, kunitachi: _3, machida: _3, meguro: _3, minato: _3, mitaka: _3, mizuho: _3, musashimurayama: _3, musashino: _3, nakano: _3, nerima: _3, ogasawara: _3, okutama: _3, ome: _3, oshima: _3, ota: _3, setagaya: _3, shibuya: _3, shinagawa: _3, shinjuku: _3, suginami: _3, sumida: _3, tachikawa: _3, taito: _3, tama: _3, toshima: _3 }], tottori: [1, { chizu: _3, hino: _3, kawahara: _3, koge: _3, kotoura: _3, misasa: _3, nanbu: _3, nichinan: _3, sakaiminato: _3, tottori: _3, wakasa: _3, yazu: _3, yonago: _3 }], toyama: [1, { asahi: _3, fuchu: _3, fukumitsu: _3, funahashi: _3, himi: _3, imizu: _3, inami: _3, johana: _3, kamiichi: _3, kurobe: _3, nakaniikawa: _3, namerikawa: _3, nanto: _3, nyuzen: _3, oyabe: _3, taira: _3, takaoka: _3, tateyama: _3, toga: _3, tonami: _3, toyama: _3, unazuki: _3, uozu: _3, yamada: _3 }], wakayama: [1, { arida: _3, aridagawa: _3, gobo: _3, hashimoto: _3, hidaka: _3, hirogawa: _3, inami: _3, iwade: _3, kainan: _3, kamitonda: _3, katsuragi: _3, kimino: _3, kinokawa: _3, kitayama: _3, koya: _3, koza: _3, kozagawa: _3, kudoyama: _3, kushimoto: _3, mihama: _3, misato: _3, nachikatsuura: _3, shingu: _3, shirahama: _3, taiji: _3, tanabe: _3, wakayama: _3, yuasa: _3, yura: _3 }], yamagata: [1, { asahi: _3, funagata: _3, higashine: _3, iide: _3, kahoku: _3, kaminoyama: _3, kaneyama: _3, kawanishi: _3, mamurogawa: _3, mikawa: _3, murayama: _3, nagai: _3, nakayama: _3, nanyo: _3, nishikawa: _3, obanazawa: _3, oe: _3, oguni: _3, ohkura: _3, oishida: _3, sagae: _3, sakata: _3, sakegawa: _3, shinjo: _3, shirataka: _3, shonai: _3, takahata: _3, tendo: _3, tozawa: _3, tsuruoka: _3, yamagata: _3, yamanobe: _3, yonezawa: _3, yuza: _3 }], yamaguchi: [1, { abu: _3, hagi: _3, hikari: _3, hofu: _3, iwakuni: _3, kudamatsu: _3, mitou: _3, nagato: _3, oshima: _3, shimonoseki: _3, shunan: _3, tabuse: _3, tokuyama: _3, toyota: _3, ube: _3, yuu: _3 }], yamanashi: [1, { chuo: _3, doshi: _3, fuefuki: _3, fujikawa: _3, fujikawaguchiko: _3, fujiyoshida: _3, hayakawa: _3, hokuto: _3, ichikawamisato: _3, kai: _3, kofu: _3, koshu: _3, kosuge: _3, "minami-alps": _3, minobu: _3, nakamichi: _3, nanbu: _3, narusawa: _3, nirasaki: _3, nishikatsura: _3, oshino: _3, otsuki: _3, showa: _3, tabayama: _3, tsuru: _3, uenohara: _3, yamanakako: _3, yamanashi: _3 }], "xn--ehqz56n": _3, "": _3, "xn--1lqs03n": _3, "": _3, "xn--qqqt11m": _3, "": _3, "xn--f6qx53a": _3, "": _3, "xn--djrs72d6uy": _3, "": _3, "xn--mkru45i": _3, "": _3, "xn--0trq7p7nn": _3, "": _3, "xn--5js045d": _3, "": _3, "xn--kbrq7o": _3, "": _3, "xn--pssu33l": _3, "": _3, "xn--ntsq17g": _3, "": _3, "xn--uisz3g": _3, "": _3, "xn--6btw5a": _3, "": _3, "xn--1ctwo": _3, "": _3, "xn--6orx2r": _3, "": _3, "xn--rht61e": _3, "": _3, "xn--rht27z": _3, "": _3, "xn--nit225k": _3, "": _3, "xn--rht3d": _3, "": _3, "xn--djty4k": _3, "": _3, "xn--klty5x": _3, "": _3, "xn--kltx9a": _3, "": _3, "xn--kltp7d": _3, "": _3, "xn--c3s14m": _3, "": _3, "xn--vgu402c": _3, "": _3, "xn--efvn9s": _3, "": _3, "xn--1lqs71d": _3, "": _3, "xn--4pvxs": _3, "": _3, "xn--uuwu58a": _3, "": _3, "xn--zbx025d": _3, "": _3, "xn--8pvr4u": _3, "": _3, "xn--5rtp49c": _3, "": _3, "xn--ntso0iqx3a": _3, "": _3, "xn--elqq16h": _3, "": _3, "xn--4it168d": _3, "": _3, "xn--klt787d": _3, "": _3, "xn--rny31h": _3, "": _3, "xn--7t0a264c": _3, "": _3, "xn--uist22h": _3, "": _3, "xn--8ltr62k": _3, "": _3, "xn--2m4a15e": _3, "": _3, "xn--32vp30h": _3, "": _3, "xn--4it797k": _3, "": _3, "xn--5rtq34k": _3, "": _3, "xn--k7yn95e": _3, "": _3, "xn--tor131o": _3, "": _3, "xn--d5qv7z876c": _3, "": _3, kawasaki: _18, kitakyushu: _18, kobe: _18, nagoya: _18, sapporo: _18, sendai: _18, yokohama: _18, buyshop: _4, fashionstore: _4, handcrafted: _4, kawaiishop: _4, supersale: _4, theshop: _4, "0am": _4, "0g0": _4, "0j0": _4, "0t0": _4, mydns: _4, pgw: _4, wjg: _4, usercontent: _4, angry: _4, babyblue: _4, babymilk: _4, backdrop: _4, bambina: _4, bitter: _4, blush: _4, boo: _4, boy: _4, boyfriend: _4, but: _4, candypop: _4, capoo: _4, catfood: _4, cheap: _4, chicappa: _4, chillout: _4, chips: _4, chowder: _4, chu: _4, ciao: _4, cocotte: _4, coolblog: _4, cranky: _4, cutegirl: _4, daa: _4, deca: _4, deci: _4, digick: _4, egoism: _4, fakefur: _4, fem: _4, flier: _4, floppy: _4, fool: _4, frenchkiss: _4, girlfriend: _4, girly: _4, gloomy: _4, gonna: _4, greater: _4, hacca: _4, heavy: _4, her: _4, hiho: _4, hippy: _4, holy: _4, hungry: _4, icurus: _4, itigo: _4, jellybean: _4, kikirara: _4, kill: _4, kilo: _4, kuron: _4, littlestar: _4, lolipopmc: _4, lolitapunk: _4, lomo: _4, lovepop: _4, lovesick: _4, main: _4, mods: _4, mond: _4, mongolian: _4, moo: _4, namaste: _4, nikita: _4, nobushi: _4, noor: _4, oops: _4, parallel: _4, parasite: _4, pecori: _4, peewee: _4, penne: _4, pepper: _4, perma: _4, pigboat: _4, pinoko: _4, punyu: _4, pupu: _4, pussycat: _4, pya: _4, raindrop: _4, readymade: _4, sadist: _4, schoolbus: _4, secret: _4, staba: _4, stripper: _4, sub: _4, sunnyday: _4, thick: _4, tonkotsu: _4, under: _4, upper: _4, velvet: _4, verse: _4, versus: _4, vivian: _4, watson: _4, weblike: _4, whitesnow: _4, zombie: _4, hateblo: _4, hatenablog: _4, hatenadiary: _4, "2-d": _4, bona: _4, crap: _4, daynight: _4, eek: _4, flop: _4, halfmoon: _4, jeez: _4, matrix: _4, mimoza: _4, netgamers: _4, nyanta: _4, o0o0: _4, rdy: _4, rgr: _4, rulez: _4, sakurastorage: [0, { isk01: _55, isk02: _55 }], saloon: _4, sblo: _4, skr: _4, tank: _4, "uh-oh": _4, undo: _4, webaccel: [0, { rs: _4, user: _4 }], websozai: _4, xii: _4 }], ke: [1, { ac: _3, co: _3, go: _3, info: _3, me: _3, mobi: _3, ne: _3, or: _3, sc: _3 }], kg: [1, { com: _3, edu: _3, gov: _3, mil: _3, net: _3, org: _3, us: _4 }], kh: _18, ki: _56, km: [1, { ass: _3, com: _3, edu: _3, gov: _3, mil: _3, nom: _3, org: _3, prd: _3, tm: _3, asso: _3, coop: _3, gouv: _3, medecin: _3, notaires: _3, pharmaciens: _3, presse: _3, veterinaire: _3 }], kn: [1, { edu: _3, gov: _3, net: _3, org: _3 }], kp: [1, { com: _3, edu: _3, gov: _3, org: _3, rep: _3, tra: _3 }], kr: [1, { ac: _3, ai: _3, co: _3, es: _3, go: _3, hs: _3, io: _3, it: _3, kg: _3, me: _3, mil: _3, ms: _3, ne: _3, or: _3, pe: _3, re: _3, sc: _3, busan: _3, chungbuk: _3, chungnam: _3, daegu: _3, daejeon: _3, gangwon: _3, gwangju: _3, gyeongbuk: _3, gyeonggi: _3, gyeongnam: _3, incheon: _3, jeju: _3, jeonbuk: _3, jeonnam: _3, seoul: _3, ulsan: _3, c01: _4, "eliv-dns": _4 }], kw: [1, { com: _3, edu: _3, emb: _3, gov: _3, ind: _3, net: _3, org: _3 }], ky: _45, kz: [1, { com: _3, edu: _3, gov: _3, mil: _3, net: _3, org: _3, jcloud: _4 }], la: [1, { com: _3, edu: _3, gov: _3, info: _3, int: _3, net: _3, org: _3, per: _3, bnr: _4 }], lb: _5, lc: [1, { co: _3, com: _3, edu: _3, gov: _3, net: _3, org: _3, oy: _4 }], li: _3, lk: [1, { ac: _3, assn: _3, com: _3, edu: _3, gov: _3, grp: _3, hotel: _3, int: _3, ltd: _3, net: _3, ngo: _3, org: _3, sch: _3, soc: _3, web: _3 }], lr: _5, ls: [1, { ac: _3, biz: _3, co: _3, edu: _3, gov: _3, info: _3, net: _3, org: _3, sc: _3 }], lt: _11, lu: [1, { "123website": _4 }], lv: [1, { asn: _3, com: _3, conf: _3, edu: _3, gov: _3, id: _3, mil: _3, net: _3, org: _3 }], ly: [1, { com: _3, edu: _3, gov: _3, id: _3, med: _3, net: _3, org: _3, plc: _3, sch: _3 }], ma: [1, { ac: _3, co: _3, gov: _3, net: _3, org: _3, press: _3 }], mc: [1, { asso: _3, tm: _3 }], md: [1, { ir: _4 }], me: [1, { ac: _3, co: _3, edu: _3, gov: _3, its: _3, net: _3, org: _3, priv: _3, c66: _4, craft: _4, edgestack: _4, filegear: _4, glitch: _4, "filegear-sg": _4, lohmus: _4, barsy: _4, mcdir: _4, brasilia: _4, ddns: _4, dnsfor: _4, hopto: _4, loginto: _4, noip: _4, webhop: _4, soundcast: _4, tcp4: _4, vp4: _4, diskstation: _4, dscloud: _4, i234: _4, myds: _4, synology: _4, transip: _44, nohost: _4 }], mg: [1, { co: _3, com: _3, edu: _3, gov: _3, mil: _3, nom: _3, org: _3, prd: _3 }], mh: _3, mil: _3, mk: [1, { com: _3, edu: _3, gov: _3, inf: _3, name: _3, net: _3, org: _3 }], ml: [1, { ac: _3, art: _3, asso: _3, com: _3, edu: _3, gouv: _3, gov: _3, info: _3, inst: _3, net: _3, org: _3, pr: _3, presse: _3 }], mm: _18, mn: [1, { edu: _3, gov: _3, org: _3, nyc: _4 }], mo: _5, mobi: [1, { barsy: _4, dscloud: _4 }], mp: [1, { ju: _4 }], mq: _3, mr: _11, ms: [1, { com: _3, edu: _3, gov: _3, net: _3, org: _3, minisite: _4 }], mt: _45, mu: [1, { ac: _3, co: _3, com: _3, gov: _3, net: _3, or: _3, org: _3 }], museum: _3, mv: [1, { aero: _3, biz: _3, com: _3, coop: _3, edu: _3, gov: _3, info: _3, int: _3, mil: _3, museum: _3, name: _3, net: _3, org: _3, pro: _3 }], mw: [1, { ac: _3, biz: _3, co: _3, com: _3, coop: _3, edu: _3, gov: _3, int: _3, net: _3, org: _3 }], mx: [1, { com: _3, edu: _3, gob: _3, net: _3, org: _3 }], my: [1, { biz: _3, com: _3, edu: _3, gov: _3, mil: _3, name: _3, net: _3, org: _3 }], mz: [1, { ac: _3, adv: _3, co: _3, edu: _3, gov: _3, mil: _3, net: _3, org: _3 }], na: [1, { alt: _3, co: _3, com: _3, gov: _3, net: _3, org: _3 }], name: [1, { her: _59, his: _59 }], nc: [1, { asso: _3, nom: _3 }], ne: _3, net: [1, { adobeaemcloud: _4, "adobeio-static": _4, adobeioruntime: _4, akadns: _4, akamai: _4, "akamai-staging": _4, akamaiedge: _4, "akamaiedge-staging": _4, akamaihd: _4, "akamaihd-staging": _4, akamaiorigin: _4, "akamaiorigin-staging": _4, akamaized: _4, "akamaized-staging": _4, edgekey: _4, "edgekey-staging": _4, edgesuite: _4, "edgesuite-staging": _4, alwaysdata: _4, myamaze: _4, cloudfront: _4, appudo: _4, "atlassian-dev": [0, { prod: _52 }], myfritz: _4, onavstack: _4, shopselect: _4, blackbaudcdn: _4, boomla: _4, bplaced: _4, square7: _4, cdn77: [0, { r: _4 }], "cdn77-ssl": _4, gb: _4, hu: _4, jp: _4, se: _4, uk: _4, clickrising: _4, "ddns-ip": _4, "dns-cloud": _4, "dns-dynamic": _4, cloudaccess: _4, cloudflare: [2, { cdn: _4 }], cloudflareanycast: _52, cloudflarecn: _52, cloudflareglobal: _52, ctfcloud: _4, "feste-ip": _4, "knx-server": _4, "static-access": _4, cryptonomic: _7, dattolocal: _4, mydatto: _4, debian: _4, definima: _4, deno: _4, "at-band-camp": _4, blogdns: _4, "broke-it": _4, buyshouses: _4, dnsalias: _4, dnsdojo: _4, "does-it": _4, dontexist: _4, dynalias: _4, dynathome: _4, endofinternet: _4, "from-az": _4, "from-co": _4, "from-la": _4, "from-ny": _4, "gets-it": _4, "ham-radio-op": _4, homeftp: _4, homeip: _4, homelinux: _4, homeunix: _4, "in-the-band": _4, "is-a-chef": _4, "is-a-geek": _4, "isa-geek": _4, "kicks-ass": _4, "office-on-the": _4, podzone: _4, "scrapper-site": _4, selfip: _4, "sells-it": _4, servebbs: _4, serveftp: _4, thruhere: _4, webhop: _4, casacam: _4, dynu: _4, dynv6: _4, twmail: _4, ru: _4, channelsdvr: [2, { u: _4 }], fastly: [0, { freetls: _4, map: _4, prod: [0, { a: _4, global: _4 }], ssl: [0, { a: _4, b: _4, global: _4 }] }], fastlylb: [2, { map: _4 }], edgeapp: _4, "keyword-on": _4, "live-on": _4, "server-on": _4, "cdn-edges": _4, heteml: _4, cloudfunctions: _4, "grafana-dev": _4, iobb: _4, moonscale: _4, "in-dsl": _4, "in-vpn": _4, oninferno: _4, botdash: _4, "apps-1and1": _4, ipifony: _4, cloudjiffy: [2, { "fra1-de": _4, "west1-us": _4 }], elastx: [0, { "jls-sto1": _4, "jls-sto2": _4, "jls-sto3": _4 }], massivegrid: [0, { paas: [0, { "fr-1": _4, "lon-1": _4, "lon-2": _4, "ny-1": _4, "ny-2": _4, "sg-1": _4 }] }], saveincloud: [0, { jelastic: _4, "nordeste-idc": _4 }], scaleforce: _46, kinghost: _4, uni5: _4, krellian: _4, ggff: _4, localcert: _4, localhostcert: _4, localto: _7, barsy: _4, memset: _4, "azure-api": _4, "azure-mobile": _4, azureedge: _4, azurefd: _4, azurestaticapps: [2, { "1": _4, "2": _4, "3": _4, "4": _4, "5": _4, "6": _4, "7": _4, centralus: _4, eastasia: _4, eastus2: _4, westeurope: _4, westus2: _4 }], azurewebsites: _4, cloudapp: _4, trafficmanager: _4, windows: [0, { core: [0, { blob: _4 }], servicebus: _4 }], mynetname: [0, { sn: _4 }], routingthecloud: _4, bounceme: _4, ddns: _4, "eating-organic": _4, mydissent: _4, myeffect: _4, mymediapc: _4, mypsx: _4, mysecuritycamera: _4, nhlfan: _4, "no-ip": _4, pgafan: _4, privatizehealthinsurance: _4, redirectme: _4, serveblog: _4, serveminecraft: _4, sytes: _4, dnsup: _4, hicam: _4, "now-dns": _4, ownip: _4, vpndns: _4, cloudycluster: _4, ovh: [0, { hosting: _7, webpaas: _7 }], rackmaze: _4, myradweb: _4, in: _4, "subsc-pay": _4, squares: _4, schokokeks: _4, "firewall-gateway": _4, seidat: _4, senseering: _4, siteleaf: _4, mafelo: _4, myspreadshop: _4, "vps-host": [2, { jelastic: [0, { atl: _4, njs: _4, ric: _4 }] }], srcf: [0, { soc: _4, user: _4 }], supabase: _4, dsmynas: _4, familyds: _4, ts: [2, { c: _7 }], torproject: [2, { pages: _4 }], vusercontent: _4, "reserve-online": _4, "community-pro": _4, meinforum: _4, yandexcloud: [2, { storage: _4, website: _4 }], za: _4 }], nf: [1, { arts: _3, com: _3, firm: _3, info: _3, net: _3, other: _3, per: _3, rec: _3, store: _3, web: _3 }], ng: [1, { com: _3, edu: _3, gov: _3, i: _3, mil: _3, mobi: _3, name: _3, net: _3, org: _3, sch: _3, biz: [2, { co: _4, dl: _4, go: _4, lg: _4, on: _4 }], col: _4, firm: _4, gen: _4, ltd: _4, ngo: _4, plc: _4 }], ni: [1, { ac: _3, biz: _3, co: _3, com: _3, edu: _3, gob: _3, in: _3, info: _3, int: _3, mil: _3, net: _3, nom: _3, org: _3, web: _3 }], nl: [1, { co: _4, "hosting-cluster": _4, gov: _4, khplay: _4, "123website": _4, myspreadshop: _4, transurl: _7, cistron: _4, demon: _4 }], no: [1, { fhs: _3, folkebibl: _3, fylkesbibl: _3, idrett: _3, museum: _3, priv: _3, vgs: _3, dep: _3, herad: _3, kommune: _3, mil: _3, stat: _3, aa: _60, ah: _60, bu: _60, fm: _60, hl: _60, hm: _60, "jan-mayen": _60, mr: _60, nl: _60, nt: _60, of: _60, ol: _60, oslo: _60, rl: _60, sf: _60, st: _60, svalbard: _60, tm: _60, tr: _60, va: _60, vf: _60, akrehamn: _3, "xn--krehamn-dxa": _3, "krehamn": _3, algard: _3, "xn--lgrd-poac": _3, "lgrd": _3, arna: _3, bronnoysund: _3, "xn--brnnysund-m8ac": _3, "brnnysund": _3, brumunddal: _3, bryne: _3, drobak: _3, "xn--drbak-wua": _3, "drbak": _3, egersund: _3, fetsund: _3, floro: _3, "xn--flor-jra": _3, "flor": _3, fredrikstad: _3, hokksund: _3, honefoss: _3, "xn--hnefoss-q1a": _3, "hnefoss": _3, jessheim: _3, jorpeland: _3, "xn--jrpeland-54a": _3, "jrpeland": _3, kirkenes: _3, kopervik: _3, krokstadelva: _3, langevag: _3, "xn--langevg-jxa": _3, "langevg": _3, leirvik: _3, mjondalen: _3, "xn--mjndalen-64a": _3, "mjndalen": _3, "mo-i-rana": _3, mosjoen: _3, "xn--mosjen-eya": _3, "mosjen": _3, nesoddtangen: _3, orkanger: _3, osoyro: _3, "xn--osyro-wua": _3, "osyro": _3, raholt: _3, "xn--rholt-mra": _3, "rholt": _3, sandnessjoen: _3, "xn--sandnessjen-ogb": _3, "sandnessjen": _3, skedsmokorset: _3, slattum: _3, spjelkavik: _3, stathelle: _3, stavern: _3, stjordalshalsen: _3, "xn--stjrdalshalsen-sqb": _3, "stjrdalshalsen": _3, tananger: _3, tranby: _3, vossevangen: _3, aarborte: _3, aejrie: _3, afjord: _3, "xn--fjord-lra": _3, "fjord": _3, agdenes: _3, akershus: _61, aknoluokta: _3, "xn--koluokta-7ya57h": _3, "koluokta": _3, al: _3, "xn--l-1fa": _3, "l": _3, alaheadju: _3, "xn--laheadju-7ya": _3, "laheadju": _3, alesund: _3, "xn--lesund-hua": _3, "lesund": _3, alstahaug: _3, alta: _3, "xn--lt-liac": _3, "lt": _3, alvdal: _3, amli: _3, "xn--mli-tla": _3, "mli": _3, amot: _3, "xn--mot-tla": _3, "mot": _3, andasuolo: _3, andebu: _3, andoy: _3, "xn--andy-ira": _3, "andy": _3, ardal: _3, "xn--rdal-poa": _3, "rdal": _3, aremark: _3, arendal: _3, "xn--s-1fa": _3, "s": _3, aseral: _3, "xn--seral-lra": _3, "seral": _3, asker: _3, askim: _3, askoy: _3, "xn--asky-ira": _3, "asky": _3, askvoll: _3, asnes: _3, "xn--snes-poa": _3, "snes": _3, audnedaln: _3, aukra: _3, aure: _3, aurland: _3, "aurskog-holand": _3, "xn--aurskog-hland-jnb": _3, "aurskog-hland": _3, austevoll: _3, austrheim: _3, averoy: _3, "xn--avery-yua": _3, "avery": _3, badaddja: _3, "xn--bdddj-mrabd": _3, "bdddj": _3, "xn--brum-voa": _3, "brum": _3, bahcavuotna: _3, "xn--bhcavuotna-s4a": _3, "bhcavuotna": _3, bahccavuotna: _3, "xn--bhccavuotna-k7a": _3, "bhccavuotna": _3, baidar: _3, "xn--bidr-5nac": _3, "bidr": _3, bajddar: _3, "xn--bjddar-pta": _3, "bjddar": _3, balat: _3, "xn--blt-elab": _3, "blt": _3, balestrand: _3, ballangen: _3, balsfjord: _3, bamble: _3, bardu: _3, barum: _3, batsfjord: _3, "xn--btsfjord-9za": _3, "btsfjord": _3, bearalvahki: _3, "xn--bearalvhki-y4a": _3, "bearalvhki": _3, beardu: _3, beiarn: _3, berg: _3, bergen: _3, berlevag: _3, "xn--berlevg-jxa": _3, "berlevg": _3, bievat: _3, "xn--bievt-0qa": _3, "bievt": _3, bindal: _3, birkenes: _3, bjarkoy: _3, "xn--bjarky-fya": _3, "bjarky": _3, bjerkreim: _3, bjugn: _3, bodo: _3, "xn--bod-2na": _3, "bod": _3, bokn: _3, bomlo: _3, "xn--bmlo-gra": _3, "bmlo": _3, bremanger: _3, bronnoy: _3, "xn--brnny-wuac": _3, "brnny": _3, budejju: _3, buskerud: _61, bygland: _3, bykle: _3, cahcesuolo: _3, "xn--hcesuolo-7ya35b": _3, "hcesuolo": _3, davvenjarga: _3, "xn--davvenjrga-y4a": _3, "davvenjrga": _3, davvesiida: _3, deatnu: _3, dielddanuorri: _3, divtasvuodna: _3, divttasvuotna: _3, donna: _3, "xn--dnna-gra": _3, "dnna": _3, dovre: _3, drammen: _3, drangedal: _3, dyroy: _3, "xn--dyry-ira": _3, "dyry": _3, eid: _3, eidfjord: _3, eidsberg: _3, eidskog: _3, eidsvoll: _3, eigersund: _3, elverum: _3, enebakk: _3, engerdal: _3, etne: _3, etnedal: _3, evenassi: _3, "xn--eveni-0qa01ga": _3, "eveni": _3, evenes: _3, "evje-og-hornnes": _3, farsund: _3, fauske: _3, fedje: _3, fet: _3, finnoy: _3, "xn--finny-yua": _3, "finny": _3, fitjar: _3, fjaler: _3, fjell: _3, fla: _3, "xn--fl-zia": _3, "fl": _3, flakstad: _3, flatanger: _3, flekkefjord: _3, flesberg: _3, flora: _3, folldal: _3, forde: _3, "xn--frde-gra": _3, "frde": _3, forsand: _3, fosnes: _3, "xn--frna-woa": _3, "frna": _3, frana: _3, frei: _3, frogn: _3, froland: _3, frosta: _3, froya: _3, "xn--frya-hra": _3, "frya": _3, fuoisku: _3, fuossko: _3, fusa: _3, fyresdal: _3, gaivuotna: _3, "xn--givuotna-8ya": _3, "givuotna": _3, galsa: _3, "xn--gls-elac": _3, "gls": _3, gamvik: _3, gangaviika: _3, "xn--ggaviika-8ya47h": _3, "ggaviika": _3, gaular: _3, gausdal: _3, giehtavuoatna: _3, gildeskal: _3, "xn--gildeskl-g0a": _3, "gildeskl": _3, giske: _3, gjemnes: _3, gjerdrum: _3, gjerstad: _3, gjesdal: _3, gjovik: _3, "xn--gjvik-wua": _3, "gjvik": _3, gloppen: _3, gol: _3, gran: _3, grane: _3, granvin: _3, gratangen: _3, grimstad: _3, grong: _3, grue: _3, gulen: _3, guovdageaidnu: _3, ha: _3, "xn--h-2fa": _3, "h": _3, habmer: _3, "xn--hbmer-xqa": _3, "hbmer": _3, hadsel: _3, "xn--hgebostad-g3a": _3, "hgebostad": _3, hagebostad: _3, halden: _3, halsa: _3, hamar: _3, hamaroy: _3, hammarfeasta: _3, "xn--hmmrfeasta-s4ac": _3, "hmmrfeasta": _3, hammerfest: _3, hapmir: _3, "xn--hpmir-xqa": _3, "hpmir": _3, haram: _3, hareid: _3, harstad: _3, hasvik: _3, hattfjelldal: _3, haugesund: _3, hedmark: [0, { os: _3, valer: _3, "xn--vler-qoa": _3, "vler": _3 }], hemne: _3, hemnes: _3, hemsedal: _3, hitra: _3, hjartdal: _3, hjelmeland: _3, hobol: _3, "xn--hobl-ira": _3, "hobl": _3, hof: _3, hol: _3, hole: _3, holmestrand: _3, holtalen: _3, "xn--holtlen-hxa": _3, "holtlen": _3, hordaland: [0, { os: _3 }], hornindal: _3, horten: _3, hoyanger: _3, "xn--hyanger-q1a": _3, "hyanger": _3, hoylandet: _3, "xn--hylandet-54a": _3, "hylandet": _3, hurdal: _3, hurum: _3, hvaler: _3, hyllestad: _3, ibestad: _3, inderoy: _3, "xn--indery-fya": _3, "indery": _3, iveland: _3, ivgu: _3, jevnaker: _3, jolster: _3, "xn--jlster-bya": _3, "jlster": _3, jondal: _3, kafjord: _3, "xn--kfjord-iua": _3, "kfjord": _3, karasjohka: _3, "xn--krjohka-hwab49j": _3, "krjohka": _3, karasjok: _3, karlsoy: _3, karmoy: _3, "xn--karmy-yua": _3, "karmy": _3, kautokeino: _3, klabu: _3, "xn--klbu-woa": _3, "klbu": _3, klepp: _3, kongsberg: _3, kongsvinger: _3, kraanghke: _3, "xn--kranghke-b0a": _3, "kranghke": _3, kragero: _3, "xn--krager-gya": _3, "krager": _3, kristiansand: _3, kristiansund: _3, krodsherad: _3, "xn--krdsherad-m8a": _3, "krdsherad": _3, "xn--kvfjord-nxa": _3, "kvfjord": _3, "xn--kvnangen-k0a": _3, "kvnangen": _3, kvafjord: _3, kvalsund: _3, kvam: _3, kvanangen: _3, kvinesdal: _3, kvinnherad: _3, kviteseid: _3, kvitsoy: _3, "xn--kvitsy-fya": _3, "kvitsy": _3, laakesvuemie: _3, "xn--lrdal-sra": _3, "lrdal": _3, lahppi: _3, "xn--lhppi-xqa": _3, "lhppi": _3, lardal: _3, larvik: _3, lavagis: _3, lavangen: _3, leangaviika: _3, "xn--leagaviika-52b": _3, "leagaviika": _3, lebesby: _3, leikanger: _3, leirfjord: _3, leka: _3, leksvik: _3, lenvik: _3, lerdal: _3, lesja: _3, levanger: _3, lier: _3, lierne: _3, lillehammer: _3, lillesand: _3, lindas: _3, "xn--linds-pra": _3, "linds": _3, lindesnes: _3, loabat: _3, "xn--loabt-0qa": _3, "loabt": _3, lodingen: _3, "xn--ldingen-q1a": _3, "ldingen": _3, lom: _3, loppa: _3, lorenskog: _3, "xn--lrenskog-54a": _3, "lrenskog": _3, loten: _3, "xn--lten-gra": _3, "lten": _3, lund: _3, lunner: _3, luroy: _3, "xn--lury-ira": _3, "lury": _3, luster: _3, lyngdal: _3, lyngen: _3, malatvuopmi: _3, "xn--mlatvuopmi-s4a": _3, "mlatvuopmi": _3, malselv: _3, "xn--mlselv-iua": _3, "mlselv": _3, malvik: _3, mandal: _3, marker: _3, marnardal: _3, masfjorden: _3, masoy: _3, "xn--msy-ula0h": _3, "msy": _3, "matta-varjjat": _3, "xn--mtta-vrjjat-k7af": _3, "mtta-vrjjat": _3, meland: _3, meldal: _3, melhus: _3, meloy: _3, "xn--mely-ira": _3, "mely": _3, meraker: _3, "xn--merker-kua": _3, "merker": _3, midsund: _3, "midtre-gauldal": _3, moareke: _3, "xn--moreke-jua": _3, "moreke": _3, modalen: _3, modum: _3, molde: _3, "more-og-romsdal": [0, { heroy: _3, sande: _3 }], "xn--mre-og-romsdal-qqb": [0, { "xn--hery-ira": _3, sande: _3 }], "mre-og-romsdal": [0, { "hery": _3, sande: _3 }], moskenes: _3, moss: _3, mosvik: _3, muosat: _3, "xn--muost-0qa": _3, "muost": _3, naamesjevuemie: _3, "xn--nmesjevuemie-tcba": _3, "nmesjevuemie": _3, "xn--nry-yla5g": _3, "nry": _3, namdalseid: _3, namsos: _3, namsskogan: _3, nannestad: _3, naroy: _3, narviika: _3, narvik: _3, naustdal: _3, navuotna: _3, "xn--nvuotna-hwa": _3, "nvuotna": _3, "nedre-eiker": _3, nesna: _3, nesodden: _3, nesseby: _3, nesset: _3, nissedal: _3, nittedal: _3, "nord-aurdal": _3, "nord-fron": _3, "nord-odal": _3, norddal: _3, nordkapp: _3, nordland: [0, { bo: _3, "xn--b-5ga": _3, "b": _3, heroy: _3, "xn--hery-ira": _3, "hery": _3 }], "nordre-land": _3, nordreisa: _3, "nore-og-uvdal": _3, notodden: _3, notteroy: _3, "xn--nttery-byae": _3, "nttery": _3, odda: _3, oksnes: _3, "xn--ksnes-uua": _3, "ksnes": _3, omasvuotna: _3, oppdal: _3, oppegard: _3, "xn--oppegrd-ixa": _3, "oppegrd": _3, orkdal: _3, orland: _3, "xn--rland-uua": _3, "rland": _3, orskog: _3, "xn--rskog-uua": _3, "rskog": _3, orsta: _3, "xn--rsta-fra": _3, "rsta": _3, osen: _3, osteroy: _3, "xn--ostery-fya": _3, "ostery": _3, ostfold: [0, { valer: _3 }], "xn--stfold-9xa": [0, { "xn--vler-qoa": _3 }], "stfold": [0, { "vler": _3 }], "ostre-toten": _3, "xn--stre-toten-zcb": _3, "stre-toten": _3, overhalla: _3, "ovre-eiker": _3, "xn--vre-eiker-k8a": _3, "vre-eiker": _3, oyer: _3, "xn--yer-zna": _3, "yer": _3, oygarden: _3, "xn--ygarden-p1a": _3, "ygarden": _3, "oystre-slidre": _3, "xn--ystre-slidre-ujb": _3, "ystre-slidre": _3, porsanger: _3, porsangu: _3, "xn--porsgu-sta26f": _3, "porsgu": _3, porsgrunn: _3, rade: _3, "xn--rde-ula": _3, "rde": _3, radoy: _3, "xn--rady-ira": _3, "rady": _3, "xn--rlingen-mxa": _3, "rlingen": _3, rahkkeravju: _3, "xn--rhkkervju-01af": _3, "rhkkervju": _3, raisa: _3, "xn--risa-5na": _3, "risa": _3, rakkestad: _3, ralingen: _3, rana: _3, randaberg: _3, rauma: _3, rendalen: _3, rennebu: _3, rennesoy: _3, "xn--rennesy-v1a": _3, "rennesy": _3, rindal: _3, ringebu: _3, ringerike: _3, ringsaker: _3, risor: _3, "xn--risr-ira": _3, "risr": _3, rissa: _3, roan: _3, rodoy: _3, "xn--rdy-0nab": _3, "rdy": _3, rollag: _3, romsa: _3, romskog: _3, "xn--rmskog-bya": _3, "rmskog": _3, roros: _3, "xn--rros-gra": _3, "rros": _3, rost: _3, "xn--rst-0na": _3, "rst": _3, royken: _3, "xn--ryken-vua": _3, "ryken": _3, royrvik: _3, "xn--ryrvik-bya": _3, "ryrvik": _3, ruovat: _3, rygge: _3, salangen: _3, salat: _3, "xn--slat-5na": _3, "slat": _3, "xn--slt-elab": _3, "slt": _3, saltdal: _3, samnanger: _3, sandefjord: _3, sandnes: _3, sandoy: _3, "xn--sandy-yua": _3, "sandy": _3, sarpsborg: _3, sauda: _3, sauherad: _3, sel: _3, selbu: _3, selje: _3, seljord: _3, siellak: _3, sigdal: _3, siljan: _3, sirdal: _3, skanit: _3, "xn--sknit-yqa": _3, "sknit": _3, skanland: _3, "xn--sknland-fxa": _3, "sknland": _3, skaun: _3, skedsmo: _3, ski: _3, skien: _3, skierva: _3, "xn--skierv-uta": _3, "skierv": _3, skiptvet: _3, skjak: _3, "xn--skjk-soa": _3, "skjk": _3, skjervoy: _3, "xn--skjervy-v1a": _3, "skjervy": _3, skodje: _3, smola: _3, "xn--smla-hra": _3, "smla": _3, snaase: _3, "xn--snase-nra": _3, "snase": _3, snasa: _3, "xn--snsa-roa": _3, "snsa": _3, snillfjord: _3, snoasa: _3, sogndal: _3, sogne: _3, "xn--sgne-gra": _3, "sgne": _3, sokndal: _3, sola: _3, solund: _3, somna: _3, "xn--smna-gra": _3, "smna": _3, "sondre-land": _3, "xn--sndre-land-0cb": _3, "sndre-land": _3, songdalen: _3, "sor-aurdal": _3, "xn--sr-aurdal-l8a": _3, "sr-aurdal": _3, "sor-fron": _3, "xn--sr-fron-q1a": _3, "sr-fron": _3, "sor-odal": _3, "xn--sr-odal-q1a": _3, "sr-odal": _3, "sor-varanger": _3, "xn--sr-varanger-ggb": _3, "sr-varanger": _3, sorfold: _3, "xn--srfold-bya": _3, "srfold": _3, sorreisa: _3, "xn--srreisa-q1a": _3, "srreisa": _3, sortland: _3, sorum: _3, "xn--srum-gra": _3, "srum": _3, spydeberg: _3, stange: _3, stavanger: _3, steigen: _3, steinkjer: _3, stjordal: _3, "xn--stjrdal-s1a": _3, "stjrdal": _3, stokke: _3, "stor-elvdal": _3, stord: _3, stordal: _3, storfjord: _3, strand: _3, stranda: _3, stryn: _3, sula: _3, suldal: _3, sund: _3, sunndal: _3, surnadal: _3, sveio: _3, svelvik: _3, sykkylven: _3, tana: _3, telemark: [0, { bo: _3, "xn--b-5ga": _3, "b": _3 }], time: _3, tingvoll: _3, tinn: _3, tjeldsund: _3, tjome: _3, "xn--tjme-hra": _3, "tjme": _3, tokke: _3, tolga: _3, tonsberg: _3, "xn--tnsberg-q1a": _3, "tnsberg": _3, torsken: _3, "xn--trna-woa": _3, "trna": _3, trana: _3, tranoy: _3, "xn--trany-yua": _3, "trany": _3, troandin: _3, trogstad: _3, "xn--trgstad-r1a": _3, "trgstad": _3, tromsa: _3, tromso: _3, "xn--troms-zua": _3, "troms": _3, trondheim: _3, trysil: _3, tvedestrand: _3, tydal: _3, tynset: _3, tysfjord: _3, tysnes: _3, "xn--tysvr-vra": _3, "tysvr": _3, tysvar: _3, ullensaker: _3, ullensvang: _3, ulvik: _3, unjarga: _3, "xn--unjrga-rta": _3, "unjrga": _3, utsira: _3, vaapste: _3, vadso: _3, "xn--vads-jra": _3, "vads": _3, "xn--vry-yla5g": _3, "vry": _3, vaga: _3, "xn--vg-yiab": _3, "vg": _3, vagan: _3, "xn--vgan-qoa": _3, "vgan": _3, vagsoy: _3, "xn--vgsy-qoa0j": _3, "vgsy": _3, vaksdal: _3, valle: _3, vang: _3, vanylven: _3, vardo: _3, "xn--vard-jra": _3, "vard": _3, varggat: _3, "xn--vrggt-xqad": _3, "vrggt": _3, varoy: _3, vefsn: _3, vega: _3, vegarshei: _3, "xn--vegrshei-c0a": _3, "vegrshei": _3, vennesla: _3, verdal: _3, verran: _3, vestby: _3, vestfold: [0, { sande: _3 }], vestnes: _3, "vestre-slidre": _3, "vestre-toten": _3, vestvagoy: _3, "xn--vestvgy-ixa6o": _3, "vestvgy": _3, vevelstad: _3, vik: _3, vikna: _3, vindafjord: _3, voagat: _3, volda: _3, voss: _3, co: _4, "123hjemmeside": _4, myspreadshop: _4 }], np: _18, nr: _56, nu: [1, { merseine: _4, mine: _4, shacknet: _4, enterprisecloud: _4 }], nz: [1, { ac: _3, co: _3, cri: _3, geek: _3, gen: _3, govt: _3, health: _3, iwi: _3, kiwi: _3, maori: _3, "xn--mori-qsa": _3, "mori": _3, mil: _3, net: _3, org: _3, parliament: _3, school: _3, cloudns: _4 }], om: [1, { co: _3, com: _3, edu: _3, gov: _3, med: _3, museum: _3, net: _3, org: _3, pro: _3 }], onion: _3, org: [1, { altervista: _4, pimienta: _4, poivron: _4, potager: _4, sweetpepper: _4, cdn77: [0, { c: _4, rsc: _4 }], "cdn77-secure": [0, { origin: [0, { ssl: _4 }] }], ae: _4, cloudns: _4, "ip-dynamic": _4, ddnss: _4, dpdns: _4, duckdns: _4, tunk: _4, blogdns: _4, blogsite: _4, boldlygoingnowhere: _4, dnsalias: _4, dnsdojo: _4, doesntexist: _4, dontexist: _4, doomdns: _4, dvrdns: _4, dynalias: _4, dyndns: [2, { go: _4, home: _4 }], endofinternet: _4, endoftheinternet: _4, "from-me": _4, "game-host": _4, gotdns: _4, "hobby-site": _4, homedns: _4, homeftp: _4, homelinux: _4, homeunix: _4, "is-a-bruinsfan": _4, "is-a-candidate": _4, "is-a-celticsfan": _4, "is-a-chef": _4, "is-a-geek": _4, "is-a-knight": _4, "is-a-linux-user": _4, "is-a-patsfan": _4, "is-a-soxfan": _4, "is-found": _4, "is-lost": _4, "is-saved": _4, "is-very-bad": _4, "is-very-evil": _4, "is-very-good": _4, "is-very-nice": _4, "is-very-sweet": _4, "isa-geek": _4, "kicks-ass": _4, misconfused: _4, podzone: _4, readmyblog: _4, selfip: _4, sellsyourhome: _4, servebbs: _4, serveftp: _4, servegame: _4, "stuff-4-sale": _4, webhop: _4, accesscam: _4, camdvr: _4, freeddns: _4, mywire: _4, webredirect: _4, twmail: _4, eu: [2, { al: _4, asso: _4, at: _4, au: _4, be: _4, bg: _4, ca: _4, cd: _4, ch: _4, cn: _4, cy: _4, cz: _4, de: _4, dk: _4, edu: _4, ee: _4, es: _4, fi: _4, fr: _4, gr: _4, hr: _4, hu: _4, ie: _4, il: _4, in: _4, int: _4, is: _4, it: _4, jp: _4, kr: _4, lt: _4, lu: _4, lv: _4, me: _4, mk: _4, mt: _4, my: _4, net: _4, ng: _4, nl: _4, no: _4, nz: _4, pl: _4, pt: _4, ro: _4, ru: _4, se: _4, si: _4, sk: _4, tr: _4, uk: _4, us: _4 }], fedorainfracloud: _4, fedorapeople: _4, fedoraproject: [0, { cloud: _4, os: _43, stg: [0, { os: _43 }] }], freedesktop: _4, hatenadiary: _4, hepforge: _4, "in-dsl": _4, "in-vpn": _4, js: _4, barsy: _4, mayfirst: _4, routingthecloud: _4, bmoattachments: _4, "cable-modem": _4, collegefan: _4, couchpotatofries: _4, hopto: _4, mlbfan: _4, myftp: _4, mysecuritycamera: _4, nflfan: _4, "no-ip": _4, "read-books": _4, ufcfan: _4, zapto: _4, dynserv: _4, "now-dns": _4, "is-local": _4, httpbin: _4, pubtls: _4, jpn: _4, "my-firewall": _4, myfirewall: _4, spdns: _4, "small-web": _4, dsmynas: _4, familyds: _4, teckids: _55, tuxfamily: _4, diskstation: _4, hk: _4, us: _4, toolforge: _4, wmcloud: _4, wmflabs: _4, za: _4 }], pa: [1, { abo: _3, ac: _3, com: _3, edu: _3, gob: _3, ing: _3, med: _3, net: _3, nom: _3, org: _3, sld: _3 }], pe: [1, { com: _3, edu: _3, gob: _3, mil: _3, net: _3, nom: _3, org: _3 }], pf: [1, { com: _3, edu: _3, org: _3 }], pg: _18, ph: [1, { com: _3, edu: _3, gov: _3, i: _3, mil: _3, net: _3, ngo: _3, org: _3, cloudns: _4 }], pk: [1, { ac: _3, biz: _3, com: _3, edu: _3, fam: _3, gkp: _3, gob: _3, gog: _3, gok: _3, gop: _3, gos: _3, gov: _3, net: _3, org: _3, web: _3 }], pl: [1, { com: _3, net: _3, org: _3, agro: _3, aid: _3, atm: _3, auto: _3, biz: _3, edu: _3, gmina: _3, gsm: _3, info: _3, mail: _3, media: _3, miasta: _3, mil: _3, nieruchomosci: _3, nom: _3, pc: _3, powiat: _3, priv: _3, realestate: _3, rel: _3, sex: _3, shop: _3, sklep: _3, sos: _3, szkola: _3, targi: _3, tm: _3, tourism: _3, travel: _3, turystyka: _3, gov: [1, { ap: _3, griw: _3, ic: _3, is: _3, kmpsp: _3, konsulat: _3, kppsp: _3, kwp: _3, kwpsp: _3, mup: _3, mw: _3, oia: _3, oirm: _3, oke: _3, oow: _3, oschr: _3, oum: _3, pa: _3, pinb: _3, piw: _3, po: _3, pr: _3, psp: _3, psse: _3, pup: _3, rzgw: _3, sa: _3, sdn: _3, sko: _3, so: _3, sr: _3, starostwo: _3, ug: _3, ugim: _3, um: _3, umig: _3, upow: _3, uppo: _3, us: _3, uw: _3, uzs: _3, wif: _3, wiih: _3, winb: _3, wios: _3, witd: _3, wiw: _3, wkz: _3, wsa: _3, wskr: _3, wsse: _3, wuoz: _3, wzmiuw: _3, zp: _3, zpisdn: _3 }], augustow: _3, "babia-gora": _3, bedzin: _3, beskidy: _3, bialowieza: _3, bialystok: _3, bielawa: _3, bieszczady: _3, boleslawiec: _3, bydgoszcz: _3, bytom: _3, cieszyn: _3, czeladz: _3, czest: _3, dlugoleka: _3, elblag: _3, elk: _3, glogow: _3, gniezno: _3, gorlice: _3, grajewo: _3, ilawa: _3, jaworzno: _3, "jelenia-gora": _3, jgora: _3, kalisz: _3, karpacz: _3, kartuzy: _3, kaszuby: _3, katowice: _3, "kazimierz-dolny": _3, kepno: _3, ketrzyn: _3, klodzko: _3, kobierzyce: _3, kolobrzeg: _3, konin: _3, konskowola: _3, kutno: _3, lapy: _3, lebork: _3, legnica: _3, lezajsk: _3, limanowa: _3, lomza: _3, lowicz: _3, lubin: _3, lukow: _3, malbork: _3, malopolska: _3, mazowsze: _3, mazury: _3, mielec: _3, mielno: _3, mragowo: _3, naklo: _3, nowaruda: _3, nysa: _3, olawa: _3, olecko: _3, olkusz: _3, olsztyn: _3, opoczno: _3, opole: _3, ostroda: _3, ostroleka: _3, ostrowiec: _3, ostrowwlkp: _3, pila: _3, pisz: _3, podhale: _3, podlasie: _3, polkowice: _3, pomorskie: _3, pomorze: _3, prochowice: _3, pruszkow: _3, przeworsk: _3, pulawy: _3, radom: _3, "rawa-maz": _3, rybnik: _3, rzeszow: _3, sanok: _3, sejny: _3, skoczow: _3, slask: _3, slupsk: _3, sosnowiec: _3, "stalowa-wola": _3, starachowice: _3, stargard: _3, suwalki: _3, swidnica: _3, swiebodzin: _3, swinoujscie: _3, szczecin: _3, szczytno: _3, tarnobrzeg: _3, tgory: _3, turek: _3, tychy: _3, ustka: _3, walbrzych: _3, warmia: _3, warszawa: _3, waw: _3, wegrow: _3, wielun: _3, wlocl: _3, wloclawek: _3, wodzislaw: _3, wolomin: _3, wroclaw: _3, zachpomor: _3, zagan: _3, zarow: _3, zgora: _3, zgorzelec: _3, art: _4, gliwice: _4, krakow: _4, poznan: _4, wroc: _4, zakopane: _4, beep: _4, "ecommerce-shop": _4, cfolks: _4, dfirma: _4, dkonto: _4, you2: _4, shoparena: _4, homesklep: _4, sdscloud: _4, unicloud: _4, lodz: _4, pabianice: _4, plock: _4, sieradz: _4, skierniewice: _4, zgierz: _4, krasnik: _4, leczna: _4, lubartow: _4, lublin: _4, poniatowa: _4, swidnik: _4, co: _4, torun: _4, simplesite: _4, myspreadshop: _4, gda: _4, gdansk: _4, gdynia: _4, med: _4, sopot: _4, bielsko: _4 }], pm: [1, { own: _4, name: _4 }], pn: [1, { co: _3, edu: _3, gov: _3, net: _3, org: _3 }], post: _3, pr: [1, { biz: _3, com: _3, edu: _3, gov: _3, info: _3, isla: _3, name: _3, net: _3, org: _3, pro: _3, ac: _3, est: _3, prof: _3 }], pro: [1, { aaa: _3, aca: _3, acct: _3, avocat: _3, bar: _3, cpa: _3, eng: _3, jur: _3, law: _3, med: _3, recht: _3, "12chars": _4, cloudns: _4, barsy: _4, ngrok: _4 }], ps: [1, { com: _3, edu: _3, gov: _3, net: _3, org: _3, plo: _3, sec: _3 }], pt: [1, { com: _3, edu: _3, gov: _3, int: _3, net: _3, nome: _3, org: _3, publ: _3, "123paginaweb": _4 }], pw: [1, { gov: _3, cloudns: _4, x443: _4 }], py: [1, { com: _3, coop: _3, edu: _3, gov: _3, mil: _3, net: _3, org: _3 }], qa: [1, { com: _3, edu: _3, gov: _3, mil: _3, name: _3, net: _3, org: _3, sch: _3 }], re: [1, { asso: _3, com: _3, netlib: _4, can: _4 }], ro: [1, { arts: _3, com: _3, firm: _3, info: _3, nom: _3, nt: _3, org: _3, rec: _3, store: _3, tm: _3, www: _3, co: _4, shop: _4, barsy: _4 }], rs: [1, { ac: _3, co: _3, edu: _3, gov: _3, in: _3, org: _3, brendly: _51, barsy: _4, ox: _4 }], ru: [1, { ac: _4, edu: _4, gov: _4, int: _4, mil: _4, eurodir: _4, adygeya: _4, bashkiria: _4, bir: _4, cbg: _4, com: _4, dagestan: _4, grozny: _4, kalmykia: _4, kustanai: _4, marine: _4, mordovia: _4, msk: _4, mytis: _4, nalchik: _4, nov: _4, pyatigorsk: _4, spb: _4, vladikavkaz: _4, vladimir: _4, na4u: _4, mircloud: _4, myjino: [2, { hosting: _7, landing: _7, spectrum: _7, vps: _7 }], cldmail: [0, { hb: _4 }], mcdir: [2, { vps: _4 }], mcpre: _4, net: _4, org: _4, pp: _4, lk3: _4, ras: _4 }], rw: [1, { ac: _3, co: _3, coop: _3, gov: _3, mil: _3, net: _3, org: _3 }], sa: [1, { com: _3, edu: _3, gov: _3, med: _3, net: _3, org: _3, pub: _3, sch: _3 }], sb: _5, sc: _5, sd: [1, { com: _3, edu: _3, gov: _3, info: _3, med: _3, net: _3, org: _3, tv: _3 }], se: [1, { a: _3, ac: _3, b: _3, bd: _3, brand: _3, c: _3, d: _3, e: _3, f: _3, fh: _3, fhsk: _3, fhv: _3, g: _3, h: _3, i: _3, k: _3, komforb: _3, kommunalforbund: _3, komvux: _3, l: _3, lanbib: _3, m: _3, n: _3, naturbruksgymn: _3, o: _3, org: _3, p: _3, parti: _3, pp: _3, press: _3, r: _3, s: _3, t: _3, tm: _3, u: _3, w: _3, x: _3, y: _3, z: _3, com: _4, iopsys: _4, "123minsida": _4, itcouldbewor: _4, myspreadshop: _4 }], sg: [1, { com: _3, edu: _3, gov: _3, net: _3, org: _3, enscaled: _4 }], sh: [1, { com: _3, gov: _3, mil: _3, net: _3, org: _3, hashbang: _4, botda: _4, platform: [0, { ent: _4, eu: _4, us: _4 }], now: _4 }], si: [1, { f5: _4, gitapp: _4, gitpage: _4 }], sj: _3, sk: _3, sl: _5, sm: _3, sn: [1, { art: _3, com: _3, edu: _3, gouv: _3, org: _3, perso: _3, univ: _3 }], so: [1, { com: _3, edu: _3, gov: _3, me: _3, net: _3, org: _3, surveys: _4 }], sr: _3, ss: [1, { biz: _3, co: _3, com: _3, edu: _3, gov: _3, me: _3, net: _3, org: _3, sch: _3 }], st: [1, { co: _3, com: _3, consulado: _3, edu: _3, embaixada: _3, mil: _3, net: _3, org: _3, principe: _3, saotome: _3, store: _3, helioho: _4, kirara: _4, noho: _4 }], su: [1, { abkhazia: _4, adygeya: _4, aktyubinsk: _4, arkhangelsk: _4, armenia: _4, ashgabad: _4, azerbaijan: _4, balashov: _4, bashkiria: _4, bryansk: _4, bukhara: _4, chimkent: _4, dagestan: _4, "east-kazakhstan": _4, exnet: _4, georgia: _4, grozny: _4, ivanovo: _4, jambyl: _4, kalmykia: _4, kaluga: _4, karacol: _4, karaganda: _4, karelia: _4, khakassia: _4, krasnodar: _4, kurgan: _4, kustanai: _4, lenug: _4, mangyshlak: _4, mordovia: _4, msk: _4, murmansk: _4, nalchik: _4, navoi: _4, "north-kazakhstan": _4, nov: _4, obninsk: _4, penza: _4, pokrovsk: _4, sochi: _4, spb: _4, tashkent: _4, termez: _4, togliatti: _4, troitsk: _4, tselinograd: _4, tula: _4, tuva: _4, vladikavkaz: _4, vladimir: _4, vologda: _4 }], sv: [1, { com: _3, edu: _3, gob: _3, org: _3, red: _3 }], sx: _11, sy: _6, sz: [1, { ac: _3, co: _3, org: _3 }], tc: _3, td: _3, tel: _3, tf: [1, { sch: _4 }], tg: _3, th: [1, { ac: _3, co: _3, go: _3, in: _3, mi: _3, net: _3, or: _3, online: _4, shop: _4 }], tj: [1, { ac: _3, biz: _3, co: _3, com: _3, edu: _3, go: _3, gov: _3, int: _3, mil: _3, name: _3, net: _3, nic: _3, org: _3, test: _3, web: _3 }], tk: _3, tl: _11, tm: [1, { co: _3, com: _3, edu: _3, gov: _3, mil: _3, net: _3, nom: _3, org: _3 }], tn: [1, { com: _3, ens: _3, fin: _3, gov: _3, ind: _3, info: _3, intl: _3, mincom: _3, nat: _3, net: _3, org: _3, perso: _3, tourism: _3, orangecloud: _4 }], to: [1, { "611": _4, com: _3, edu: _3, gov: _3, mil: _3, net: _3, org: _3, oya: _4, x0: _4, quickconnect: _25, vpnplus: _4 }], tr: [1, { av: _3, bbs: _3, bel: _3, biz: _3, com: _3, dr: _3, edu: _3, gen: _3, gov: _3, info: _3, k12: _3, kep: _3, mil: _3, name: _3, net: _3, org: _3, pol: _3, tel: _3, tsk: _3, tv: _3, web: _3, nc: _11 }], tt: [1, { biz: _3, co: _3, com: _3, edu: _3, gov: _3, info: _3, mil: _3, name: _3, net: _3, org: _3, pro: _3 }], tv: [1, { "better-than": _4, dyndns: _4, "on-the-web": _4, "worse-than": _4, from: _4, sakura: _4 }], tw: [1, { club: _3, com: [1, { mymailer: _4 }], ebiz: _3, edu: _3, game: _3, gov: _3, idv: _3, mil: _3, net: _3, org: _3, url: _4, mydns: _4 }], tz: [1, { ac: _3, co: _3, go: _3, hotel: _3, info: _3, me: _3, mil: _3, mobi: _3, ne: _3, or: _3, sc: _3, tv: _3 }], ua: [1, { com: _3, edu: _3, gov: _3, in: _3, net: _3, org: _3, cherkassy: _3, cherkasy: _3, chernigov: _3, chernihiv: _3, chernivtsi: _3, chernovtsy: _3, ck: _3, cn: _3, cr: _3, crimea: _3, cv: _3, dn: _3, dnepropetrovsk: _3, dnipropetrovsk: _3, donetsk: _3, dp: _3, if: _3, "ivano-frankivsk": _3, kh: _3, kharkiv: _3, kharkov: _3, kherson: _3, khmelnitskiy: _3, khmelnytskyi: _3, kiev: _3, kirovograd: _3, km: _3, kr: _3, kropyvnytskyi: _3, krym: _3, ks: _3, kv: _3, kyiv: _3, lg: _3, lt: _3, lugansk: _3, luhansk: _3, lutsk: _3, lv: _3, lviv: _3, mk: _3, mykolaiv: _3, nikolaev: _3, od: _3, odesa: _3, odessa: _3, pl: _3, poltava: _3, rivne: _3, rovno: _3, rv: _3, sb: _3, sebastopol: _3, sevastopol: _3, sm: _3, sumy: _3, te: _3, ternopil: _3, uz: _3, uzhgorod: _3, uzhhorod: _3, vinnica: _3, vinnytsia: _3, vn: _3, volyn: _3, yalta: _3, zakarpattia: _3, zaporizhzhe: _3, zaporizhzhia: _3, zhitomir: _3, zhytomyr: _3, zp: _3, zt: _3, cc: _4, inf: _4, ltd: _4, cx: _4, ie: _4, biz: _4, co: _4, pp: _4, v: _4 }], ug: [1, { ac: _3, co: _3, com: _3, edu: _3, go: _3, gov: _3, mil: _3, ne: _3, or: _3, org: _3, sc: _3, us: _3 }], uk: [1, { ac: _3, co: [1, { bytemark: [0, { dh: _4, vm: _4 }], layershift: _46, barsy: _4, barsyonline: _4, retrosnub: _54, "nh-serv": _4, "no-ip": _4, adimo: _4, myspreadshop: _4 }], gov: [1, { api: _4, campaign: _4, service: _4 }], ltd: _3, me: _3, net: _3, nhs: _3, org: [1, { glug: _4, lug: _4, lugs: _4, affinitylottery: _4, raffleentry: _4, weeklylottery: _4 }], plc: _3, police: _3, sch: _18, conn: _4, copro: _4, hosp: _4, "independent-commission": _4, "independent-inquest": _4, "independent-inquiry": _4, "independent-panel": _4, "independent-review": _4, "public-inquiry": _4, "royal-commission": _4, pymnt: _4, barsy: _4, nimsite: _4, oraclegovcloudapps: _7 }], us: [1, { dni: _3, isa: _3, nsn: _3, ak: _62, al: _62, ar: _62, as: _62, az: _62, ca: _62, co: _62, ct: _62, dc: _62, de: [1, { cc: _3, lib: _4 }], fl: _62, ga: _62, gu: _62, hi: _63, ia: _62, id: _62, il: _62, in: _62, ks: _62, ky: _62, la: _62, ma: [1, { k12: [1, { chtr: _3, paroch: _3, pvt: _3 }], cc: _3, lib: _3 }], md: _62, me: _62, mi: [1, { k12: _3, cc: _3, lib: _3, "ann-arbor": _3, cog: _3, dst: _3, eaton: _3, gen: _3, mus: _3, tec: _3, washtenaw: _3 }], mn: _62, mo: _62, ms: _62, mt: _62, nc: _62, nd: _63, ne: _62, nh: _62, nj: _62, nm: _62, nv: _62, ny: _62, oh: _62, ok: _62, or: _62, pa: _62, pr: _62, ri: _63, sc: _62, sd: _63, tn: _62, tx: _62, ut: _62, va: _62, vi: _62, vt: _62, wa: _62, wi: _62, wv: [1, { cc: _3 }], wy: _62, cloudns: _4, "is-by": _4, "land-4-sale": _4, "stuff-4-sale": _4, heliohost: _4, enscaled: [0, { phx: _4 }], mircloud: _4, ngo: _4, golffan: _4, noip: _4, pointto: _4, freeddns: _4, srv: [2, { gh: _4, gl: _4 }], platterp: _4, servername: _4 }], uy: [1, { com: _3, edu: _3, gub: _3, mil: _3, net: _3, org: _3 }], uz: [1, { co: _3, com: _3, net: _3, org: _3 }], va: _3, vc: [1, { com: _3, edu: _3, gov: _3, mil: _3, net: _3, org: _3, gv: [2, { d: _4 }], "0e": _7, mydns: _4 }], ve: [1, { arts: _3, bib: _3, co: _3, com: _3, e12: _3, edu: _3, emprende: _3, firm: _3, gob: _3, gov: _3, info: _3, int: _3, mil: _3, net: _3, nom: _3, org: _3, rar: _3, rec: _3, store: _3, tec: _3, web: _3 }], vg: [1, { edu: _3 }], vi: [1, { co: _3, com: _3, k12: _3, net: _3, org: _3 }], vn: [1, { ac: _3, ai: _3, biz: _3, com: _3, edu: _3, gov: _3, health: _3, id: _3, info: _3, int: _3, io: _3, name: _3, net: _3, org: _3, pro: _3, angiang: _3, bacgiang: _3, backan: _3, baclieu: _3, bacninh: _3, "baria-vungtau": _3, bentre: _3, binhdinh: _3, binhduong: _3, binhphuoc: _3, binhthuan: _3, camau: _3, cantho: _3, caobang: _3, daklak: _3, daknong: _3, danang: _3, dienbien: _3, dongnai: _3, dongthap: _3, gialai: _3, hagiang: _3, haiduong: _3, haiphong: _3, hanam: _3, hanoi: _3, hatinh: _3, haugiang: _3, hoabinh: _3, hungyen: _3, khanhhoa: _3, kiengiang: _3, kontum: _3, laichau: _3, lamdong: _3, langson: _3, laocai: _3, longan: _3, namdinh: _3, nghean: _3, ninhbinh: _3, ninhthuan: _3, phutho: _3, phuyen: _3, quangbinh: _3, quangnam: _3, quangngai: _3, quangninh: _3, quangtri: _3, soctrang: _3, sonla: _3, tayninh: _3, thaibinh: _3, thainguyen: _3, thanhhoa: _3, thanhphohochiminh: _3, thuathienhue: _3, tiengiang: _3, travinh: _3, tuyenquang: _3, vinhlong: _3, vinhphuc: _3, yenbai: _3 }], vu: _45, wf: [1, { biz: _4, sch: _4 }], ws: [1, { com: _3, edu: _3, gov: _3, net: _3, org: _3, advisor: _7, cloud66: _4, dyndns: _4, mypets: _4 }], yt: [1, { org: _4 }], "xn--mgbaam7a8h": _3, "": _3, "xn--y9a3aq": _3, "": _3, "xn--54b7fta0cc": _3, "": _3, "xn--90ae": _3, "": _3, "xn--mgbcpq6gpa1a": _3, "": _3, "xn--90ais": _3, "": _3, "xn--fiqs8s": _3, "": _3, "xn--fiqz9s": _3, "": _3, "xn--lgbbat1ad8j": _3, "": _3, "xn--wgbh1c": _3, "": _3, "xn--e1a4c": _3, "": _3, "xn--qxa6a": _3, "": _3, "xn--mgbah1a3hjkrd": _3, "": _3, "xn--node": _3, "": _3, "xn--qxam": _3, "": _3, "xn--j6w193g": [1, { "xn--gmqw5a": _3, "xn--55qx5d": _3, "xn--mxtq1m": _3, "xn--wcvs22d": _3, "xn--uc0atv": _3, "xn--od0alg": _3 }], "": [1, { "": _3, "": _3, "": _3, "": _3, "": _3, "": _3 }], "xn--2scrj9c": _3, "": _3, "xn--3hcrj9c": _3, "": _3, "xn--45br5cyl": _3, "": _3, "xn--h2breg3eve": _3, "": _3, "xn--h2brj9c8c": _3, "": _3, "xn--mgbgu82a": _3, "": _3, "xn--rvc1e0am3e": _3, "": _3, "xn--h2brj9c": _3, "": _3, "xn--mgbbh1a": _3, "": _3, "xn--mgbbh1a71e": _3, "": _3, "xn--fpcrj9c3d": _3, "": _3, "xn--gecrj9c": _3, "": _3, "xn--s9brj9c": _3, "": _3, "xn--45brj9c": _3, "": _3, "xn--xkc2dl3a5ee0h": _3, "": _3, "xn--mgba3a4f16a": _3, "": _3, "xn--mgba3a4fra": _3, "": _3, "xn--mgbtx2b": _3, "": _3, "xn--mgbayh7gpa": _3, "": _3, "xn--3e0b707e": _3, "": _3, "xn--80ao21a": _3, "": _3, "xn--q7ce6a": _3, "": _3, "xn--fzc2c9e2c": _3, "": _3, "xn--xkc2al3hye2a": _3, "": _3, "xn--mgbc0a9azcg": _3, "": _3, "xn--d1alf": _3, "": _3, "xn--l1acc": _3, "": _3, "xn--mix891f": _3, "": _3, "xn--mix082f": _3, "": _3, "xn--mgbx4cd0ab": _3, "": _3, "xn--mgb9awbf": _3, "": _3, "xn--mgbai9azgqp6j": _3, "": _3, "xn--mgbai9a5eva00b": _3, "": _3, "xn--ygbi2ammx": _3, "": _3, "xn--90a3ac": [1, { "xn--80au": _3, "xn--90azh": _3, "xn--d1at": _3, "xn--c1avg": _3, "xn--o1ac": _3, "xn--o1ach": _3 }], "": [1, { "": _3, "": _3, "": _3, "": _3, "": _3, "": _3 }], "xn--p1ai": _3, "": _3, "xn--wgbl6a": _3, "": _3, "xn--mgberp4a5d4ar": _3, "": _3, "xn--mgberp4a5d4a87g": _3, "": _3, "xn--mgbqly7c0a67fbc": _3, "": _3, "xn--mgbqly7cvafr": _3, "": _3, "xn--mgbpl2fh": _3, "": _3, "xn--yfro4i67o": _3, "": _3, "xn--clchc0ea0b2g2a9gcd": _3, "": _3, "xn--ogbpf8fl": _3, "": _3, "xn--mgbtf8fl": _3, "": _3, "xn--o3cw4h": [1, { "xn--o3cyx2a": _3, "xn--12co0c3b4eva": _3, "xn--m3ch0j3a": _3, "xn--h3cuzk1di": _3, "xn--12c1fe0br": _3, "xn--12cfi8ixb8l": _3 }], "": [1, { "": _3, "": _3, "": _3, "": _3, "": _3, "": _3 }], "xn--pgbs0dh": _3, "": _3, "xn--kpry57d": _3, "": _3, "xn--kprw13d": _3, "": _3, "xn--nnx388a": _3, "": _3, "xn--j1amh": _3, "": _3, "xn--mgb2ddes": _3, "": _3, xxx: _3, ye: _6, za: [0, { ac: _3, agric: _3, alt: _3, co: _3, edu: _3, gov: _3, grondar: _3, law: _3, mil: _3, net: _3, ngo: _3, nic: _3, nis: _3, nom: _3, org: _3, school: _3, tm: _3, web: _3 }], zm: [1, { ac: _3, biz: _3, co: _3, com: _3, edu: _3, gov: _3, info: _3, mil: _3, net: _3, org: _3, sch: _3 }], zw: [1, { ac: _3, co: _3, gov: _3, mil: _3, org: _3 }], aaa: _3, aarp: _3, abb: _3, abbott: _3, abbvie: _3, abc: _3, able: _3, abogado: _3, abudhabi: _3, academy: [1, { official: _4 }], accenture: _3, accountant: _3, accountants: _3, aco: _3, actor: _3, ads: _3, adult: _3, aeg: _3, aetna: _3, afl: _3, africa: _3, agakhan: _3, agency: _3, aig: _3, airbus: _3, airforce: _3, airtel: _3, akdn: _3, alibaba: _3, alipay: _3, allfinanz: _3, allstate: _3, ally: _3, alsace: _3, alstom: _3, amazon: _3, americanexpress: _3, americanfamily: _3, amex: _3, amfam: _3, amica: _3, amsterdam: _3, analytics: _3, android: _3, anquan: _3, anz: _3, aol: _3, apartments: _3, app: [1, { adaptable: _4, aiven: _4, beget: _7, brave: _8, clerk: _4, clerkstage: _4, wnext: _4, csb: [2, { preview: _4 }], convex: _4, deta: _4, ondigitalocean: _4, easypanel: _4, encr: _4, evervault: _9, expo: [2, { staging: _4 }], edgecompute: _4, "on-fleek": _4, flutterflow: _4, e2b: _4, framer: _4, hosted: _7, run: _7, web: _4, hasura: _4, botdash: _4, loginline: _4, lovable: _4, medusajs: _4, messerli: _4, netfy: _4, netlify: _4, ngrok: _4, "ngrok-free": _4, developer: _7, noop: _4, northflank: _7, upsun: _7, replit: _10, nyat: _4, snowflake: [0, { "*": _4, privatelink: _7 }], streamlit: _4, storipress: _4, telebit: _4, typedream: _4, vercel: _4, bookonline: _4, wdh: _4, windsurf: _4, zeabur: _4, zerops: _7 }], apple: _3, aquarelle: _3, arab: _3, aramco: _3, archi: _3, army: _3, art: _3, arte: _3, asda: _3, associates: _3, athleta: _3, attorney: _3, auction: _3, audi: _3, audible: _3, audio: _3, auspost: _3, author: _3, auto: _3, autos: _3, aws: [1, { sagemaker: [0, { "ap-northeast-1": _14, "ap-northeast-2": _14, "ap-south-1": _14, "ap-southeast-1": _14, "ap-southeast-2": _14, "ca-central-1": _16, "eu-central-1": _14, "eu-west-1": _14, "eu-west-2": _14, "us-east-1": _16, "us-east-2": _16, "us-west-2": _16, "af-south-1": _13, "ap-east-1": _13, "ap-northeast-3": _13, "ap-south-2": _15, "ap-southeast-3": _13, "ap-southeast-4": _15, "ca-west-1": [0, { notebook: _4, "notebook-fips": _4 }], "eu-central-2": _13, "eu-north-1": _13, "eu-south-1": _13, "eu-south-2": _13, "eu-west-3": _13, "il-central-1": _13, "me-central-1": _13, "me-south-1": _13, "sa-east-1": _13, "us-gov-east-1": _17, "us-gov-west-1": _17, "us-west-1": [0, { notebook: _4, "notebook-fips": _4, studio: _4 }], experiments: _7 }], repost: [0, { private: _7 }], on: [0, { "ap-northeast-1": _12, "ap-southeast-1": _12, "ap-southeast-2": _12, "eu-central-1": _12, "eu-north-1": _12, "eu-west-1": _12, "us-east-1": _12, "us-east-2": _12, "us-west-2": _12 }] }], axa: _3, azure: _3, baby: _3, baidu: _3, banamex: _3, band: _3, bank: _3, bar: _3, barcelona: _3, barclaycard: _3, barclays: _3, barefoot: _3, bargains: _3, baseball: _3, basketball: [1, { aus: _4, nz: _4 }], bauhaus: _3, bayern: _3, bbc: _3, bbt: _3, bbva: _3, bcg: _3, bcn: _3, beats: _3, beauty: _3, beer: _3, bentley: _3, berlin: _3, best: _3, bestbuy: _3, bet: _3, bharti: _3, bible: _3, bid: _3, bike: _3, bing: _3, bingo: _3, bio: _3, black: _3, blackfriday: _3, blockbuster: _3, blog: _3, bloomberg: _3, blue: _3, bms: _3, bmw: _3, bnpparibas: _3, boats: _3, boehringer: _3, bofa: _3, bom: _3, bond: _3, boo: _3, book: _3, booking: _3, bosch: _3, bostik: _3, boston: _3, bot: _3, boutique: _3, box: _3, bradesco: _3, bridgestone: _3, broadway: _3, broker: _3, brother: _3, brussels: _3, build: [1, { v0: _4, windsurf: _4 }], builders: [1, { cloudsite: _4 }], business: _19, buy: _3, buzz: _3, bzh: _3, cab: _3, cafe: _3, cal: _3, call: _3, calvinklein: _3, cam: _3, camera: _3, camp: [1, { emf: [0, { at: _4 }] }], canon: _3, capetown: _3, capital: _3, capitalone: _3, car: _3, caravan: _3, cards: _3, care: _3, career: _3, careers: _3, cars: _3, casa: [1, { nabu: [0, { ui: _4 }] }], case: _3, cash: _3, casino: _3, catering: _3, catholic: _3, cba: _3, cbn: _3, cbre: _3, center: _3, ceo: _3, cern: _3, cfa: _3, cfd: _3, chanel: _3, channel: _3, charity: _3, chase: _3, chat: _3, cheap: _3, chintai: _3, christmas: _3, chrome: _3, church: _3, cipriani: _3, circle: _3, cisco: _3, citadel: _3, citi: _3, citic: _3, city: _3, claims: _3, cleaning: _3, click: _3, clinic: _3, clinique: _3, clothing: _3, cloud: [1, { convex: _4, elementor: _4, encoway: [0, { eu: _4 }], statics: _7, ravendb: _4, axarnet: [0, { "es-1": _4 }], diadem: _4, jelastic: [0, { vip: _4 }], jele: _4, "jenv-aruba": [0, { aruba: [0, { eur: [0, { it1: _4 }] }], it1: _4 }], keliweb: [2, { cs: _4 }], oxa: [2, { tn: _4, uk: _4 }], primetel: [2, { uk: _4 }], reclaim: [0, { ca: _4, uk: _4, us: _4 }], trendhosting: [0, { ch: _4, de: _4 }], jotelulu: _4, kuleuven: _4, laravel: _4, linkyard: _4, magentosite: _7, matlab: _4, observablehq: _4, perspecta: _4, vapor: _4, "on-rancher": _7, scw: [0, { baremetal: [0, { "fr-par-1": _4, "fr-par-2": _4, "nl-ams-1": _4 }], "fr-par": [0, { cockpit: _4, fnc: [2, { functions: _4 }], k8s: _21, s3: _4, "s3-website": _4, whm: _4 }], instances: [0, { priv: _4, pub: _4 }], k8s: _4, "nl-ams": [0, { cockpit: _4, k8s: _21, s3: _4, "s3-website": _4, whm: _4 }], "pl-waw": [0, { cockpit: _4, k8s: _21, s3: _4, "s3-website": _4 }], scalebook: _4, smartlabeling: _4 }], servebolt: _4, onstackit: [0, { runs: _4 }], trafficplex: _4, "unison-services": _4, urown: _4, voorloper: _4, zap: _4 }], club: [1, { cloudns: _4, jele: _4, barsy: _4 }], clubmed: _3, coach: _3, codes: [1, { owo: _7 }], coffee: _3, college: _3, cologne: _3, commbank: _3, community: [1, { nog: _4, ravendb: _4, myforum: _4 }], company: _3, compare: _3, computer: _3, comsec: _3, condos: _3, construction: _3, consulting: _3, contact: _3, contractors: _3, cooking: _3, cool: [1, { elementor: _4, de: _4 }], corsica: _3, country: _3, coupon: _3, coupons: _3, courses: _3, cpa: _3, credit: _3, creditcard: _3, creditunion: _3, cricket: _3, crown: _3, crs: _3, cruise: _3, cruises: _3, cuisinella: _3, cymru: _3, cyou: _3, dad: _3, dance: _3, data: _3, date: _3, dating: _3, datsun: _3, day: _3, dclk: _3, dds: _3, deal: _3, dealer: _3, deals: _3, degree: _3, delivery: _3, dell: _3, deloitte: _3, delta: _3, democrat: _3, dental: _3, dentist: _3, desi: _3, design: [1, { graphic: _4, bss: _4 }], dev: [1, { "12chars": _4, myaddr: _4, panel: _4, lcl: _7, lclstage: _7, stg: _7, stgstage: _7, pages: _4, r2: _4, workers: _4, deno: _4, "deno-staging": _4, deta: _4, evervault: _9, fly: _4, githubpreview: _4, gateway: _7, hrsn: [2, { psl: [0, { sub: _4, wc: [0, { "*": _4, sub: _7 }] }] }], botdash: _4, inbrowser: _7, "is-a-good": _4, "is-a": _4, iserv: _4, runcontainers: _4, localcert: [0, { user: _7 }], loginline: _4, barsy: _4, mediatech: _4, modx: _4, ngrok: _4, "ngrok-free": _4, "is-a-fullstack": _4, "is-cool": _4, "is-not-a": _4, localplayer: _4, xmit: _4, "platter-app": _4, replit: [2, { archer: _4, bones: _4, canary: _4, global: _4, hacker: _4, id: _4, janeway: _4, kim: _4, kira: _4, kirk: _4, odo: _4, paris: _4, picard: _4, pike: _4, prerelease: _4, reed: _4, riker: _4, sisko: _4, spock: _4, staging: _4, sulu: _4, tarpit: _4, teams: _4, tucker: _4, wesley: _4, worf: _4 }], crm: [0, { d: _7, w: _7, wa: _7, wb: _7, wc: _7, wd: _7, we: _7, wf: _7 }], vercel: _4, webhare: _7 }], dhl: _3, diamonds: _3, diet: _3, digital: [1, { cloudapps: [2, { london: _4 }] }], direct: [1, { libp2p: _4 }], directory: _3, discount: _3, discover: _3, dish: _3, diy: _3, dnp: _3, docs: _3, doctor: _3, dog: _3, domains: _3, dot: _3, download: _3, drive: _3, dtv: _3, dubai: _3, dunlop: _3, dupont: _3, durban: _3, dvag: _3, dvr: _3, earth: _3, eat: _3, eco: _3, edeka: _3, education: _19, email: [1, { crisp: [0, { on: _4 }], tawk: _49, tawkto: _49 }], emerck: _3, energy: _3, engineer: _3, engineering: _3, enterprises: _3, epson: _3, equipment: _3, ericsson: _3, erni: _3, esq: _3, estate: [1, { compute: _7 }], eurovision: _3, eus: [1, { party: _50 }], events: [1, { koobin: _4, co: _4 }], exchange: _3, expert: _3, exposed: _3, express: _3, extraspace: _3, fage: _3, fail: _3, fairwinds: _3, faith: _3, family: _3, fan: _3, fans: _3, farm: [1, { storj: _4 }], farmers: _3, fashion: _3, fast: _3, fedex: _3, feedback: _3, ferrari: _3, ferrero: _3, fidelity: _3, fido: _3, film: _3, final: _3, finance: _3, financial: _19, fire: _3, firestone: _3, firmdale: _3, fish: _3, fishing: _3, fit: _3, fitness: _3, flickr: _3, flights: _3, flir: _3, florist: _3, flowers: _3, fly: _3, foo: _3, food: _3, football: _3, ford: _3, forex: _3, forsale: _3, forum: _3, foundation: _3, fox: _3, free: _3, fresenius: _3, frl: _3, frogans: _3, frontier: _3, ftr: _3, fujitsu: _3, fun: _3, fund: _3, furniture: _3, futbol: _3, fyi: _3, gal: _3, gallery: _3, gallo: _3, gallup: _3, game: _3, games: [1, { pley: _4, sheezy: _4 }], gap: _3, garden: _3, gay: [1, { pages: _4 }], gbiz: _3, gdn: [1, { cnpy: _4 }], gea: _3, gent: _3, genting: _3, george: _3, ggee: _3, gift: _3, gifts: _3, gives: _3, giving: _3, glass: _3, gle: _3, global: [1, { appwrite: _4 }], globo: _3, gmail: _3, gmbh: _3, gmo: _3, gmx: _3, godaddy: _3, gold: _3, goldpoint: _3, golf: _3, goo: _3, goodyear: _3, goog: [1, { cloud: _4, translate: _4, usercontent: _7 }], google: _3, gop: _3, got: _3, grainger: _3, graphics: _3, gratis: _3, green: _3, gripe: _3, grocery: _3, group: [1, { discourse: _4 }], gucci: _3, guge: _3, guide: _3, guitars: _3, guru: _3, hair: _3, hamburg: _3, hangout: _3, haus: _3, hbo: _3, hdfc: _3, hdfcbank: _3, health: [1, { hra: _4 }], healthcare: _3, help: _3, helsinki: _3, here: _3, hermes: _3, hiphop: _3, hisamitsu: _3, hitachi: _3, hiv: _3, hkt: _3, hockey: _3, holdings: _3, holiday: _3, homedepot: _3, homegoods: _3, homes: _3, homesense: _3, honda: _3, horse: _3, hospital: _3, host: [1, { cloudaccess: _4, freesite: _4, easypanel: _4, fastvps: _4, myfast: _4, tempurl: _4, wpmudev: _4, jele: _4, mircloud: _4, wp2: _4, half: _4 }], hosting: [1, { opencraft: _4 }], hot: _3, hotels: _3, hotmail: _3, house: _3, how: _3, hsbc: _3, hughes: _3, hyatt: _3, hyundai: _3, ibm: _3, icbc: _3, ice: _3, icu: _3, ieee: _3, ifm: _3, ikano: _3, imamat: _3, imdb: _3, immo: _3, immobilien: _3, inc: _3, industries: _3, infiniti: _3, ing: _3, ink: _3, institute: _3, insurance: _3, insure: _3, international: _3, intuit: _3, investments: _3, ipiranga: _3, irish: _3, ismaili: _3, ist: _3, istanbul: _3, itau: _3, itv: _3, jaguar: _3, java: _3, jcb: _3, jeep: _3, jetzt: _3, jewelry: _3, jio: _3, jll: _3, jmp: _3, jnj: _3, joburg: _3, jot: _3, joy: _3, jpmorgan: _3, jprs: _3, juegos: _3, juniper: _3, kaufen: _3, kddi: _3, kerryhotels: _3, kerryproperties: _3, kfh: _3, kia: _3, kids: _3, kim: _3, kindle: _3, kitchen: _3, kiwi: _3, koeln: _3, komatsu: _3, kosher: _3, kpmg: _3, kpn: _3, krd: [1, { co: _4, edu: _4 }], kred: _3, kuokgroup: _3, kyoto: _3, lacaixa: _3, lamborghini: _3, lamer: _3, lancaster: _3, land: _3, landrover: _3, lanxess: _3, lasalle: _3, lat: _3, latino: _3, latrobe: _3, law: _3, lawyer: _3, lds: _3, lease: _3, leclerc: _3, lefrak: _3, legal: _3, lego: _3, lexus: _3, lgbt: _3, lidl: _3, life: _3, lifeinsurance: _3, lifestyle: _3, lighting: _3, like: _3, lilly: _3, limited: _3, limo: _3, lincoln: _3, link: [1, { myfritz: _4, cyon: _4, dweb: _7, inbrowser: _7, nftstorage: _57, mypep: _4, storacha: _57, w3s: _57 }], live: [1, { aem: _4, hlx: _4, ewp: _7 }], living: _3, llc: _3, llp: _3, loan: _3, loans: _3, locker: _3, locus: _3, lol: [1, { omg: _4 }], london: _3, lotte: _3, lotto: _3, love: _3, lpl: _3, lplfinancial: _3, ltd: _3, ltda: _3, lundbeck: _3, luxe: _3, luxury: _3, madrid: _3, maif: _3, maison: _3, makeup: _3, man: _3, management: _3, mango: _3, map: _3, market: _3, marketing: _3, markets: _3, marriott: _3, marshalls: _3, mattel: _3, mba: _3, mckinsey: _3, med: _3, media: _58, meet: _3, melbourne: _3, meme: _3, memorial: _3, men: _3, menu: [1, { barsy: _4, barsyonline: _4 }], merck: _3, merckmsd: _3, miami: _3, microsoft: _3, mini: _3, mint: _3, mit: _3, mitsubishi: _3, mlb: _3, mls: _3, mma: _3, mobile: _3, moda: _3, moe: _3, moi: _3, mom: [1, { ind: _4 }], monash: _3, money: _3, monster: _3, mormon: _3, mortgage: _3, moscow: _3, moto: _3, motorcycles: _3, mov: _3, movie: _3, msd: _3, mtn: _3, mtr: _3, music: _3, nab: _3, nagoya: _3, navy: _3, nba: _3, nec: _3, netbank: _3, netflix: _3, network: [1, { alces: _7, co: _4, arvo: _4, azimuth: _4, tlon: _4 }], neustar: _3, new: _3, news: [1, { noticeable: _4 }], next: _3, nextdirect: _3, nexus: _3, nfl: _3, ngo: _3, nhk: _3, nico: _3, nike: _3, nikon: _3, ninja: _3, nissan: _3, nissay: _3, nokia: _3, norton: _3, now: _3, nowruz: _3, nowtv: _3, nra: _3, nrw: _3, ntt: _3, nyc: _3, obi: _3, observer: _3, office: _3, okinawa: _3, olayan: _3, olayangroup: _3, ollo: _3, omega: _3, one: [1, { kin: _7, service: _4 }], ong: [1, { obl: _4 }], onl: _3, online: [1, { eero: _4, "eero-stage": _4, websitebuilder: _4, barsy: _4 }], ooo: _3, open: _3, oracle: _3, orange: [1, { tech: _4 }], organic: _3, origins: _3, osaka: _3, otsuka: _3, ott: _3, ovh: [1, { nerdpol: _4 }], page: [1, { aem: _4, hlx: _4, hlx3: _4, translated: _4, codeberg: _4, heyflow: _4, prvcy: _4, rocky: _4, pdns: _4, plesk: _4 }], panasonic: _3, paris: _3, pars: _3, partners: _3, parts: _3, party: _3, pay: _3, pccw: _3, pet: _3, pfizer: _3, pharmacy: _3, phd: _3, philips: _3, phone: _3, photo: _3, photography: _3, photos: _58, physio: _3, pics: _3, pictet: _3, pictures: [1, { "1337": _4 }], pid: _3, pin: _3, ping: _3, pink: _3, pioneer: _3, pizza: [1, { ngrok: _4 }], place: _19, play: _3, playstation: _3, plumbing: _3, plus: _3, pnc: _3, pohl: _3, poker: _3, politie: _3, porn: _3, pramerica: _3, praxi: _3, press: _3, prime: _3, prod: _3, productions: _3, prof: _3, progressive: _3, promo: _3, properties: _3, property: _3, protection: _3, pru: _3, prudential: _3, pub: [1, { id: _7, kin: _7, barsy: _4 }], pwc: _3, qpon: _3, quebec: _3, quest: _3, racing: _3, radio: _3, read: _3, realestate: _3, realtor: _3, realty: _3, recipes: _3, red: _3, redstone: _3, redumbrella: _3, rehab: _3, reise: _3, reisen: _3, reit: _3, reliance: _3, ren: _3, rent: _3, rentals: _3, repair: _3, report: _3, republican: _3, rest: _3, restaurant: _3, review: _3, reviews: _3, rexroth: _3, rich: _3, richardli: _3, ricoh: _3, ril: _3, rio: _3, rip: [1, { clan: _4 }], rocks: [1, { myddns: _4, stackit: _4, "lima-city": _4, webspace: _4 }], rodeo: _3, rogers: _3, room: _3, rsvp: _3, rugby: _3, ruhr: _3, run: [1, { appwrite: _7, development: _4, ravendb: _4, liara: [2, { iran: _4 }], servers: _4, build: _7, code: _7, database: _7, migration: _7, onporter: _4, repl: _4, stackit: _4, val: [0, { express: _4, web: _4 }], wix: _4 }], rwe: _3, ryukyu: _3, saarland: _3, safe: _3, safety: _3, sakura: _3, sale: _3, salon: _3, samsclub: _3, samsung: _3, sandvik: _3, sandvikcoromant: _3, sanofi: _3, sap: _3, sarl: _3, sas: _3, save: _3, saxo: _3, sbi: _3, sbs: _3, scb: _3, schaeffler: _3, schmidt: _3, scholarships: _3, school: _3, schule: _3, schwarz: _3, science: _3, scot: [1, { gov: [2, { service: _4 }] }], search: _3, seat: _3, secure: _3, security: _3, seek: _3, select: _3, sener: _3, services: [1, { loginline: _4 }], seven: _3, sew: _3, sex: _3, sexy: _3, sfr: _3, shangrila: _3, sharp: _3, shell: _3, shia: _3, shiksha: _3, shoes: _3, shop: [1, { base: _4, hoplix: _4, barsy: _4, barsyonline: _4, shopware: _4 }], shopping: _3, shouji: _3, show: _3, silk: _3, sina: _3, singles: _3, site: [1, { square: _4, canva: _22, cloudera: _7, convex: _4, cyon: _4, fastvps: _4, figma: _4, heyflow: _4, jele: _4, jouwweb: _4, loginline: _4, barsy: _4, notion: _4, omniwe: _4, opensocial: _4, madethis: _4, platformsh: _7, tst: _7, byen: _4, srht: _4, novecore: _4, cpanel: _4, wpsquared: _4 }], ski: _3, skin: _3, sky: _3, skype: _3, sling: _3, smart: _3, smile: _3, sncf: _3, soccer: _3, social: _3, softbank: _3, software: _3, sohu: _3, solar: _3, solutions: _3, song: _3, sony: _3, soy: _3, spa: _3, space: [1, { myfast: _4, heiyu: _4, hf: [2, { static: _4 }], "app-ionos": _4, project: _4, uber: _4, xs4all: _4 }], sport: _3, spot: _3, srl: _3, stada: _3, staples: _3, star: _3, statebank: _3, statefarm: _3, stc: _3, stcgroup: _3, stockholm: _3, storage: _3, store: [1, { barsy: _4, sellfy: _4, shopware: _4, storebase: _4 }], stream: _3, studio: _3, study: _3, style: _3, sucks: _3, supplies: _3, supply: _3, support: [1, { barsy: _4 }], surf: _3, surgery: _3, suzuki: _3, swatch: _3, swiss: _3, sydney: _3, systems: [1, { knightpoint: _4 }], tab: _3, taipei: _3, talk: _3, taobao: _3, target: _3, tatamotors: _3, tatar: _3, tattoo: _3, tax: _3, taxi: _3, tci: _3, tdk: _3, team: [1, { discourse: _4, jelastic: _4 }], tech: [1, { cleverapps: _4 }], technology: _19, temasek: _3, tennis: _3, teva: _3, thd: _3, theater: _3, theatre: _3, tiaa: _3, tickets: _3, tienda: _3, tips: _3, tires: _3, tirol: _3, tjmaxx: _3, tjx: _3, tkmaxx: _3, tmall: _3, today: [1, { prequalifyme: _4 }], tokyo: _3, tools: [1, { addr: _47, myaddr: _4 }], top: [1, { ntdll: _4, wadl: _7 }], toray: _3, toshiba: _3, total: _3, tours: _3, town: _3, toyota: _3, toys: _3, trade: _3, trading: _3, training: _3, travel: _3, travelers: _3, travelersinsurance: _3, trust: _3, trv: _3, tube: _3, tui: _3, tunes: _3, tushu: _3, tvs: _3, ubank: _3, ubs: _3, unicom: _3, university: _3, uno: _3, uol: _3, ups: _3, vacations: _3, vana: _3, vanguard: _3, vegas: _3, ventures: _3, verisign: _3, versicherung: _3, vet: _3, viajes: _3, video: _3, vig: _3, viking: _3, villas: _3, vin: _3, vip: _3, virgin: _3, visa: _3, vision: _3, viva: _3, vivo: _3, vlaanderen: _3, vodka: _3, volvo: _3, vote: _3, voting: _3, voto: _3, voyage: _3, wales: _3, walmart: _3, walter: _3, wang: _3, wanggou: _3, watch: _3, watches: _3, weather: _3, weatherchannel: _3, webcam: _3, weber: _3, website: _58, wed: _3, wedding: _3, weibo: _3, weir: _3, whoswho: _3, wien: _3, wiki: _58, williamhill: _3, win: _3, windows: _3, wine: _3, winners: _3, wme: _3, wolterskluwer: _3, woodside: _3, work: _3, works: _3, world: _3, wow: _3, wtc: _3, wtf: _3, xbox: _3, xerox: _3, xihuan: _3, xin: _3, "xn--11b4c3d": _3, "": _3, "xn--1ck2e1b": _3, "": _3, "xn--1qqw23a": _3, "": _3, "xn--30rr7y": _3, "": _3, "xn--3bst00m": _3, "": _3, "xn--3ds443g": _3, "": _3, "xn--3pxu8k": _3, "": _3, "xn--42c2d9a": _3, "": _3, "xn--45q11c": _3, "": _3, "xn--4gbrim": _3, "": _3, "xn--55qw42g": _3, "": _3, "xn--55qx5d": _3, "": _3, "xn--5su34j936bgsg": _3, "": _3, "xn--5tzm5g": _3, "": _3, "xn--6frz82g": _3, "": _3, "xn--6qq986b3xl": _3, "": _3, "xn--80adxhks": _3, "": _3, "xn--80aqecdr1a": _3, "": _3, "xn--80asehdb": _3, "": _3, "xn--80aswg": _3, "": _3, "xn--8y0a063a": _3, "": _3, "xn--9dbq2a": _3, "": _3, "xn--9et52u": _3, "": _3, "xn--9krt00a": _3, "": _3, "xn--b4w605ferd": _3, "": _3, "xn--bck1b9a5dre4c": _3, "": _3, "xn--c1avg": _3, "": _3, "xn--c2br7g": _3, "": _3, "xn--cck2b3b": _3, "": _3, "xn--cckwcxetd": _3, "": _3, "xn--cg4bki": _3, "": _3, "xn--czr694b": _3, "": _3, "xn--czrs0t": _3, "": _3, "xn--czru2d": _3, "": _3, "xn--d1acj3b": _3, "": _3, "xn--eckvdtc9d": _3, "": _3, "xn--efvy88h": _3, "": _3, "xn--fct429k": _3, "": _3, "xn--fhbei": _3, "": _3, "xn--fiq228c5hs": _3, "": _3, "xn--fiq64b": _3, "": _3, "xn--fjq720a": _3, "": _3, "xn--flw351e": _3, "": _3, "xn--fzys8d69uvgm": _3, "": _3, "xn--g2xx48c": _3, "": _3, "xn--gckr3f0f": _3, "": _3, "xn--gk3at1e": _3, "": _3, "xn--hxt814e": _3, "": _3, "xn--i1b6b1a6a2e": _3, "": _3, "xn--imr513n": _3, "": _3, "xn--io0a7i": _3, "": _3, "xn--j1aef": _3, "": _3, "xn--jlq480n2rg": _3, "": _3, "xn--jvr189m": _3, "": _3, "xn--kcrx77d1x4a": _3, "": _3, "xn--kput3i": _3, "": _3, "xn--mgba3a3ejt": _3, "": _3, "xn--mgba7c0bbn0a": _3, "": _3, "xn--mgbab2bd": _3, "": _3, "xn--mgbca7dzdo": _3, "": _3, "xn--mgbi4ecexp": _3, "": _3, "xn--mgbt3dhd": _3, "": _3, "xn--mk1bu44c": _3, "": _3, "xn--mxtq1m": _3, "": _3, "xn--ngbc5azd": _3, "": _3, "xn--ngbe9e0a": _3, "": _3, "xn--ngbrx": _3, "": _3, "xn--nqv7f": _3, "": _3, "xn--nqv7fs00ema": _3, "": _3, "xn--nyqy26a": _3, "": _3, "xn--otu796d": _3, "": _3, "xn--p1acf": [1, { "xn--90amc": _4, "xn--j1aef": _4, "xn--j1ael8b": _4, "xn--h1ahn": _4, "xn--j1adp": _4, "xn--c1avg": _4, "xn--80aaa0cvac": _4, "xn--h1aliz": _4, "xn--90a1af": _4, "xn--41a": _4 }], "": [1, { "": _4, "": _4, "": _4, "": _4, "": _4, "": _4, "": _4, "": _4, "": _4, "": _4 }], "xn--pssy2u": _3, "": _3, "xn--q9jyb4c": _3, "": _3, "xn--qcka1pmc": _3, "": _3, "xn--rhqv96g": _3, "": _3, "xn--rovu88b": _3, "": _3, "xn--ses554g": _3, "": _3, "xn--t60b56a": _3, "": _3, "xn--tckwe": _3, "": _3, "xn--tiq49xqyj": _3, "": _3, "xn--unup4y": _3, "": _3, "xn--vermgensberater-ctb": _3, "vermgensberater": _3, "xn--vermgensberatung-pwb": _3, "vermgensberatung": _3, "xn--vhquv": _3, "": _3, "xn--vuq861b": _3, "": _3, "xn--w4r85el8fhu5dnra": _3, "": _3, "xn--w4rs40l": _3, "": _3, "xn--xhq521b": _3, "": _3, "xn--zfr164b": _3, "": _3, xyz: [1, { botdash: _4, telebit: _7 }], yachts: _3, yahoo: _3, yamaxun: _3, yandex: _3, yodobashi: _3, yoga: _3, yokohama: _3, you: _3, youtube: _3, yun: _3, zappos: _3, zara: _3, zero: _3, zip: _3, zone: [1, { cloud66: _4, triton: _7, stackit: _4, lima: _4 }], zuerich: _3 }];
    return rules2;
  }();
  function lookupInTrie(parts, trie, index, allowedMask) {
    let result = null;
    let node = trie;
    while (node !== undefined) {
      if ((node[0] & allowedMask) !== 0) {
        result = {
          index: index + 1,
          isIcann: node[0] === 1,
          isPrivate: node[0] === 2
        };
      }
      if (index === -1) {
        break;
      }
      const succ = node[1];
      node = Object.prototype.hasOwnProperty.call(succ, parts[index]) ? succ[parts[index]] : succ["*"];
      index -= 1;
    }
    return result;
  }
  function suffixLookup(hostname, options, out) {
    var _a3;
    if (fastPathLookup(hostname, options, out)) {
      return;
    }
    const hostnameParts = hostname.split(".");
    const allowedMask = (options.allowPrivateDomains ? 2 : 0) | (options.allowIcannDomains ? 1 : 0);
    const exceptionMatch = lookupInTrie(hostnameParts, exceptions, hostnameParts.length - 1, allowedMask);
    if (exceptionMatch !== null) {
      out.isIcann = exceptionMatch.isIcann;
      out.isPrivate = exceptionMatch.isPrivate;
      out.publicSuffix = hostnameParts.slice(exceptionMatch.index + 1).join(".");
      return;
    }
    const rulesMatch = lookupInTrie(hostnameParts, rules, hostnameParts.length - 1, allowedMask);
    if (rulesMatch !== null) {
      out.isIcann = rulesMatch.isIcann;
      out.isPrivate = rulesMatch.isPrivate;
      out.publicSuffix = hostnameParts.slice(rulesMatch.index).join(".");
      return;
    }
    out.isIcann = false;
    out.isPrivate = false;
    out.publicSuffix = (_a3 = hostnameParts[hostnameParts.length - 1]) !== null && _a3 !== undefined ? _a3 : null;
  }
  var RESULT = getEmptyResult();
  function parse(url2, options = {}) {
    return parseImpl(url2, 5, suffixLookup, options, getEmptyResult());
  }
  function getHostname(url2, options = {}) {
    resetResult(RESULT);
    return parseImpl(url2, 0, suffixLookup, options, RESULT).hostname;
  }
  function getPublicSuffix(url2, options = {}) {
    resetResult(RESULT);
    return parseImpl(url2, 2, suffixLookup, options, RESULT).publicSuffix;
  }
  function getDomain(url2, options = {}) {
    resetResult(RESULT);
    return parseImpl(url2, 3, suffixLookup, options, RESULT).domain;
  }
  function getSubdomain(url2, options = {}) {
    resetResult(RESULT);
    return parseImpl(url2, 4, suffixLookup, options, RESULT).subdomain;
  }
  function getDomainWithoutSuffix(url2, options = {}) {
    resetResult(RESULT);
    return parseImpl(url2, 5, suffixLookup, options, RESULT).domainWithoutSuffix;
  }
  exports2.getDomain = getDomain;
  exports2.getDomainWithoutSuffix = getDomainWithoutSuffix;
  exports2.getHostname = getHostname;
  exports2.getPublicSuffix = getPublicSuffix;
  exports2.getSubdomain = getSubdomain;
  exports2.parse = parse;
});

// backend/node_modules/tough-cookie/dist/getPublicSuffix.js
var require_getPublicSuffix = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.getPublicSuffix = getPublicSuffix;
  var tldts_1 = require_cjs2();
  var SPECIAL_USE_DOMAINS = ["local", "example", "invalid", "localhost", "test"];
  var SPECIAL_TREATMENT_DOMAINS = ["localhost", "invalid"];
  var defaultGetPublicSuffixOptions = {
    allowSpecialUseDomain: false,
    ignoreError: false
  };
  function getPublicSuffix(domain, options = {}) {
    options = { ...defaultGetPublicSuffixOptions, ...options };
    const domainParts = domain.split(".");
    const topLevelDomain = domainParts[domainParts.length - 1];
    const allowSpecialUseDomain = !!options.allowSpecialUseDomain;
    const ignoreError = !!options.ignoreError;
    if (allowSpecialUseDomain && topLevelDomain !== undefined && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {
      if (domainParts.length > 1) {
        const secondLevelDomain = domainParts[domainParts.length - 2];
        return `${secondLevelDomain}.${topLevelDomain}`;
      } else if (SPECIAL_TREATMENT_DOMAINS.includes(topLevelDomain)) {
        return topLevelDomain;
      }
    }
    if (!ignoreError && topLevelDomain !== undefined && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {
      throw new Error(`Cookie has domain set to the public suffix "${topLevelDomain}" which is a special use domain. To allow this, configure your CookieJar with {allowSpecialUseDomain: true, rejectPublicSuffixes: false}.`);
    }
    const publicSuffix = (0, tldts_1.getDomain)(domain, {
      allowIcannDomains: true,
      allowPrivateDomains: true
    });
    if (publicSuffix)
      return publicSuffix;
  }
});

// backend/node_modules/tough-cookie/dist/permuteDomain.js
var require_permuteDomain = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.permuteDomain = permuteDomain;
  var getPublicSuffix_1 = require_getPublicSuffix();
  function permuteDomain(domain, allowSpecialUseDomain) {
    const pubSuf = (0, getPublicSuffix_1.getPublicSuffix)(domain, {
      allowSpecialUseDomain
    });
    if (!pubSuf) {
      return;
    }
    if (pubSuf == domain) {
      return [domain];
    }
    if (domain.slice(-1) == ".") {
      domain = domain.slice(0, -1);
    }
    const prefix = domain.slice(0, -(pubSuf.length + 1));
    const parts = prefix.split(".").reverse();
    let cur = pubSuf;
    const permutations = [cur];
    while (parts.length) {
      const part = parts.shift();
      cur = `${part}.${cur}`;
      permutations.push(cur);
    }
    return permutations;
  }
});

// backend/node_modules/tough-cookie/dist/store.js
var require_store = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Store = undefined;

  class Store {
    constructor() {
      this.synchronous = false;
    }
    findCookie(_domain, _path, _key, _callback) {
      throw new Error("findCookie is not implemented");
    }
    findCookies(_domain, _path, _allowSpecialUseDomain = false, _callback) {
      throw new Error("findCookies is not implemented");
    }
    putCookie(_cookie, _callback) {
      throw new Error("putCookie is not implemented");
    }
    updateCookie(_oldCookie, _newCookie, _callback) {
      throw new Error("updateCookie is not implemented");
    }
    removeCookie(_domain, _path, _key, _callback) {
      throw new Error("removeCookie is not implemented");
    }
    removeCookies(_domain, _path, _callback) {
      throw new Error("removeCookies is not implemented");
    }
    removeAllCookies(_callback) {
      throw new Error("removeAllCookies is not implemented");
    }
    getAllCookies(_callback) {
      throw new Error("getAllCookies is not implemented (therefore jar cannot be serialized)");
    }
  }
  exports2.Store = Store;
});

// backend/node_modules/tough-cookie/dist/utils.js
var require_utils3 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.safeToString = exports2.objectToString = undefined;
  exports2.createPromiseCallback = createPromiseCallback;
  exports2.inOperator = inOperator;
  var objectToString = (obj2) => Object.prototype.toString.call(obj2);
  exports2.objectToString = objectToString;
  var safeArrayToString = (arr, seenArrays) => {
    if (typeof arr.join !== "function")
      return (0, exports2.objectToString)(arr);
    seenArrays.add(arr);
    const mapped = arr.map((val) => val === null || val === undefined || seenArrays.has(val) ? "" : safeToStringImpl(val, seenArrays));
    return mapped.join();
  };
  var safeToStringImpl = (val, seenArrays = new WeakSet) => {
    if (typeof val !== "object" || val === null) {
      return String(val);
    } else if (typeof val.toString === "function") {
      return Array.isArray(val) ? safeArrayToString(val, seenArrays) : String(val);
    } else {
      return (0, exports2.objectToString)(val);
    }
  };
  var safeToString = (val) => safeToStringImpl(val);
  exports2.safeToString = safeToString;
  function createPromiseCallback(cb) {
    let callback;
    let resolve;
    let reject;
    const promise = new Promise((_resolve, _reject) => {
      resolve = _resolve;
      reject = _reject;
    });
    if (typeof cb === "function") {
      callback = (err, result) => {
        try {
          if (err)
            cb(err);
          else
            cb(null, result);
        } catch (e) {
          reject(e instanceof Error ? e : new Error);
        }
      };
    } else {
      callback = (err, result) => {
        try {
          if (err)
            reject(err);
          else
            resolve(result);
        } catch (e) {
          reject(e instanceof Error ? e : new Error);
        }
      };
    }
    return {
      promise,
      callback,
      resolve: (value) => {
        callback(null, value);
        return promise;
      },
      reject: (error2) => {
        callback(error2);
        return promise;
      }
    };
  }
  function inOperator(k, o) {
    return k in o;
  }
});

// backend/node_modules/tough-cookie/dist/memstore.js
var require_memstore = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.MemoryCookieStore = undefined;
  var pathMatch_1 = require_pathMatch();
  var permuteDomain_1 = require_permuteDomain();
  var store_1 = require_store();
  var utils_1 = require_utils3();

  class MemoryCookieStore extends store_1.Store {
    constructor() {
      super();
      this.synchronous = true;
      this.idx = Object.create(null);
    }
    findCookie(domain, path2, key, callback) {
      const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
      if (domain == null || path2 == null || key == null) {
        return promiseCallback.resolve(undefined);
      }
      const result = this.idx[domain]?.[path2]?.[key];
      return promiseCallback.resolve(result);
    }
    findCookies(domain, path2, allowSpecialUseDomain = false, callback) {
      if (typeof allowSpecialUseDomain === "function") {
        callback = allowSpecialUseDomain;
        allowSpecialUseDomain = true;
      }
      const results = [];
      const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
      if (!domain) {
        return promiseCallback.resolve([]);
      }
      let pathMatcher;
      if (!path2) {
        pathMatcher = function matchAll(domainIndex) {
          for (const curPath in domainIndex) {
            const pathIndex = domainIndex[curPath];
            for (const key in pathIndex) {
              const value = pathIndex[key];
              if (value) {
                results.push(value);
              }
            }
          }
        };
      } else {
        pathMatcher = function matchRFC(domainIndex) {
          for (const cookiePath in domainIndex) {
            if ((0, pathMatch_1.pathMatch)(path2, cookiePath)) {
              const pathIndex = domainIndex[cookiePath];
              for (const key in pathIndex) {
                const value = pathIndex[key];
                if (value) {
                  results.push(value);
                }
              }
            }
          }
        };
      }
      const domains = (0, permuteDomain_1.permuteDomain)(domain, allowSpecialUseDomain) || [domain];
      const idx = this.idx;
      domains.forEach((curDomain) => {
        const domainIndex = idx[curDomain];
        if (!domainIndex) {
          return;
        }
        pathMatcher(domainIndex);
      });
      return promiseCallback.resolve(results);
    }
    putCookie(cookie, callback) {
      const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
      const { domain, path: path2, key } = cookie;
      if (domain == null || path2 == null || key == null) {
        return promiseCallback.resolve(undefined);
      }
      const domainEntry = this.idx[domain] ?? Object.create(null);
      this.idx[domain] = domainEntry;
      const pathEntry = domainEntry[path2] ?? Object.create(null);
      domainEntry[path2] = pathEntry;
      pathEntry[key] = cookie;
      return promiseCallback.resolve(undefined);
    }
    updateCookie(_oldCookie, newCookie, callback) {
      if (callback)
        this.putCookie(newCookie, callback);
      else
        return this.putCookie(newCookie);
    }
    removeCookie(domain, path2, key, callback) {
      const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
      delete this.idx[domain]?.[path2]?.[key];
      return promiseCallback.resolve(undefined);
    }
    removeCookies(domain, path2, callback) {
      const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
      const domainEntry = this.idx[domain];
      if (domainEntry) {
        if (path2) {
          delete domainEntry[path2];
        } else {
          delete this.idx[domain];
        }
      }
      return promiseCallback.resolve(undefined);
    }
    removeAllCookies(callback) {
      const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
      this.idx = Object.create(null);
      return promiseCallback.resolve(undefined);
    }
    getAllCookies(callback) {
      const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
      const cookies = [];
      const idx = this.idx;
      const domains = Object.keys(idx);
      domains.forEach((domain) => {
        const domainEntry = idx[domain] ?? {};
        const paths = Object.keys(domainEntry);
        paths.forEach((path2) => {
          const pathEntry = domainEntry[path2] ?? {};
          const keys = Object.keys(pathEntry);
          keys.forEach((key) => {
            const keyEntry = pathEntry[key];
            if (keyEntry != null) {
              cookies.push(keyEntry);
            }
          });
        });
      });
      cookies.sort((a, b) => {
        return (a.creationIndex || 0) - (b.creationIndex || 0);
      });
      return promiseCallback.resolve(cookies);
    }
  }
  exports2.MemoryCookieStore = MemoryCookieStore;
});

// backend/node_modules/tough-cookie/dist/validators.js
var require_validators = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ParameterError = undefined;
  exports2.isNonEmptyString = isNonEmptyString;
  exports2.isDate = isDate2;
  exports2.isEmptyString = isEmptyString;
  exports2.isString = isString2;
  exports2.isObject = isObject2;
  exports2.isInteger = isInteger;
  exports2.validate = validate;
  var utils_1 = require_utils3();
  function isNonEmptyString(data) {
    return isString2(data) && data !== "";
  }
  function isDate2(data) {
    return data instanceof Date && isInteger(data.getTime());
  }
  function isEmptyString(data) {
    return data === "" || data instanceof String && data.toString() === "";
  }
  function isString2(data) {
    return typeof data === "string" || data instanceof String;
  }
  function isObject2(data) {
    return (0, utils_1.objectToString)(data) === "[object Object]";
  }
  function isInteger(data) {
    return typeof data === "number" && data % 1 === 0;
  }
  function validate(bool, cbOrMessage, message) {
    if (bool)
      return;
    const cb = typeof cbOrMessage === "function" ? cbOrMessage : undefined;
    let options = typeof cbOrMessage === "function" ? message : cbOrMessage;
    if (!isObject2(options))
      options = "[object Object]";
    const err = new ParameterError((0, utils_1.safeToString)(options));
    if (cb)
      cb(err);
    else
      throw err;
  }

  class ParameterError extends Error {
  }
  exports2.ParameterError = ParameterError;
});

// backend/node_modules/tough-cookie/dist/version.js
var require_version5 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.version = undefined;
  exports2.version = "5.1.2";
});

// backend/node_modules/tough-cookie/dist/cookie/constants.js
var require_constants7 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.IP_V6_REGEX_OBJECT = exports2.PrefixSecurityEnum = undefined;
  exports2.PrefixSecurityEnum = {
    SILENT: "silent",
    STRICT: "strict",
    DISABLED: "unsafe-disabled"
  };
  Object.freeze(exports2.PrefixSecurityEnum);
  var IP_V6_REGEX = `
\\[?(?:
(?:[a-fA-F\\d]{1,4}:){7}(?:[a-fA-F\\d]{1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|:[a-fA-F\\d]{1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,2}|:)|
(?:[a-fA-F\\d]{1,4}:){4}(?:(?::[a-fA-F\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,3}|:)|
(?:[a-fA-F\\d]{1,4}:){3}(?:(?::[a-fA-F\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){2}(?:(?::[a-fA-F\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,5}|:)|
(?:[a-fA-F\\d]{1,4}:){1}(?:(?::[a-fA-F\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,6}|:)|
(?::(?:(?::[a-fA-F\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,7}|:))
)(?:%[0-9a-zA-Z]{1,})?\\]?
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
  exports2.IP_V6_REGEX_OBJECT = new RegExp(`^${IP_V6_REGEX}$`);
});

// backend/node_modules/tough-cookie/dist/cookie/canonicalDomain.js
var require_canonicalDomain = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.canonicalDomain = canonicalDomain;
  var constants_1 = require_constants7();
  function domainToASCII(domain) {
    return new URL(`http://${domain}`).hostname;
  }
  function canonicalDomain(domainName) {
    if (domainName == null) {
      return;
    }
    let str2 = domainName.trim().replace(/^\./, "");
    if (constants_1.IP_V6_REGEX_OBJECT.test(str2)) {
      if (!str2.startsWith("[")) {
        str2 = "[" + str2;
      }
      if (!str2.endsWith("]")) {
        str2 = str2 + "]";
      }
      return domainToASCII(str2).slice(1, -1);
    }
    if (/[^\u0001-\u007f]/.test(str2)) {
      return domainToASCII(str2);
    }
    return str2.toLowerCase();
  }
});

// backend/node_modules/tough-cookie/dist/cookie/formatDate.js
var require_formatDate = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.formatDate = formatDate;
  function formatDate(date) {
    return date.toUTCString();
  }
});

// backend/node_modules/tough-cookie/dist/cookie/parseDate.js
var require_parseDate = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.parseDate = parseDate;
  var DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;
  var MONTH_TO_NUM = {
    jan: 0,
    feb: 1,
    mar: 2,
    apr: 3,
    may: 4,
    jun: 5,
    jul: 6,
    aug: 7,
    sep: 8,
    oct: 9,
    nov: 10,
    dec: 11
  };
  function parseDigits(token, minDigits, maxDigits, trailingOK) {
    let count = 0;
    while (count < token.length) {
      const c = token.charCodeAt(count);
      if (c <= 47 || c >= 58) {
        break;
      }
      count++;
    }
    if (count < minDigits || count > maxDigits) {
      return;
    }
    if (!trailingOK && count != token.length) {
      return;
    }
    return parseInt(token.slice(0, count), 10);
  }
  function parseTime(token) {
    const parts = token.split(":");
    const result = [0, 0, 0];
    if (parts.length !== 3) {
      return;
    }
    for (let i = 0;i < 3; i++) {
      const trailingOK = i == 2;
      const numPart = parts[i];
      if (numPart === undefined) {
        return;
      }
      const num = parseDigits(numPart, 1, 2, trailingOK);
      if (num === undefined) {
        return;
      }
      result[i] = num;
    }
    return result;
  }
  function parseMonth(token) {
    token = String(token).slice(0, 3).toLowerCase();
    switch (token) {
      case "jan":
        return MONTH_TO_NUM.jan;
      case "feb":
        return MONTH_TO_NUM.feb;
      case "mar":
        return MONTH_TO_NUM.mar;
      case "apr":
        return MONTH_TO_NUM.apr;
      case "may":
        return MONTH_TO_NUM.may;
      case "jun":
        return MONTH_TO_NUM.jun;
      case "jul":
        return MONTH_TO_NUM.jul;
      case "aug":
        return MONTH_TO_NUM.aug;
      case "sep":
        return MONTH_TO_NUM.sep;
      case "oct":
        return MONTH_TO_NUM.oct;
      case "nov":
        return MONTH_TO_NUM.nov;
      case "dec":
        return MONTH_TO_NUM.dec;
      default:
        return;
    }
  }
  function parseDate(cookieDate) {
    if (!cookieDate) {
      return;
    }
    const tokens = cookieDate.split(DATE_DELIM);
    let hour;
    let minute;
    let second;
    let dayOfMonth;
    let month;
    let year;
    for (let i = 0;i < tokens.length; i++) {
      const token = (tokens[i] ?? "").trim();
      if (!token.length) {
        continue;
      }
      if (second === undefined) {
        const result = parseTime(token);
        if (result) {
          hour = result[0];
          minute = result[1];
          second = result[2];
          continue;
        }
      }
      if (dayOfMonth === undefined) {
        const result = parseDigits(token, 1, 2, true);
        if (result !== undefined) {
          dayOfMonth = result;
          continue;
        }
      }
      if (month === undefined) {
        const result = parseMonth(token);
        if (result !== undefined) {
          month = result;
          continue;
        }
      }
      if (year === undefined) {
        const result = parseDigits(token, 2, 4, true);
        if (result !== undefined) {
          year = result;
          if (year >= 70 && year <= 99) {
            year += 1900;
          } else if (year >= 0 && year <= 69) {
            year += 2000;
          }
        }
      }
    }
    if (dayOfMonth === undefined || month === undefined || year === undefined || hour === undefined || minute === undefined || second === undefined || dayOfMonth < 1 || dayOfMonth > 31 || year < 1601 || hour > 23 || minute > 59 || second > 59) {
      return;
    }
    return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));
  }
});

// backend/node_modules/tough-cookie/dist/cookie/cookie.js
var require_cookie = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Cookie = undefined;
  /*!
   * Copyright (c) 2015-2020, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  var getPublicSuffix_1 = require_getPublicSuffix();
  var validators3 = __importStar(require_validators());
  var utils_1 = require_utils3();
  var formatDate_1 = require_formatDate();
  var parseDate_1 = require_parseDate();
  var canonicalDomain_1 = require_canonicalDomain();
  var COOKIE_OCTETS = /^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/;
  var PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;
  var CONTROL_CHARS = /[\x00-\x1F]/;
  var TERMINATORS = [`
`, "\r", "\x00"];
  function trimTerminator(str2) {
    if (validators3.isEmptyString(str2))
      return str2;
    for (let t = 0;t < TERMINATORS.length; t++) {
      const terminator = TERMINATORS[t];
      const terminatorIdx = terminator ? str2.indexOf(terminator) : -1;
      if (terminatorIdx !== -1) {
        str2 = str2.slice(0, terminatorIdx);
      }
    }
    return str2;
  }
  function parseCookiePair(cookiePair, looseMode) {
    cookiePair = trimTerminator(cookiePair);
    let firstEq = cookiePair.indexOf("=");
    if (looseMode) {
      if (firstEq === 0) {
        cookiePair = cookiePair.substring(1);
        firstEq = cookiePair.indexOf("=");
      }
    } else {
      if (firstEq <= 0) {
        return;
      }
    }
    let cookieName, cookieValue;
    if (firstEq <= 0) {
      cookieName = "";
      cookieValue = cookiePair.trim();
    } else {
      cookieName = cookiePair.slice(0, firstEq).trim();
      cookieValue = cookiePair.slice(firstEq + 1).trim();
    }
    if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {
      return;
    }
    const c = new Cookie;
    c.key = cookieName;
    c.value = cookieValue;
    return c;
  }
  function parse(str2, options) {
    if (validators3.isEmptyString(str2) || !validators3.isString(str2)) {
      return;
    }
    str2 = str2.trim();
    const firstSemi = str2.indexOf(";");
    const cookiePair = firstSemi === -1 ? str2 : str2.slice(0, firstSemi);
    const c = parseCookiePair(cookiePair, options?.loose ?? false);
    if (!c) {
      return;
    }
    if (firstSemi === -1) {
      return c;
    }
    const unparsed = str2.slice(firstSemi + 1).trim();
    if (unparsed.length === 0) {
      return c;
    }
    const cookie_avs = unparsed.split(";");
    while (cookie_avs.length) {
      const av = (cookie_avs.shift() ?? "").trim();
      if (av.length === 0) {
        continue;
      }
      const av_sep = av.indexOf("=");
      let av_key, av_value;
      if (av_sep === -1) {
        av_key = av;
        av_value = null;
      } else {
        av_key = av.slice(0, av_sep);
        av_value = av.slice(av_sep + 1);
      }
      av_key = av_key.trim().toLowerCase();
      if (av_value) {
        av_value = av_value.trim();
      }
      switch (av_key) {
        case "expires":
          if (av_value) {
            const exp = (0, parseDate_1.parseDate)(av_value);
            if (exp) {
              c.expires = exp;
            }
          }
          break;
        case "max-age":
          if (av_value) {
            if (/^-?[0-9]+$/.test(av_value)) {
              const delta = parseInt(av_value, 10);
              c.setMaxAge(delta);
            }
          }
          break;
        case "domain":
          if (av_value) {
            const domain = av_value.trim().replace(/^\./, "");
            if (domain) {
              c.domain = domain.toLowerCase();
            }
          }
          break;
        case "path":
          c.path = av_value && av_value[0] === "/" ? av_value : null;
          break;
        case "secure":
          c.secure = true;
          break;
        case "httponly":
          c.httpOnly = true;
          break;
        case "samesite":
          switch (av_value ? av_value.toLowerCase() : "") {
            case "strict":
              c.sameSite = "strict";
              break;
            case "lax":
              c.sameSite = "lax";
              break;
            case "none":
              c.sameSite = "none";
              break;
            default:
              c.sameSite = undefined;
              break;
          }
          break;
        default:
          c.extensions = c.extensions || [];
          c.extensions.push(av);
          break;
      }
    }
    return c;
  }
  function fromJSON(str2) {
    if (!str2 || validators3.isEmptyString(str2)) {
      return;
    }
    let obj2;
    if (typeof str2 === "string") {
      try {
        obj2 = JSON.parse(str2);
      } catch {
        return;
      }
    } else {
      obj2 = str2;
    }
    const c = new Cookie;
    Cookie.serializableProperties.forEach((prop) => {
      if (obj2 && typeof obj2 === "object" && (0, utils_1.inOperator)(prop, obj2)) {
        const val = obj2[prop];
        if (val === undefined) {
          return;
        }
        if ((0, utils_1.inOperator)(prop, cookieDefaults) && val === cookieDefaults[prop]) {
          return;
        }
        switch (prop) {
          case "key":
          case "value":
          case "sameSite":
            if (typeof val === "string") {
              c[prop] = val;
            }
            break;
          case "expires":
          case "creation":
          case "lastAccessed":
            if (typeof val === "number" || typeof val === "string" || val instanceof Date) {
              c[prop] = obj2[prop] == "Infinity" ? "Infinity" : new Date(val);
            } else if (val === null) {
              c[prop] = null;
            }
            break;
          case "maxAge":
            if (typeof val === "number" || val === "Infinity" || val === "-Infinity") {
              c[prop] = val;
            }
            break;
          case "domain":
          case "path":
            if (typeof val === "string" || val === null) {
              c[prop] = val;
            }
            break;
          case "secure":
          case "httpOnly":
            if (typeof val === "boolean") {
              c[prop] = val;
            }
            break;
          case "extensions":
            if (Array.isArray(val) && val.every((item) => typeof item === "string")) {
              c[prop] = val;
            }
            break;
          case "hostOnly":
          case "pathIsDefault":
            if (typeof val === "boolean" || val === null) {
              c[prop] = val;
            }
            break;
        }
      }
    });
    return c;
  }
  var cookieDefaults = {
    key: "",
    value: "",
    expires: "Infinity",
    maxAge: null,
    domain: null,
    path: null,
    secure: false,
    httpOnly: false,
    extensions: null,
    hostOnly: null,
    pathIsDefault: null,
    creation: null,
    lastAccessed: null,
    sameSite: undefined
  };

  class Cookie {
    constructor(options = {}) {
      this.key = options.key ?? cookieDefaults.key;
      this.value = options.value ?? cookieDefaults.value;
      this.expires = options.expires ?? cookieDefaults.expires;
      this.maxAge = options.maxAge ?? cookieDefaults.maxAge;
      this.domain = options.domain ?? cookieDefaults.domain;
      this.path = options.path ?? cookieDefaults.path;
      this.secure = options.secure ?? cookieDefaults.secure;
      this.httpOnly = options.httpOnly ?? cookieDefaults.httpOnly;
      this.extensions = options.extensions ?? cookieDefaults.extensions;
      this.creation = options.creation ?? cookieDefaults.creation;
      this.hostOnly = options.hostOnly ?? cookieDefaults.hostOnly;
      this.pathIsDefault = options.pathIsDefault ?? cookieDefaults.pathIsDefault;
      this.lastAccessed = options.lastAccessed ?? cookieDefaults.lastAccessed;
      this.sameSite = options.sameSite ?? cookieDefaults.sameSite;
      this.creation = options.creation ?? new Date;
      Object.defineProperty(this, "creationIndex", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: ++Cookie.cookiesCreated
      });
      this.creationIndex = Cookie.cookiesCreated;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      const now = Date.now();
      const hostOnly = this.hostOnly != null ? this.hostOnly.toString() : "?";
      const createAge = this.creation && this.creation !== "Infinity" ? `${String(now - this.creation.getTime())}ms` : "?";
      const accessAge = this.lastAccessed && this.lastAccessed !== "Infinity" ? `${String(now - this.lastAccessed.getTime())}ms` : "?";
      return `Cookie="${this.toString()}; hostOnly=${hostOnly}; aAge=${accessAge}; cAge=${createAge}"`;
    }
    toJSON() {
      const obj2 = {};
      for (const prop of Cookie.serializableProperties) {
        const val = this[prop];
        if (val === cookieDefaults[prop]) {
          continue;
        }
        switch (prop) {
          case "key":
          case "value":
          case "sameSite":
            if (typeof val === "string") {
              obj2[prop] = val;
            }
            break;
          case "expires":
          case "creation":
          case "lastAccessed":
            if (typeof val === "number" || typeof val === "string" || val instanceof Date) {
              obj2[prop] = val == "Infinity" ? "Infinity" : new Date(val).toISOString();
            } else if (val === null) {
              obj2[prop] = null;
            }
            break;
          case "maxAge":
            if (typeof val === "number" || val === "Infinity" || val === "-Infinity") {
              obj2[prop] = val;
            }
            break;
          case "domain":
          case "path":
            if (typeof val === "string" || val === null) {
              obj2[prop] = val;
            }
            break;
          case "secure":
          case "httpOnly":
            if (typeof val === "boolean") {
              obj2[prop] = val;
            }
            break;
          case "extensions":
            if (Array.isArray(val)) {
              obj2[prop] = val;
            }
            break;
          case "hostOnly":
          case "pathIsDefault":
            if (typeof val === "boolean" || val === null) {
              obj2[prop] = val;
            }
            break;
        }
      }
      return obj2;
    }
    clone() {
      return fromJSON(this.toJSON());
    }
    validate() {
      if (!this.value || !COOKIE_OCTETS.test(this.value)) {
        return false;
      }
      if (this.expires != "Infinity" && !(this.expires instanceof Date) && !(0, parseDate_1.parseDate)(this.expires)) {
        return false;
      }
      if (this.maxAge != null && this.maxAge !== "Infinity" && (this.maxAge === "-Infinity" || this.maxAge <= 0)) {
        return false;
      }
      if (this.path != null && !PATH_VALUE.test(this.path)) {
        return false;
      }
      const cdomain = this.cdomain();
      if (cdomain) {
        if (cdomain.match(/\.$/)) {
          return false;
        }
        const suffix = (0, getPublicSuffix_1.getPublicSuffix)(cdomain);
        if (suffix == null) {
          return false;
        }
      }
      return true;
    }
    setExpires(exp) {
      if (exp instanceof Date) {
        this.expires = exp;
      } else {
        this.expires = (0, parseDate_1.parseDate)(exp) || "Infinity";
      }
    }
    setMaxAge(age) {
      if (age === Infinity) {
        this.maxAge = "Infinity";
      } else if (age === -Infinity) {
        this.maxAge = "-Infinity";
      } else {
        this.maxAge = age;
      }
    }
    cookieString() {
      const val = this.value || "";
      if (this.key) {
        return `${this.key}=${val}`;
      }
      return val;
    }
    toString() {
      let str2 = this.cookieString();
      if (this.expires != "Infinity") {
        if (this.expires instanceof Date) {
          str2 += `; Expires=${(0, formatDate_1.formatDate)(this.expires)}`;
        }
      }
      if (this.maxAge != null && this.maxAge != Infinity) {
        str2 += `; Max-Age=${String(this.maxAge)}`;
      }
      if (this.domain && !this.hostOnly) {
        str2 += `; Domain=${this.domain}`;
      }
      if (this.path) {
        str2 += `; Path=${this.path}`;
      }
      if (this.secure) {
        str2 += "; Secure";
      }
      if (this.httpOnly) {
        str2 += "; HttpOnly";
      }
      if (this.sameSite && this.sameSite !== "none") {
        if (this.sameSite.toLowerCase() === Cookie.sameSiteCanonical.lax.toLowerCase()) {
          str2 += `; SameSite=${Cookie.sameSiteCanonical.lax}`;
        } else if (this.sameSite.toLowerCase() === Cookie.sameSiteCanonical.strict.toLowerCase()) {
          str2 += `; SameSite=${Cookie.sameSiteCanonical.strict}`;
        } else {
          str2 += `; SameSite=${this.sameSite}`;
        }
      }
      if (this.extensions) {
        this.extensions.forEach((ext) => {
          str2 += `; ${ext}`;
        });
      }
      return str2;
    }
    TTL(now = Date.now()) {
      if (this.maxAge != null && typeof this.maxAge === "number") {
        return this.maxAge <= 0 ? 0 : this.maxAge * 1000;
      }
      const expires = this.expires;
      if (expires === "Infinity") {
        return Infinity;
      }
      return (expires?.getTime() ?? now) - (now || Date.now());
    }
    expiryTime(now) {
      if (this.maxAge != null) {
        const relativeTo = now || this.lastAccessed || new Date;
        const maxAge = typeof this.maxAge === "number" ? this.maxAge : -Infinity;
        const age = maxAge <= 0 ? -Infinity : maxAge * 1000;
        if (relativeTo === "Infinity") {
          return Infinity;
        }
        return relativeTo.getTime() + age;
      }
      if (this.expires == "Infinity") {
        return Infinity;
      }
      return this.expires ? this.expires.getTime() : undefined;
    }
    expiryDate(now) {
      const millisec = this.expiryTime(now);
      if (millisec == Infinity) {
        return new Date(2147483647000);
      } else if (millisec == -Infinity) {
        return new Date(0);
      } else {
        return millisec == undefined ? undefined : new Date(millisec);
      }
    }
    isPersistent() {
      return this.maxAge != null || this.expires != "Infinity";
    }
    canonicalizedDomain() {
      return (0, canonicalDomain_1.canonicalDomain)(this.domain);
    }
    cdomain() {
      return (0, canonicalDomain_1.canonicalDomain)(this.domain);
    }
    static parse(str2, options) {
      return parse(str2, options);
    }
    static fromJSON(str2) {
      return fromJSON(str2);
    }
  }
  exports2.Cookie = Cookie;
  Cookie.cookiesCreated = 0;
  Cookie.sameSiteLevel = {
    strict: 3,
    lax: 2,
    none: 1
  };
  Cookie.sameSiteCanonical = {
    strict: "Strict",
    lax: "Lax"
  };
  Cookie.serializableProperties = [
    "key",
    "value",
    "expires",
    "maxAge",
    "domain",
    "path",
    "secure",
    "httpOnly",
    "extensions",
    "hostOnly",
    "pathIsDefault",
    "creation",
    "lastAccessed",
    "sameSite"
  ];
});

// backend/node_modules/tough-cookie/dist/cookie/cookieCompare.js
var require_cookieCompare = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.cookieCompare = cookieCompare;
  var MAX_TIME = 2147483647000;
  function cookieCompare(a, b) {
    let cmp;
    const aPathLen = a.path ? a.path.length : 0;
    const bPathLen = b.path ? b.path.length : 0;
    cmp = bPathLen - aPathLen;
    if (cmp !== 0) {
      return cmp;
    }
    const aTime = a.creation && a.creation instanceof Date ? a.creation.getTime() : MAX_TIME;
    const bTime = b.creation && b.creation instanceof Date ? b.creation.getTime() : MAX_TIME;
    cmp = aTime - bTime;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = (a.creationIndex || 0) - (b.creationIndex || 0);
    return cmp;
  }
});

// backend/node_modules/tough-cookie/dist/cookie/defaultPath.js
var require_defaultPath = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.defaultPath = defaultPath;
  function defaultPath(path2) {
    if (!path2 || path2.slice(0, 1) !== "/") {
      return "/";
    }
    if (path2 === "/") {
      return path2;
    }
    const rightSlash = path2.lastIndexOf("/");
    if (rightSlash === 0) {
      return "/";
    }
    return path2.slice(0, rightSlash);
  }
});

// backend/node_modules/tough-cookie/dist/cookie/domainMatch.js
var require_domainMatch = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.domainMatch = domainMatch;
  var canonicalDomain_1 = require_canonicalDomain();
  var IP_REGEX_LOWERCASE = /(?:^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}$)|(?:^(?:(?:[a-f\d]{1,4}:){7}(?:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,2}|:)|(?:[a-f\d]{1,4}:){4}(?:(?::[a-f\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,3}|:)|(?:[a-f\d]{1,4}:){3}(?:(?::[a-f\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,4}|:)|(?:[a-f\d]{1,4}:){2}(?:(?::[a-f\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,5}|:)|(?:[a-f\d]{1,4}:){1}(?:(?::[a-f\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,6}|:)|(?::(?:(?::[a-f\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,7}|:)))$)/;
  function domainMatch(domain, cookieDomain, canonicalize) {
    if (domain == null || cookieDomain == null) {
      return;
    }
    let _str;
    let _domStr;
    if (canonicalize !== false) {
      _str = (0, canonicalDomain_1.canonicalDomain)(domain);
      _domStr = (0, canonicalDomain_1.canonicalDomain)(cookieDomain);
    } else {
      _str = domain;
      _domStr = cookieDomain;
    }
    if (_str == null || _domStr == null) {
      return;
    }
    if (_str == _domStr) {
      return true;
    }
    const idx = _str.lastIndexOf(_domStr);
    if (idx <= 0) {
      return false;
    }
    if (_str.length !== _domStr.length + idx) {
      return false;
    }
    if (_str.substring(idx - 1, idx) !== ".") {
      return false;
    }
    return !IP_REGEX_LOWERCASE.test(_str);
  }
});

// backend/node_modules/tough-cookie/dist/cookie/cookieJar.js
var require_cookieJar = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.CookieJar = undefined;
  var getPublicSuffix_1 = require_getPublicSuffix();
  var validators3 = __importStar(require_validators());
  var validators_1 = require_validators();
  var store_1 = require_store();
  var memstore_1 = require_memstore();
  var pathMatch_1 = require_pathMatch();
  var cookie_1 = require_cookie();
  var utils_1 = require_utils3();
  var canonicalDomain_1 = require_canonicalDomain();
  var constants_1 = require_constants7();
  var defaultPath_1 = require_defaultPath();
  var domainMatch_1 = require_domainMatch();
  var cookieCompare_1 = require_cookieCompare();
  var version_1 = require_version5();
  var defaultSetCookieOptions = {
    loose: false,
    sameSiteContext: undefined,
    ignoreError: false,
    http: true
  };
  var defaultGetCookieOptions = {
    http: true,
    expire: true,
    allPaths: false,
    sameSiteContext: undefined,
    sort: undefined
  };
  var SAME_SITE_CONTEXT_VAL_ERR = 'Invalid sameSiteContext option for getCookies(); expected one of "strict", "lax", or "none"';
  function getCookieContext(url2) {
    if (url2 && typeof url2 === "object" && "hostname" in url2 && typeof url2.hostname === "string" && "pathname" in url2 && typeof url2.pathname === "string" && "protocol" in url2 && typeof url2.protocol === "string") {
      return {
        hostname: url2.hostname,
        pathname: url2.pathname,
        protocol: url2.protocol
      };
    } else if (typeof url2 === "string") {
      try {
        return new URL(decodeURI(url2));
      } catch {
        return new URL(url2);
      }
    } else {
      throw new validators_1.ParameterError("`url` argument is not a string or URL.");
    }
  }
  function checkSameSiteContext(value) {
    const context = String(value).toLowerCase();
    if (context === "none" || context === "lax" || context === "strict") {
      return context;
    } else {
      return;
    }
  }
  function isSecurePrefixConditionMet(cookie) {
    const startsWithSecurePrefix = typeof cookie.key === "string" && cookie.key.startsWith("__Secure-");
    return !startsWithSecurePrefix || cookie.secure;
  }
  function isHostPrefixConditionMet(cookie) {
    const startsWithHostPrefix = typeof cookie.key === "string" && cookie.key.startsWith("__Host-");
    return !startsWithHostPrefix || Boolean(cookie.secure && cookie.hostOnly && cookie.path != null && cookie.path === "/");
  }
  function getNormalizedPrefixSecurity(prefixSecurity) {
    const normalizedPrefixSecurity = prefixSecurity.toLowerCase();
    switch (normalizedPrefixSecurity) {
      case constants_1.PrefixSecurityEnum.STRICT:
      case constants_1.PrefixSecurityEnum.SILENT:
      case constants_1.PrefixSecurityEnum.DISABLED:
        return normalizedPrefixSecurity;
      default:
        return constants_1.PrefixSecurityEnum.SILENT;
    }
  }

  class CookieJar {
    constructor(store, options) {
      if (typeof options === "boolean") {
        options = { rejectPublicSuffixes: options };
      }
      this.rejectPublicSuffixes = options?.rejectPublicSuffixes ?? true;
      this.enableLooseMode = options?.looseMode ?? false;
      this.allowSpecialUseDomain = options?.allowSpecialUseDomain ?? true;
      this.prefixSecurity = getNormalizedPrefixSecurity(options?.prefixSecurity ?? "silent");
      this.store = store ?? new memstore_1.MemoryCookieStore;
    }
    callSync(fn) {
      if (!this.store.synchronous) {
        throw new Error("CookieJar store is not synchronous; use async API instead.");
      }
      let syncErr = null;
      let syncResult = undefined;
      try {
        fn.call(this, (error2, result) => {
          syncErr = error2;
          syncResult = result;
        });
      } catch (err) {
        syncErr = err;
      }
      if (syncErr)
        throw syncErr;
      return syncResult;
    }
    setCookie(cookie, url2, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = undefined;
      }
      const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
      const cb = promiseCallback.callback;
      let context;
      try {
        if (typeof url2 === "string") {
          validators3.validate(validators3.isNonEmptyString(url2), callback, (0, utils_1.safeToString)(options));
        }
        context = getCookieContext(url2);
        if (typeof url2 === "function") {
          return promiseCallback.reject(new Error("No URL was specified"));
        }
        if (typeof options === "function") {
          options = defaultSetCookieOptions;
        }
        validators3.validate(typeof cb === "function", cb);
        if (!validators3.isNonEmptyString(cookie) && !validators3.isObject(cookie) && cookie instanceof String && cookie.length == 0) {
          return promiseCallback.resolve(undefined);
        }
      } catch (err) {
        return promiseCallback.reject(err);
      }
      const host = (0, canonicalDomain_1.canonicalDomain)(context.hostname) ?? null;
      const loose = options?.loose || this.enableLooseMode;
      let sameSiteContext = null;
      if (options?.sameSiteContext) {
        sameSiteContext = checkSameSiteContext(options.sameSiteContext);
        if (!sameSiteContext) {
          return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));
        }
      }
      if (typeof cookie === "string" || cookie instanceof String) {
        const parsedCookie = cookie_1.Cookie.parse(cookie.toString(), { loose });
        if (!parsedCookie) {
          const err = new Error("Cookie failed to parse");
          return options?.ignoreError ? promiseCallback.resolve(undefined) : promiseCallback.reject(err);
        }
        cookie = parsedCookie;
      } else if (!(cookie instanceof cookie_1.Cookie)) {
        const err = new Error("First argument to setCookie must be a Cookie object or string");
        return options?.ignoreError ? promiseCallback.resolve(undefined) : promiseCallback.reject(err);
      }
      const now = options?.now || new Date;
      if (this.rejectPublicSuffixes && cookie.domain) {
        try {
          const cdomain = cookie.cdomain();
          const suffix = typeof cdomain === "string" ? (0, getPublicSuffix_1.getPublicSuffix)(cdomain, {
            allowSpecialUseDomain: this.allowSpecialUseDomain,
            ignoreError: options?.ignoreError
          }) : null;
          if (suffix == null && !constants_1.IP_V6_REGEX_OBJECT.test(cookie.domain)) {
            const err = new Error("Cookie has domain set to a public suffix");
            return options?.ignoreError ? promiseCallback.resolve(undefined) : promiseCallback.reject(err);
          }
        } catch (err) {
          return options?.ignoreError ? promiseCallback.resolve(undefined) : promiseCallback.reject(err);
        }
      }
      if (cookie.domain) {
        if (!(0, domainMatch_1.domainMatch)(host ?? undefined, cookie.cdomain() ?? undefined, false)) {
          const err = new Error(`Cookie not in this host's domain. Cookie:${cookie.cdomain() ?? "null"} Request:${host ?? "null"}`);
          return options?.ignoreError ? promiseCallback.resolve(undefined) : promiseCallback.reject(err);
        }
        if (cookie.hostOnly == null) {
          cookie.hostOnly = false;
        }
      } else {
        cookie.hostOnly = true;
        cookie.domain = host;
      }
      if (!cookie.path || cookie.path[0] !== "/") {
        cookie.path = (0, defaultPath_1.defaultPath)(context.pathname);
        cookie.pathIsDefault = true;
      }
      if (options?.http === false && cookie.httpOnly) {
        const err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
        return options.ignoreError ? promiseCallback.resolve(undefined) : promiseCallback.reject(err);
      }
      if (cookie.sameSite !== "none" && cookie.sameSite !== undefined && sameSiteContext) {
        if (sameSiteContext === "none") {
          const err = new Error("Cookie is SameSite but this is a cross-origin request");
          return options?.ignoreError ? promiseCallback.resolve(undefined) : promiseCallback.reject(err);
        }
      }
      const ignoreErrorForPrefixSecurity = this.prefixSecurity === constants_1.PrefixSecurityEnum.SILENT;
      const prefixSecurityDisabled = this.prefixSecurity === constants_1.PrefixSecurityEnum.DISABLED;
      if (!prefixSecurityDisabled) {
        let errorFound = false;
        let errorMsg;
        if (!isSecurePrefixConditionMet(cookie)) {
          errorFound = true;
          errorMsg = "Cookie has __Secure prefix but Secure attribute is not set";
        } else if (!isHostPrefixConditionMet(cookie)) {
          errorFound = true;
          errorMsg = "Cookie has __Host prefix but either Secure or HostOnly attribute is not set or Path is not '/'";
        }
        if (errorFound) {
          return options?.ignoreError || ignoreErrorForPrefixSecurity ? promiseCallback.resolve(undefined) : promiseCallback.reject(new Error(errorMsg));
        }
      }
      const store = this.store;
      if (!store.updateCookie) {
        store.updateCookie = async function(_oldCookie, newCookie, cb2) {
          return this.putCookie(newCookie).then(() => cb2?.(null), (error2) => cb2?.(error2));
        };
      }
      const withCookie = function withCookie(err, oldCookie) {
        if (err) {
          cb(err);
          return;
        }
        const next = function(err2) {
          if (err2) {
            cb(err2);
          } else if (typeof cookie === "string") {
            cb(null, undefined);
          } else {
            cb(null, cookie);
          }
        };
        if (oldCookie) {
          if (options && "http" in options && options.http === false && oldCookie.httpOnly) {
            err = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
            if (options.ignoreError)
              cb(null, undefined);
            else
              cb(err);
            return;
          }
          if (cookie instanceof cookie_1.Cookie) {
            cookie.creation = oldCookie.creation;
            cookie.creationIndex = oldCookie.creationIndex;
            cookie.lastAccessed = now;
            store.updateCookie(oldCookie, cookie, next);
          }
        } else {
          if (cookie instanceof cookie_1.Cookie) {
            cookie.creation = cookie.lastAccessed = now;
            store.putCookie(cookie, next);
          }
        }
      };
      store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
      return promiseCallback.promise;
    }
    setCookieSync(cookie, url2, options) {
      const setCookieFn = options ? this.setCookie.bind(this, cookie, url2, options) : this.setCookie.bind(this, cookie, url2);
      return this.callSync(setCookieFn);
    }
    getCookies(url2, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = defaultGetCookieOptions;
      } else if (options === undefined) {
        options = defaultGetCookieOptions;
      }
      const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
      const cb = promiseCallback.callback;
      let context;
      try {
        if (typeof url2 === "string") {
          validators3.validate(validators3.isNonEmptyString(url2), cb, url2);
        }
        context = getCookieContext(url2);
        validators3.validate(validators3.isObject(options), cb, (0, utils_1.safeToString)(options));
        validators3.validate(typeof cb === "function", cb);
      } catch (parameterError) {
        return promiseCallback.reject(parameterError);
      }
      const host = (0, canonicalDomain_1.canonicalDomain)(context.hostname);
      const path2 = context.pathname || "/";
      const secure = context.protocol && (context.protocol == "https:" || context.protocol == "wss:");
      let sameSiteLevel = 0;
      if (options.sameSiteContext) {
        const sameSiteContext = checkSameSiteContext(options.sameSiteContext);
        if (sameSiteContext == null) {
          return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));
        }
        sameSiteLevel = cookie_1.Cookie.sameSiteLevel[sameSiteContext];
        if (!sameSiteLevel) {
          return promiseCallback.reject(new Error(SAME_SITE_CONTEXT_VAL_ERR));
        }
      }
      const http3 = options.http ?? true;
      const now = Date.now();
      const expireCheck = options.expire ?? true;
      const allPaths = options.allPaths ?? false;
      const store = this.store;
      function matchingCookie(c) {
        if (c.hostOnly) {
          if (c.domain != host) {
            return false;
          }
        } else {
          if (!(0, domainMatch_1.domainMatch)(host ?? undefined, c.domain ?? undefined, false)) {
            return false;
          }
        }
        if (!allPaths && typeof c.path === "string" && !(0, pathMatch_1.pathMatch)(path2, c.path)) {
          return false;
        }
        if (c.secure && !secure) {
          return false;
        }
        if (c.httpOnly && !http3) {
          return false;
        }
        if (sameSiteLevel) {
          let cookieLevel;
          if (c.sameSite === "lax") {
            cookieLevel = cookie_1.Cookie.sameSiteLevel.lax;
          } else if (c.sameSite === "strict") {
            cookieLevel = cookie_1.Cookie.sameSiteLevel.strict;
          } else {
            cookieLevel = cookie_1.Cookie.sameSiteLevel.none;
          }
          if (cookieLevel > sameSiteLevel) {
            return false;
          }
        }
        const expiryTime = c.expiryTime();
        if (expireCheck && expiryTime != null && expiryTime <= now) {
          store.removeCookie(c.domain, c.path, c.key, () => {});
          return false;
        }
        return true;
      }
      store.findCookies(host, allPaths ? null : path2, this.allowSpecialUseDomain, (err, cookies) => {
        if (err) {
          cb(err);
          return;
        }
        if (cookies == null) {
          cb(null, []);
          return;
        }
        cookies = cookies.filter(matchingCookie);
        if ("sort" in options && options.sort !== false) {
          cookies = cookies.sort(cookieCompare_1.cookieCompare);
        }
        const now2 = new Date;
        for (const cookie of cookies) {
          cookie.lastAccessed = now2;
        }
        cb(null, cookies);
      });
      return promiseCallback.promise;
    }
    getCookiesSync(url2, options) {
      return this.callSync(this.getCookies.bind(this, url2, options)) ?? [];
    }
    getCookieString(url2, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = undefined;
      }
      const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
      const next = function(err, cookies) {
        if (err) {
          promiseCallback.callback(err);
        } else {
          promiseCallback.callback(null, cookies?.sort(cookieCompare_1.cookieCompare).map((c) => c.cookieString()).join("; "));
        }
      };
      this.getCookies(url2, options, next);
      return promiseCallback.promise;
    }
    getCookieStringSync(url2, options) {
      return this.callSync(options ? this.getCookieString.bind(this, url2, options) : this.getCookieString.bind(this, url2)) ?? "";
    }
    getSetCookieStrings(url2, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = undefined;
      }
      const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
      const next = function(err, cookies) {
        if (err) {
          promiseCallback.callback(err);
        } else {
          promiseCallback.callback(null, cookies?.map((c) => {
            return c.toString();
          }));
        }
      };
      this.getCookies(url2, options, next);
      return promiseCallback.promise;
    }
    getSetCookieStringsSync(url2, options = {}) {
      return this.callSync(this.getSetCookieStrings.bind(this, url2, options)) ?? [];
    }
    serialize(callback) {
      const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
      let type = this.store.constructor.name;
      if (validators3.isObject(type)) {
        type = null;
      }
      const serialized = {
        version: `tough-cookie@${version_1.version}`,
        storeType: type,
        rejectPublicSuffixes: this.rejectPublicSuffixes,
        enableLooseMode: this.enableLooseMode,
        allowSpecialUseDomain: this.allowSpecialUseDomain,
        prefixSecurity: getNormalizedPrefixSecurity(this.prefixSecurity),
        cookies: []
      };
      if (typeof this.store.getAllCookies !== "function") {
        return promiseCallback.reject(new Error("store does not support getAllCookies and cannot be serialized"));
      }
      this.store.getAllCookies((err, cookies) => {
        if (err) {
          promiseCallback.callback(err);
          return;
        }
        if (cookies == null) {
          promiseCallback.callback(null, serialized);
          return;
        }
        serialized.cookies = cookies.map((cookie) => {
          const serializedCookie = cookie.toJSON();
          delete serializedCookie.creationIndex;
          return serializedCookie;
        });
        promiseCallback.callback(null, serialized);
      });
      return promiseCallback.promise;
    }
    serializeSync() {
      return this.callSync((callback) => {
        this.serialize(callback);
      });
    }
    toJSON() {
      return this.serializeSync();
    }
    _importCookies(serialized, callback) {
      let cookies = undefined;
      if (serialized && typeof serialized === "object" && (0, utils_1.inOperator)("cookies", serialized) && Array.isArray(serialized.cookies)) {
        cookies = serialized.cookies;
      }
      if (!cookies) {
        callback(new Error("serialized jar has no cookies array"), undefined);
        return;
      }
      cookies = cookies.slice();
      const putNext = (err) => {
        if (err) {
          callback(err, undefined);
          return;
        }
        if (Array.isArray(cookies)) {
          if (!cookies.length) {
            callback(err, this);
            return;
          }
          let cookie;
          try {
            cookie = cookie_1.Cookie.fromJSON(cookies.shift());
          } catch (e) {
            callback(e instanceof Error ? e : new Error, undefined);
            return;
          }
          if (cookie === undefined) {
            putNext(null);
            return;
          }
          this.store.putCookie(cookie, putNext);
        }
      };
      putNext(null);
    }
    _importCookiesSync(serialized) {
      this.callSync(this._importCookies.bind(this, serialized));
    }
    clone(newStore, callback) {
      if (typeof newStore === "function") {
        callback = newStore;
        newStore = undefined;
      }
      const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
      const cb = promiseCallback.callback;
      this.serialize((err, serialized) => {
        if (err) {
          return promiseCallback.reject(err);
        }
        return CookieJar.deserialize(serialized ?? "", newStore, cb);
      });
      return promiseCallback.promise;
    }
    _cloneSync(newStore) {
      const cloneFn = newStore && typeof newStore !== "function" ? this.clone.bind(this, newStore) : this.clone.bind(this);
      return this.callSync((callback) => {
        cloneFn(callback);
      });
    }
    cloneSync(newStore) {
      if (!newStore) {
        return this._cloneSync();
      }
      if (!newStore.synchronous) {
        throw new Error("CookieJar clone destination store is not synchronous; use async API instead.");
      }
      return this._cloneSync(newStore);
    }
    removeAllCookies(callback) {
      const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
      const cb = promiseCallback.callback;
      const store = this.store;
      if (typeof store.removeAllCookies === "function" && store.removeAllCookies !== store_1.Store.prototype.removeAllCookies) {
        store.removeAllCookies(cb);
        return promiseCallback.promise;
      }
      store.getAllCookies((err, cookies) => {
        if (err) {
          cb(err);
          return;
        }
        if (!cookies) {
          cookies = [];
        }
        if (cookies.length === 0) {
          cb(null, undefined);
          return;
        }
        let completedCount = 0;
        const removeErrors = [];
        const removeCookieCb = function removeCookieCb(removeErr) {
          if (removeErr) {
            removeErrors.push(removeErr);
          }
          completedCount++;
          if (completedCount === cookies.length) {
            if (removeErrors[0])
              cb(removeErrors[0]);
            else
              cb(null, undefined);
            return;
          }
        };
        cookies.forEach((cookie) => {
          store.removeCookie(cookie.domain, cookie.path, cookie.key, removeCookieCb);
        });
      });
      return promiseCallback.promise;
    }
    removeAllCookiesSync() {
      this.callSync((callback) => {
        this.removeAllCookies(callback);
      });
    }
    static deserialize(strOrObj, store, callback) {
      if (typeof store === "function") {
        callback = store;
        store = undefined;
      }
      const promiseCallback = (0, utils_1.createPromiseCallback)(callback);
      let serialized;
      if (typeof strOrObj === "string") {
        try {
          serialized = JSON.parse(strOrObj);
        } catch (e) {
          return promiseCallback.reject(e instanceof Error ? e : new Error);
        }
      } else {
        serialized = strOrObj;
      }
      const readSerializedProperty = (property) => {
        return serialized && typeof serialized === "object" && (0, utils_1.inOperator)(property, serialized) ? serialized[property] : undefined;
      };
      const readSerializedBoolean = (property) => {
        const value = readSerializedProperty(property);
        return typeof value === "boolean" ? value : undefined;
      };
      const readSerializedString = (property) => {
        const value = readSerializedProperty(property);
        return typeof value === "string" ? value : undefined;
      };
      const jar = new CookieJar(store, {
        rejectPublicSuffixes: readSerializedBoolean("rejectPublicSuffixes"),
        looseMode: readSerializedBoolean("enableLooseMode"),
        allowSpecialUseDomain: readSerializedBoolean("allowSpecialUseDomain"),
        prefixSecurity: getNormalizedPrefixSecurity(readSerializedString("prefixSecurity") ?? "silent")
      });
      jar._importCookies(serialized, (err) => {
        if (err) {
          promiseCallback.callback(err);
          return;
        }
        promiseCallback.callback(null, jar);
      });
      return promiseCallback.promise;
    }
    static deserializeSync(strOrObj, store) {
      const serialized = typeof strOrObj === "string" ? JSON.parse(strOrObj) : strOrObj;
      const readSerializedProperty = (property) => {
        return serialized && typeof serialized === "object" && (0, utils_1.inOperator)(property, serialized) ? serialized[property] : undefined;
      };
      const readSerializedBoolean = (property) => {
        const value = readSerializedProperty(property);
        return typeof value === "boolean" ? value : undefined;
      };
      const readSerializedString = (property) => {
        const value = readSerializedProperty(property);
        return typeof value === "string" ? value : undefined;
      };
      const jar = new CookieJar(store, {
        rejectPublicSuffixes: readSerializedBoolean("rejectPublicSuffixes"),
        looseMode: readSerializedBoolean("enableLooseMode"),
        allowSpecialUseDomain: readSerializedBoolean("allowSpecialUseDomain"),
        prefixSecurity: getNormalizedPrefixSecurity(readSerializedString("prefixSecurity") ?? "silent")
      });
      if (!jar.store.synchronous) {
        throw new Error("CookieJar store is not synchronous; use async API instead.");
      }
      jar._importCookiesSync(serialized);
      return jar;
    }
    static fromJSON(jsonString, store) {
      return CookieJar.deserializeSync(jsonString, store);
    }
  }
  exports2.CookieJar = CookieJar;
});

// backend/node_modules/tough-cookie/dist/cookie/permutePath.js
var require_permutePath = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.permutePath = permutePath;
  function permutePath(path2) {
    if (path2 === "/") {
      return ["/"];
    }
    const permutations = [path2];
    while (path2.length > 1) {
      const lindex = path2.lastIndexOf("/");
      if (lindex === 0) {
        break;
      }
      path2 = path2.slice(0, lindex);
      permutations.push(path2);
    }
    permutations.push("/");
    return permutations;
  }
});

// backend/node_modules/tough-cookie/dist/cookie/index.js
var require_cookie2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.permutePath = exports2.parseDate = exports2.formatDate = exports2.domainMatch = exports2.defaultPath = exports2.CookieJar = exports2.cookieCompare = exports2.Cookie = exports2.PrefixSecurityEnum = exports2.canonicalDomain = exports2.version = exports2.ParameterError = exports2.Store = exports2.getPublicSuffix = exports2.permuteDomain = exports2.pathMatch = exports2.MemoryCookieStore = undefined;
  exports2.parse = parse;
  exports2.fromJSON = fromJSON;
  var memstore_1 = require_memstore();
  Object.defineProperty(exports2, "MemoryCookieStore", { enumerable: true, get: function() {
    return memstore_1.MemoryCookieStore;
  } });
  var pathMatch_1 = require_pathMatch();
  Object.defineProperty(exports2, "pathMatch", { enumerable: true, get: function() {
    return pathMatch_1.pathMatch;
  } });
  var permuteDomain_1 = require_permuteDomain();
  Object.defineProperty(exports2, "permuteDomain", { enumerable: true, get: function() {
    return permuteDomain_1.permuteDomain;
  } });
  var getPublicSuffix_1 = require_getPublicSuffix();
  Object.defineProperty(exports2, "getPublicSuffix", { enumerable: true, get: function() {
    return getPublicSuffix_1.getPublicSuffix;
  } });
  var store_1 = require_store();
  Object.defineProperty(exports2, "Store", { enumerable: true, get: function() {
    return store_1.Store;
  } });
  var validators_1 = require_validators();
  Object.defineProperty(exports2, "ParameterError", { enumerable: true, get: function() {
    return validators_1.ParameterError;
  } });
  var version_1 = require_version5();
  Object.defineProperty(exports2, "version", { enumerable: true, get: function() {
    return version_1.version;
  } });
  var canonicalDomain_1 = require_canonicalDomain();
  Object.defineProperty(exports2, "canonicalDomain", { enumerable: true, get: function() {
    return canonicalDomain_1.canonicalDomain;
  } });
  var constants_1 = require_constants7();
  Object.defineProperty(exports2, "PrefixSecurityEnum", { enumerable: true, get: function() {
    return constants_1.PrefixSecurityEnum;
  } });
  var cookie_1 = require_cookie();
  Object.defineProperty(exports2, "Cookie", { enumerable: true, get: function() {
    return cookie_1.Cookie;
  } });
  var cookieCompare_1 = require_cookieCompare();
  Object.defineProperty(exports2, "cookieCompare", { enumerable: true, get: function() {
    return cookieCompare_1.cookieCompare;
  } });
  var cookieJar_1 = require_cookieJar();
  Object.defineProperty(exports2, "CookieJar", { enumerable: true, get: function() {
    return cookieJar_1.CookieJar;
  } });
  var defaultPath_1 = require_defaultPath();
  Object.defineProperty(exports2, "defaultPath", { enumerable: true, get: function() {
    return defaultPath_1.defaultPath;
  } });
  var domainMatch_1 = require_domainMatch();
  Object.defineProperty(exports2, "domainMatch", { enumerable: true, get: function() {
    return domainMatch_1.domainMatch;
  } });
  var formatDate_1 = require_formatDate();
  Object.defineProperty(exports2, "formatDate", { enumerable: true, get: function() {
    return formatDate_1.formatDate;
  } });
  var parseDate_1 = require_parseDate();
  Object.defineProperty(exports2, "parseDate", { enumerable: true, get: function() {
    return parseDate_1.parseDate;
  } });
  var permutePath_1 = require_permutePath();
  Object.defineProperty(exports2, "permutePath", { enumerable: true, get: function() {
    return permutePath_1.permutePath;
  } });
  var cookie_2 = require_cookie();
  function parse(str2, options) {
    return cookie_2.Cookie.parse(str2, options);
  }
  function fromJSON(str2) {
    return cookie_2.Cookie.fromJSON(str2);
  }
});

// backend/node_modules/@cypress/request/lib/cookies.js
var require_cookies = __commonJS((exports2) => {
  var tough = require_cookie2();
  var Cookie = tough.Cookie;
  var CookieJar = tough.CookieJar;
  exports2.parse = function(str2) {
    if (str2 && str2.uri) {
      str2 = str2.uri;
    }
    if (typeof str2 !== "string") {
      throw new Error("The cookie function only accepts STRING as param");
    }
    return Cookie.parse(str2, { loose: true });
  };
  function RequestJar(store) {
    var self2 = this;
    self2._jar = new CookieJar(store, { looseMode: true });
  }
  RequestJar.prototype.setCookie = function(cookieOrStr, uri, options) {
    var self2 = this;
    return self2._jar.setCookieSync(cookieOrStr, uri, options || {});
  };
  RequestJar.prototype.getCookieString = function(uri) {
    var self2 = this;
    return self2._jar.getCookieStringSync(uri);
  };
  RequestJar.prototype.getCookies = function(uri) {
    var self2 = this;
    return self2._jar.getCookiesSync(uri);
  };
  exports2.jar = function(store) {
    return new RequestJar(store);
  };
});

// backend/node_modules/json-stringify-safe/stringify.js
var require_stringify = __commonJS((exports2, module2) => {
  exports2 = module2.exports = stringify2;
  exports2.getSerialize = serializer;
  function stringify2(obj2, replacer, spaces, cycleReplacer) {
    return JSON.stringify(obj2, serializer(replacer, cycleReplacer), spaces);
  }
  function serializer(replacer, cycleReplacer) {
    var stack = [], keys = [];
    if (cycleReplacer == null)
      cycleReplacer = function(key, value) {
        if (stack[0] === value)
          return "[Circular ~]";
        return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
      };
    return function(key, value) {
      if (stack.length > 0) {
        var thisPos = stack.indexOf(this);
        ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
        ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
        if (~stack.indexOf(value))
          value = cycleReplacer.call(this, key, value);
      } else
        stack.push(value);
      return replacer == null ? value : replacer.call(this, key, value);
    };
  }
});

// backend/node_modules/@cypress/request/lib/helpers.js
var require_helpers5 = __commonJS((exports2) => {
  var jsonSafeStringify = require_stringify();
  var crypto3 = require("crypto");
  var Buffer2 = require_safe_buffer3().Buffer;
  var defer = typeof setImmediate === "undefined" ? process.nextTick : setImmediate;
  function paramsHaveRequestBody(params) {
    return params.body || params.requestBodyStream || params.json && typeof params.json !== "boolean" || params.multipart;
  }
  function safeStringify(obj2, replacer) {
    var ret;
    try {
      ret = JSON.stringify(obj2, replacer);
    } catch (e) {
      ret = jsonSafeStringify(obj2, replacer);
    }
    return ret;
  }
  function md5(str2) {
    return crypto3.createHash("md5").update(str2).digest("hex");
  }
  function isReadStream(rs) {
    return rs.readable && rs.path && rs.mode;
  }
  function toBase64(str2) {
    return Buffer2.from(str2 || "", "utf8").toString("base64");
  }
  function copy(obj2) {
    var o = {};
    Object.keys(obj2).forEach(function(i) {
      o[i] = obj2[i];
    });
    return o;
  }
  function version() {
    var numbers = process.version.replace("v", "").split(".");
    return {
      major: parseInt(numbers[0], 10),
      minor: parseInt(numbers[1], 10),
      patch: parseInt(numbers[2], 10)
    };
  }
  exports2.paramsHaveRequestBody = paramsHaveRequestBody;
  exports2.safeStringify = safeStringify;
  exports2.md5 = md5;
  exports2.isReadStream = isReadStream;
  exports2.toBase64 = toBase64;
  exports2.copy = copy;
  exports2.version = version;
  exports2.defer = defer;
});

// backend/node_modules/aws-sign2/index.js
var require_aws_sign2 = __commonJS((exports2, module2) => {
  /*!
   *  Copyright 2010 LearnBoost <dev@learnboost.com>
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var crypto3 = require("crypto");
  var parse = require("url").parse;
  var keys = [
    "acl",
    "location",
    "logging",
    "notification",
    "partNumber",
    "policy",
    "requestPayment",
    "torrent",
    "uploadId",
    "uploads",
    "versionId",
    "versioning",
    "versions",
    "website"
  ];
  function authorization(options) {
    return "AWS " + options.key + ":" + sign(options);
  }
  module2.exports = authorization;
  module2.exports.authorization = authorization;
  function hmacSha1(options) {
    return crypto3.createHmac("sha1", options.secret).update(options.message).digest("base64");
  }
  module2.exports.hmacSha1 = hmacSha1;
  function sign(options) {
    options.message = stringToSign(options);
    return hmacSha1(options);
  }
  module2.exports.sign = sign;
  function signQuery(options) {
    options.message = queryStringToSign(options);
    return hmacSha1(options);
  }
  module2.exports.signQuery = signQuery;
  function stringToSign(options) {
    var headers = options.amazonHeaders || "";
    if (headers)
      headers += `
`;
    var r = [
      options.verb,
      options.md5,
      options.contentType,
      options.date ? options.date.toUTCString() : "",
      headers + options.resource
    ];
    return r.join(`
`);
  }
  module2.exports.stringToSign = stringToSign;
  function queryStringToSign(options) {
    return `GET


` + options.date + `
` + options.resource;
  }
  module2.exports.queryStringToSign = queryStringToSign;
  function canonicalizeHeaders(headers) {
    var buf = [], fields = Object.keys(headers);
    for (var i = 0, len = fields.length;i < len; ++i) {
      var field = fields[i], val = headers[field], field = field.toLowerCase();
      if (field.indexOf("x-amz") !== 0)
        continue;
      buf.push(field + ":" + val);
    }
    return buf.sort().join(`
`);
  }
  module2.exports.canonicalizeHeaders = canonicalizeHeaders;
  function canonicalizeResource(resource) {
    var url2 = parse(resource, true), path2 = url2.pathname, buf = [];
    Object.keys(url2.query).forEach(function(key) {
      if (!~keys.indexOf(key))
        return;
      var val = url2.query[key] == "" ? "" : "=" + encodeURIComponent(url2.query[key]);
      buf.push(key + val);
    });
    return path2 + (buf.length ? "?" + buf.sort().join("&") : "");
  }
  module2.exports.canonicalizeResource = canonicalizeResource;
});

// backend/node_modules/aws4/lru.js
var require_lru = __commonJS((exports2, module2) => {
  module2.exports = function(size) {
    return new LruCache(size);
  };
  function LruCache(size) {
    this.capacity = size | 0;
    this.map = Object.create(null);
    this.list = new DoublyLinkedList;
  }
  LruCache.prototype.get = function(key) {
    var node = this.map[key];
    if (node == null)
      return;
    this.used(node);
    return node.val;
  };
  LruCache.prototype.set = function(key, val) {
    var node = this.map[key];
    if (node != null) {
      node.val = val;
    } else {
      if (!this.capacity)
        this.prune();
      if (!this.capacity)
        return false;
      node = new DoublyLinkedNode(key, val);
      this.map[key] = node;
      this.capacity--;
    }
    this.used(node);
    return true;
  };
  LruCache.prototype.used = function(node) {
    this.list.moveToFront(node);
  };
  LruCache.prototype.prune = function() {
    var node = this.list.pop();
    if (node != null) {
      delete this.map[node.key];
      this.capacity++;
    }
  };
  function DoublyLinkedList() {
    this.firstNode = null;
    this.lastNode = null;
  }
  DoublyLinkedList.prototype.moveToFront = function(node) {
    if (this.firstNode == node)
      return;
    this.remove(node);
    if (this.firstNode == null) {
      this.firstNode = node;
      this.lastNode = node;
      node.prev = null;
      node.next = null;
    } else {
      node.prev = null;
      node.next = this.firstNode;
      node.next.prev = node;
      this.firstNode = node;
    }
  };
  DoublyLinkedList.prototype.pop = function() {
    var lastNode = this.lastNode;
    if (lastNode != null) {
      this.remove(lastNode);
    }
    return lastNode;
  };
  DoublyLinkedList.prototype.remove = function(node) {
    if (this.firstNode == node) {
      this.firstNode = node.next;
    } else if (node.prev != null) {
      node.prev.next = node.next;
    }
    if (this.lastNode == node) {
      this.lastNode = node.prev;
    } else if (node.next != null) {
      node.next.prev = node.prev;
    }
  };
  function DoublyLinkedNode(key, val) {
    this.key = key;
    this.val = val;
    this.prev = null;
    this.next = null;
  }
});

// backend/node_modules/aws4/aws4.js
var require_aws4 = __commonJS((exports2) => {
  var aws4 = exports2;
  var url2 = require("url");
  var querystring = require("querystring");
  var crypto3 = require("crypto");
  var lru = require_lru();
  var credentialsCache = lru(1000);
  function hmac(key, string, encoding) {
    return crypto3.createHmac("sha256", key).update(string, "utf8").digest(encoding);
  }
  function hash(string, encoding) {
    return crypto3.createHash("sha256").update(string, "utf8").digest(encoding);
  }
  function encodeRfc3986(urlEncodedString) {
    return urlEncodedString.replace(/[!'()*]/g, function(c) {
      return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
  }
  function encodeRfc3986Full(str2) {
    return encodeRfc3986(encodeURIComponent(str2));
  }
  var HEADERS_TO_IGNORE = {
    authorization: true,
    connection: true,
    "x-amzn-trace-id": true,
    "user-agent": true,
    expect: true,
    "presigned-expires": true,
    range: true
  };
  function RequestSigner(request, credentials) {
    if (typeof request === "string")
      request = url2.parse(request);
    var headers = request.headers = Object.assign({}, request.headers || {}), hostParts = (!this.service || !this.region) && this.matchHost(request.hostname || request.host || headers.Host || headers.host);
    this.request = request;
    this.credentials = credentials || this.defaultCredentials();
    this.service = request.service || hostParts[0] || "";
    this.region = request.region || hostParts[1] || "us-east-1";
    if (this.service === "email")
      this.service = "ses";
    if (!request.method && request.body)
      request.method = "POST";
    if (!headers.Host && !headers.host) {
      headers.Host = request.hostname || request.host || this.createHost();
      if (request.port)
        headers.Host += ":" + request.port;
    }
    if (!request.hostname && !request.host)
      request.hostname = headers.Host || headers.host;
    this.isCodeCommitGit = this.service === "codecommit" && request.method === "GIT";
    this.extraHeadersToIgnore = request.extraHeadersToIgnore || Object.create(null);
    this.extraHeadersToInclude = request.extraHeadersToInclude || Object.create(null);
  }
  RequestSigner.prototype.matchHost = function(host) {
    var match2 = (host || "").match(/([^\.]{1,63})\.(?:([^\.]{0,63})\.)?amazonaws\.com(\.cn)?$/);
    var hostParts = (match2 || []).slice(1, 3);
    if (hostParts[1] === "es" || hostParts[1] === "aoss")
      hostParts = hostParts.reverse();
    if (hostParts[1] == "s3") {
      hostParts[0] = "s3";
      hostParts[1] = "us-east-1";
    } else {
      for (var i = 0;i < 2; i++) {
        if (/^s3-/.test(hostParts[i])) {
          hostParts[1] = hostParts[i].slice(3);
          hostParts[0] = "s3";
          break;
        }
      }
    }
    return hostParts;
  };
  RequestSigner.prototype.isSingleRegion = function() {
    if (["s3", "sdb"].indexOf(this.service) >= 0 && this.region === "us-east-1")
      return true;
    return ["cloudfront", "ls", "route53", "iam", "importexport", "sts"].indexOf(this.service) >= 0;
  };
  RequestSigner.prototype.createHost = function() {
    var region = this.isSingleRegion() ? "" : "." + this.region, subdomain = this.service === "ses" ? "email" : this.service;
    return subdomain + region + ".amazonaws.com";
  };
  RequestSigner.prototype.prepareRequest = function() {
    this.parsePath();
    var request = this.request, headers = request.headers, query;
    if (request.signQuery) {
      this.parsedPath.query = query = this.parsedPath.query || {};
      if (this.credentials.sessionToken)
        query["X-Amz-Security-Token"] = this.credentials.sessionToken;
      if (this.service === "s3" && !query["X-Amz-Expires"])
        query["X-Amz-Expires"] = 86400;
      if (query["X-Amz-Date"])
        this.datetime = query["X-Amz-Date"];
      else
        query["X-Amz-Date"] = this.getDateTime();
      query["X-Amz-Algorithm"] = "AWS4-HMAC-SHA256";
      query["X-Amz-Credential"] = this.credentials.accessKeyId + "/" + this.credentialString();
      query["X-Amz-SignedHeaders"] = this.signedHeaders();
    } else {
      if (!request.doNotModifyHeaders && !this.isCodeCommitGit) {
        if (request.body && !headers["Content-Type"] && !headers["content-type"])
          headers["Content-Type"] = "application/x-www-form-urlencoded; charset=utf-8";
        if (request.body && !headers["Content-Length"] && !headers["content-length"])
          headers["Content-Length"] = Buffer.byteLength(request.body);
        if (this.credentials.sessionToken && !headers["X-Amz-Security-Token"] && !headers["x-amz-security-token"])
          headers["X-Amz-Security-Token"] = this.credentials.sessionToken;
        if (this.service === "s3" && !headers["X-Amz-Content-Sha256"] && !headers["x-amz-content-sha256"])
          headers["X-Amz-Content-Sha256"] = hash(this.request.body || "", "hex");
        if (headers["X-Amz-Date"] || headers["x-amz-date"])
          this.datetime = headers["X-Amz-Date"] || headers["x-amz-date"];
        else
          headers["X-Amz-Date"] = this.getDateTime();
      }
      delete headers.Authorization;
      delete headers.authorization;
    }
  };
  RequestSigner.prototype.sign = function() {
    if (!this.parsedPath)
      this.prepareRequest();
    if (this.request.signQuery) {
      this.parsedPath.query["X-Amz-Signature"] = this.signature();
    } else {
      this.request.headers.Authorization = this.authHeader();
    }
    this.request.path = this.formatPath();
    return this.request;
  };
  RequestSigner.prototype.getDateTime = function() {
    if (!this.datetime) {
      var headers = this.request.headers, date = new Date(headers.Date || headers.date || new Date);
      this.datetime = date.toISOString().replace(/[:\-]|\.\d{3}/g, "");
      if (this.isCodeCommitGit)
        this.datetime = this.datetime.slice(0, -1);
    }
    return this.datetime;
  };
  RequestSigner.prototype.getDate = function() {
    return this.getDateTime().substr(0, 8);
  };
  RequestSigner.prototype.authHeader = function() {
    return [
      "AWS4-HMAC-SHA256 Credential=" + this.credentials.accessKeyId + "/" + this.credentialString(),
      "SignedHeaders=" + this.signedHeaders(),
      "Signature=" + this.signature()
    ].join(", ");
  };
  RequestSigner.prototype.signature = function() {
    var date = this.getDate(), cacheKey = [this.credentials.secretAccessKey, date, this.region, this.service].join(), kDate, kRegion, kService, kCredentials = credentialsCache.get(cacheKey);
    if (!kCredentials) {
      kDate = hmac("AWS4" + this.credentials.secretAccessKey, date);
      kRegion = hmac(kDate, this.region);
      kService = hmac(kRegion, this.service);
      kCredentials = hmac(kService, "aws4_request");
      credentialsCache.set(cacheKey, kCredentials);
    }
    return hmac(kCredentials, this.stringToSign(), "hex");
  };
  RequestSigner.prototype.stringToSign = function() {
    return [
      "AWS4-HMAC-SHA256",
      this.getDateTime(),
      this.credentialString(),
      hash(this.canonicalString(), "hex")
    ].join(`
`);
  };
  RequestSigner.prototype.canonicalString = function() {
    if (!this.parsedPath)
      this.prepareRequest();
    var pathStr = this.parsedPath.path, query = this.parsedPath.query, headers = this.request.headers, queryStr = "", normalizePath = this.service !== "s3", decodePath = this.service === "s3" || this.request.doNotEncodePath, decodeSlashesInPath = this.service === "s3", firstValOnly = this.service === "s3", bodyHash;
    if (this.service === "s3" && this.request.signQuery) {
      bodyHash = "UNSIGNED-PAYLOAD";
    } else if (this.isCodeCommitGit) {
      bodyHash = "";
    } else {
      bodyHash = headers["X-Amz-Content-Sha256"] || headers["x-amz-content-sha256"] || hash(this.request.body || "", "hex");
    }
    if (query) {
      var reducedQuery = Object.keys(query).reduce(function(obj2, key) {
        if (!key)
          return obj2;
        obj2[encodeRfc3986Full(key)] = !Array.isArray(query[key]) ? query[key] : firstValOnly ? query[key][0] : query[key];
        return obj2;
      }, {});
      var encodedQueryPieces = [];
      Object.keys(reducedQuery).sort().forEach(function(key) {
        if (!Array.isArray(reducedQuery[key])) {
          encodedQueryPieces.push(key + "=" + encodeRfc3986Full(reducedQuery[key]));
        } else {
          reducedQuery[key].map(encodeRfc3986Full).sort().forEach(function(val) {
            encodedQueryPieces.push(key + "=" + val);
          });
        }
      });
      queryStr = encodedQueryPieces.join("&");
    }
    if (pathStr !== "/") {
      if (normalizePath)
        pathStr = pathStr.replace(/\/{2,}/g, "/");
      pathStr = pathStr.split("/").reduce(function(path2, piece) {
        if (normalizePath && piece === "..") {
          path2.pop();
        } else if (!normalizePath || piece !== ".") {
          if (decodePath)
            piece = decodeURIComponent(piece.replace(/\+/g, " "));
          path2.push(encodeRfc3986Full(piece));
        }
        return path2;
      }, []).join("/");
      if (pathStr[0] !== "/")
        pathStr = "/" + pathStr;
      if (decodeSlashesInPath)
        pathStr = pathStr.replace(/%2F/g, "/");
    }
    return [
      this.request.method || "GET",
      pathStr,
      queryStr,
      this.canonicalHeaders() + `
`,
      this.signedHeaders(),
      bodyHash
    ].join(`
`);
  };
  RequestSigner.prototype.filterHeaders = function() {
    var headers = this.request.headers, extraHeadersToInclude = this.extraHeadersToInclude, extraHeadersToIgnore = this.extraHeadersToIgnore;
    this.filteredHeaders = Object.keys(headers).map(function(key) {
      return [key.toLowerCase(), headers[key]];
    }).filter(function(entry) {
      return extraHeadersToInclude[entry[0]] || HEADERS_TO_IGNORE[entry[0]] == null && !extraHeadersToIgnore[entry[0]];
    }).sort(function(a, b) {
      return a[0] < b[0] ? -1 : 1;
    });
  };
  RequestSigner.prototype.canonicalHeaders = function() {
    if (!this.filteredHeaders)
      this.filterHeaders();
    return this.filteredHeaders.map(function(entry) {
      return entry[0] + ":" + entry[1].toString().trim().replace(/\s+/g, " ");
    }).join(`
`);
  };
  RequestSigner.prototype.signedHeaders = function() {
    if (!this.filteredHeaders)
      this.filterHeaders();
    return this.filteredHeaders.map(function(entry) {
      return entry[0];
    }).join(";");
  };
  RequestSigner.prototype.credentialString = function() {
    return [
      this.getDate(),
      this.region,
      this.service,
      "aws4_request"
    ].join("/");
  };
  RequestSigner.prototype.defaultCredentials = function() {
    var env2 = process.env;
    return {
      accessKeyId: env2.AWS_ACCESS_KEY_ID || env2.AWS_ACCESS_KEY,
      secretAccessKey: env2.AWS_SECRET_ACCESS_KEY || env2.AWS_SECRET_KEY,
      sessionToken: env2.AWS_SESSION_TOKEN
    };
  };
  RequestSigner.prototype.parsePath = function() {
    var path2 = this.request.path || "/";
    if (/[^0-9A-Za-z;,/?:@&=+$\-_.!~*'()#%]/.test(path2)) {
      path2 = encodeURI(decodeURI(path2));
    }
    var queryIx = path2.indexOf("?"), query = null;
    if (queryIx >= 0) {
      query = querystring.parse(path2.slice(queryIx + 1));
      path2 = path2.slice(0, queryIx);
    }
    this.parsedPath = {
      path: path2,
      query
    };
  };
  RequestSigner.prototype.formatPath = function() {
    var path2 = this.parsedPath.path, query = this.parsedPath.query;
    if (!query)
      return path2;
    if (query[""] != null)
      delete query[""];
    return path2 + "?" + encodeRfc3986(querystring.stringify(query));
  };
  aws4.RequestSigner = RequestSigner;
  aws4.sign = function(request, credentials) {
    return new RequestSigner(request, credentials).sign();
  };
});

// backend/node_modules/assert-plus/assert.js
var require_assert = __commonJS((exports2, module2) => {
  var assert = require("assert");
  var Stream2 = require("stream").Stream;
  var util3 = require("util");
  var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
  function _capitalize(str2) {
    return str2.charAt(0).toUpperCase() + str2.slice(1);
  }
  function _toss(name, expected, oper, arg, actual) {
    throw new assert.AssertionError({
      message: util3.format("%s (%s) is required", name, expected),
      actual: actual === undefined ? typeof arg : actual(arg),
      expected,
      operator: oper || "===",
      stackStartFunction: _toss.caller
    });
  }
  function _getClass(arg) {
    return Object.prototype.toString.call(arg).slice(8, -1);
  }
  function noop3() {}
  var types = {
    bool: {
      check: function(arg) {
        return typeof arg === "boolean";
      }
    },
    func: {
      check: function(arg) {
        return typeof arg === "function";
      }
    },
    string: {
      check: function(arg) {
        return typeof arg === "string";
      }
    },
    object: {
      check: function(arg) {
        return typeof arg === "object" && arg !== null;
      }
    },
    number: {
      check: function(arg) {
        return typeof arg === "number" && !isNaN(arg);
      }
    },
    finite: {
      check: function(arg) {
        return typeof arg === "number" && !isNaN(arg) && isFinite(arg);
      }
    },
    buffer: {
      check: function(arg) {
        return Buffer.isBuffer(arg);
      },
      operator: "Buffer.isBuffer"
    },
    array: {
      check: function(arg) {
        return Array.isArray(arg);
      },
      operator: "Array.isArray"
    },
    stream: {
      check: function(arg) {
        return arg instanceof Stream2;
      },
      operator: "instanceof",
      actual: _getClass
    },
    date: {
      check: function(arg) {
        return arg instanceof Date;
      },
      operator: "instanceof",
      actual: _getClass
    },
    regexp: {
      check: function(arg) {
        return arg instanceof RegExp;
      },
      operator: "instanceof",
      actual: _getClass
    },
    uuid: {
      check: function(arg) {
        return typeof arg === "string" && UUID_REGEXP.test(arg);
      },
      operator: "isUUID"
    }
  };
  function _setExports(ndebug) {
    var keys = Object.keys(types);
    var out;
    if (process.env.NODE_NDEBUG) {
      out = noop3;
    } else {
      out = function(arg, msg) {
        if (!arg) {
          _toss(msg, "true", arg);
        }
      };
    }
    keys.forEach(function(k) {
      if (ndebug) {
        out[k] = noop3;
        return;
      }
      var type = types[k];
      out[k] = function(arg, msg) {
        if (!type.check(arg)) {
          _toss(msg, k, type.operator, arg, type.actual);
        }
      };
    });
    keys.forEach(function(k) {
      var name = "optional" + _capitalize(k);
      if (ndebug) {
        out[name] = noop3;
        return;
      }
      var type = types[k];
      out[name] = function(arg, msg) {
        if (arg === undefined || arg === null) {
          return;
        }
        if (!type.check(arg)) {
          _toss(msg, k, type.operator, arg, type.actual);
        }
      };
    });
    keys.forEach(function(k) {
      var name = "arrayOf" + _capitalize(k);
      if (ndebug) {
        out[name] = noop3;
        return;
      }
      var type = types[k];
      var expected = "[" + k + "]";
      out[name] = function(arg, msg) {
        if (!Array.isArray(arg)) {
          _toss(msg, expected, type.operator, arg, type.actual);
        }
        var i;
        for (i = 0;i < arg.length; i++) {
          if (!type.check(arg[i])) {
            _toss(msg, expected, type.operator, arg, type.actual);
          }
        }
      };
    });
    keys.forEach(function(k) {
      var name = "optionalArrayOf" + _capitalize(k);
      if (ndebug) {
        out[name] = noop3;
        return;
      }
      var type = types[k];
      var expected = "[" + k + "]";
      out[name] = function(arg, msg) {
        if (arg === undefined || arg === null) {
          return;
        }
        if (!Array.isArray(arg)) {
          _toss(msg, expected, type.operator, arg, type.actual);
        }
        var i;
        for (i = 0;i < arg.length; i++) {
          if (!type.check(arg[i])) {
            _toss(msg, expected, type.operator, arg, type.actual);
          }
        }
      };
    });
    Object.keys(assert).forEach(function(k) {
      if (k === "AssertionError") {
        out[k] = assert[k];
        return;
      }
      if (ndebug) {
        out[k] = noop3;
        return;
      }
      out[k] = assert[k];
    });
    out._setExports = _setExports;
    return out;
  }
  module2.exports = _setExports(process.env.NODE_NDEBUG);
});

// backend/node_modules/safer-buffer/safer.js
var require_safer = __commonJS((exports2, module2) => {
  var buffer = require("buffer");
  var Buffer2 = buffer.Buffer;
  var safer = {};
  var key;
  for (key in buffer) {
    if (!buffer.hasOwnProperty(key))
      continue;
    if (key === "SlowBuffer" || key === "Buffer")
      continue;
    safer[key] = buffer[key];
  }
  var Safer = safer.Buffer = {};
  for (key in Buffer2) {
    if (!Buffer2.hasOwnProperty(key))
      continue;
    if (key === "allocUnsafe" || key === "allocUnsafeSlow")
      continue;
    Safer[key] = Buffer2[key];
  }
  safer.Buffer.prototype = Buffer2.prototype;
  if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
      }
      if (value && typeof value.length === "undefined") {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      return Buffer2(value, encodingOrOffset, length);
    };
  }
  if (!Safer.alloc) {
    Safer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
      }
      if (size < 0 || size >= 2 * (1 << 30)) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
      var buf = Buffer2(size);
      if (!fill || fill.length === 0) {
        buf.fill(0);
      } else if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
      return buf;
    };
  }
  if (!safer.kStringMaxLength) {
    try {
      safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch (e) {}
  }
  if (!safer.constants) {
    safer.constants = {
      MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) {
      safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
  }
  module2.exports = safer;
});

// backend/node_modules/sshpk/lib/algs.js
var require_algs = __commonJS((exports2, module2) => {
  var Buffer2 = require_safer().Buffer;
  var algInfo = {
    dsa: {
      parts: ["p", "q", "g", "y"],
      sizePart: "p"
    },
    rsa: {
      parts: ["e", "n"],
      sizePart: "n"
    },
    ecdsa: {
      parts: ["curve", "Q"],
      sizePart: "Q"
    },
    ed25519: {
      parts: ["A"],
      sizePart: "A"
    }
  };
  algInfo["curve25519"] = algInfo["ed25519"];
  var algPrivInfo = {
    dsa: {
      parts: ["p", "q", "g", "y", "x"]
    },
    rsa: {
      parts: ["n", "e", "d", "iqmp", "p", "q"]
    },
    ecdsa: {
      parts: ["curve", "Q", "d"]
    },
    ed25519: {
      parts: ["A", "k"]
    }
  };
  algPrivInfo["curve25519"] = algPrivInfo["ed25519"];
  var hashAlgs = {
    md5: true,
    sha1: true,
    sha256: true,
    sha384: true,
    sha512: true
  };
  var curves = {
    nistp256: {
      size: 256,
      pkcs8oid: "1.2.840.10045.3.1.7",
      p: Buffer2.from(("00" + "ffffffff 00000001 00000000 00000000" + "00000000 ffffffff ffffffff ffffffff").replace(/ /g, ""), "hex"),
      a: Buffer2.from(("00" + "FFFFFFFF 00000001 00000000 00000000" + "00000000 FFFFFFFF FFFFFFFF FFFFFFFC").replace(/ /g, ""), "hex"),
      b: Buffer2.from(("5ac635d8 aa3a93e7 b3ebbd55 769886bc" + "651d06b0 cc53b0f6 3bce3c3e 27d2604b").replace(/ /g, ""), "hex"),
      s: Buffer2.from(("00" + "c49d3608 86e70493 6a6678e1 139d26b7" + "819f7e90").replace(/ /g, ""), "hex"),
      n: Buffer2.from(("00" + "ffffffff 00000000 ffffffff ffffffff" + "bce6faad a7179e84 f3b9cac2 fc632551").replace(/ /g, ""), "hex"),
      G: Buffer2.from(("04" + "6b17d1f2 e12c4247 f8bce6e5 63a440f2" + "77037d81 2deb33a0 f4a13945 d898c296" + "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16" + "2bce3357 6b315ece cbb64068 37bf51f5").replace(/ /g, ""), "hex")
    },
    nistp384: {
      size: 384,
      pkcs8oid: "1.3.132.0.34",
      p: Buffer2.from(("00" + "ffffffff ffffffff ffffffff ffffffff" + "ffffffff ffffffff ffffffff fffffffe" + "ffffffff 00000000 00000000 ffffffff").replace(/ /g, ""), "hex"),
      a: Buffer2.from(("00" + "FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF" + "FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE" + "FFFFFFFF 00000000 00000000 FFFFFFFC").replace(/ /g, ""), "hex"),
      b: Buffer2.from(("b3312fa7 e23ee7e4 988e056b e3f82d19" + "181d9c6e fe814112 0314088f 5013875a" + "c656398d 8a2ed19d 2a85c8ed d3ec2aef").replace(/ /g, ""), "hex"),
      s: Buffer2.from(("00" + "a335926a a319a27a 1d00896a 6773a482" + "7acdac73").replace(/ /g, ""), "hex"),
      n: Buffer2.from(("00" + "ffffffff ffffffff ffffffff ffffffff" + "ffffffff ffffffff c7634d81 f4372ddf" + "581a0db2 48b0a77a ecec196a ccc52973").replace(/ /g, ""), "hex"),
      G: Buffer2.from(("04" + "aa87ca22 be8b0537 8eb1c71e f320ad74" + "6e1d3b62 8ba79b98 59f741e0 82542a38" + "5502f25d bf55296c 3a545e38 72760ab7" + "3617de4a 96262c6f 5d9e98bf 9292dc29" + "f8f41dbd 289a147c e9da3113 b5f0b8c0" + "0a60b1ce 1d7e819d 7a431d7c 90ea0e5f").replace(/ /g, ""), "hex")
    },
    nistp521: {
      size: 521,
      pkcs8oid: "1.3.132.0.35",
      p: Buffer2.from(("01ffffff ffffffff ffffffff ffffffff" + "ffffffff ffffffff ffffffff ffffffff" + "ffffffff ffffffff ffffffff ffffffff" + "ffffffff ffffffff ffffffff ffffffff" + "ffff").replace(/ /g, ""), "hex"),
      a: Buffer2.from(("01FF" + "FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF" + "FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF" + "FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF" + "FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFC").replace(/ /g, ""), "hex"),
      b: Buffer2.from(("51" + "953eb961 8e1c9a1f 929a21a0 b68540ee" + "a2da725b 99b315f3 b8b48991 8ef109e1" + "56193951 ec7e937b 1652c0bd 3bb1bf07" + "3573df88 3d2c34f1 ef451fd4 6b503f00").replace(/ /g, ""), "hex"),
      s: Buffer2.from(("00" + "d09e8800 291cb853 96cc6717 393284aa" + "a0da64ba").replace(/ /g, ""), "hex"),
      n: Buffer2.from(("01ff" + "ffffffff ffffffff ffffffff ffffffff" + "ffffffff ffffffff ffffffff fffffffa" + "51868783 bf2f966b 7fcc0148 f709a5d0" + "3bb5c9b8 899c47ae bb6fb71e 91386409").replace(/ /g, ""), "hex"),
      G: Buffer2.from(("04" + "00c6 858e06b7 0404e9cd 9e3ecb66 2395b442" + "9c648139 053fb521 f828af60 6b4d3dba" + "a14b5e77 efe75928 fe1dc127 a2ffa8de" + "3348b3c1 856a429b f97e7e31 c2e5bd66" + "0118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9" + "98f54449 579b4468 17afbd17 273e662c" + "97ee7299 5ef42640 c550b901 3fad0761" + "353c7086 a272c240 88be9476 9fd16650").replace(/ /g, ""), "hex")
    }
  };
  module2.exports = {
    info: algInfo,
    privInfo: algPrivInfo,
    hashAlgs,
    curves
  };
});

// backend/node_modules/sshpk/lib/errors.js
var require_errors7 = __commonJS((exports2, module2) => {
  var assert = require_assert();
  var util3 = require("util");
  function FingerprintFormatError(fp, format) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, FingerprintFormatError);
    this.name = "FingerprintFormatError";
    this.fingerprint = fp;
    this.format = format;
    this.message = "Fingerprint format is not supported, or is invalid: ";
    if (fp !== undefined)
      this.message += " fingerprint = " + fp;
    if (format !== undefined)
      this.message += " format = " + format;
  }
  util3.inherits(FingerprintFormatError, Error);
  function InvalidAlgorithmError(alg) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, InvalidAlgorithmError);
    this.name = "InvalidAlgorithmError";
    this.algorithm = alg;
    this.message = 'Algorithm "' + alg + '" is not supported';
  }
  util3.inherits(InvalidAlgorithmError, Error);
  function KeyParseError(name, format, innerErr) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, KeyParseError);
    this.name = "KeyParseError";
    this.format = format;
    this.keyName = name;
    this.innerErr = innerErr;
    this.message = "Failed to parse " + name + " as a valid " + format + " format key: " + innerErr.message;
  }
  util3.inherits(KeyParseError, Error);
  function SignatureParseError(type, format, innerErr) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, SignatureParseError);
    this.name = "SignatureParseError";
    this.type = type;
    this.format = format;
    this.innerErr = innerErr;
    this.message = "Failed to parse the given data as a " + type + " signature in " + format + " format: " + innerErr.message;
  }
  util3.inherits(SignatureParseError, Error);
  function CertificateParseError(name, format, innerErr) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, CertificateParseError);
    this.name = "CertificateParseError";
    this.format = format;
    this.certName = name;
    this.innerErr = innerErr;
    this.message = "Failed to parse " + name + " as a valid " + format + " format certificate: " + innerErr.message;
  }
  util3.inherits(CertificateParseError, Error);
  function KeyEncryptedError(name, format) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, KeyEncryptedError);
    this.name = "KeyEncryptedError";
    this.format = format;
    this.keyName = name;
    this.message = "The " + format + " format key " + name + " is " + "encrypted (password-protected), and no passphrase was " + "provided in `options`";
  }
  util3.inherits(KeyEncryptedError, Error);
  module2.exports = {
    FingerprintFormatError,
    InvalidAlgorithmError,
    KeyParseError,
    SignatureParseError,
    KeyEncryptedError,
    CertificateParseError
  };
});

// backend/node_modules/asn1/lib/ber/errors.js
var require_errors8 = __commonJS((exports2, module2) => {
  module2.exports = {
    newInvalidAsn1Error: function(msg) {
      var e = new Error;
      e.name = "InvalidAsn1Error";
      e.message = msg || "";
      return e;
    }
  };
});

// backend/node_modules/asn1/lib/ber/types.js
var require_types4 = __commonJS((exports2, module2) => {
  module2.exports = {
    EOC: 0,
    Boolean: 1,
    Integer: 2,
    BitString: 3,
    OctetString: 4,
    Null: 5,
    OID: 6,
    ObjectDescriptor: 7,
    External: 8,
    Real: 9,
    Enumeration: 10,
    PDV: 11,
    Utf8String: 12,
    RelativeOID: 13,
    Sequence: 16,
    Set: 17,
    NumericString: 18,
    PrintableString: 19,
    T61String: 20,
    VideotexString: 21,
    IA5String: 22,
    UTCTime: 23,
    GeneralizedTime: 24,
    GraphicString: 25,
    VisibleString: 26,
    GeneralString: 28,
    UniversalString: 29,
    CharacterString: 30,
    BMPString: 31,
    Constructor: 32,
    Context: 128
  };
});

// backend/node_modules/asn1/lib/ber/reader.js
var require_reader = __commonJS((exports2, module2) => {
  var assert = require("assert");
  var Buffer2 = require_safer().Buffer;
  var ASN1 = require_types4();
  var errors = require_errors8();
  var newInvalidAsn1Error = errors.newInvalidAsn1Error;
  function Reader(data) {
    if (!data || !Buffer2.isBuffer(data))
      throw new TypeError("data must be a node Buffer");
    this._buf = data;
    this._size = data.length;
    this._len = 0;
    this._offset = 0;
  }
  Object.defineProperty(Reader.prototype, "length", {
    enumerable: true,
    get: function() {
      return this._len;
    }
  });
  Object.defineProperty(Reader.prototype, "offset", {
    enumerable: true,
    get: function() {
      return this._offset;
    }
  });
  Object.defineProperty(Reader.prototype, "remain", {
    get: function() {
      return this._size - this._offset;
    }
  });
  Object.defineProperty(Reader.prototype, "buffer", {
    get: function() {
      return this._buf.slice(this._offset);
    }
  });
  Reader.prototype.readByte = function(peek) {
    if (this._size - this._offset < 1)
      return null;
    var b = this._buf[this._offset] & 255;
    if (!peek)
      this._offset += 1;
    return b;
  };
  Reader.prototype.peek = function() {
    return this.readByte(true);
  };
  Reader.prototype.readLength = function(offset) {
    if (offset === undefined)
      offset = this._offset;
    if (offset >= this._size)
      return null;
    var lenB = this._buf[offset++] & 255;
    if (lenB === null)
      return null;
    if ((lenB & 128) === 128) {
      lenB &= 127;
      if (lenB === 0)
        throw newInvalidAsn1Error("Indefinite length not supported");
      if (lenB > 4)
        throw newInvalidAsn1Error("encoding too long");
      if (this._size - offset < lenB)
        return null;
      this._len = 0;
      for (var i = 0;i < lenB; i++)
        this._len = (this._len << 8) + (this._buf[offset++] & 255);
    } else {
      this._len = lenB;
    }
    return offset;
  };
  Reader.prototype.readSequence = function(tag) {
    var seq = this.peek();
    if (seq === null)
      return null;
    if (tag !== undefined && tag !== seq)
      throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + seq.toString(16));
    var o = this.readLength(this._offset + 1);
    if (o === null)
      return null;
    this._offset = o;
    return seq;
  };
  Reader.prototype.readInt = function() {
    return this._readTag(ASN1.Integer);
  };
  Reader.prototype.readBoolean = function() {
    return this._readTag(ASN1.Boolean) === 0 ? false : true;
  };
  Reader.prototype.readEnumeration = function() {
    return this._readTag(ASN1.Enumeration);
  };
  Reader.prototype.readString = function(tag, retbuf) {
    if (!tag)
      tag = ASN1.OctetString;
    var b = this.peek();
    if (b === null)
      return null;
    if (b !== tag)
      throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
    var o = this.readLength(this._offset + 1);
    if (o === null)
      return null;
    if (this.length > this._size - o)
      return null;
    this._offset = o;
    if (this.length === 0)
      return retbuf ? Buffer2.alloc(0) : "";
    var str2 = this._buf.slice(this._offset, this._offset + this.length);
    this._offset += this.length;
    return retbuf ? str2 : str2.toString("utf8");
  };
  Reader.prototype.readOID = function(tag) {
    if (!tag)
      tag = ASN1.OID;
    var b = this.readString(tag, true);
    if (b === null)
      return null;
    var values2 = [];
    var value = 0;
    for (var i = 0;i < b.length; i++) {
      var byte = b[i] & 255;
      value <<= 7;
      value += byte & 127;
      if ((byte & 128) === 0) {
        values2.push(value);
        value = 0;
      }
    }
    value = values2.shift();
    values2.unshift(value % 40);
    values2.unshift(value / 40 >> 0);
    return values2.join(".");
  };
  Reader.prototype._readTag = function(tag) {
    assert.ok(tag !== undefined);
    var b = this.peek();
    if (b === null)
      return null;
    if (b !== tag)
      throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
    var o = this.readLength(this._offset + 1);
    if (o === null)
      return null;
    if (this.length > 4)
      throw newInvalidAsn1Error("Integer too long: " + this.length);
    if (this.length > this._size - o)
      return null;
    this._offset = o;
    var fb = this._buf[this._offset];
    var value = 0;
    for (var i = 0;i < this.length; i++) {
      value <<= 8;
      value |= this._buf[this._offset++] & 255;
    }
    if ((fb & 128) === 128 && i !== 4)
      value -= 1 << i * 8;
    return value >> 0;
  };
  module2.exports = Reader;
});

// backend/node_modules/asn1/lib/ber/writer.js
var require_writer = __commonJS((exports2, module2) => {
  var assert = require("assert");
  var Buffer2 = require_safer().Buffer;
  var ASN1 = require_types4();
  var errors = require_errors8();
  var newInvalidAsn1Error = errors.newInvalidAsn1Error;
  var DEFAULT_OPTS = {
    size: 1024,
    growthFactor: 8
  };
  function merge2(from, to) {
    assert.ok(from);
    assert.equal(typeof from, "object");
    assert.ok(to);
    assert.equal(typeof to, "object");
    var keys = Object.getOwnPropertyNames(from);
    keys.forEach(function(key) {
      if (to[key])
        return;
      var value = Object.getOwnPropertyDescriptor(from, key);
      Object.defineProperty(to, key, value);
    });
    return to;
  }
  function Writer(options) {
    options = merge2(DEFAULT_OPTS, options || {});
    this._buf = Buffer2.alloc(options.size || 1024);
    this._size = this._buf.length;
    this._offset = 0;
    this._options = options;
    this._seq = [];
  }
  Object.defineProperty(Writer.prototype, "buffer", {
    get: function() {
      if (this._seq.length)
        throw newInvalidAsn1Error(this._seq.length + " unended sequence(s)");
      return this._buf.slice(0, this._offset);
    }
  });
  Writer.prototype.writeByte = function(b) {
    if (typeof b !== "number")
      throw new TypeError("argument must be a Number");
    this._ensure(1);
    this._buf[this._offset++] = b;
  };
  Writer.prototype.writeInt = function(i, tag) {
    if (typeof i !== "number")
      throw new TypeError("argument must be a Number");
    if (typeof tag !== "number")
      tag = ASN1.Integer;
    var sz = 4;
    while (((i & 4286578688) === 0 || (i & 4286578688) === 4286578688 >> 0) && sz > 1) {
      sz--;
      i <<= 8;
    }
    if (sz > 4)
      throw newInvalidAsn1Error("BER ints cannot be > 0xffffffff");
    this._ensure(2 + sz);
    this._buf[this._offset++] = tag;
    this._buf[this._offset++] = sz;
    while (sz-- > 0) {
      this._buf[this._offset++] = (i & 4278190080) >>> 24;
      i <<= 8;
    }
  };
  Writer.prototype.writeNull = function() {
    this.writeByte(ASN1.Null);
    this.writeByte(0);
  };
  Writer.prototype.writeEnumeration = function(i, tag) {
    if (typeof i !== "number")
      throw new TypeError("argument must be a Number");
    if (typeof tag !== "number")
      tag = ASN1.Enumeration;
    return this.writeInt(i, tag);
  };
  Writer.prototype.writeBoolean = function(b, tag) {
    if (typeof b !== "boolean")
      throw new TypeError("argument must be a Boolean");
    if (typeof tag !== "number")
      tag = ASN1.Boolean;
    this._ensure(3);
    this._buf[this._offset++] = tag;
    this._buf[this._offset++] = 1;
    this._buf[this._offset++] = b ? 255 : 0;
  };
  Writer.prototype.writeString = function(s, tag) {
    if (typeof s !== "string")
      throw new TypeError("argument must be a string (was: " + typeof s + ")");
    if (typeof tag !== "number")
      tag = ASN1.OctetString;
    var len = Buffer2.byteLength(s);
    this.writeByte(tag);
    this.writeLength(len);
    if (len) {
      this._ensure(len);
      this._buf.write(s, this._offset);
      this._offset += len;
    }
  };
  Writer.prototype.writeBuffer = function(buf, tag) {
    if (typeof tag !== "number")
      throw new TypeError("tag must be a number");
    if (!Buffer2.isBuffer(buf))
      throw new TypeError("argument must be a buffer");
    this.writeByte(tag);
    this.writeLength(buf.length);
    this._ensure(buf.length);
    buf.copy(this._buf, this._offset, 0, buf.length);
    this._offset += buf.length;
  };
  Writer.prototype.writeStringArray = function(strings) {
    if (!strings instanceof Array)
      throw new TypeError("argument must be an Array[String]");
    var self2 = this;
    strings.forEach(function(s) {
      self2.writeString(s);
    });
  };
  Writer.prototype.writeOID = function(s, tag) {
    if (typeof s !== "string")
      throw new TypeError("argument must be a string");
    if (typeof tag !== "number")
      tag = ASN1.OID;
    if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
      throw new Error("argument is not a valid OID string");
    function encodeOctet(bytes2, octet) {
      if (octet < 128) {
        bytes2.push(octet);
      } else if (octet < 16384) {
        bytes2.push(octet >>> 7 | 128);
        bytes2.push(octet & 127);
      } else if (octet < 2097152) {
        bytes2.push(octet >>> 14 | 128);
        bytes2.push((octet >>> 7 | 128) & 255);
        bytes2.push(octet & 127);
      } else if (octet < 268435456) {
        bytes2.push(octet >>> 21 | 128);
        bytes2.push((octet >>> 14 | 128) & 255);
        bytes2.push((octet >>> 7 | 128) & 255);
        bytes2.push(octet & 127);
      } else {
        bytes2.push((octet >>> 28 | 128) & 255);
        bytes2.push((octet >>> 21 | 128) & 255);
        bytes2.push((octet >>> 14 | 128) & 255);
        bytes2.push((octet >>> 7 | 128) & 255);
        bytes2.push(octet & 127);
      }
    }
    var tmp = s.split(".");
    var bytes = [];
    bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
    tmp.slice(2).forEach(function(b) {
      encodeOctet(bytes, parseInt(b, 10));
    });
    var self2 = this;
    this._ensure(2 + bytes.length);
    this.writeByte(tag);
    this.writeLength(bytes.length);
    bytes.forEach(function(b) {
      self2.writeByte(b);
    });
  };
  Writer.prototype.writeLength = function(len) {
    if (typeof len !== "number")
      throw new TypeError("argument must be a Number");
    this._ensure(4);
    if (len <= 127) {
      this._buf[this._offset++] = len;
    } else if (len <= 255) {
      this._buf[this._offset++] = 129;
      this._buf[this._offset++] = len;
    } else if (len <= 65535) {
      this._buf[this._offset++] = 130;
      this._buf[this._offset++] = len >> 8;
      this._buf[this._offset++] = len;
    } else if (len <= 16777215) {
      this._buf[this._offset++] = 131;
      this._buf[this._offset++] = len >> 16;
      this._buf[this._offset++] = len >> 8;
      this._buf[this._offset++] = len;
    } else {
      throw newInvalidAsn1Error("Length too long (> 4 bytes)");
    }
  };
  Writer.prototype.startSequence = function(tag) {
    if (typeof tag !== "number")
      tag = ASN1.Sequence | ASN1.Constructor;
    this.writeByte(tag);
    this._seq.push(this._offset);
    this._ensure(3);
    this._offset += 3;
  };
  Writer.prototype.endSequence = function() {
    var seq = this._seq.pop();
    var start = seq + 3;
    var len = this._offset - start;
    if (len <= 127) {
      this._shift(start, len, -2);
      this._buf[seq] = len;
    } else if (len <= 255) {
      this._shift(start, len, -1);
      this._buf[seq] = 129;
      this._buf[seq + 1] = len;
    } else if (len <= 65535) {
      this._buf[seq] = 130;
      this._buf[seq + 1] = len >> 8;
      this._buf[seq + 2] = len;
    } else if (len <= 16777215) {
      this._shift(start, len, 1);
      this._buf[seq] = 131;
      this._buf[seq + 1] = len >> 16;
      this._buf[seq + 2] = len >> 8;
      this._buf[seq + 3] = len;
    } else {
      throw newInvalidAsn1Error("Sequence too long");
    }
  };
  Writer.prototype._shift = function(start, len, shift) {
    assert.ok(start !== undefined);
    assert.ok(len !== undefined);
    assert.ok(shift);
    this._buf.copy(this._buf, start + shift, start, start + len);
    this._offset += shift;
  };
  Writer.prototype._ensure = function(len) {
    assert.ok(len);
    if (this._size - this._offset < len) {
      var sz = this._size * this._options.growthFactor;
      if (sz - this._offset < len)
        sz += len;
      var buf = Buffer2.alloc(sz);
      this._buf.copy(buf, 0, 0, this._offset);
      this._buf = buf;
      this._size = sz;
    }
  };
  module2.exports = Writer;
});

// backend/node_modules/asn1/lib/ber/index.js
var require_ber = __commonJS((exports2, module2) => {
  var errors = require_errors8();
  var types = require_types4();
  var Reader = require_reader();
  var Writer = require_writer();
  module2.exports = {
    Reader,
    Writer
  };
  for (t in types) {
    if (types.hasOwnProperty(t))
      module2.exports[t] = types[t];
  }
  var t;
  for (e in errors) {
    if (errors.hasOwnProperty(e))
      module2.exports[e] = errors[e];
  }
  var e;
});

// backend/node_modules/asn1/lib/index.js
var require_lib3 = __commonJS((exports2, module2) => {
  var Ber = require_ber();
  module2.exports = {
    Ber,
    BerReader: Ber.Reader,
    BerWriter: Ber.Writer
  };
});

// backend/node_modules/jsbn/index.js
var require_jsbn = __commonJS((exports2, module2) => {
  (function() {
    var dbits;
    var canary = 244837814094590;
    var j_lm = (canary & 16777215) == 15715070;
    function BigInteger(a, b, c) {
      if (a != null)
        if (typeof a == "number")
          this.fromNumber(a, b, c);
        else if (b == null && typeof a != "string")
          this.fromString(a, 256);
        else
          this.fromString(a, b);
    }
    function nbi() {
      return new BigInteger(null);
    }
    function am1(i, x, w, j, c, n) {
      while (--n >= 0) {
        var v = x * this[i++] + w[j] + c;
        c = Math.floor(v / 67108864);
        w[j++] = v & 67108863;
      }
      return c;
    }
    function am2(i, x, w, j, c, n) {
      var xl = x & 32767, xh = x >> 15;
      while (--n >= 0) {
        var l = this[i] & 32767;
        var h = this[i++] >> 15;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);
        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
        w[j++] = l & 1073741823;
      }
      return c;
    }
    function am3(i, x, w, j, c, n) {
      var xl = x & 16383, xh = x >> 14;
      while (--n >= 0) {
        var l = this[i] & 16383;
        var h = this[i++] >> 14;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 16383) << 14) + w[j] + c;
        c = (l >> 28) + (m >> 14) + xh * h;
        w[j++] = l & 268435455;
      }
      return c;
    }
    var inBrowser = typeof navigator !== "undefined";
    if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
      BigInteger.prototype.am = am2;
      dbits = 30;
    } else if (inBrowser && j_lm && navigator.appName != "Netscape") {
      BigInteger.prototype.am = am1;
      dbits = 26;
    } else {
      BigInteger.prototype.am = am3;
      dbits = 28;
    }
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = (1 << dbits) - 1;
    BigInteger.prototype.DV = 1 << dbits;
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array;
    var rr, vv;
    rr = 48;
    for (vv = 0;vv <= 9; ++vv)
      BI_RC[rr++] = vv;
    rr = 97;
    for (vv = 10;vv < 36; ++vv)
      BI_RC[rr++] = vv;
    rr = 65;
    for (vv = 10;vv < 36; ++vv)
      BI_RC[rr++] = vv;
    function int2char(n) {
      return BI_RM.charAt(n);
    }
    function intAt(s, i) {
      var c = BI_RC[s.charCodeAt(i)];
      return c == null ? -1 : c;
    }
    function bnpCopyTo(r) {
      for (var i = this.t - 1;i >= 0; --i)
        r[i] = this[i];
      r.t = this.t;
      r.s = this.s;
    }
    function bnpFromInt(x) {
      this.t = 1;
      this.s = x < 0 ? -1 : 0;
      if (x > 0)
        this[0] = x;
      else if (x < -1)
        this[0] = x + this.DV;
      else
        this.t = 0;
    }
    function nbv(i) {
      var r = nbi();
      r.fromInt(i);
      return r;
    }
    function bnpFromString(s, b) {
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 256)
        k = 8;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else {
        this.fromRadix(s, b);
        return;
      }
      this.t = 0;
      this.s = 0;
      var i = s.length, mi = false, sh = 0;
      while (--i >= 0) {
        var x = k == 8 ? s[i] & 255 : intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-")
            mi = true;
          continue;
        }
        mi = false;
        if (sh == 0)
          this[this.t++] = x;
        else if (sh + k > this.DB) {
          this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
          this[this.t++] = x >> this.DB - sh;
        } else
          this[this.t - 1] |= x << sh;
        sh += k;
        if (sh >= this.DB)
          sh -= this.DB;
      }
      if (k == 8 && (s[0] & 128) != 0) {
        this.s = -1;
        if (sh > 0)
          this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
      }
      this.clamp();
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpClamp() {
      var c = this.s & this.DM;
      while (this.t > 0 && this[this.t - 1] == c)
        --this.t;
    }
    function bnToString(b) {
      if (this.s < 0)
        return "-" + this.negate().toString(b);
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else
        return this.toRadix(b);
      var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
      var p = this.DB - i * this.DB % k;
      if (i-- > 0) {
        if (p < this.DB && (d = this[i] >> p) > 0) {
          m = true;
          r = int2char(d);
        }
        while (i >= 0) {
          if (p < k) {
            d = (this[i] & (1 << p) - 1) << k - p;
            d |= this[--i] >> (p += this.DB - k);
          } else {
            d = this[i] >> (p -= k) & km;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if (d > 0)
            m = true;
          if (m)
            r += int2char(d);
        }
      }
      return m ? r : "0";
    }
    function bnNegate() {
      var r = nbi();
      BigInteger.ZERO.subTo(this, r);
      return r;
    }
    function bnAbs() {
      return this.s < 0 ? this.negate() : this;
    }
    function bnCompareTo(a) {
      var r = this.s - a.s;
      if (r != 0)
        return r;
      var i = this.t;
      r = i - a.t;
      if (r != 0)
        return this.s < 0 ? -r : r;
      while (--i >= 0)
        if ((r = this[i] - a[i]) != 0)
          return r;
      return 0;
    }
    function nbits(x) {
      var r = 1, t2;
      if ((t2 = x >>> 16) != 0) {
        x = t2;
        r += 16;
      }
      if ((t2 = x >> 8) != 0) {
        x = t2;
        r += 8;
      }
      if ((t2 = x >> 4) != 0) {
        x = t2;
        r += 4;
      }
      if ((t2 = x >> 2) != 0) {
        x = t2;
        r += 2;
      }
      if ((t2 = x >> 1) != 0) {
        x = t2;
        r += 1;
      }
      return r;
    }
    function bnBitLength() {
      if (this.t <= 0)
        return 0;
      return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
    }
    function bnpDLShiftTo(n, r) {
      var i;
      for (i = this.t - 1;i >= 0; --i)
        r[i + n] = this[i];
      for (i = n - 1;i >= 0; --i)
        r[i] = 0;
      r.t = this.t + n;
      r.s = this.s;
    }
    function bnpDRShiftTo(n, r) {
      for (var i = n;i < this.t; ++i)
        r[i - n] = this[i];
      r.t = Math.max(this.t - n, 0);
      r.s = this.s;
    }
    function bnpLShiftTo(n, r) {
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << cbs) - 1;
      var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
      for (i = this.t - 1;i >= 0; --i) {
        r[i + ds + 1] = this[i] >> cbs | c;
        c = (this[i] & bm) << bs;
      }
      for (i = ds - 1;i >= 0; --i)
        r[i] = 0;
      r[ds] = c;
      r.t = this.t + ds + 1;
      r.s = this.s;
      r.clamp();
    }
    function bnpRShiftTo(n, r) {
      r.s = this.s;
      var ds = Math.floor(n / this.DB);
      if (ds >= this.t) {
        r.t = 0;
        return;
      }
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << bs) - 1;
      r[0] = this[ds] >> bs;
      for (var i = ds + 1;i < this.t; ++i) {
        r[i - ds - 1] |= (this[i] & bm) << cbs;
        r[i - ds] = this[i] >> bs;
      }
      if (bs > 0)
        r[this.t - ds - 1] |= (this.s & bm) << cbs;
      r.t = this.t - ds;
      r.clamp();
    }
    function bnpSubTo(a, r) {
      var i = 0, c = 0, m = Math.min(a.t, this.t);
      while (i < m) {
        c += this[i] - a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c -= a.s;
        while (i < this.t) {
          c += this[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c -= a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c -= a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c < -1)
        r[i++] = this.DV + c;
      else if (c > 0)
        r[i++] = c;
      r.t = i;
      r.clamp();
    }
    function bnpMultiplyTo(a, r) {
      var x = this.abs(), y = a.abs();
      var i = x.t;
      r.t = i + y.t;
      while (--i >= 0)
        r[i] = 0;
      for (i = 0;i < y.t; ++i)
        r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
      r.s = 0;
      r.clamp();
      if (this.s != a.s)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnpSquareTo(r) {
      var x = this.abs();
      var i = r.t = 2 * x.t;
      while (--i >= 0)
        r[i] = 0;
      for (i = 0;i < x.t - 1; ++i) {
        var c = x.am(i, x[i], r, 2 * i, 0, 1);
        if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
          r[i + x.t] -= x.DV;
          r[i + x.t + 1] = 1;
        }
      }
      if (r.t > 0)
        r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
      r.s = 0;
      r.clamp();
    }
    function bnpDivRemTo(m, q2, r) {
      var pm = m.abs();
      if (pm.t <= 0)
        return;
      var pt = this.abs();
      if (pt.t < pm.t) {
        if (q2 != null)
          q2.fromInt(0);
        if (r != null)
          this.copyTo(r);
        return;
      }
      if (r == null)
        r = nbi();
      var y = nbi(), ts = this.s, ms = m.s;
      var nsh = this.DB - nbits(pm[pm.t - 1]);
      if (nsh > 0) {
        pm.lShiftTo(nsh, y);
        pt.lShiftTo(nsh, r);
      } else {
        pm.copyTo(y);
        pt.copyTo(r);
      }
      var ys = y.t;
      var y0 = y[ys - 1];
      if (y0 == 0)
        return;
      var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
      var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
      var i = r.t, j = i - ys, t2 = q2 == null ? nbi() : q2;
      y.dlShiftTo(j, t2);
      if (r.compareTo(t2) >= 0) {
        r[r.t++] = 1;
        r.subTo(t2, r);
      }
      BigInteger.ONE.dlShiftTo(ys, t2);
      t2.subTo(y, y);
      while (y.t < ys)
        y[y.t++] = 0;
      while (--j >= 0) {
        var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
        if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
          y.dlShiftTo(j, t2);
          r.subTo(t2, r);
          while (r[i] < --qd)
            r.subTo(t2, r);
        }
      }
      if (q2 != null) {
        r.drShiftTo(ys, q2);
        if (ts != ms)
          BigInteger.ZERO.subTo(q2, q2);
      }
      r.t = ys;
      r.clamp();
      if (nsh > 0)
        r.rShiftTo(nsh, r);
      if (ts < 0)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnMod(a) {
      var r = nbi();
      this.abs().divRemTo(a, null, r);
      if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        a.subTo(r, r);
      return r;
    }
    function Classic(m) {
      this.m = m;
    }
    function cConvert(x) {
      if (x.s < 0 || x.compareTo(this.m) >= 0)
        return x.mod(this.m);
      else
        return x;
    }
    function cRevert(x) {
      return x;
    }
    function cReduce(x) {
      x.divRemTo(this.m, null, x);
    }
    function cMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    function cSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1)
        return 0;
      var x = this[0];
      if ((x & 1) == 0)
        return 0;
      var y = x & 3;
      y = y * (2 - (x & 15) * y) & 15;
      y = y * (2 - (x & 255) * y) & 255;
      y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
      y = y * (2 - x * y % this.DV) % this.DV;
      return y > 0 ? this.DV - y : -y;
    }
    function Montgomery(m) {
      this.m = m;
      this.mp = m.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << m.DB - 15) - 1;
      this.mt2 = 2 * m.t;
    }
    function montConvert(x) {
      var r = nbi();
      x.abs().dlShiftTo(this.m.t, r);
      r.divRemTo(this.m, null, r);
      if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        this.m.subTo(r, r);
      return r;
    }
    function montRevert(x) {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }
    function montReduce(x) {
      while (x.t <= this.mt2)
        x[x.t++] = 0;
      for (var i = 0;i < this.m.t; ++i) {
        var j = x[i] & 32767;
        var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
        j = i + this.m.t;
        x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
        while (x[j] >= x.DV) {
          x[j] -= x.DV;
          x[++j]++;
        }
      }
      x.clamp();
      x.drShiftTo(this.m.t, x);
      if (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function montSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function montMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return (this.t > 0 ? this[0] & 1 : this.s) == 0;
    }
    function bnpExp(e, z2) {
      if (e > 4294967295 || e < 1)
        return BigInteger.ONE;
      var r = nbi(), r2 = nbi(), g = z2.convert(this), i = nbits(e) - 1;
      g.copyTo(r);
      while (--i >= 0) {
        z2.sqrTo(r, r2);
        if ((e & 1 << i) > 0)
          z2.mulTo(r2, g, r);
        else {
          var t2 = r;
          r = r2;
          r2 = t2;
        }
      }
      return z2.revert(r);
    }
    function bnModPowInt(e, m) {
      var z2;
      if (e < 256 || m.isEven())
        z2 = new Classic(m);
      else
        z2 = new Montgomery(m);
      return this.exp(e, z2);
    }
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    function bnClone() {
      var r = nbi();
      this.copyTo(r);
      return r;
    }
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1)
          return this[0] - this.DV;
        else if (this.t == 0)
          return -1;
      } else if (this.t == 1)
        return this[0];
      else if (this.t == 0)
        return 0;
      return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
    }
    function bnByteValue() {
      return this.t == 0 ? this.s : this[0] << 24 >> 24;
    }
    function bnShortValue() {
      return this.t == 0 ? this.s : this[0] << 16 >> 16;
    }
    function bnpChunkSize(r) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r));
    }
    function bnSigNum() {
      if (this.s < 0)
        return -1;
      else if (this.t <= 0 || this.t == 1 && this[0] <= 0)
        return 0;
      else
        return 1;
    }
    function bnpToRadix(b) {
      if (b == null)
        b = 10;
      if (this.signum() == 0 || b < 2 || b > 36)
        return "0";
      var cs = this.chunkSize(b);
      var a = Math.pow(b, cs);
      var d = nbv(a), y = nbi(), z2 = nbi(), r = "";
      this.divRemTo(d, y, z2);
      while (y.signum() > 0) {
        r = (a + z2.intValue()).toString(b).substr(1) + r;
        y.divRemTo(d, y, z2);
      }
      return z2.intValue().toString(b) + r;
    }
    function bnpFromRadix(s, b) {
      this.fromInt(0);
      if (b == null)
        b = 10;
      var cs = this.chunkSize(b);
      var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
      for (var i = 0;i < s.length; ++i) {
        var x = intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-" && this.signum() == 0)
            mi = true;
          continue;
        }
        w = b * w + x;
        if (++j >= cs) {
          this.dMultiply(d);
          this.dAddOffset(w, 0);
          j = 0;
          w = 0;
        }
      }
      if (j > 0) {
        this.dMultiply(Math.pow(b, j));
        this.dAddOffset(w, 0);
      }
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpFromNumber(a, b, c) {
      if (typeof b == "number") {
        if (a < 2)
          this.fromInt(1);
        else {
          this.fromNumber(a, c);
          if (!this.testBit(a - 1))
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
          if (this.isEven())
            this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a)
              this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
          }
        }
      } else {
        var x = new Array, t2 = a & 7;
        x.length = (a >> 3) + 1;
        b.nextBytes(x);
        if (t2 > 0)
          x[0] &= (1 << t2) - 1;
        else
          x[0] = 0;
        this.fromString(x, 256);
      }
    }
    function bnToByteArray() {
      var i = this.t, r = new Array;
      r[0] = this.s;
      var p = this.DB - i * this.DB % 8, d, k = 0;
      if (i-- > 0) {
        if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
          r[k++] = d | this.s << this.DB - p;
        while (i >= 0) {
          if (p < 8) {
            d = (this[i] & (1 << p) - 1) << 8 - p;
            d |= this[--i] >> (p += this.DB - 8);
          } else {
            d = this[i] >> (p -= 8) & 255;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if ((d & 128) != 0)
            d |= -256;
          if (k == 0 && (this.s & 128) != (d & 128))
            ++k;
          if (k > 0 || d != this.s)
            r[k++] = d;
        }
      }
      return r;
    }
    function bnEquals(a) {
      return this.compareTo(a) == 0;
    }
    function bnMin(a) {
      return this.compareTo(a) < 0 ? this : a;
    }
    function bnMax(a) {
      return this.compareTo(a) > 0 ? this : a;
    }
    function bnpBitwiseTo(a, op, r) {
      var i, f, m = Math.min(a.t, this.t);
      for (i = 0;i < m; ++i)
        r[i] = op(this[i], a[i]);
      if (a.t < this.t) {
        f = a.s & this.DM;
        for (i = m;i < this.t; ++i)
          r[i] = op(this[i], f);
        r.t = this.t;
      } else {
        f = this.s & this.DM;
        for (i = m;i < a.t; ++i)
          r[i] = op(f, a[i]);
        r.t = a.t;
      }
      r.s = op(this.s, a.s);
      r.clamp();
    }
    function op_and(x, y) {
      return x & y;
    }
    function bnAnd(a) {
      var r = nbi();
      this.bitwiseTo(a, op_and, r);
      return r;
    }
    function op_or(x, y) {
      return x | y;
    }
    function bnOr(a) {
      var r = nbi();
      this.bitwiseTo(a, op_or, r);
      return r;
    }
    function op_xor(x, y) {
      return x ^ y;
    }
    function bnXor(a) {
      var r = nbi();
      this.bitwiseTo(a, op_xor, r);
      return r;
    }
    function op_andnot(x, y) {
      return x & ~y;
    }
    function bnAndNot(a) {
      var r = nbi();
      this.bitwiseTo(a, op_andnot, r);
      return r;
    }
    function bnNot() {
      var r = nbi();
      for (var i = 0;i < this.t; ++i)
        r[i] = this.DM & ~this[i];
      r.t = this.t;
      r.s = ~this.s;
      return r;
    }
    function bnShiftLeft(n) {
      var r = nbi();
      if (n < 0)
        this.rShiftTo(-n, r);
      else
        this.lShiftTo(n, r);
      return r;
    }
    function bnShiftRight(n) {
      var r = nbi();
      if (n < 0)
        this.lShiftTo(-n, r);
      else
        this.rShiftTo(n, r);
      return r;
    }
    function lbit(x) {
      if (x == 0)
        return -1;
      var r = 0;
      if ((x & 65535) == 0) {
        x >>= 16;
        r += 16;
      }
      if ((x & 255) == 0) {
        x >>= 8;
        r += 8;
      }
      if ((x & 15) == 0) {
        x >>= 4;
        r += 4;
      }
      if ((x & 3) == 0) {
        x >>= 2;
        r += 2;
      }
      if ((x & 1) == 0)
        ++r;
      return r;
    }
    function bnGetLowestSetBit() {
      for (var i = 0;i < this.t; ++i)
        if (this[i] != 0)
          return i * this.DB + lbit(this[i]);
      if (this.s < 0)
        return this.t * this.DB;
      return -1;
    }
    function cbit(x) {
      var r = 0;
      while (x != 0) {
        x &= x - 1;
        ++r;
      }
      return r;
    }
    function bnBitCount() {
      var r = 0, x = this.s & this.DM;
      for (var i = 0;i < this.t; ++i)
        r += cbit(this[i] ^ x);
      return r;
    }
    function bnTestBit(n) {
      var j = Math.floor(n / this.DB);
      if (j >= this.t)
        return this.s != 0;
      return (this[j] & 1 << n % this.DB) != 0;
    }
    function bnpChangeBit(n, op) {
      var r = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r, op, r);
      return r;
    }
    function bnSetBit(n) {
      return this.changeBit(n, op_or);
    }
    function bnClearBit(n) {
      return this.changeBit(n, op_andnot);
    }
    function bnFlipBit(n) {
      return this.changeBit(n, op_xor);
    }
    function bnpAddTo(a, r) {
      var i = 0, c = 0, m = Math.min(a.t, this.t);
      while (i < m) {
        c += this[i] + a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c += a.s;
        while (i < this.t) {
          c += this[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c += a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c > 0)
        r[i++] = c;
      else if (c < -1)
        r[i++] = this.DV + c;
      r.t = i;
      r.clamp();
    }
    function bnAdd(a) {
      var r = nbi();
      this.addTo(a, r);
      return r;
    }
    function bnSubtract(a) {
      var r = nbi();
      this.subTo(a, r);
      return r;
    }
    function bnMultiply(a) {
      var r = nbi();
      this.multiplyTo(a, r);
      return r;
    }
    function bnSquare() {
      var r = nbi();
      this.squareTo(r);
      return r;
    }
    function bnDivide(a) {
      var r = nbi();
      this.divRemTo(a, r, null);
      return r;
    }
    function bnRemainder(a) {
      var r = nbi();
      this.divRemTo(a, null, r);
      return r;
    }
    function bnDivideAndRemainder(a) {
      var q2 = nbi(), r = nbi();
      this.divRemTo(a, q2, r);
      return new Array(q2, r);
    }
    function bnpDMultiply(n) {
      this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(n, w) {
      if (n == 0)
        return;
      while (this.t <= w)
        this[this.t++] = 0;
      this[w] += n;
      while (this[w] >= this.DV) {
        this[w] -= this.DV;
        if (++w >= this.t)
          this[this.t++] = 0;
        ++this[w];
      }
    }
    function NullExp() {}
    function nNop(x) {
      return x;
    }
    function nMulTo(x, y, r) {
      x.multiplyTo(y, r);
    }
    function nSqrTo(x, r) {
      x.squareTo(r);
    }
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e) {
      return this.exp(e, new NullExp);
    }
    function bnpMultiplyLowerTo(a, n, r) {
      var i = Math.min(this.t + a.t, n);
      r.s = 0;
      r.t = i;
      while (i > 0)
        r[--i] = 0;
      var j;
      for (j = r.t - this.t;i < j; ++i)
        r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
      for (j = Math.min(a.t, n);i < j; ++i)
        this.am(0, a[i], r, i, 0, n - i);
      r.clamp();
    }
    function bnpMultiplyUpperTo(a, n, r) {
      --n;
      var i = r.t = this.t + a.t - n;
      r.s = 0;
      while (--i >= 0)
        r[i] = 0;
      for (i = Math.max(n - this.t, 0);i < a.t; ++i)
        r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
      r.clamp();
      r.drShiftTo(1, r);
    }
    function Barrett(m) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
      this.mu = this.r2.divide(m);
      this.m = m;
    }
    function barrettConvert(x) {
      if (x.s < 0 || x.t > 2 * this.m.t)
        return x.mod(this.m);
      else if (x.compareTo(this.m) < 0)
        return x;
      else {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
    }
    function barrettRevert(x) {
      return x;
    }
    function barrettReduce(x) {
      x.drShiftTo(this.m.t - 1, this.r2);
      if (x.t > this.m.t + 1) {
        x.t = this.m.t + 1;
        x.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x.compareTo(this.r2) < 0)
        x.dAddOffset(1, this.m.t + 1);
      x.subTo(this.r2, x);
      while (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function barrettSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function barrettMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e, m) {
      var i = e.bitLength(), k, r = nbv(1), z2;
      if (i <= 0)
        return r;
      else if (i < 18)
        k = 1;
      else if (i < 48)
        k = 3;
      else if (i < 144)
        k = 4;
      else if (i < 768)
        k = 5;
      else
        k = 6;
      if (i < 8)
        z2 = new Classic(m);
      else if (m.isEven())
        z2 = new Barrett(m);
      else
        z2 = new Montgomery(m);
      var g = new Array, n = 3, k1 = k - 1, km = (1 << k) - 1;
      g[1] = z2.convert(this);
      if (k > 1) {
        var g2 = nbi();
        z2.sqrTo(g[1], g2);
        while (n <= km) {
          g[n] = nbi();
          z2.mulTo(g2, g[n - 2], g[n]);
          n += 2;
        }
      }
      var j = e.t - 1, w, is1 = true, r2 = nbi(), t2;
      i = nbits(e[j]) - 1;
      while (j >= 0) {
        if (i >= k1)
          w = e[j] >> i - k1 & km;
        else {
          w = (e[j] & (1 << i + 1) - 1) << k1 - i;
          if (j > 0)
            w |= e[j - 1] >> this.DB + i - k1;
        }
        n = k;
        while ((w & 1) == 0) {
          w >>= 1;
          --n;
        }
        if ((i -= n) < 0) {
          i += this.DB;
          --j;
        }
        if (is1) {
          g[w].copyTo(r);
          is1 = false;
        } else {
          while (n > 1) {
            z2.sqrTo(r, r2);
            z2.sqrTo(r2, r);
            n -= 2;
          }
          if (n > 0)
            z2.sqrTo(r, r2);
          else {
            t2 = r;
            r = r2;
            r2 = t2;
          }
          z2.mulTo(r2, g[w], r);
        }
        while (j >= 0 && (e[j] & 1 << i) == 0) {
          z2.sqrTo(r, r2);
          t2 = r;
          r = r2;
          r2 = t2;
          if (--i < 0) {
            i = this.DB - 1;
            --j;
          }
        }
      }
      return z2.revert(r);
    }
    function bnGCD(a) {
      var x = this.s < 0 ? this.negate() : this.clone();
      var y = a.s < 0 ? a.negate() : a.clone();
      if (x.compareTo(y) < 0) {
        var t2 = x;
        x = y;
        y = t2;
      }
      var i = x.getLowestSetBit(), g = y.getLowestSetBit();
      if (g < 0)
        return x;
      if (i < g)
        g = i;
      if (g > 0) {
        x.rShiftTo(g, x);
        y.rShiftTo(g, y);
      }
      while (x.signum() > 0) {
        if ((i = x.getLowestSetBit()) > 0)
          x.rShiftTo(i, x);
        if ((i = y.getLowestSetBit()) > 0)
          y.rShiftTo(i, y);
        if (x.compareTo(y) >= 0) {
          x.subTo(y, x);
          x.rShiftTo(1, x);
        } else {
          y.subTo(x, y);
          y.rShiftTo(1, y);
        }
      }
      if (g > 0)
        y.lShiftTo(g, y);
      return y;
    }
    function bnpModInt(n) {
      if (n <= 0)
        return 0;
      var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
      if (this.t > 0)
        if (d == 0)
          r = this[0] % n;
        else
          for (var i = this.t - 1;i >= 0; --i)
            r = (d * r + this[i]) % n;
      return r;
    }
    function bnModInverse(m) {
      var ac = m.isEven();
      if (this.isEven() && ac || m.signum() == 0)
        return BigInteger.ZERO;
      var u = m.clone(), v = this.clone();
      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
      while (u.signum() != 0) {
        while (u.isEven()) {
          u.rShiftTo(1, u);
          if (ac) {
            if (!a.isEven() || !b.isEven()) {
              a.addTo(this, a);
              b.subTo(m, b);
            }
            a.rShiftTo(1, a);
          } else if (!b.isEven())
            b.subTo(m, b);
          b.rShiftTo(1, b);
        }
        while (v.isEven()) {
          v.rShiftTo(1, v);
          if (ac) {
            if (!c.isEven() || !d.isEven()) {
              c.addTo(this, c);
              d.subTo(m, d);
            }
            c.rShiftTo(1, c);
          } else if (!d.isEven())
            d.subTo(m, d);
          d.rShiftTo(1, d);
        }
        if (u.compareTo(v) >= 0) {
          u.subTo(v, u);
          if (ac)
            a.subTo(c, a);
          b.subTo(d, b);
        } else {
          v.subTo(u, v);
          if (ac)
            c.subTo(a, c);
          d.subTo(b, d);
        }
      }
      if (v.compareTo(BigInteger.ONE) != 0)
        return BigInteger.ZERO;
      if (d.compareTo(m) >= 0)
        return d.subtract(m);
      if (d.signum() < 0)
        d.addTo(m, d);
      else
        return d;
      if (d.signum() < 0)
        return d.add(m);
      else
        return d;
    }
    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t2) {
      var i, x = this.abs();
      if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
        for (i = 0;i < lowprimes.length; ++i)
          if (x[0] == lowprimes[i])
            return true;
        return false;
      }
      if (x.isEven())
        return false;
      i = 1;
      while (i < lowprimes.length) {
        var m = lowprimes[i], j = i + 1;
        while (j < lowprimes.length && m < lplim)
          m *= lowprimes[j++];
        m = x.modInt(m);
        while (i < j)
          if (m % lowprimes[i++] == 0)
            return false;
      }
      return x.millerRabin(t2);
    }
    function bnpMillerRabin(t2) {
      var n1 = this.subtract(BigInteger.ONE);
      var k = n1.getLowestSetBit();
      if (k <= 0)
        return false;
      var r = n1.shiftRight(k);
      t2 = t2 + 1 >> 1;
      if (t2 > lowprimes.length)
        t2 = lowprimes.length;
      var a = nbi();
      for (var i = 0;i < t2; ++i) {
        a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
        var y = a.modPow(r, this);
        if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
          var j = 1;
          while (j++ < k && y.compareTo(n1) != 0) {
            y = y.modPowInt(2, this);
            if (y.compareTo(BigInteger.ONE) == 0)
              return false;
          }
          if (y.compareTo(n1) != 0)
            return false;
        }
      }
      return true;
    }
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
    BigInteger.prototype.square = bnSquare;
    BigInteger.prototype.Barrett = Barrett;
    var rng_state;
    var rng_pool;
    var rng_pptr;
    function rng_seed_int(x) {
      rng_pool[rng_pptr++] ^= x & 255;
      rng_pool[rng_pptr++] ^= x >> 8 & 255;
      rng_pool[rng_pptr++] ^= x >> 16 & 255;
      rng_pool[rng_pptr++] ^= x >> 24 & 255;
      if (rng_pptr >= rng_psize)
        rng_pptr -= rng_psize;
    }
    function rng_seed_time() {
      rng_seed_int(new Date().getTime());
    }
    if (rng_pool == null) {
      rng_pool = new Array;
      rng_pptr = 0;
      var t;
      if (typeof window !== "undefined" && window.crypto) {
        if (window.crypto.getRandomValues) {
          var ua = new Uint8Array(32);
          window.crypto.getRandomValues(ua);
          for (t = 0;t < 32; ++t)
            rng_pool[rng_pptr++] = ua[t];
        } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
          var z = window.crypto.random(32);
          for (t = 0;t < z.length; ++t)
            rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
        }
      }
      while (rng_pptr < rng_psize) {
        t = Math.floor(65536 * Math.random());
        rng_pool[rng_pptr++] = t >>> 8;
        rng_pool[rng_pptr++] = t & 255;
      }
      rng_pptr = 0;
      rng_seed_time();
    }
    function rng_get_byte() {
      if (rng_state == null) {
        rng_seed_time();
        rng_state = prng_newstate();
        rng_state.init(rng_pool);
        for (rng_pptr = 0;rng_pptr < rng_pool.length; ++rng_pptr)
          rng_pool[rng_pptr] = 0;
        rng_pptr = 0;
      }
      return rng_state.next();
    }
    function rng_get_bytes(ba) {
      var i;
      for (i = 0;i < ba.length; ++i)
        ba[i] = rng_get_byte();
    }
    function SecureRandom2() {}
    SecureRandom2.prototype.nextBytes = rng_get_bytes;
    function Arcfour() {
      this.i = 0;
      this.j = 0;
      this.S = new Array;
    }
    function ARC4init(key) {
      var i, j, t2;
      for (i = 0;i < 256; ++i)
        this.S[i] = i;
      j = 0;
      for (i = 0;i < 256; ++i) {
        j = j + this.S[i] + key[i % key.length] & 255;
        t2 = this.S[i];
        this.S[i] = this.S[j];
        this.S[j] = t2;
      }
      this.i = 0;
      this.j = 0;
    }
    function ARC4next() {
      var t2;
      this.i = this.i + 1 & 255;
      this.j = this.j + this.S[this.i] & 255;
      t2 = this.S[this.i];
      this.S[this.i] = this.S[this.j];
      this.S[this.j] = t2;
      return this.S[t2 + this.S[this.i] & 255];
    }
    Arcfour.prototype.init = ARC4init;
    Arcfour.prototype.next = ARC4next;
    function prng_newstate() {
      return new Arcfour;
    }
    var rng_psize = 256;
    BigInteger.SecureRandom = SecureRandom2;
    BigInteger.BigInteger = BigInteger;
    if (typeof exports2 !== "undefined") {
      exports2 = module2.exports = BigInteger;
    } else {
      this.BigInteger = BigInteger;
      this.SecureRandom = SecureRandom2;
    }
  }).call(exports2);
});

// backend/node_modules/ecc-jsbn/lib/ec.js
var require_ec = __commonJS((exports2, module2) => {
  var BigInteger = require_jsbn().BigInteger;
  var Barrett = BigInteger.prototype.Barrett;
  function ECFieldElementFp(q2, x) {
    this.x = x;
    this.q = q2;
  }
  function feFpEquals(other) {
    if (other == this)
      return true;
    return this.q.equals(other.q) && this.x.equals(other.x);
  }
  function feFpToBigInteger() {
    return this.x;
  }
  function feFpNegate() {
    return new ECFieldElementFp(this.q, this.x.negate().mod(this.q));
  }
  function feFpAdd(b) {
    return new ECFieldElementFp(this.q, this.x.add(b.toBigInteger()).mod(this.q));
  }
  function feFpSubtract(b) {
    return new ECFieldElementFp(this.q, this.x.subtract(b.toBigInteger()).mod(this.q));
  }
  function feFpMultiply(b) {
    return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger()).mod(this.q));
  }
  function feFpSquare() {
    return new ECFieldElementFp(this.q, this.x.square().mod(this.q));
  }
  function feFpDivide(b) {
    return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger().modInverse(this.q)).mod(this.q));
  }
  ECFieldElementFp.prototype.equals = feFpEquals;
  ECFieldElementFp.prototype.toBigInteger = feFpToBigInteger;
  ECFieldElementFp.prototype.negate = feFpNegate;
  ECFieldElementFp.prototype.add = feFpAdd;
  ECFieldElementFp.prototype.subtract = feFpSubtract;
  ECFieldElementFp.prototype.multiply = feFpMultiply;
  ECFieldElementFp.prototype.square = feFpSquare;
  ECFieldElementFp.prototype.divide = feFpDivide;
  function ECPointFp(curve, x, y, z) {
    this.curve = curve;
    this.x = x;
    this.y = y;
    if (z == null) {
      this.z = BigInteger.ONE;
    } else {
      this.z = z;
    }
    this.zinv = null;
  }
  function pointFpGetX() {
    if (this.zinv == null) {
      this.zinv = this.z.modInverse(this.curve.q);
    }
    var r = this.x.toBigInteger().multiply(this.zinv);
    this.curve.reduce(r);
    return this.curve.fromBigInteger(r);
  }
  function pointFpGetY() {
    if (this.zinv == null) {
      this.zinv = this.z.modInverse(this.curve.q);
    }
    var r = this.y.toBigInteger().multiply(this.zinv);
    this.curve.reduce(r);
    return this.curve.fromBigInteger(r);
  }
  function pointFpEquals(other) {
    if (other == this)
      return true;
    if (this.isInfinity())
      return other.isInfinity();
    if (other.isInfinity())
      return this.isInfinity();
    var u, v;
    u = other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.q);
    if (!u.equals(BigInteger.ZERO))
      return false;
    v = other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.q);
    return v.equals(BigInteger.ZERO);
  }
  function pointFpIsInfinity() {
    if (this.x == null && this.y == null)
      return true;
    return this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO);
  }
  function pointFpNegate() {
    return new ECPointFp(this.curve, this.x, this.y.negate(), this.z);
  }
  function pointFpAdd(b) {
    if (this.isInfinity())
      return b;
    if (b.isInfinity())
      return this;
    var u = b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.q);
    var v = b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.q);
    if (BigInteger.ZERO.equals(v)) {
      if (BigInteger.ZERO.equals(u)) {
        return this.twice();
      }
      return this.curve.getInfinity();
    }
    var THREE = new BigInteger("3");
    var x1 = this.x.toBigInteger();
    var y1 = this.y.toBigInteger();
    var x2 = b.x.toBigInteger();
    var y2 = b.y.toBigInteger();
    var v2 = v.square();
    var v3 = v2.multiply(v);
    var x1v2 = x1.multiply(v2);
    var zu2 = u.square().multiply(this.z);
    var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.q);
    var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.q);
    var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.q);
    return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
  }
  function pointFpTwice() {
    if (this.isInfinity())
      return this;
    if (this.y.toBigInteger().signum() == 0)
      return this.curve.getInfinity();
    var THREE = new BigInteger("3");
    var x1 = this.x.toBigInteger();
    var y1 = this.y.toBigInteger();
    var y1z1 = y1.multiply(this.z);
    var y1sqz1 = y1z1.multiply(y1).mod(this.curve.q);
    var a = this.curve.a.toBigInteger();
    var w = x1.square().multiply(THREE);
    if (!BigInteger.ZERO.equals(a)) {
      w = w.add(this.z.square().multiply(a));
    }
    w = w.mod(this.curve.q);
    var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.q);
    var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.square().multiply(w)).mod(this.curve.q);
    var z3 = y1z1.square().multiply(y1z1).shiftLeft(3).mod(this.curve.q);
    return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
  }
  function pointFpMultiply(k) {
    if (this.isInfinity())
      return this;
    if (k.signum() == 0)
      return this.curve.getInfinity();
    var e = k;
    var h = e.multiply(new BigInteger("3"));
    var neg = this.negate();
    var R = this;
    var i;
    for (i = h.bitLength() - 2;i > 0; --i) {
      R = R.twice();
      var hBit = h.testBit(i);
      var eBit = e.testBit(i);
      if (hBit != eBit) {
        R = R.add(hBit ? this : neg);
      }
    }
    return R;
  }
  function pointFpMultiplyTwo(j, x, k) {
    var i;
    if (j.bitLength() > k.bitLength())
      i = j.bitLength() - 1;
    else
      i = k.bitLength() - 1;
    var R = this.curve.getInfinity();
    var both = this.add(x);
    while (i >= 0) {
      R = R.twice();
      if (j.testBit(i)) {
        if (k.testBit(i)) {
          R = R.add(both);
        } else {
          R = R.add(this);
        }
      } else {
        if (k.testBit(i)) {
          R = R.add(x);
        }
      }
      --i;
    }
    return R;
  }
  ECPointFp.prototype.getX = pointFpGetX;
  ECPointFp.prototype.getY = pointFpGetY;
  ECPointFp.prototype.equals = pointFpEquals;
  ECPointFp.prototype.isInfinity = pointFpIsInfinity;
  ECPointFp.prototype.negate = pointFpNegate;
  ECPointFp.prototype.add = pointFpAdd;
  ECPointFp.prototype.twice = pointFpTwice;
  ECPointFp.prototype.multiply = pointFpMultiply;
  ECPointFp.prototype.multiplyTwo = pointFpMultiplyTwo;
  function ECCurveFp(q2, a, b) {
    this.q = q2;
    this.a = this.fromBigInteger(a);
    this.b = this.fromBigInteger(b);
    this.infinity = new ECPointFp(this, null, null);
    this.reducer = new Barrett(this.q);
  }
  function curveFpGetQ() {
    return this.q;
  }
  function curveFpGetA() {
    return this.a;
  }
  function curveFpGetB() {
    return this.b;
  }
  function curveFpEquals(other) {
    if (other == this)
      return true;
    return this.q.equals(other.q) && this.a.equals(other.a) && this.b.equals(other.b);
  }
  function curveFpGetInfinity() {
    return this.infinity;
  }
  function curveFpFromBigInteger(x) {
    return new ECFieldElementFp(this.q, x);
  }
  function curveReduce(x) {
    this.reducer.reduce(x);
  }
  function curveFpEncodePointHex(p) {
    if (p.isInfinity())
      return "00";
    var xHex = p.getX().toBigInteger().toString(16);
    var yHex = p.getY().toBigInteger().toString(16);
    var oLen = this.getQ().toString(16).length;
    if (oLen % 2 != 0)
      oLen++;
    while (xHex.length < oLen) {
      xHex = "0" + xHex;
    }
    while (yHex.length < oLen) {
      yHex = "0" + yHex;
    }
    return "04" + xHex + yHex;
  }
  ECCurveFp.prototype.getQ = curveFpGetQ;
  ECCurveFp.prototype.getA = curveFpGetA;
  ECCurveFp.prototype.getB = curveFpGetB;
  ECCurveFp.prototype.equals = curveFpEquals;
  ECCurveFp.prototype.getInfinity = curveFpGetInfinity;
  ECCurveFp.prototype.fromBigInteger = curveFpFromBigInteger;
  ECCurveFp.prototype.reduce = curveReduce;
  ECCurveFp.prototype.encodePointHex = curveFpEncodePointHex;
  ECCurveFp.prototype.decodePointHex = function(s) {
    var yIsEven;
    switch (parseInt(s.substr(0, 2), 16)) {
      case 0:
        return this.infinity;
      case 2:
        yIsEven = false;
      case 3:
        if (yIsEven == undefined)
          yIsEven = true;
        var len = s.length - 2;
        var xHex = s.substr(2, len);
        var x = this.fromBigInteger(new BigInteger(xHex, 16));
        var alpha = x.multiply(x.square().add(this.getA())).add(this.getB());
        var beta = alpha.sqrt();
        if (beta == null)
          throw "Invalid point compression";
        var betaValue = beta.toBigInteger();
        if (betaValue.testBit(0) != yIsEven) {
          beta = this.fromBigInteger(this.getQ().subtract(betaValue));
        }
        return new ECPointFp(this, x, beta);
      case 4:
      case 6:
      case 7:
        var len = (s.length - 2) / 2;
        var xHex = s.substr(2, len);
        var yHex = s.substr(len + 2, len);
        return new ECPointFp(this, this.fromBigInteger(new BigInteger(xHex, 16)), this.fromBigInteger(new BigInteger(yHex, 16)));
      default:
        return null;
    }
  };
  ECCurveFp.prototype.encodeCompressedPointHex = function(p) {
    if (p.isInfinity())
      return "00";
    var xHex = p.getX().toBigInteger().toString(16);
    var oLen = this.getQ().toString(16).length;
    if (oLen % 2 != 0)
      oLen++;
    while (xHex.length < oLen)
      xHex = "0" + xHex;
    var yPrefix;
    if (p.getY().toBigInteger().isEven())
      yPrefix = "02";
    else
      yPrefix = "03";
    return yPrefix + xHex;
  };
  ECFieldElementFp.prototype.getR = function() {
    if (this.r != null)
      return this.r;
    this.r = null;
    var bitLength = this.q.bitLength();
    if (bitLength > 128) {
      var firstWord = this.q.shiftRight(bitLength - 64);
      if (firstWord.intValue() == -1) {
        this.r = BigInteger.ONE.shiftLeft(bitLength).subtract(this.q);
      }
    }
    return this.r;
  };
  ECFieldElementFp.prototype.modMult = function(x1, x2) {
    return this.modReduce(x1.multiply(x2));
  };
  ECFieldElementFp.prototype.modReduce = function(x) {
    if (this.getR() != null) {
      var qLen = q.bitLength();
      while (x.bitLength() > qLen + 1) {
        var u = x.shiftRight(qLen);
        var v = x.subtract(u.shiftLeft(qLen));
        if (!this.getR().equals(BigInteger.ONE)) {
          u = u.multiply(this.getR());
        }
        x = u.add(v);
      }
      while (x.compareTo(q) >= 0) {
        x = x.subtract(q);
      }
    } else {
      x = x.mod(q);
    }
    return x;
  };
  ECFieldElementFp.prototype.sqrt = function() {
    if (!this.q.testBit(0))
      throw "unsupported";
    if (this.q.testBit(1)) {
      var z = new ECFieldElementFp(this.q, this.x.modPow(this.q.shiftRight(2).add(BigInteger.ONE), this.q));
      return z.square().equals(this) ? z : null;
    }
    var qMinusOne = this.q.subtract(BigInteger.ONE);
    var legendreExponent = qMinusOne.shiftRight(1);
    if (!this.x.modPow(legendreExponent, this.q).equals(BigInteger.ONE)) {
      return null;
    }
    var u = qMinusOne.shiftRight(2);
    var k = u.shiftLeft(1).add(BigInteger.ONE);
    var Q = this.x;
    var fourQ = modDouble(modDouble(Q));
    var U, V;
    do {
      var P;
      do {
        P = new BigInteger(this.q.bitLength(), new SecureRandom);
      } while (P.compareTo(this.q) >= 0 || !P.multiply(P).subtract(fourQ).modPow(legendreExponent, this.q).equals(qMinusOne));
      var result = this.lucasSequence(P, Q, k);
      U = result[0];
      V = result[1];
      if (this.modMult(V, V).equals(fourQ)) {
        if (V.testBit(0)) {
          V = V.add(q);
        }
        V = V.shiftRight(1);
        return new ECFieldElementFp(q, V);
      }
    } while (U.equals(BigInteger.ONE) || U.equals(qMinusOne));
    return null;
  };
  ECFieldElementFp.prototype.lucasSequence = function(P, Q, k) {
    var n = k.bitLength();
    var s = k.getLowestSetBit();
    var Uh = BigInteger.ONE;
    var Vl = BigInteger.TWO;
    var Vh = P;
    var Ql = BigInteger.ONE;
    var Qh = BigInteger.ONE;
    for (var j = n - 1;j >= s + 1; --j) {
      Ql = this.modMult(Ql, Qh);
      if (k.testBit(j)) {
        Qh = this.modMult(Ql, Q);
        Uh = this.modMult(Uh, Vh);
        Vl = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
        Vh = this.modReduce(Vh.multiply(Vh).subtract(Qh.shiftLeft(1)));
      } else {
        Qh = Ql;
        Uh = this.modReduce(Uh.multiply(Vl).subtract(Ql));
        Vh = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
        Vl = this.modReduce(Vl.multiply(Vl).subtract(Ql.shiftLeft(1)));
      }
    }
    Ql = this.modMult(Ql, Qh);
    Qh = this.modMult(Ql, Q);
    Uh = this.modReduce(Uh.multiply(Vl).subtract(Ql));
    Vl = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
    Ql = this.modMult(Ql, Qh);
    for (var j = 1;j <= s; ++j) {
      Uh = this.modMult(Uh, Vl);
      Vl = this.modReduce(Vl.multiply(Vl).subtract(Ql.shiftLeft(1)));
      Ql = this.modMult(Ql, Ql);
    }
    return [Uh, Vl];
  };
  var exports2 = {
    ECCurveFp,
    ECPointFp,
    ECFieldElementFp
  };
  module2.exports = exports2;
});

// backend/node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS((exports2, module2) => {
  (function(nacl) {
    var gf = function(init) {
      var i, r = new Float64Array(16);
      if (init)
        for (i = 0;i < init.length; i++)
          r[i] = init[i];
      return r;
    };
    var randombytes = function() {
      throw new Error("no PRNG");
    };
    var _0 = new Uint8Array(16);
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function ts64(x, i, h, l) {
      x[i] = h >> 24 & 255;
      x[i + 1] = h >> 16 & 255;
      x[i + 2] = h >> 8 & 255;
      x[i + 3] = h & 255;
      x[i + 4] = l >> 24 & 255;
      x[i + 5] = l >> 16 & 255;
      x[i + 6] = l >> 8 & 255;
      x[i + 7] = l & 255;
    }
    function vn(x, xi, y, yi, n) {
      var i, d = 0;
      for (i = 0;i < n; i++)
        d |= x[xi + i] ^ y[yi + i];
      return (1 & d - 1 >>> 8) - 1;
    }
    function crypto_verify_16(x, xi, y, yi) {
      return vn(x, xi, y, yi, 16);
    }
    function crypto_verify_32(x, xi, y, yi) {
      return vn(x, xi, y, yi, 32);
    }
    function core_salsa20(o, p, k, c) {
      var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
      for (var i = 0;i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> 32 - 7;
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> 32 - 13;
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 32 - 7;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 32 - 13;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 32 - 7;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 32 - 13;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 32 - 7;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 32 - 13;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> 32 - 7;
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 32 - 13;
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> 32 - 7;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> 32 - 13;
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 32 - 7;
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> 32 - 13;
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 32 - 7;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 32 - 13;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
      }
      x0 = x0 + j0 | 0;
      x1 = x1 + j1 | 0;
      x2 = x2 + j2 | 0;
      x3 = x3 + j3 | 0;
      x4 = x4 + j4 | 0;
      x5 = x5 + j5 | 0;
      x6 = x6 + j6 | 0;
      x7 = x7 + j7 | 0;
      x8 = x8 + j8 | 0;
      x9 = x9 + j9 | 0;
      x10 = x10 + j10 | 0;
      x11 = x11 + j11 | 0;
      x12 = x12 + j12 | 0;
      x13 = x13 + j13 | 0;
      x14 = x14 + j14 | 0;
      x15 = x15 + j15 | 0;
      o[0] = x0 >>> 0 & 255;
      o[1] = x0 >>> 8 & 255;
      o[2] = x0 >>> 16 & 255;
      o[3] = x0 >>> 24 & 255;
      o[4] = x1 >>> 0 & 255;
      o[5] = x1 >>> 8 & 255;
      o[6] = x1 >>> 16 & 255;
      o[7] = x1 >>> 24 & 255;
      o[8] = x2 >>> 0 & 255;
      o[9] = x2 >>> 8 & 255;
      o[10] = x2 >>> 16 & 255;
      o[11] = x2 >>> 24 & 255;
      o[12] = x3 >>> 0 & 255;
      o[13] = x3 >>> 8 & 255;
      o[14] = x3 >>> 16 & 255;
      o[15] = x3 >>> 24 & 255;
      o[16] = x4 >>> 0 & 255;
      o[17] = x4 >>> 8 & 255;
      o[18] = x4 >>> 16 & 255;
      o[19] = x4 >>> 24 & 255;
      o[20] = x5 >>> 0 & 255;
      o[21] = x5 >>> 8 & 255;
      o[22] = x5 >>> 16 & 255;
      o[23] = x5 >>> 24 & 255;
      o[24] = x6 >>> 0 & 255;
      o[25] = x6 >>> 8 & 255;
      o[26] = x6 >>> 16 & 255;
      o[27] = x6 >>> 24 & 255;
      o[28] = x7 >>> 0 & 255;
      o[29] = x7 >>> 8 & 255;
      o[30] = x7 >>> 16 & 255;
      o[31] = x7 >>> 24 & 255;
      o[32] = x8 >>> 0 & 255;
      o[33] = x8 >>> 8 & 255;
      o[34] = x8 >>> 16 & 255;
      o[35] = x8 >>> 24 & 255;
      o[36] = x9 >>> 0 & 255;
      o[37] = x9 >>> 8 & 255;
      o[38] = x9 >>> 16 & 255;
      o[39] = x9 >>> 24 & 255;
      o[40] = x10 >>> 0 & 255;
      o[41] = x10 >>> 8 & 255;
      o[42] = x10 >>> 16 & 255;
      o[43] = x10 >>> 24 & 255;
      o[44] = x11 >>> 0 & 255;
      o[45] = x11 >>> 8 & 255;
      o[46] = x11 >>> 16 & 255;
      o[47] = x11 >>> 24 & 255;
      o[48] = x12 >>> 0 & 255;
      o[49] = x12 >>> 8 & 255;
      o[50] = x12 >>> 16 & 255;
      o[51] = x12 >>> 24 & 255;
      o[52] = x13 >>> 0 & 255;
      o[53] = x13 >>> 8 & 255;
      o[54] = x13 >>> 16 & 255;
      o[55] = x13 >>> 24 & 255;
      o[56] = x14 >>> 0 & 255;
      o[57] = x14 >>> 8 & 255;
      o[58] = x14 >>> 16 & 255;
      o[59] = x14 >>> 24 & 255;
      o[60] = x15 >>> 0 & 255;
      o[61] = x15 >>> 8 & 255;
      o[62] = x15 >>> 16 & 255;
      o[63] = x15 >>> 24 & 255;
    }
    function core_hsalsa20(o, p, k, c) {
      var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
      for (var i = 0;i < 20; i += 2) {
        u = x0 + x12 | 0;
        x4 ^= u << 7 | u >>> 32 - 7;
        u = x4 + x0 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x4 | 0;
        x12 ^= u << 13 | u >>> 32 - 13;
        u = x12 + x8 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x1 | 0;
        x9 ^= u << 7 | u >>> 32 - 7;
        u = x9 + x5 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x9 | 0;
        x1 ^= u << 13 | u >>> 32 - 13;
        u = x1 + x13 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x6 | 0;
        x14 ^= u << 7 | u >>> 32 - 7;
        u = x14 + x10 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x14 | 0;
        x6 ^= u << 13 | u >>> 32 - 13;
        u = x6 + x2 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x11 | 0;
        x3 ^= u << 7 | u >>> 32 - 7;
        u = x3 + x15 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x3 | 0;
        x11 ^= u << 13 | u >>> 32 - 13;
        u = x11 + x7 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
        u = x0 + x3 | 0;
        x1 ^= u << 7 | u >>> 32 - 7;
        u = x1 + x0 | 0;
        x2 ^= u << 9 | u >>> 32 - 9;
        u = x2 + x1 | 0;
        x3 ^= u << 13 | u >>> 32 - 13;
        u = x3 + x2 | 0;
        x0 ^= u << 18 | u >>> 32 - 18;
        u = x5 + x4 | 0;
        x6 ^= u << 7 | u >>> 32 - 7;
        u = x6 + x5 | 0;
        x7 ^= u << 9 | u >>> 32 - 9;
        u = x7 + x6 | 0;
        x4 ^= u << 13 | u >>> 32 - 13;
        u = x4 + x7 | 0;
        x5 ^= u << 18 | u >>> 32 - 18;
        u = x10 + x9 | 0;
        x11 ^= u << 7 | u >>> 32 - 7;
        u = x11 + x10 | 0;
        x8 ^= u << 9 | u >>> 32 - 9;
        u = x8 + x11 | 0;
        x9 ^= u << 13 | u >>> 32 - 13;
        u = x9 + x8 | 0;
        x10 ^= u << 18 | u >>> 32 - 18;
        u = x15 + x14 | 0;
        x12 ^= u << 7 | u >>> 32 - 7;
        u = x12 + x15 | 0;
        x13 ^= u << 9 | u >>> 32 - 9;
        u = x13 + x12 | 0;
        x14 ^= u << 13 | u >>> 32 - 13;
        u = x14 + x13 | 0;
        x15 ^= u << 18 | u >>> 32 - 18;
      }
      o[0] = x0 >>> 0 & 255;
      o[1] = x0 >>> 8 & 255;
      o[2] = x0 >>> 16 & 255;
      o[3] = x0 >>> 24 & 255;
      o[4] = x5 >>> 0 & 255;
      o[5] = x5 >>> 8 & 255;
      o[6] = x5 >>> 16 & 255;
      o[7] = x5 >>> 24 & 255;
      o[8] = x10 >>> 0 & 255;
      o[9] = x10 >>> 8 & 255;
      o[10] = x10 >>> 16 & 255;
      o[11] = x10 >>> 24 & 255;
      o[12] = x15 >>> 0 & 255;
      o[13] = x15 >>> 8 & 255;
      o[14] = x15 >>> 16 & 255;
      o[15] = x15 >>> 24 & 255;
      o[16] = x6 >>> 0 & 255;
      o[17] = x6 >>> 8 & 255;
      o[18] = x6 >>> 16 & 255;
      o[19] = x6 >>> 24 & 255;
      o[20] = x7 >>> 0 & 255;
      o[21] = x7 >>> 8 & 255;
      o[22] = x7 >>> 16 & 255;
      o[23] = x7 >>> 24 & 255;
      o[24] = x8 >>> 0 & 255;
      o[25] = x8 >>> 8 & 255;
      o[26] = x8 >>> 16 & 255;
      o[27] = x8 >>> 24 & 255;
      o[28] = x9 >>> 0 & 255;
      o[29] = x9 >>> 8 & 255;
      o[30] = x9 >>> 16 & 255;
      o[31] = x9 >>> 24 & 255;
    }
    function crypto_core_salsa20(out, inp, k, c) {
      core_salsa20(out, inp, k, c);
    }
    function crypto_core_hsalsa20(out, inp, k, c) {
      core_hsalsa20(out, inp, k, c);
    }
    var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
      var z = new Uint8Array(16), x = new Uint8Array(64);
      var u, i;
      for (i = 0;i < 16; i++)
        z[i] = 0;
      for (i = 0;i < 8; i++)
        z[i] = n[i];
      while (b >= 64) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0;i < 64; i++)
          c[cpos + i] = m[mpos + i] ^ x[i];
        u = 1;
        for (i = 8;i < 16; i++) {
          u = u + (z[i] & 255) | 0;
          z[i] = u & 255;
          u >>>= 8;
        }
        b -= 64;
        cpos += 64;
        mpos += 64;
      }
      if (b > 0) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0;i < b; i++)
          c[cpos + i] = m[mpos + i] ^ x[i];
      }
      return 0;
    }
    function crypto_stream_salsa20(c, cpos, b, n, k) {
      var z = new Uint8Array(16), x = new Uint8Array(64);
      var u, i;
      for (i = 0;i < 16; i++)
        z[i] = 0;
      for (i = 0;i < 8; i++)
        z[i] = n[i];
      while (b >= 64) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0;i < 64; i++)
          c[cpos + i] = x[i];
        u = 1;
        for (i = 8;i < 16; i++) {
          u = u + (z[i] & 255) | 0;
          z[i] = u & 255;
          u >>>= 8;
        }
        b -= 64;
        cpos += 64;
      }
      if (b > 0) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0;i < b; i++)
          c[cpos + i] = x[i];
      }
      return 0;
    }
    function crypto_stream(c, cpos, d, n, k) {
      var s = new Uint8Array(32);
      crypto_core_hsalsa20(s, n, k, sigma);
      var sn = new Uint8Array(8);
      for (var i = 0;i < 8; i++)
        sn[i] = n[i + 16];
      return crypto_stream_salsa20(c, cpos, d, sn, s);
    }
    function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
      var s = new Uint8Array(32);
      crypto_core_hsalsa20(s, n, k, sigma);
      var sn = new Uint8Array(8);
      for (var i = 0;i < 8; i++)
        sn[i] = n[i + 16];
      return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
    }
    var poly1305 = function(key) {
      this.buffer = new Uint8Array(16);
      this.r = new Uint16Array(10);
      this.h = new Uint16Array(10);
      this.pad = new Uint16Array(8);
      this.leftover = 0;
      this.fin = 0;
      var t0, t1, t2, t3, t4, t5, t6, t7;
      t0 = key[0] & 255 | (key[1] & 255) << 8;
      this.r[0] = t0 & 8191;
      t1 = key[2] & 255 | (key[3] & 255) << 8;
      this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
      t2 = key[4] & 255 | (key[5] & 255) << 8;
      this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
      t3 = key[6] & 255 | (key[7] & 255) << 8;
      this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
      t4 = key[8] & 255 | (key[9] & 255) << 8;
      this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
      this.r[5] = t4 >>> 1 & 8190;
      t5 = key[10] & 255 | (key[11] & 255) << 8;
      this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
      t6 = key[12] & 255 | (key[13] & 255) << 8;
      this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
      t7 = key[14] & 255 | (key[15] & 255) << 8;
      this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
      this.r[9] = t7 >>> 5 & 127;
      this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
      this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
      this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
      this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
      this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
      this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
      this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
      this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
    };
    poly1305.prototype.blocks = function(m, mpos, bytes) {
      var hibit = this.fin ? 0 : 1 << 11;
      var t0, t1, t2, t3, t4, t5, t6, t7, c;
      var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
      var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
      var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
      while (bytes >= 16) {
        t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
        h0 += t0 & 8191;
        t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
        h1 += (t0 >>> 13 | t1 << 3) & 8191;
        t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
        h2 += (t1 >>> 10 | t2 << 6) & 8191;
        t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
        h3 += (t2 >>> 7 | t3 << 9) & 8191;
        t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
        h4 += (t3 >>> 4 | t4 << 12) & 8191;
        h5 += t4 >>> 1 & 8191;
        t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
        h6 += (t4 >>> 14 | t5 << 2) & 8191;
        t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
        h7 += (t5 >>> 11 | t6 << 5) & 8191;
        t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
        h8 += (t6 >>> 8 | t7 << 8) & 8191;
        h9 += t7 >>> 5 | hibit;
        c = 0;
        d0 = c;
        d0 += h0 * r0;
        d0 += h1 * (5 * r9);
        d0 += h2 * (5 * r8);
        d0 += h3 * (5 * r7);
        d0 += h4 * (5 * r6);
        c = d0 >>> 13;
        d0 &= 8191;
        d0 += h5 * (5 * r5);
        d0 += h6 * (5 * r4);
        d0 += h7 * (5 * r3);
        d0 += h8 * (5 * r2);
        d0 += h9 * (5 * r1);
        c += d0 >>> 13;
        d0 &= 8191;
        d1 = c;
        d1 += h0 * r1;
        d1 += h1 * r0;
        d1 += h2 * (5 * r9);
        d1 += h3 * (5 * r8);
        d1 += h4 * (5 * r7);
        c = d1 >>> 13;
        d1 &= 8191;
        d1 += h5 * (5 * r6);
        d1 += h6 * (5 * r5);
        d1 += h7 * (5 * r4);
        d1 += h8 * (5 * r3);
        d1 += h9 * (5 * r2);
        c += d1 >>> 13;
        d1 &= 8191;
        d2 = c;
        d2 += h0 * r2;
        d2 += h1 * r1;
        d2 += h2 * r0;
        d2 += h3 * (5 * r9);
        d2 += h4 * (5 * r8);
        c = d2 >>> 13;
        d2 &= 8191;
        d2 += h5 * (5 * r7);
        d2 += h6 * (5 * r6);
        d2 += h7 * (5 * r5);
        d2 += h8 * (5 * r4);
        d2 += h9 * (5 * r3);
        c += d2 >>> 13;
        d2 &= 8191;
        d3 = c;
        d3 += h0 * r3;
        d3 += h1 * r2;
        d3 += h2 * r1;
        d3 += h3 * r0;
        d3 += h4 * (5 * r9);
        c = d3 >>> 13;
        d3 &= 8191;
        d3 += h5 * (5 * r8);
        d3 += h6 * (5 * r7);
        d3 += h7 * (5 * r6);
        d3 += h8 * (5 * r5);
        d3 += h9 * (5 * r4);
        c += d3 >>> 13;
        d3 &= 8191;
        d4 = c;
        d4 += h0 * r4;
        d4 += h1 * r3;
        d4 += h2 * r2;
        d4 += h3 * r1;
        d4 += h4 * r0;
        c = d4 >>> 13;
        d4 &= 8191;
        d4 += h5 * (5 * r9);
        d4 += h6 * (5 * r8);
        d4 += h7 * (5 * r7);
        d4 += h8 * (5 * r6);
        d4 += h9 * (5 * r5);
        c += d4 >>> 13;
        d4 &= 8191;
        d5 = c;
        d5 += h0 * r5;
        d5 += h1 * r4;
        d5 += h2 * r3;
        d5 += h3 * r2;
        d5 += h4 * r1;
        c = d5 >>> 13;
        d5 &= 8191;
        d5 += h5 * r0;
        d5 += h6 * (5 * r9);
        d5 += h7 * (5 * r8);
        d5 += h8 * (5 * r7);
        d5 += h9 * (5 * r6);
        c += d5 >>> 13;
        d5 &= 8191;
        d6 = c;
        d6 += h0 * r6;
        d6 += h1 * r5;
        d6 += h2 * r4;
        d6 += h3 * r3;
        d6 += h4 * r2;
        c = d6 >>> 13;
        d6 &= 8191;
        d6 += h5 * r1;
        d6 += h6 * r0;
        d6 += h7 * (5 * r9);
        d6 += h8 * (5 * r8);
        d6 += h9 * (5 * r7);
        c += d6 >>> 13;
        d6 &= 8191;
        d7 = c;
        d7 += h0 * r7;
        d7 += h1 * r6;
        d7 += h2 * r5;
        d7 += h3 * r4;
        d7 += h4 * r3;
        c = d7 >>> 13;
        d7 &= 8191;
        d7 += h5 * r2;
        d7 += h6 * r1;
        d7 += h7 * r0;
        d7 += h8 * (5 * r9);
        d7 += h9 * (5 * r8);
        c += d7 >>> 13;
        d7 &= 8191;
        d8 = c;
        d8 += h0 * r8;
        d8 += h1 * r7;
        d8 += h2 * r6;
        d8 += h3 * r5;
        d8 += h4 * r4;
        c = d8 >>> 13;
        d8 &= 8191;
        d8 += h5 * r3;
        d8 += h6 * r2;
        d8 += h7 * r1;
        d8 += h8 * r0;
        d8 += h9 * (5 * r9);
        c += d8 >>> 13;
        d8 &= 8191;
        d9 = c;
        d9 += h0 * r9;
        d9 += h1 * r8;
        d9 += h2 * r7;
        d9 += h3 * r6;
        d9 += h4 * r5;
        c = d9 >>> 13;
        d9 &= 8191;
        d9 += h5 * r4;
        d9 += h6 * r3;
        d9 += h7 * r2;
        d9 += h8 * r1;
        d9 += h9 * r0;
        c += d9 >>> 13;
        d9 &= 8191;
        c = (c << 2) + c | 0;
        c = c + d0 | 0;
        d0 = c & 8191;
        c = c >>> 13;
        d1 += c;
        h0 = d0;
        h1 = d1;
        h2 = d2;
        h3 = d3;
        h4 = d4;
        h5 = d5;
        h6 = d6;
        h7 = d7;
        h8 = d8;
        h9 = d9;
        mpos += 16;
        bytes -= 16;
      }
      this.h[0] = h0;
      this.h[1] = h1;
      this.h[2] = h2;
      this.h[3] = h3;
      this.h[4] = h4;
      this.h[5] = h5;
      this.h[6] = h6;
      this.h[7] = h7;
      this.h[8] = h8;
      this.h[9] = h9;
    };
    poly1305.prototype.finish = function(mac, macpos) {
      var g = new Uint16Array(10);
      var c, mask, f, i;
      if (this.leftover) {
        i = this.leftover;
        this.buffer[i++] = 1;
        for (;i < 16; i++)
          this.buffer[i] = 0;
        this.fin = 1;
        this.blocks(this.buffer, 0, 16);
      }
      c = this.h[1] >>> 13;
      this.h[1] &= 8191;
      for (i = 2;i < 10; i++) {
        this.h[i] += c;
        c = this.h[i] >>> 13;
        this.h[i] &= 8191;
      }
      this.h[0] += c * 5;
      c = this.h[0] >>> 13;
      this.h[0] &= 8191;
      this.h[1] += c;
      c = this.h[1] >>> 13;
      this.h[1] &= 8191;
      this.h[2] += c;
      g[0] = this.h[0] + 5;
      c = g[0] >>> 13;
      g[0] &= 8191;
      for (i = 1;i < 10; i++) {
        g[i] = this.h[i] + c;
        c = g[i] >>> 13;
        g[i] &= 8191;
      }
      g[9] -= 1 << 13;
      mask = (c ^ 1) - 1;
      for (i = 0;i < 10; i++)
        g[i] &= mask;
      mask = ~mask;
      for (i = 0;i < 10; i++)
        this.h[i] = this.h[i] & mask | g[i];
      this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
      this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
      this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
      this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
      this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
      this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
      this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
      this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
      f = this.h[0] + this.pad[0];
      this.h[0] = f & 65535;
      for (i = 1;i < 8; i++) {
        f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
        this.h[i] = f & 65535;
      }
      mac[macpos + 0] = this.h[0] >>> 0 & 255;
      mac[macpos + 1] = this.h[0] >>> 8 & 255;
      mac[macpos + 2] = this.h[1] >>> 0 & 255;
      mac[macpos + 3] = this.h[1] >>> 8 & 255;
      mac[macpos + 4] = this.h[2] >>> 0 & 255;
      mac[macpos + 5] = this.h[2] >>> 8 & 255;
      mac[macpos + 6] = this.h[3] >>> 0 & 255;
      mac[macpos + 7] = this.h[3] >>> 8 & 255;
      mac[macpos + 8] = this.h[4] >>> 0 & 255;
      mac[macpos + 9] = this.h[4] >>> 8 & 255;
      mac[macpos + 10] = this.h[5] >>> 0 & 255;
      mac[macpos + 11] = this.h[5] >>> 8 & 255;
      mac[macpos + 12] = this.h[6] >>> 0 & 255;
      mac[macpos + 13] = this.h[6] >>> 8 & 255;
      mac[macpos + 14] = this.h[7] >>> 0 & 255;
      mac[macpos + 15] = this.h[7] >>> 8 & 255;
    };
    poly1305.prototype.update = function(m, mpos, bytes) {
      var i, want;
      if (this.leftover) {
        want = 16 - this.leftover;
        if (want > bytes)
          want = bytes;
        for (i = 0;i < want; i++)
          this.buffer[this.leftover + i] = m[mpos + i];
        bytes -= want;
        mpos += want;
        this.leftover += want;
        if (this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16);
        this.leftover = 0;
      }
      if (bytes >= 16) {
        want = bytes - bytes % 16;
        this.blocks(m, mpos, want);
        mpos += want;
        bytes -= want;
      }
      if (bytes) {
        for (i = 0;i < bytes; i++)
          this.buffer[this.leftover + i] = m[mpos + i];
        this.leftover += bytes;
      }
    };
    function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
      var s = new poly1305(k);
      s.update(m, mpos, n);
      s.finish(out, outpos);
      return 0;
    }
    function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
      var x = new Uint8Array(16);
      crypto_onetimeauth(x, 0, m, mpos, n, k);
      return crypto_verify_16(h, hpos, x, 0);
    }
    function crypto_secretbox(c, m, d, n, k) {
      var i;
      if (d < 32)
        return -1;
      crypto_stream_xor(c, 0, m, 0, d, n, k);
      crypto_onetimeauth(c, 16, c, 32, d - 32, c);
      for (i = 0;i < 16; i++)
        c[i] = 0;
      return 0;
    }
    function crypto_secretbox_open(m, c, d, n, k) {
      var i;
      var x = new Uint8Array(32);
      if (d < 32)
        return -1;
      crypto_stream(x, 0, 32, n, k);
      if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
        return -1;
      crypto_stream_xor(m, 0, c, 0, d, n, k);
      for (i = 0;i < 32; i++)
        m[i] = 0;
      return 0;
    }
    function set25519(r, a) {
      var i;
      for (i = 0;i < 16; i++)
        r[i] = a[i] | 0;
    }
    function car25519(o) {
      var i, v, c = 1;
      for (i = 0;i < 16; i++) {
        v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
      }
      o[0] += c - 1 + 37 * (c - 1);
    }
    function sel25519(p, q2, b) {
      var t, c = ~(b - 1);
      for (var i = 0;i < 16; i++) {
        t = c & (p[i] ^ q2[i]);
        p[i] ^= t;
        q2[i] ^= t;
      }
    }
    function pack25519(o, n) {
      var i, j, b;
      var m = gf(), t = gf();
      for (i = 0;i < 16; i++)
        t[i] = n[i];
      car25519(t);
      car25519(t);
      car25519(t);
      for (j = 0;j < 2; j++) {
        m[0] = t[0] - 65517;
        for (i = 1;i < 15; i++) {
          m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
          m[i - 1] &= 65535;
        }
        m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
        b = m[15] >> 16 & 1;
        m[14] &= 65535;
        sel25519(t, m, 1 - b);
      }
      for (i = 0;i < 16; i++) {
        o[2 * i] = t[i] & 255;
        o[2 * i + 1] = t[i] >> 8;
      }
    }
    function neq25519(a, b) {
      var c = new Uint8Array(32), d = new Uint8Array(32);
      pack25519(c, a);
      pack25519(d, b);
      return crypto_verify_32(c, 0, d, 0);
    }
    function par25519(a) {
      var d = new Uint8Array(32);
      pack25519(d, a);
      return d[0] & 1;
    }
    function unpack25519(o, n) {
      var i;
      for (i = 0;i < 16; i++)
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
      o[15] &= 32767;
    }
    function A(o, a, b) {
      for (var i = 0;i < 16; i++)
        o[i] = a[i] + b[i];
    }
    function Z(o, a, b) {
      for (var i = 0;i < 16; i++)
        o[i] = a[i] - b[i];
    }
    function M(o, a, b) {
      var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    function S(o, a) {
      M(o, a, a);
    }
    function inv25519(o, i) {
      var c = gf();
      var a;
      for (a = 0;a < 16; a++)
        c[a] = i[a];
      for (a = 253;a >= 0; a--) {
        S(c, c);
        if (a !== 2 && a !== 4)
          M(c, c, i);
      }
      for (a = 0;a < 16; a++)
        o[a] = c[a];
    }
    function pow2523(o, i) {
      var c = gf();
      var a;
      for (a = 0;a < 16; a++)
        c[a] = i[a];
      for (a = 250;a >= 0; a--) {
        S(c, c);
        if (a !== 1)
          M(c, c, i);
      }
      for (a = 0;a < 16; a++)
        o[a] = c[a];
    }
    function crypto_scalarmult(q2, n, p) {
      var z = new Uint8Array(32);
      var x = new Float64Array(80), r, i;
      var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
      for (i = 0;i < 31; i++)
        z[i] = n[i];
      z[31] = n[31] & 127 | 64;
      z[0] &= 248;
      unpack25519(x, p);
      for (i = 0;i < 16; i++) {
        b[i] = x[i];
        d[i] = a[i] = c[i] = 0;
      }
      a[0] = d[0] = 1;
      for (i = 254;i >= 0; --i) {
        r = z[i >>> 3] >>> (i & 7) & 1;
        sel25519(a, b, r);
        sel25519(c, d, r);
        A(e, a, c);
        Z(a, a, c);
        A(c, b, d);
        Z(b, b, d);
        S(d, e);
        S(f, a);
        M(a, c, a);
        M(c, b, e);
        A(e, a, c);
        Z(a, a, c);
        S(b, a);
        Z(c, d, f);
        M(a, c, _121665);
        A(a, a, d);
        M(c, c, a);
        M(a, d, f);
        M(d, b, x);
        S(b, e);
        sel25519(a, b, r);
        sel25519(c, d, r);
      }
      for (i = 0;i < 16; i++) {
        x[i + 16] = a[i];
        x[i + 32] = c[i];
        x[i + 48] = b[i];
        x[i + 64] = d[i];
      }
      var x32 = x.subarray(32);
      var x16 = x.subarray(16);
      inv25519(x32, x32);
      M(x16, x16, x32);
      pack25519(q2, x16);
      return 0;
    }
    function crypto_scalarmult_base(q2, n) {
      return crypto_scalarmult(q2, n, _9);
    }
    function crypto_box_keypair(y, x) {
      randombytes(x, 32);
      return crypto_scalarmult_base(y, x);
    }
    function crypto_box_beforenm(k, y, x) {
      var s = new Uint8Array(32);
      crypto_scalarmult(s, x, y);
      return crypto_core_hsalsa20(k, _0, s, sigma);
    }
    var crypto_box_afternm = crypto_secretbox;
    var crypto_box_open_afternm = crypto_secretbox_open;
    function crypto_box(c, m, d, n, y, x) {
      var k = new Uint8Array(32);
      crypto_box_beforenm(k, y, x);
      return crypto_box_afternm(c, m, d, n, k);
    }
    function crypto_box_open(m, c, d, n, y, x) {
      var k = new Uint8Array(32);
      crypto_box_beforenm(k, y, x);
      return crypto_box_open_afternm(m, c, d, n, k);
    }
    var K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function crypto_hashblocks_hl(hh, hl, m, n) {
      var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
      var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
      var pos = 0;
      while (n >= 128) {
        for (i = 0;i < 16; i++) {
          j = 8 * i + pos;
          wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
          wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
        }
        for (i = 0;i < 80; i++) {
          bh0 = ah0;
          bh1 = ah1;
          bh2 = ah2;
          bh3 = ah3;
          bh4 = ah4;
          bh5 = ah5;
          bh6 = ah6;
          bh7 = ah7;
          bl0 = al0;
          bl1 = al1;
          bl2 = al2;
          bl3 = al3;
          bl4 = al4;
          bl5 = al5;
          bl6 = al6;
          bl7 = al7;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = ah4 & ah5 ^ ~ah4 & ah6;
          l = al4 & al5 ^ ~al4 & al6;
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = K[i * 2];
          l = K[i * 2 + 1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = wh[i % 16];
          l = wl[i % 16];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          th = c & 65535 | d << 16;
          tl = a & 65535 | b << 16;
          h = th;
          l = tl;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          bh7 = c & 65535 | d << 16;
          bl7 = a & 65535 | b << 16;
          h = bh3;
          l = bl3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = th;
          l = tl;
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          bh3 = c & 65535 | d << 16;
          bl3 = a & 65535 | b << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i % 16 === 15) {
            for (j = 0;j < 16; j++) {
              h = wh[j];
              l = wl[j];
              a = l & 65535;
              b = l >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = wh[(j + 9) % 16];
              l = wl[(j + 9) % 16];
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              th = wh[(j + 1) % 16];
              tl = wl[(j + 1) % 16];
              h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
              l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              th = wh[(j + 14) % 16];
              tl = wl[(j + 14) % 16];
              h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
              l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              wh[j] = c & 65535 | d << 16;
              wl[j] = a & 65535 | b << 16;
            }
          }
        }
        h = ah0;
        l = al0;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[0];
        l = hl[0];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[0] = ah0 = c & 65535 | d << 16;
        hl[0] = al0 = a & 65535 | b << 16;
        h = ah1;
        l = al1;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[1];
        l = hl[1];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[1] = ah1 = c & 65535 | d << 16;
        hl[1] = al1 = a & 65535 | b << 16;
        h = ah2;
        l = al2;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[2];
        l = hl[2];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[2] = ah2 = c & 65535 | d << 16;
        hl[2] = al2 = a & 65535 | b << 16;
        h = ah3;
        l = al3;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[3];
        l = hl[3];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[3] = ah3 = c & 65535 | d << 16;
        hl[3] = al3 = a & 65535 | b << 16;
        h = ah4;
        l = al4;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[4];
        l = hl[4];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[4] = ah4 = c & 65535 | d << 16;
        hl[4] = al4 = a & 65535 | b << 16;
        h = ah5;
        l = al5;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[5];
        l = hl[5];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[5] = ah5 = c & 65535 | d << 16;
        hl[5] = al5 = a & 65535 | b << 16;
        h = ah6;
        l = al6;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[6];
        l = hl[6];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[6] = ah6 = c & 65535 | d << 16;
        hl[6] = al6 = a & 65535 | b << 16;
        h = ah7;
        l = al7;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[7];
        l = hl[7];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[7] = ah7 = c & 65535 | d << 16;
        hl[7] = al7 = a & 65535 | b << 16;
        pos += 128;
        n -= 128;
      }
      return n;
    }
    function crypto_hash(out, m, n) {
      var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
      hh[0] = 1779033703;
      hh[1] = 3144134277;
      hh[2] = 1013904242;
      hh[3] = 2773480762;
      hh[4] = 1359893119;
      hh[5] = 2600822924;
      hh[6] = 528734635;
      hh[7] = 1541459225;
      hl[0] = 4089235720;
      hl[1] = 2227873595;
      hl[2] = 4271175723;
      hl[3] = 1595750129;
      hl[4] = 2917565137;
      hl[5] = 725511199;
      hl[6] = 4215389547;
      hl[7] = 327033209;
      crypto_hashblocks_hl(hh, hl, m, n);
      n %= 128;
      for (i = 0;i < n; i++)
        x[i] = m[b - n + i];
      x[n] = 128;
      n = 256 - 128 * (n < 112 ? 1 : 0);
      x[n - 9] = 0;
      ts64(x, n - 8, b / 536870912 | 0, b << 3);
      crypto_hashblocks_hl(hh, hl, x, n);
      for (i = 0;i < 8; i++)
        ts64(out, 8 * i, hh[i], hl[i]);
      return 0;
    }
    function add(p, q2) {
      var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
      Z(a, p[1], p[0]);
      Z(t, q2[1], q2[0]);
      M(a, a, t);
      A(b, p[0], p[1]);
      A(t, q2[0], q2[1]);
      M(b, b, t);
      M(c, p[3], q2[3]);
      M(c, c, D2);
      M(d, p[2], q2[2]);
      A(d, d, d);
      Z(e, b, a);
      Z(f, d, c);
      A(g, d, c);
      A(h, b, a);
      M(p[0], e, f);
      M(p[1], h, g);
      M(p[2], g, f);
      M(p[3], e, h);
    }
    function cswap(p, q2, b) {
      var i;
      for (i = 0;i < 4; i++) {
        sel25519(p[i], q2[i], b);
      }
    }
    function pack(r, p) {
      var tx = gf(), ty = gf(), zi = gf();
      inv25519(zi, p[2]);
      M(tx, p[0], zi);
      M(ty, p[1], zi);
      pack25519(r, ty);
      r[31] ^= par25519(tx) << 7;
    }
    function scalarmult(p, q2, s) {
      var b, i;
      set25519(p[0], gf0);
      set25519(p[1], gf1);
      set25519(p[2], gf1);
      set25519(p[3], gf0);
      for (i = 255;i >= 0; --i) {
        b = s[i / 8 | 0] >> (i & 7) & 1;
        cswap(p, q2, b);
        add(q2, p);
        add(p, p);
        cswap(p, q2, b);
      }
    }
    function scalarbase(p, s) {
      var q2 = [gf(), gf(), gf(), gf()];
      set25519(q2[0], X);
      set25519(q2[1], Y);
      set25519(q2[2], gf1);
      M(q2[3], X, Y);
      scalarmult(p, q2, s);
    }
    function crypto_sign_keypair(pk, sk, seeded) {
      var d = new Uint8Array(64);
      var p = [gf(), gf(), gf(), gf()];
      var i;
      if (!seeded)
        randombytes(sk, 32);
      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      scalarbase(p, d);
      pack(pk, p);
      for (i = 0;i < 32; i++)
        sk[i + 32] = pk[i];
      return 0;
    }
    var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function modL(r, x) {
      var carry, i, j, k;
      for (i = 63;i >= 32; --i) {
        carry = 0;
        for (j = i - 32, k = i - 12;j < k; ++j) {
          x[j] += carry - 16 * x[i] * L[j - (i - 32)];
          carry = x[j] + 128 >> 8;
          x[j] -= carry * 256;
        }
        x[j] += carry;
        x[i] = 0;
      }
      carry = 0;
      for (j = 0;j < 32; j++) {
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
      }
      for (j = 0;j < 32; j++)
        x[j] -= carry * L[j];
      for (i = 0;i < 32; i++) {
        x[i + 1] += x[i] >> 8;
        r[i] = x[i] & 255;
      }
    }
    function reduce(r) {
      var x = new Float64Array(64), i;
      for (i = 0;i < 64; i++)
        x[i] = r[i];
      for (i = 0;i < 64; i++)
        r[i] = 0;
      modL(r, x);
    }
    function crypto_sign(sm, m, n, sk) {
      var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
      var i, j, x = new Float64Array(64);
      var p = [gf(), gf(), gf(), gf()];
      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      var smlen = n + 64;
      for (i = 0;i < n; i++)
        sm[64 + i] = m[i];
      for (i = 0;i < 32; i++)
        sm[32 + i] = d[32 + i];
      crypto_hash(r, sm.subarray(32), n + 32);
      reduce(r);
      scalarbase(p, r);
      pack(sm, p);
      for (i = 32;i < 64; i++)
        sm[i] = sk[i];
      crypto_hash(h, sm, n + 64);
      reduce(h);
      for (i = 0;i < 64; i++)
        x[i] = 0;
      for (i = 0;i < 32; i++)
        x[i] = r[i];
      for (i = 0;i < 32; i++) {
        for (j = 0;j < 32; j++) {
          x[i + j] += h[i] * d[j];
        }
      }
      modL(sm.subarray(32), x);
      return smlen;
    }
    function unpackneg(r, p) {
      var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r[2], gf1);
      unpack25519(r[1], p);
      S(num, r[1]);
      M(den, num, D);
      Z(num, num, r[2]);
      A(den, r[2], den);
      S(den2, den);
      S(den4, den2);
      M(den6, den4, den2);
      M(t, den6, num);
      M(t, t, den);
      pow2523(t, t);
      M(t, t, num);
      M(t, t, den);
      M(t, t, den);
      M(r[0], t, den);
      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num))
        M(r[0], r[0], I);
      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num))
        return -1;
      if (par25519(r[0]) === p[31] >> 7)
        Z(r[0], gf0, r[0]);
      M(r[3], r[0], r[1]);
      return 0;
    }
    function crypto_sign_open(m, sm, n, pk) {
      var i, mlen;
      var t = new Uint8Array(32), h = new Uint8Array(64);
      var p = [gf(), gf(), gf(), gf()], q2 = [gf(), gf(), gf(), gf()];
      mlen = -1;
      if (n < 64)
        return -1;
      if (unpackneg(q2, pk))
        return -1;
      for (i = 0;i < n; i++)
        m[i] = sm[i];
      for (i = 0;i < 32; i++)
        m[i + 32] = pk[i];
      crypto_hash(h, m, n);
      reduce(h);
      scalarmult(p, q2, h);
      scalarbase(q2, sm.subarray(32));
      add(p, q2);
      pack(t, p);
      n -= 64;
      if (crypto_verify_32(sm, 0, t, 0)) {
        for (i = 0;i < n; i++)
          m[i] = 0;
        return -1;
      }
      for (i = 0;i < n; i++)
        m[i] = sm[i + 64];
      mlen = n;
      return mlen;
    }
    var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
    nacl.lowlevel = {
      crypto_core_hsalsa20,
      crypto_stream_xor,
      crypto_stream,
      crypto_stream_salsa20_xor,
      crypto_stream_salsa20,
      crypto_onetimeauth,
      crypto_onetimeauth_verify,
      crypto_verify_16,
      crypto_verify_32,
      crypto_secretbox,
      crypto_secretbox_open,
      crypto_scalarmult,
      crypto_scalarmult_base,
      crypto_box_beforenm,
      crypto_box_afternm,
      crypto_box,
      crypto_box_open,
      crypto_box_keypair,
      crypto_hash,
      crypto_sign,
      crypto_sign_keypair,
      crypto_sign_open,
      crypto_secretbox_KEYBYTES,
      crypto_secretbox_NONCEBYTES,
      crypto_secretbox_ZEROBYTES,
      crypto_secretbox_BOXZEROBYTES,
      crypto_scalarmult_BYTES,
      crypto_scalarmult_SCALARBYTES,
      crypto_box_PUBLICKEYBYTES,
      crypto_box_SECRETKEYBYTES,
      crypto_box_BEFORENMBYTES,
      crypto_box_NONCEBYTES,
      crypto_box_ZEROBYTES,
      crypto_box_BOXZEROBYTES,
      crypto_sign_BYTES,
      crypto_sign_PUBLICKEYBYTES,
      crypto_sign_SECRETKEYBYTES,
      crypto_sign_SEEDBYTES,
      crypto_hash_BYTES
    };
    function checkLengths(k, n) {
      if (k.length !== crypto_secretbox_KEYBYTES)
        throw new Error("bad key size");
      if (n.length !== crypto_secretbox_NONCEBYTES)
        throw new Error("bad nonce size");
    }
    function checkBoxLengths(pk, sk) {
      if (pk.length !== crypto_box_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      if (sk.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
    }
    function checkArrayTypes() {
      var t, i;
      for (i = 0;i < arguments.length; i++) {
        if ((t = Object.prototype.toString.call(arguments[i])) !== "[object Uint8Array]")
          throw new TypeError("unexpected type " + t + ", use Uint8Array");
      }
    }
    function cleanup(arr) {
      for (var i = 0;i < arr.length; i++)
        arr[i] = 0;
    }
    if (!nacl.util) {
      nacl.util = {};
      nacl.util.decodeUTF8 = nacl.util.encodeUTF8 = nacl.util.encodeBase64 = nacl.util.decodeBase64 = function() {
        throw new Error("nacl.util moved into separate package: https://github.com/dchest/tweetnacl-util-js");
      };
    }
    nacl.randomBytes = function(n) {
      var b = new Uint8Array(n);
      randombytes(b, n);
      return b;
    };
    nacl.secretbox = function(msg, nonce, key) {
      checkArrayTypes(msg, nonce, key);
      checkLengths(key, nonce);
      var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
      var c = new Uint8Array(m.length);
      for (var i = 0;i < msg.length; i++)
        m[i + crypto_secretbox_ZEROBYTES] = msg[i];
      crypto_secretbox(c, m, m.length, nonce, key);
      return c.subarray(crypto_secretbox_BOXZEROBYTES);
    };
    nacl.secretbox.open = function(box, nonce, key) {
      checkArrayTypes(box, nonce, key);
      checkLengths(key, nonce);
      var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
      var m = new Uint8Array(c.length);
      for (var i = 0;i < box.length; i++)
        c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
      if (c.length < 32)
        return false;
      if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)
        return false;
      return m.subarray(crypto_secretbox_ZEROBYTES);
    };
    nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
    nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
    nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
    nacl.scalarMult = function(n, p) {
      checkArrayTypes(n, p);
      if (n.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      if (p.length !== crypto_scalarmult_BYTES)
        throw new Error("bad p size");
      var q2 = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult(q2, n, p);
      return q2;
    };
    nacl.scalarMult.base = function(n) {
      checkArrayTypes(n);
      if (n.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      var q2 = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult_base(q2, n);
      return q2;
    };
    nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
    nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
    nacl.box = function(msg, nonce, publicKey, secretKey) {
      var k = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox(msg, nonce, k);
    };
    nacl.box.before = function(publicKey, secretKey) {
      checkArrayTypes(publicKey, secretKey);
      checkBoxLengths(publicKey, secretKey);
      var k = new Uint8Array(crypto_box_BEFORENMBYTES);
      crypto_box_beforenm(k, publicKey, secretKey);
      return k;
    };
    nacl.box.after = nacl.secretbox;
    nacl.box.open = function(msg, nonce, publicKey, secretKey) {
      var k = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox.open(msg, nonce, k);
    };
    nacl.box.open.after = nacl.secretbox.open;
    nacl.box.keyPair = function() {
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
      crypto_box_keypair(pk, sk);
      return { publicKey: pk, secretKey: sk };
    };
    nacl.box.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      crypto_scalarmult_base(pk, secretKey);
      return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
    };
    nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
    nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
    nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
    nacl.box.nonceLength = crypto_box_NONCEBYTES;
    nacl.box.overheadLength = nacl.secretbox.overheadLength;
    nacl.sign = function(msg, secretKey) {
      checkArrayTypes(msg, secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
      crypto_sign(signedMsg, msg, msg.length, secretKey);
      return signedMsg;
    };
    nacl.sign.open = function(signedMsg, publicKey) {
      if (arguments.length !== 2)
        throw new Error("nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?");
      checkArrayTypes(signedMsg, publicKey);
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var tmp = new Uint8Array(signedMsg.length);
      var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
      if (mlen < 0)
        return null;
      var m = new Uint8Array(mlen);
      for (var i = 0;i < m.length; i++)
        m[i] = tmp[i];
      return m;
    };
    nacl.sign.detached = function(msg, secretKey) {
      var signedMsg = nacl.sign(msg, secretKey);
      var sig = new Uint8Array(crypto_sign_BYTES);
      for (var i = 0;i < sig.length; i++)
        sig[i] = signedMsg[i];
      return sig;
    };
    nacl.sign.detached.verify = function(msg, sig, publicKey) {
      checkArrayTypes(msg, sig, publicKey);
      if (sig.length !== crypto_sign_BYTES)
        throw new Error("bad signature size");
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
      var m = new Uint8Array(crypto_sign_BYTES + msg.length);
      var i;
      for (i = 0;i < crypto_sign_BYTES; i++)
        sm[i] = sig[i];
      for (i = 0;i < msg.length; i++)
        sm[i + crypto_sign_BYTES] = msg[i];
      return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
    };
    nacl.sign.keyPair = function() {
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      crypto_sign_keypair(pk, sk);
      return { publicKey: pk, secretKey: sk };
    };
    nacl.sign.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      for (var i = 0;i < pk.length; i++)
        pk[i] = secretKey[32 + i];
      return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
    };
    nacl.sign.keyPair.fromSeed = function(seed) {
      checkArrayTypes(seed);
      if (seed.length !== crypto_sign_SEEDBYTES)
        throw new Error("bad seed size");
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      for (var i = 0;i < 32; i++)
        sk[i] = seed[i];
      crypto_sign_keypair(pk, sk, true);
      return { publicKey: pk, secretKey: sk };
    };
    nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
    nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
    nacl.sign.seedLength = crypto_sign_SEEDBYTES;
    nacl.sign.signatureLength = crypto_sign_BYTES;
    nacl.hash = function(msg) {
      checkArrayTypes(msg);
      var h = new Uint8Array(crypto_hash_BYTES);
      crypto_hash(h, msg, msg.length);
      return h;
    };
    nacl.hash.hashLength = crypto_hash_BYTES;
    nacl.verify = function(x, y) {
      checkArrayTypes(x, y);
      if (x.length === 0 || y.length === 0)
        return false;
      if (x.length !== y.length)
        return false;
      return vn(x, 0, y, 0, x.length) === 0 ? true : false;
    };
    nacl.setPRNG = function(fn) {
      randombytes = fn;
    };
    (function() {
      var crypto3 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
      if (crypto3 && crypto3.getRandomValues) {
        var QUOTA = 65536;
        nacl.setPRNG(function(x, n) {
          var i, v = new Uint8Array(n);
          for (i = 0;i < n; i += QUOTA) {
            crypto3.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
          }
          for (i = 0;i < n; i++)
            x[i] = v[i];
          cleanup(v);
        });
      } else if (true) {
        crypto3 = require("crypto");
        if (crypto3 && crypto3.randomBytes) {
          nacl.setPRNG(function(x, n) {
            var i, v = crypto3.randomBytes(n);
            for (i = 0;i < n; i++)
              x[i] = v[i];
            cleanup(v);
          });
        }
      }
    })();
  })(typeof module2 !== "undefined" && module2.exports ? module2.exports : self.nacl = self.nacl || {});
});

// backend/node_modules/sshpk/lib/utils.js
var require_utils4 = __commonJS((exports2, module2) => {
  module2.exports = {
    bufferSplit,
    addRSAMissing,
    calculateDSAPublic,
    calculateED25519Public,
    calculateX25519Public,
    mpNormalize,
    mpDenormalize,
    ecNormalize,
    countZeros,
    assertCompatible,
    isCompatible,
    opensslKeyDeriv,
    opensshCipherInfo,
    publicFromPrivateECDSA,
    zeroPadToLength,
    writeBitString,
    readBitString,
    pbkdf2
  };
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var PrivateKey = require_private_key();
  var Key = require_key();
  var crypto3 = require("crypto");
  var algs = require_algs();
  var asn1 = require_lib3();
  var ec = require_ec();
  var jsbn = require_jsbn().BigInteger;
  var nacl = require_nacl_fast();
  var MAX_CLASS_DEPTH = 3;
  function isCompatible(obj2, klass, needVer) {
    if (obj2 === null || typeof obj2 !== "object")
      return false;
    if (needVer === undefined)
      needVer = klass.prototype._sshpkApiVersion;
    if (obj2 instanceof klass && klass.prototype._sshpkApiVersion[0] == needVer[0])
      return true;
    var proto = Object.getPrototypeOf(obj2);
    var depth = 0;
    while (proto.constructor.name !== klass.name) {
      proto = Object.getPrototypeOf(proto);
      if (!proto || ++depth > MAX_CLASS_DEPTH)
        return false;
    }
    if (proto.constructor.name !== klass.name)
      return false;
    var ver = proto._sshpkApiVersion;
    if (ver === undefined)
      ver = klass._oldVersionDetect(obj2);
    if (ver[0] != needVer[0] || ver[1] < needVer[1])
      return false;
    return true;
  }
  function assertCompatible(obj2, klass, needVer, name) {
    if (name === undefined)
      name = "object";
    assert.ok(obj2, name + " must not be null");
    assert.object(obj2, name + " must be an object");
    if (needVer === undefined)
      needVer = klass.prototype._sshpkApiVersion;
    if (obj2 instanceof klass && klass.prototype._sshpkApiVersion[0] == needVer[0])
      return;
    var proto = Object.getPrototypeOf(obj2);
    var depth = 0;
    while (proto.constructor.name !== klass.name) {
      proto = Object.getPrototypeOf(proto);
      assert.ok(proto && ++depth <= MAX_CLASS_DEPTH, name + " must be a " + klass.name + " instance");
    }
    assert.strictEqual(proto.constructor.name, klass.name, name + " must be a " + klass.name + " instance");
    var ver = proto._sshpkApiVersion;
    if (ver === undefined)
      ver = klass._oldVersionDetect(obj2);
    assert.ok(ver[0] == needVer[0] && ver[1] >= needVer[1], name + " must be compatible with " + klass.name + " klass " + "version " + needVer[0] + "." + needVer[1]);
  }
  var CIPHER_LEN = {
    "des-ede3-cbc": { key: 24, iv: 8 },
    "aes-128-cbc": { key: 16, iv: 16 },
    "aes-256-cbc": { key: 32, iv: 16 }
  };
  var PKCS5_SALT_LEN = 8;
  function opensslKeyDeriv(cipher, salt, passphrase, count) {
    assert.buffer(salt, "salt");
    assert.buffer(passphrase, "passphrase");
    assert.number(count, "iteration count");
    var clen = CIPHER_LEN[cipher];
    assert.object(clen, "supported cipher");
    salt = salt.slice(0, PKCS5_SALT_LEN);
    var D, D_prev, bufs;
    var material = Buffer2.alloc(0);
    while (material.length < clen.key + clen.iv) {
      bufs = [];
      if (D_prev)
        bufs.push(D_prev);
      bufs.push(passphrase);
      bufs.push(salt);
      D = Buffer2.concat(bufs);
      for (var j = 0;j < count; ++j)
        D = crypto3.createHash("md5").update(D).digest();
      material = Buffer2.concat([material, D]);
      D_prev = D;
    }
    return {
      key: material.slice(0, clen.key),
      iv: material.slice(clen.key, clen.key + clen.iv)
    };
  }
  function pbkdf2(hashAlg, salt, iterations, size, passphrase) {
    var hkey = Buffer2.alloc(salt.length + 4);
    salt.copy(hkey);
    var gen = 0, ts = [];
    var i = 1;
    while (gen < size) {
      var t = T(i++);
      gen += t.length;
      ts.push(t);
    }
    return Buffer2.concat(ts).slice(0, size);
    function T(I) {
      hkey.writeUInt32BE(I, hkey.length - 4);
      var hmac = crypto3.createHmac(hashAlg, passphrase);
      hmac.update(hkey);
      var Ti = hmac.digest();
      var Uc = Ti;
      var c = 1;
      while (c++ < iterations) {
        hmac = crypto3.createHmac(hashAlg, passphrase);
        hmac.update(Uc);
        Uc = hmac.digest();
        for (var x = 0;x < Ti.length; ++x)
          Ti[x] ^= Uc[x];
      }
      return Ti;
    }
  }
  function countZeros(buf) {
    var o = 0, obit = 8;
    while (o < buf.length) {
      var mask = 1 << obit;
      if ((buf[o] & mask) === mask)
        break;
      obit--;
      if (obit < 0) {
        o++;
        obit = 8;
      }
    }
    return o * 8 + (8 - obit) - 1;
  }
  function bufferSplit(buf, chr) {
    assert.buffer(buf);
    assert.string(chr);
    var parts = [];
    var lastPart = 0;
    var matches = 0;
    for (var i = 0;i < buf.length; ++i) {
      if (buf[i] === chr.charCodeAt(matches))
        ++matches;
      else if (buf[i] === chr.charCodeAt(0))
        matches = 1;
      else
        matches = 0;
      if (matches >= chr.length) {
        var newPart = i + 1;
        parts.push(buf.slice(lastPart, newPart - matches));
        lastPart = newPart;
        matches = 0;
      }
    }
    if (lastPart <= buf.length)
      parts.push(buf.slice(lastPart, buf.length));
    return parts;
  }
  function ecNormalize(buf, addZero) {
    assert.buffer(buf);
    if (buf[0] === 0 && buf[1] === 4) {
      if (addZero)
        return buf;
      return buf.slice(1);
    } else if (buf[0] === 4) {
      if (!addZero)
        return buf;
    } else {
      while (buf[0] === 0)
        buf = buf.slice(1);
      if (buf[0] === 2 || buf[0] === 3)
        throw new Error("Compressed elliptic curve points " + "are not supported");
      if (buf[0] !== 4)
        throw new Error("Not a valid elliptic curve point");
      if (!addZero)
        return buf;
    }
    var b = Buffer2.alloc(buf.length + 1);
    b[0] = 0;
    buf.copy(b, 1);
    return b;
  }
  function readBitString(der, tag) {
    if (tag === undefined)
      tag = asn1.Ber.BitString;
    var buf = der.readString(tag, true);
    assert.strictEqual(buf[0], 0, "bit strings with unused bits are " + "not supported (0x" + buf[0].toString(16) + ")");
    return buf.slice(1);
  }
  function writeBitString(der, buf, tag) {
    if (tag === undefined)
      tag = asn1.Ber.BitString;
    var b = Buffer2.alloc(buf.length + 1);
    b[0] = 0;
    buf.copy(b, 1);
    der.writeBuffer(b, tag);
  }
  function mpNormalize(buf) {
    assert.buffer(buf);
    while (buf.length > 1 && buf[0] === 0 && (buf[1] & 128) === 0)
      buf = buf.slice(1);
    if ((buf[0] & 128) === 128) {
      var b = Buffer2.alloc(buf.length + 1);
      b[0] = 0;
      buf.copy(b, 1);
      buf = b;
    }
    return buf;
  }
  function mpDenormalize(buf) {
    assert.buffer(buf);
    while (buf.length > 1 && buf[0] === 0)
      buf = buf.slice(1);
    return buf;
  }
  function zeroPadToLength(buf, len) {
    assert.buffer(buf);
    assert.number(len);
    while (buf.length > len) {
      assert.equal(buf[0], 0);
      buf = buf.slice(1);
    }
    while (buf.length < len) {
      var b = Buffer2.alloc(buf.length + 1);
      b[0] = 0;
      buf.copy(b, 1);
      buf = b;
    }
    return buf;
  }
  function bigintToMpBuf(bigint) {
    var buf = Buffer2.from(bigint.toByteArray());
    buf = mpNormalize(buf);
    return buf;
  }
  function calculateDSAPublic(g, p, x) {
    assert.buffer(g);
    assert.buffer(p);
    assert.buffer(x);
    g = new jsbn(g);
    p = new jsbn(p);
    x = new jsbn(x);
    var y = g.modPow(x, p);
    var ybuf = bigintToMpBuf(y);
    return ybuf;
  }
  function calculateED25519Public(k) {
    assert.buffer(k);
    var kp = nacl.sign.keyPair.fromSeed(new Uint8Array(k));
    return Buffer2.from(kp.publicKey);
  }
  function calculateX25519Public(k) {
    assert.buffer(k);
    var kp = nacl.box.keyPair.fromSeed(new Uint8Array(k));
    return Buffer2.from(kp.publicKey);
  }
  function addRSAMissing(key) {
    assert.object(key);
    assertCompatible(key, PrivateKey, [1, 1]);
    var d = new jsbn(key.part.d.data);
    var buf;
    if (!key.part.dmodp) {
      var p = new jsbn(key.part.p.data);
      var dmodp = d.mod(p.subtract(1));
      buf = bigintToMpBuf(dmodp);
      key.part.dmodp = { name: "dmodp", data: buf };
      key.parts.push(key.part.dmodp);
    }
    if (!key.part.dmodq) {
      var q2 = new jsbn(key.part.q.data);
      var dmodq = d.mod(q2.subtract(1));
      buf = bigintToMpBuf(dmodq);
      key.part.dmodq = { name: "dmodq", data: buf };
      key.parts.push(key.part.dmodq);
    }
  }
  function publicFromPrivateECDSA(curveName, priv) {
    assert.string(curveName, "curveName");
    assert.buffer(priv);
    var params = algs.curves[curveName];
    var p = new jsbn(params.p);
    var a = new jsbn(params.a);
    var b = new jsbn(params.b);
    var curve = new ec.ECCurveFp(p, a, b);
    var G = curve.decodePointHex(params.G.toString("hex"));
    var d = new jsbn(mpNormalize(priv));
    var pub = G.multiply(d);
    pub = Buffer2.from(curve.encodePointHex(pub), "hex");
    var parts = [];
    parts.push({ name: "curve", data: Buffer2.from(curveName) });
    parts.push({ name: "Q", data: pub });
    var key = new Key({ type: "ecdsa", curve, parts });
    return key;
  }
  function opensshCipherInfo(cipher) {
    var inf = {};
    switch (cipher) {
      case "3des-cbc":
        inf.keySize = 24;
        inf.blockSize = 8;
        inf.opensslName = "des-ede3-cbc";
        break;
      case "blowfish-cbc":
        inf.keySize = 16;
        inf.blockSize = 8;
        inf.opensslName = "bf-cbc";
        break;
      case "aes128-cbc":
      case "aes128-ctr":
      case "aes128-gcm@openssh.com":
        inf.keySize = 16;
        inf.blockSize = 16;
        inf.opensslName = "aes-128-" + cipher.slice(7, 10);
        break;
      case "aes192-cbc":
      case "aes192-ctr":
      case "aes192-gcm@openssh.com":
        inf.keySize = 24;
        inf.blockSize = 16;
        inf.opensslName = "aes-192-" + cipher.slice(7, 10);
        break;
      case "aes256-cbc":
      case "aes256-ctr":
      case "aes256-gcm@openssh.com":
        inf.keySize = 32;
        inf.blockSize = 16;
        inf.opensslName = "aes-256-" + cipher.slice(7, 10);
        break;
      default:
        throw new Error('Unsupported openssl cipher "' + cipher + '"');
    }
    return inf;
  }
});

// backend/node_modules/sshpk/lib/ssh-buffer.js
var require_ssh_buffer = __commonJS((exports2, module2) => {
  module2.exports = SSHBuffer;
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  function SSHBuffer(opts) {
    assert.object(opts, "options");
    if (opts.buffer !== undefined)
      assert.buffer(opts.buffer, "options.buffer");
    this._size = opts.buffer ? opts.buffer.length : 1024;
    this._buffer = opts.buffer || Buffer2.alloc(this._size);
    this._offset = 0;
  }
  SSHBuffer.prototype.toBuffer = function() {
    return this._buffer.slice(0, this._offset);
  };
  SSHBuffer.prototype.atEnd = function() {
    return this._offset >= this._buffer.length;
  };
  SSHBuffer.prototype.remainder = function() {
    return this._buffer.slice(this._offset);
  };
  SSHBuffer.prototype.skip = function(n) {
    this._offset += n;
  };
  SSHBuffer.prototype.expand = function() {
    this._size *= 2;
    var buf = Buffer2.alloc(this._size);
    this._buffer.copy(buf, 0);
    this._buffer = buf;
  };
  SSHBuffer.prototype.readPart = function() {
    return { data: this.readBuffer() };
  };
  SSHBuffer.prototype.readBuffer = function() {
    var len = this._buffer.readUInt32BE(this._offset);
    this._offset += 4;
    assert.ok(this._offset + len <= this._buffer.length, "length out of bounds at +0x" + this._offset.toString(16) + " (data truncated?)");
    var buf = this._buffer.slice(this._offset, this._offset + len);
    this._offset += len;
    return buf;
  };
  SSHBuffer.prototype.readString = function() {
    return this.readBuffer().toString();
  };
  SSHBuffer.prototype.readCString = function() {
    var offset = this._offset;
    while (offset < this._buffer.length && this._buffer[offset] !== 0)
      offset++;
    assert.ok(offset < this._buffer.length, "c string does not terminate");
    var str2 = this._buffer.slice(this._offset, offset).toString();
    this._offset = offset + 1;
    return str2;
  };
  SSHBuffer.prototype.readInt = function() {
    var v = this._buffer.readUInt32BE(this._offset);
    this._offset += 4;
    return v;
  };
  SSHBuffer.prototype.readInt64 = function() {
    assert.ok(this._offset + 8 < this._buffer.length, "buffer not long enough to read Int64");
    var v = this._buffer.slice(this._offset, this._offset + 8);
    this._offset += 8;
    return v;
  };
  SSHBuffer.prototype.readChar = function() {
    var v = this._buffer[this._offset++];
    return v;
  };
  SSHBuffer.prototype.writeBuffer = function(buf) {
    while (this._offset + 4 + buf.length > this._size)
      this.expand();
    this._buffer.writeUInt32BE(buf.length, this._offset);
    this._offset += 4;
    buf.copy(this._buffer, this._offset);
    this._offset += buf.length;
  };
  SSHBuffer.prototype.writeString = function(str2) {
    this.writeBuffer(Buffer2.from(str2, "utf8"));
  };
  SSHBuffer.prototype.writeCString = function(str2) {
    while (this._offset + 1 + str2.length > this._size)
      this.expand();
    this._buffer.write(str2, this._offset);
    this._offset += str2.length;
    this._buffer[this._offset++] = 0;
  };
  SSHBuffer.prototype.writeInt = function(v) {
    while (this._offset + 4 > this._size)
      this.expand();
    this._buffer.writeUInt32BE(v, this._offset);
    this._offset += 4;
  };
  SSHBuffer.prototype.writeInt64 = function(v) {
    assert.buffer(v, "value");
    if (v.length > 8) {
      var lead = v.slice(0, v.length - 8);
      for (var i = 0;i < lead.length; ++i) {
        assert.strictEqual(lead[i], 0, "must fit in 64 bits of precision");
      }
      v = v.slice(v.length - 8, v.length);
    }
    while (this._offset + 8 > this._size)
      this.expand();
    v.copy(this._buffer, this._offset);
    this._offset += 8;
  };
  SSHBuffer.prototype.writeChar = function(v) {
    while (this._offset + 1 > this._size)
      this.expand();
    this._buffer[this._offset++] = v;
  };
  SSHBuffer.prototype.writePart = function(p) {
    this.writeBuffer(p.data);
  };
  SSHBuffer.prototype.write = function(buf) {
    while (this._offset + buf.length > this._size)
      this.expand();
    buf.copy(this._buffer, this._offset);
    this._offset += buf.length;
  };
});

// backend/node_modules/sshpk/lib/signature.js
var require_signature = __commonJS((exports2, module2) => {
  module2.exports = Signature;
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var crypto3 = require("crypto");
  var errs = require_errors7();
  var utils = require_utils4();
  var asn1 = require_lib3();
  var SSHBuffer = require_ssh_buffer();
  var InvalidAlgorithmError = errs.InvalidAlgorithmError;
  var SignatureParseError = errs.SignatureParseError;
  function Signature(opts) {
    assert.object(opts, "options");
    assert.arrayOfObject(opts.parts, "options.parts");
    assert.string(opts.type, "options.type");
    var partLookup = {};
    for (var i = 0;i < opts.parts.length; ++i) {
      var part = opts.parts[i];
      partLookup[part.name] = part;
    }
    this.type = opts.type;
    this.hashAlgorithm = opts.hashAlgo;
    this.curve = opts.curve;
    this.parts = opts.parts;
    this.part = partLookup;
  }
  Signature.prototype.toBuffer = function(format) {
    if (format === undefined)
      format = "asn1";
    assert.string(format, "format");
    var buf;
    var stype = "ssh-" + this.type;
    switch (this.type) {
      case "rsa":
        switch (this.hashAlgorithm) {
          case "sha256":
            stype = "rsa-sha2-256";
            break;
          case "sha512":
            stype = "rsa-sha2-512";
            break;
          case "sha1":
          case undefined:
            break;
          default:
            throw new Error("SSH signature " + "format does not support hash " + "algorithm " + this.hashAlgorithm);
        }
        if (format === "ssh") {
          buf = new SSHBuffer({});
          buf.writeString(stype);
          buf.writePart(this.part.sig);
          return buf.toBuffer();
        } else {
          return this.part.sig.data;
        }
        break;
      case "ed25519":
        if (format === "ssh") {
          buf = new SSHBuffer({});
          buf.writeString(stype);
          buf.writePart(this.part.sig);
          return buf.toBuffer();
        } else {
          return this.part.sig.data;
        }
        break;
      case "dsa":
      case "ecdsa":
        var r, s;
        if (format === "asn1") {
          var der = new asn1.BerWriter;
          der.startSequence();
          r = utils.mpNormalize(this.part.r.data);
          s = utils.mpNormalize(this.part.s.data);
          der.writeBuffer(r, asn1.Ber.Integer);
          der.writeBuffer(s, asn1.Ber.Integer);
          der.endSequence();
          return der.buffer;
        } else if (format === "ssh" && this.type === "dsa") {
          buf = new SSHBuffer({});
          buf.writeString("ssh-dss");
          r = this.part.r.data;
          if (r.length > 20 && r[0] === 0)
            r = r.slice(1);
          s = this.part.s.data;
          if (s.length > 20 && s[0] === 0)
            s = s.slice(1);
          if (this.hashAlgorithm && this.hashAlgorithm !== "sha1" || r.length + s.length !== 40) {
            throw new Error("OpenSSH only supports " + "DSA signatures with SHA1 hash");
          }
          buf.writeBuffer(Buffer2.concat([r, s]));
          return buf.toBuffer();
        } else if (format === "ssh" && this.type === "ecdsa") {
          var inner = new SSHBuffer({});
          r = this.part.r.data;
          inner.writeBuffer(r);
          inner.writePart(this.part.s);
          buf = new SSHBuffer({});
          var curve;
          if (r[0] === 0)
            r = r.slice(1);
          var sz = r.length * 8;
          if (sz === 256)
            curve = "nistp256";
          else if (sz === 384)
            curve = "nistp384";
          else if (sz === 528)
            curve = "nistp521";
          buf.writeString("ecdsa-sha2-" + curve);
          buf.writeBuffer(inner.toBuffer());
          return buf.toBuffer();
        }
        throw new Error("Invalid signature format");
      default:
        throw new Error("Invalid signature data");
    }
  };
  Signature.prototype.toString = function(format) {
    assert.optionalString(format, "format");
    return this.toBuffer(format).toString("base64");
  };
  Signature.parse = function(data, type, format) {
    if (typeof data === "string")
      data = Buffer2.from(data, "base64");
    assert.buffer(data, "data");
    assert.string(format, "format");
    assert.string(type, "type");
    var opts = {};
    opts.type = type.toLowerCase();
    opts.parts = [];
    try {
      assert.ok(data.length > 0, "signature must not be empty");
      switch (opts.type) {
        case "rsa":
          return parseOneNum(data, type, format, opts);
        case "ed25519":
          return parseOneNum(data, type, format, opts);
        case "dsa":
        case "ecdsa":
          if (format === "asn1")
            return parseDSAasn1(data, type, format, opts);
          else if (opts.type === "dsa")
            return parseDSA(data, type, format, opts);
          else
            return parseECDSA(data, type, format, opts);
        default:
          throw new InvalidAlgorithmError(type);
      }
    } catch (e) {
      if (e instanceof InvalidAlgorithmError)
        throw e;
      throw new SignatureParseError(type, format, e);
    }
  };
  function parseOneNum(data, type, format, opts) {
    if (format === "ssh") {
      try {
        var buf = new SSHBuffer({ buffer: data });
        var head = buf.readString();
      } catch (e) {}
      if (buf !== undefined) {
        var msg = "SSH signature does not match expected " + "type (expected " + type + ", got " + head + ")";
        switch (head) {
          case "ssh-rsa":
            assert.strictEqual(type, "rsa", msg);
            opts.hashAlgo = "sha1";
            break;
          case "rsa-sha2-256":
            assert.strictEqual(type, "rsa", msg);
            opts.hashAlgo = "sha256";
            break;
          case "rsa-sha2-512":
            assert.strictEqual(type, "rsa", msg);
            opts.hashAlgo = "sha512";
            break;
          case "ssh-ed25519":
            assert.strictEqual(type, "ed25519", msg);
            opts.hashAlgo = "sha512";
            break;
          default:
            throw new Error("Unknown SSH signature " + "type: " + head);
        }
        var sig = buf.readPart();
        assert.ok(buf.atEnd(), "extra trailing bytes");
        sig.name = "sig";
        opts.parts.push(sig);
        return new Signature(opts);
      }
    }
    opts.parts.push({ name: "sig", data });
    return new Signature(opts);
  }
  function parseDSAasn1(data, type, format, opts) {
    var der = new asn1.BerReader(data);
    der.readSequence();
    var r = der.readString(asn1.Ber.Integer, true);
    var s = der.readString(asn1.Ber.Integer, true);
    opts.parts.push({ name: "r", data: utils.mpNormalize(r) });
    opts.parts.push({ name: "s", data: utils.mpNormalize(s) });
    return new Signature(opts);
  }
  function parseDSA(data, type, format, opts) {
    if (data.length != 40) {
      var buf = new SSHBuffer({ buffer: data });
      var d = buf.readBuffer();
      if (d.toString("ascii") === "ssh-dss")
        d = buf.readBuffer();
      assert.ok(buf.atEnd(), "extra trailing bytes");
      assert.strictEqual(d.length, 40, "invalid inner length");
      data = d;
    }
    opts.parts.push({ name: "r", data: data.slice(0, 20) });
    opts.parts.push({ name: "s", data: data.slice(20, 40) });
    return new Signature(opts);
  }
  function parseECDSA(data, type, format, opts) {
    var buf = new SSHBuffer({ buffer: data });
    var r, s;
    var inner = buf.readBuffer();
    var stype = inner.toString("ascii");
    if (stype.slice(0, 6) === "ecdsa-") {
      var parts = stype.split("-");
      assert.strictEqual(parts[0], "ecdsa");
      assert.strictEqual(parts[1], "sha2");
      opts.curve = parts[2];
      switch (opts.curve) {
        case "nistp256":
          opts.hashAlgo = "sha256";
          break;
        case "nistp384":
          opts.hashAlgo = "sha384";
          break;
        case "nistp521":
          opts.hashAlgo = "sha512";
          break;
        default:
          throw new Error("Unsupported ECDSA curve: " + opts.curve);
      }
      inner = buf.readBuffer();
      assert.ok(buf.atEnd(), "extra trailing bytes on outer");
      buf = new SSHBuffer({ buffer: inner });
      r = buf.readPart();
    } else {
      r = { data: inner };
    }
    s = buf.readPart();
    assert.ok(buf.atEnd(), "extra trailing bytes");
    r.name = "r";
    s.name = "s";
    opts.parts.push(r);
    opts.parts.push(s);
    return new Signature(opts);
  }
  Signature.isSignature = function(obj2, ver) {
    return utils.isCompatible(obj2, Signature, ver);
  };
  Signature.prototype._sshpkApiVersion = [2, 1];
  Signature._oldVersionDetect = function(obj2) {
    assert.func(obj2.toBuffer);
    if (obj2.hasOwnProperty("hashAlgorithm"))
      return [2, 0];
    return [1, 0];
  };
});

// backend/node_modules/ecc-jsbn/lib/sec.js
var require_sec = __commonJS((exports2, module2) => {
  var BigInteger = require_jsbn().BigInteger;
  var ECCurveFp = require_ec().ECCurveFp;
  function X9ECParameters(curve, g, n, h) {
    this.curve = curve;
    this.g = g;
    this.n = n;
    this.h = h;
  }
  function x9getCurve() {
    return this.curve;
  }
  function x9getG() {
    return this.g;
  }
  function x9getN() {
    return this.n;
  }
  function x9getH() {
    return this.h;
  }
  X9ECParameters.prototype.getCurve = x9getCurve;
  X9ECParameters.prototype.getG = x9getG;
  X9ECParameters.prototype.getN = x9getN;
  X9ECParameters.prototype.getH = x9getH;
  function fromHex(s) {
    return new BigInteger(s, 16);
  }
  function secp128r1() {
    var p = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF");
    var a = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC");
    var b = fromHex("E87579C11079F43DD824993C2CEE5ED3");
    var n = fromHex("FFFFFFFE0000000075A30D1B9038A115");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04" + "161FF7528B899B2D0C28607CA52C5B86" + "CF5AC8395BAFEB13C02DA292DDED7A83");
    return new X9ECParameters(curve, G, n, h);
  }
  function secp160k1() {
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73");
    var a = BigInteger.ZERO;
    var b = fromHex("7");
    var n = fromHex("0100000000000000000001B8FA16DFAB9ACA16B6B3");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04" + "3B4C382CE37AA192A4019E763036F4F5DD4D7EBB" + "938CF935318FDCED6BC28286531733C3F03C4FEE");
    return new X9ECParameters(curve, G, n, h);
  }
  function secp160r1() {
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF");
    var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC");
    var b = fromHex("1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45");
    var n = fromHex("0100000000000000000001F4C8F927AED3CA752257");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04" + "4A96B5688EF573284664698968C38BB913CBFC82" + "23A628553168947D59DCC912042351377AC5FB32");
    return new X9ECParameters(curve, G, n, h);
  }
  function secp192k1() {
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37");
    var a = BigInteger.ZERO;
    var b = fromHex("3");
    var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04" + "DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D" + "9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D");
    return new X9ECParameters(curve, G, n, h);
  }
  function secp192r1() {
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF");
    var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC");
    var b = fromHex("64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1");
    var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04" + "188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012" + "07192B95FFC8DA78631011ED6B24CDD573F977A11E794811");
    return new X9ECParameters(curve, G, n, h);
  }
  function secp224r1() {
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001");
    var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE");
    var b = fromHex("B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4");
    var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04" + "B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21" + "BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34");
    return new X9ECParameters(curve, G, n, h);
  }
  function secp256r1() {
    var p = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF");
    var a = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC");
    var b = fromHex("5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B");
    var n = fromHex("FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04" + "6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296" + "4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5");
    return new X9ECParameters(curve, G, n, h);
  }
  module2.exports = {
    secp128r1,
    secp160k1,
    secp160r1,
    secp192k1,
    secp192r1,
    secp224r1,
    secp256r1
  };
});

// backend/node_modules/ecc-jsbn/index.js
var require_ecc_jsbn = __commonJS((exports2) => {
  var crypto3 = require("crypto");
  var BigInteger = require_jsbn().BigInteger;
  var ECPointFp = require_ec().ECPointFp;
  var Buffer2 = require_safer().Buffer;
  exports2.ECCurves = require_sec();
  function unstupid(hex, len) {
    return hex.length >= len ? hex : unstupid("0" + hex, len);
  }
  exports2.ECKey = function(curve, key, isPublic) {
    var priv;
    var c = curve();
    var n = c.getN();
    var bytes = Math.floor(n.bitLength() / 8);
    if (key) {
      if (isPublic) {
        var curve = c.getCurve();
        this.P = curve.decodePointHex(key.toString("hex"));
      } else {
        if (key.length != bytes)
          return false;
        priv = new BigInteger(key.toString("hex"), 16);
      }
    } else {
      var n1 = n.subtract(BigInteger.ONE);
      var r = new BigInteger(crypto3.randomBytes(n.bitLength()));
      priv = r.mod(n1).add(BigInteger.ONE);
      this.P = c.getG().multiply(priv);
    }
    if (this.P) {
      this.PublicKey = Buffer2.from(c.getCurve().encodeCompressedPointHex(this.P), "hex");
    }
    if (priv) {
      this.PrivateKey = Buffer2.from(unstupid(priv.toString(16), bytes * 2), "hex");
      this.deriveSharedSecret = function(key2) {
        if (!key2 || !key2.P)
          return false;
        var S = key2.P.multiply(priv);
        return Buffer2.from(unstupid(S.getX().toBigInteger().toString(16), bytes * 2), "hex");
      };
    }
  };
});

// backend/node_modules/sshpk/lib/dhe.js
var require_dhe = __commonJS((exports2, module2) => {
  module2.exports = {
    DiffieHellman,
    generateECDSA,
    generateED25519
  };
  var assert = require_assert();
  var crypto3 = require("crypto");
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils4();
  var nacl = require_nacl_fast();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var CRYPTO_HAVE_ECDH = crypto3.createECDH !== undefined;
  var ecdh = require_ecc_jsbn();
  var ec = require_ec();
  var jsbn = require_jsbn().BigInteger;
  function DiffieHellman(key) {
    utils.assertCompatible(key, Key, [1, 4], "key");
    this._isPriv = PrivateKey.isPrivateKey(key, [1, 3]);
    this._algo = key.type;
    this._curve = key.curve;
    this._key = key;
    if (key.type === "dsa") {
      if (!CRYPTO_HAVE_ECDH) {
        throw new Error("Due to bugs in the node 0.10 " + "crypto API, node 0.12.x or later is required " + "to use DH");
      }
      this._dh = crypto3.createDiffieHellman(key.part.p.data, undefined, key.part.g.data, undefined);
      this._p = key.part.p;
      this._g = key.part.g;
      if (this._isPriv)
        this._dh.setPrivateKey(key.part.x.data);
      this._dh.setPublicKey(key.part.y.data);
    } else if (key.type === "ecdsa") {
      if (!CRYPTO_HAVE_ECDH) {
        this._ecParams = new X9ECParameters(this._curve);
        if (this._isPriv) {
          this._priv = new ECPrivate(this._ecParams, key.part.d.data);
        }
        return;
      }
      var curve = {
        nistp256: "prime256v1",
        nistp384: "secp384r1",
        nistp521: "secp521r1"
      }[key.curve];
      this._dh = crypto3.createECDH(curve);
      if (typeof this._dh !== "object" || typeof this._dh.setPrivateKey !== "function") {
        CRYPTO_HAVE_ECDH = false;
        DiffieHellman.call(this, key);
        return;
      }
      if (this._isPriv)
        this._dh.setPrivateKey(key.part.d.data);
      this._dh.setPublicKey(key.part.Q.data);
    } else if (key.type === "curve25519") {
      if (this._isPriv) {
        utils.assertCompatible(key, PrivateKey, [1, 5], "key");
        this._priv = key.part.k.data;
      }
    } else {
      throw new Error("DH not supported for " + key.type + " keys");
    }
  }
  DiffieHellman.prototype.getPublicKey = function() {
    if (this._isPriv)
      return this._key.toPublic();
    return this._key;
  };
  DiffieHellman.prototype.getPrivateKey = function() {
    if (this._isPriv)
      return this._key;
    else
      return;
  };
  DiffieHellman.prototype.getKey = DiffieHellman.prototype.getPrivateKey;
  DiffieHellman.prototype._keyCheck = function(pk, isPub) {
    assert.object(pk, "key");
    if (!isPub)
      utils.assertCompatible(pk, PrivateKey, [1, 3], "key");
    utils.assertCompatible(pk, Key, [1, 4], "key");
    if (pk.type !== this._algo) {
      throw new Error("A " + pk.type + " key cannot be used in " + this._algo + " Diffie-Hellman");
    }
    if (pk.curve !== this._curve) {
      throw new Error("A key from the " + pk.curve + " curve " + "cannot be used with a " + this._curve + " Diffie-Hellman");
    }
    if (pk.type === "dsa") {
      assert.deepEqual(pk.part.p, this._p, "DSA key prime does not match");
      assert.deepEqual(pk.part.g, this._g, "DSA key generator does not match");
    }
  };
  DiffieHellman.prototype.setKey = function(pk) {
    this._keyCheck(pk);
    if (pk.type === "dsa") {
      this._dh.setPrivateKey(pk.part.x.data);
      this._dh.setPublicKey(pk.part.y.data);
    } else if (pk.type === "ecdsa") {
      if (CRYPTO_HAVE_ECDH) {
        this._dh.setPrivateKey(pk.part.d.data);
        this._dh.setPublicKey(pk.part.Q.data);
      } else {
        this._priv = new ECPrivate(this._ecParams, pk.part.d.data);
      }
    } else if (pk.type === "curve25519") {
      var k = pk.part.k;
      if (!pk.part.k)
        k = pk.part.r;
      this._priv = k.data;
      if (this._priv[0] === 0)
        this._priv = this._priv.slice(1);
      this._priv = this._priv.slice(0, 32);
    }
    this._key = pk;
    this._isPriv = true;
  };
  DiffieHellman.prototype.setPrivateKey = DiffieHellman.prototype.setKey;
  DiffieHellman.prototype.computeSecret = function(otherpk) {
    this._keyCheck(otherpk, true);
    if (!this._isPriv)
      throw new Error("DH exchange has not been initialized with " + "a private key yet");
    var pub;
    if (this._algo === "dsa") {
      return this._dh.computeSecret(otherpk.part.y.data);
    } else if (this._algo === "ecdsa") {
      if (CRYPTO_HAVE_ECDH) {
        return this._dh.computeSecret(otherpk.part.Q.data);
      } else {
        pub = new ECPublic(this._ecParams, otherpk.part.Q.data);
        return this._priv.deriveSharedSecret(pub);
      }
    } else if (this._algo === "curve25519") {
      pub = otherpk.part.A.data;
      while (pub[0] === 0 && pub.length > 32)
        pub = pub.slice(1);
      var priv = this._priv;
      assert.strictEqual(pub.length, 32);
      assert.strictEqual(priv.length, 32);
      var secret = nacl.box.before(new Uint8Array(pub), new Uint8Array(priv));
      return Buffer2.from(secret);
    }
    throw new Error("Invalid algorithm: " + this._algo);
  };
  DiffieHellman.prototype.generateKey = function() {
    var parts = [];
    var priv, pub;
    if (this._algo === "dsa") {
      this._dh.generateKeys();
      parts.push({ name: "p", data: this._p.data });
      parts.push({ name: "q", data: this._key.part.q.data });
      parts.push({ name: "g", data: this._g.data });
      parts.push({ name: "y", data: this._dh.getPublicKey() });
      parts.push({ name: "x", data: this._dh.getPrivateKey() });
      this._key = new PrivateKey({
        type: "dsa",
        parts
      });
      this._isPriv = true;
      return this._key;
    } else if (this._algo === "ecdsa") {
      if (CRYPTO_HAVE_ECDH) {
        this._dh.generateKeys();
        parts.push({
          name: "curve",
          data: Buffer2.from(this._curve)
        });
        parts.push({ name: "Q", data: this._dh.getPublicKey() });
        parts.push({ name: "d", data: this._dh.getPrivateKey() });
        this._key = new PrivateKey({
          type: "ecdsa",
          curve: this._curve,
          parts
        });
        this._isPriv = true;
        return this._key;
      } else {
        var n = this._ecParams.getN();
        var r = new jsbn(crypto3.randomBytes(n.bitLength()));
        var n1 = n.subtract(jsbn.ONE);
        priv = r.mod(n1).add(jsbn.ONE);
        pub = this._ecParams.getG().multiply(priv);
        priv = Buffer2.from(priv.toByteArray());
        pub = Buffer2.from(this._ecParams.getCurve().encodePointHex(pub), "hex");
        this._priv = new ECPrivate(this._ecParams, priv);
        parts.push({
          name: "curve",
          data: Buffer2.from(this._curve)
        });
        parts.push({ name: "Q", data: pub });
        parts.push({ name: "d", data: priv });
        this._key = new PrivateKey({
          type: "ecdsa",
          curve: this._curve,
          parts
        });
        this._isPriv = true;
        return this._key;
      }
    } else if (this._algo === "curve25519") {
      var pair = nacl.box.keyPair();
      priv = Buffer2.from(pair.secretKey);
      pub = Buffer2.from(pair.publicKey);
      priv = Buffer2.concat([priv, pub]);
      assert.strictEqual(priv.length, 64);
      assert.strictEqual(pub.length, 32);
      parts.push({ name: "A", data: pub });
      parts.push({ name: "k", data: priv });
      this._key = new PrivateKey({
        type: "curve25519",
        parts
      });
      this._isPriv = true;
      return this._key;
    }
    throw new Error("Invalid algorithm: " + this._algo);
  };
  DiffieHellman.prototype.generateKeys = DiffieHellman.prototype.generateKey;
  function X9ECParameters(name) {
    var params = algs.curves[name];
    assert.object(params);
    var p = new jsbn(params.p);
    var a = new jsbn(params.a);
    var b = new jsbn(params.b);
    var n = new jsbn(params.n);
    var h = jsbn.ONE;
    var curve = new ec.ECCurveFp(p, a, b);
    var G = curve.decodePointHex(params.G.toString("hex"));
    this.curve = curve;
    this.g = G;
    this.n = n;
    this.h = h;
  }
  X9ECParameters.prototype.getCurve = function() {
    return this.curve;
  };
  X9ECParameters.prototype.getG = function() {
    return this.g;
  };
  X9ECParameters.prototype.getN = function() {
    return this.n;
  };
  X9ECParameters.prototype.getH = function() {
    return this.h;
  };
  function ECPublic(params, buffer) {
    this._params = params;
    if (buffer[0] === 0)
      buffer = buffer.slice(1);
    this._pub = params.getCurve().decodePointHex(buffer.toString("hex"));
  }
  function ECPrivate(params, buffer) {
    this._params = params;
    this._priv = new jsbn(utils.mpNormalize(buffer));
  }
  ECPrivate.prototype.deriveSharedSecret = function(pubKey) {
    assert.ok(pubKey instanceof ECPublic);
    var S = pubKey._pub.multiply(this._priv);
    return Buffer2.from(S.getX().toBigInteger().toByteArray());
  };
  function generateED25519() {
    var pair = nacl.sign.keyPair();
    var priv = Buffer2.from(pair.secretKey);
    var pub = Buffer2.from(pair.publicKey);
    assert.strictEqual(priv.length, 64);
    assert.strictEqual(pub.length, 32);
    var parts = [];
    parts.push({ name: "A", data: pub });
    parts.push({ name: "k", data: priv.slice(0, 32) });
    var key = new PrivateKey({
      type: "ed25519",
      parts
    });
    return key;
  }
  function generateECDSA(curve) {
    var parts = [];
    var key;
    if (CRYPTO_HAVE_ECDH) {
      var osCurve = {
        nistp256: "prime256v1",
        nistp384: "secp384r1",
        nistp521: "secp521r1"
      }[curve];
      var dh = crypto3.createECDH(osCurve);
      dh.generateKeys();
      parts.push({
        name: "curve",
        data: Buffer2.from(curve)
      });
      parts.push({ name: "Q", data: dh.getPublicKey() });
      parts.push({ name: "d", data: dh.getPrivateKey() });
      key = new PrivateKey({
        type: "ecdsa",
        curve,
        parts
      });
      return key;
    } else {
      var ecParams = new X9ECParameters(curve);
      var n = ecParams.getN();
      var cByteLen = Math.ceil((n.bitLength() + 64) / 8);
      var c = new jsbn(crypto3.randomBytes(cByteLen));
      var n1 = n.subtract(jsbn.ONE);
      var priv = c.mod(n1).add(jsbn.ONE);
      var pub = ecParams.getG().multiply(priv);
      priv = Buffer2.from(priv.toByteArray());
      pub = Buffer2.from(ecParams.getCurve().encodePointHex(pub), "hex");
      parts.push({ name: "curve", data: Buffer2.from(curve) });
      parts.push({ name: "Q", data: pub });
      parts.push({ name: "d", data: priv });
      key = new PrivateKey({
        type: "ecdsa",
        curve,
        parts
      });
      return key;
    }
  }
});

// backend/node_modules/sshpk/lib/ed-compat.js
var require_ed_compat = __commonJS((exports2, module2) => {
  module2.exports = {
    Verifier,
    Signer
  };
  var nacl = require_nacl_fast();
  var stream4 = require("stream");
  var util3 = require("util");
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var Signature = require_signature();
  function Verifier(key, hashAlgo) {
    if (hashAlgo.toLowerCase() !== "sha512")
      throw new Error("ED25519 only supports the use of " + "SHA-512 hashes");
    this.key = key;
    this.chunks = [];
    stream4.Writable.call(this, {});
  }
  util3.inherits(Verifier, stream4.Writable);
  Verifier.prototype._write = function(chunk, enc, cb) {
    this.chunks.push(chunk);
    cb();
  };
  Verifier.prototype.update = function(chunk) {
    if (typeof chunk === "string")
      chunk = Buffer2.from(chunk, "binary");
    this.chunks.push(chunk);
  };
  Verifier.prototype.verify = function(signature, fmt) {
    var sig;
    if (Signature.isSignature(signature, [2, 0])) {
      if (signature.type !== "ed25519")
        return false;
      sig = signature.toBuffer("raw");
    } else if (typeof signature === "string") {
      sig = Buffer2.from(signature, "base64");
    } else if (Signature.isSignature(signature, [1, 0])) {
      throw new Error("signature was created by too old " + "a version of sshpk and cannot be verified");
    }
    assert.buffer(sig);
    return nacl.sign.detached.verify(new Uint8Array(Buffer2.concat(this.chunks)), new Uint8Array(sig), new Uint8Array(this.key.part.A.data));
  };
  function Signer(key, hashAlgo) {
    if (hashAlgo.toLowerCase() !== "sha512")
      throw new Error("ED25519 only supports the use of " + "SHA-512 hashes");
    this.key = key;
    this.chunks = [];
    stream4.Writable.call(this, {});
  }
  util3.inherits(Signer, stream4.Writable);
  Signer.prototype._write = function(chunk, enc, cb) {
    this.chunks.push(chunk);
    cb();
  };
  Signer.prototype.update = function(chunk) {
    if (typeof chunk === "string")
      chunk = Buffer2.from(chunk, "binary");
    this.chunks.push(chunk);
  };
  Signer.prototype.sign = function() {
    var sig = nacl.sign.detached(new Uint8Array(Buffer2.concat(this.chunks)), new Uint8Array(Buffer2.concat([
      this.key.part.k.data,
      this.key.part.A.data
    ])));
    var sigBuf = Buffer2.from(sig);
    var sigObj = Signature.parse(sigBuf, "ed25519", "raw");
    sigObj.hashAlgorithm = "sha512";
    return sigObj;
  };
});

// backend/node_modules/sshpk/lib/formats/pkcs8.js
var require_pkcs8 = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    readPkcs8,
    write,
    writePkcs8,
    pkcs8ToBuffer,
    readECDSACurve,
    writeECDSACurve
  };
  var assert = require_assert();
  var asn1 = require_lib3();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils4();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pem = require_pem();
  function read(buf, options) {
    return pem.read(buf, options, "pkcs8");
  }
  function write(key, options) {
    return pem.write(key, options, "pkcs8");
  }
  function readMPInt(der, nm) {
    assert.strictEqual(der.peek(), asn1.Ber.Integer, nm + " is not an Integer");
    return utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
  }
  function readPkcs8(alg, type, der) {
    if (der.peek() === asn1.Ber.Integer) {
      assert.strictEqual(type, "private", "unexpected Integer at start of public key");
      der.readString(asn1.Ber.Integer, true);
    }
    der.readSequence();
    var next = der.offset + der.length;
    var oid = der.readOID();
    switch (oid) {
      case "1.2.840.113549.1.1.1":
        der._offset = next;
        if (type === "public")
          return readPkcs8RSAPublic(der);
        else
          return readPkcs8RSAPrivate(der);
      case "1.2.840.10040.4.1":
        if (type === "public")
          return readPkcs8DSAPublic(der);
        else
          return readPkcs8DSAPrivate(der);
      case "1.2.840.10045.2.1":
        if (type === "public")
          return readPkcs8ECDSAPublic(der);
        else
          return readPkcs8ECDSAPrivate(der);
      case "1.3.101.112":
        if (type === "public") {
          return readPkcs8EdDSAPublic(der);
        } else {
          return readPkcs8EdDSAPrivate(der);
        }
      case "1.3.101.110":
        if (type === "public") {
          return readPkcs8X25519Public(der);
        } else {
          return readPkcs8X25519Private(der);
        }
      default:
        throw new Error("Unknown key type OID " + oid);
    }
  }
  function readPkcs8RSAPublic(der) {
    der.readSequence(asn1.Ber.BitString);
    der.readByte();
    der.readSequence();
    var n = readMPInt(der, "modulus");
    var e = readMPInt(der, "exponent");
    var key = {
      type: "rsa",
      source: der.originalInput,
      parts: [
        { name: "e", data: e },
        { name: "n", data: n }
      ]
    };
    return new Key(key);
  }
  function readPkcs8RSAPrivate(der) {
    der.readSequence(asn1.Ber.OctetString);
    der.readSequence();
    var ver = readMPInt(der, "version");
    assert.equal(ver[0], 0, "unknown RSA private key version");
    var n = readMPInt(der, "modulus");
    var e = readMPInt(der, "public exponent");
    var d = readMPInt(der, "private exponent");
    var p = readMPInt(der, "prime1");
    var q2 = readMPInt(der, "prime2");
    var dmodp = readMPInt(der, "exponent1");
    var dmodq = readMPInt(der, "exponent2");
    var iqmp = readMPInt(der, "iqmp");
    var key = {
      type: "rsa",
      parts: [
        { name: "n", data: n },
        { name: "e", data: e },
        { name: "d", data: d },
        { name: "iqmp", data: iqmp },
        { name: "p", data: p },
        { name: "q", data: q2 },
        { name: "dmodp", data: dmodp },
        { name: "dmodq", data: dmodq }
      ]
    };
    return new PrivateKey(key);
  }
  function readPkcs8DSAPublic(der) {
    der.readSequence();
    var p = readMPInt(der, "p");
    var q2 = readMPInt(der, "q");
    var g = readMPInt(der, "g");
    der.readSequence(asn1.Ber.BitString);
    der.readByte();
    var y = readMPInt(der, "y");
    var key = {
      type: "dsa",
      parts: [
        { name: "p", data: p },
        { name: "q", data: q2 },
        { name: "g", data: g },
        { name: "y", data: y }
      ]
    };
    return new Key(key);
  }
  function readPkcs8DSAPrivate(der) {
    der.readSequence();
    var p = readMPInt(der, "p");
    var q2 = readMPInt(der, "q");
    var g = readMPInt(der, "g");
    der.readSequence(asn1.Ber.OctetString);
    var x = readMPInt(der, "x");
    var y = utils.calculateDSAPublic(g, p, x);
    var key = {
      type: "dsa",
      parts: [
        { name: "p", data: p },
        { name: "q", data: q2 },
        { name: "g", data: g },
        { name: "y", data: y },
        { name: "x", data: x }
      ]
    };
    return new PrivateKey(key);
  }
  function readECDSACurve(der) {
    var curveName, curveNames;
    var j, c, cd;
    if (der.peek() === asn1.Ber.OID) {
      var oid = der.readOID();
      curveNames = Object.keys(algs.curves);
      for (j = 0;j < curveNames.length; ++j) {
        c = curveNames[j];
        cd = algs.curves[c];
        if (cd.pkcs8oid === oid) {
          curveName = c;
          break;
        }
      }
    } else {
      der.readSequence();
      var version = der.readString(asn1.Ber.Integer, true);
      assert.strictEqual(version[0], 1, "ECDSA key not version 1");
      var curve = {};
      der.readSequence();
      var fieldTypeOid = der.readOID();
      assert.strictEqual(fieldTypeOid, "1.2.840.10045.1.1", "ECDSA key is not from a prime-field");
      var p = curve.p = utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
      curve.size = p.length * 8 - utils.countZeros(p);
      der.readSequence();
      curve.a = utils.mpNormalize(der.readString(asn1.Ber.OctetString, true));
      curve.b = utils.mpNormalize(der.readString(asn1.Ber.OctetString, true));
      if (der.peek() === asn1.Ber.BitString)
        curve.s = der.readString(asn1.Ber.BitString, true);
      curve.G = der.readString(asn1.Ber.OctetString, true);
      assert.strictEqual(curve.G[0], 4, "uncompressed G is required");
      curve.n = utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
      curve.h = utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
      assert.strictEqual(curve.h[0], 1, "a cofactor=1 curve is " + "required");
      curveNames = Object.keys(algs.curves);
      var ks = Object.keys(curve);
      for (j = 0;j < curveNames.length; ++j) {
        c = curveNames[j];
        cd = algs.curves[c];
        var equal = true;
        for (var i = 0;i < ks.length; ++i) {
          var k = ks[i];
          if (cd[k] === undefined)
            continue;
          if (typeof cd[k] === "object" && cd[k].equals !== undefined) {
            if (!cd[k].equals(curve[k])) {
              equal = false;
              break;
            }
          } else if (Buffer2.isBuffer(cd[k])) {
            if (cd[k].toString("binary") !== curve[k].toString("binary")) {
              equal = false;
              break;
            }
          } else {
            if (cd[k] !== curve[k]) {
              equal = false;
              break;
            }
          }
        }
        if (equal) {
          curveName = c;
          break;
        }
      }
    }
    return curveName;
  }
  function readPkcs8ECDSAPrivate(der) {
    var curveName = readECDSACurve(der);
    assert.string(curveName, "a known elliptic curve");
    der.readSequence(asn1.Ber.OctetString);
    der.readSequence();
    var version = readMPInt(der, "version");
    assert.equal(version[0], 1, "unknown version of ECDSA key");
    var d = der.readString(asn1.Ber.OctetString, true);
    var Q;
    if (der.peek() == 160) {
      der.readSequence(160);
      der._offset += der.length;
    }
    if (der.peek() == 161) {
      der.readSequence(161);
      Q = der.readString(asn1.Ber.BitString, true);
      Q = utils.ecNormalize(Q);
    }
    if (Q === undefined) {
      var pub = utils.publicFromPrivateECDSA(curveName, d);
      Q = pub.part.Q.data;
    }
    var key = {
      type: "ecdsa",
      parts: [
        { name: "curve", data: Buffer2.from(curveName) },
        { name: "Q", data: Q },
        { name: "d", data: d }
      ]
    };
    return new PrivateKey(key);
  }
  function readPkcs8ECDSAPublic(der) {
    var curveName = readECDSACurve(der);
    assert.string(curveName, "a known elliptic curve");
    var Q = der.readString(asn1.Ber.BitString, true);
    Q = utils.ecNormalize(Q);
    var key = {
      type: "ecdsa",
      parts: [
        { name: "curve", data: Buffer2.from(curveName) },
        { name: "Q", data: Q }
      ]
    };
    return new Key(key);
  }
  function readPkcs8EdDSAPublic(der) {
    if (der.peek() === 0)
      der.readByte();
    var A = utils.readBitString(der);
    var key = {
      type: "ed25519",
      parts: [
        { name: "A", data: utils.zeroPadToLength(A, 32) }
      ]
    };
    return new Key(key);
  }
  function readPkcs8X25519Public(der) {
    var A = utils.readBitString(der);
    var key = {
      type: "curve25519",
      parts: [
        { name: "A", data: utils.zeroPadToLength(A, 32) }
      ]
    };
    return new Key(key);
  }
  function readPkcs8EdDSAPrivate(der) {
    if (der.peek() === 0)
      der.readByte();
    der.readSequence(asn1.Ber.OctetString);
    var k = der.readString(asn1.Ber.OctetString, true);
    k = utils.zeroPadToLength(k, 32);
    var A, tag;
    while ((tag = der.peek()) !== null) {
      if (tag === (asn1.Ber.Context | 1)) {
        A = utils.readBitString(der, tag);
      } else {
        der.readSequence(tag);
        der._offset += der.length;
      }
    }
    if (A === undefined)
      A = utils.calculateED25519Public(k);
    var key = {
      type: "ed25519",
      parts: [
        { name: "A", data: utils.zeroPadToLength(A, 32) },
        { name: "k", data: utils.zeroPadToLength(k, 32) }
      ]
    };
    return new PrivateKey(key);
  }
  function readPkcs8X25519Private(der) {
    if (der.peek() === 0)
      der.readByte();
    der.readSequence(asn1.Ber.OctetString);
    var k = der.readString(asn1.Ber.OctetString, true);
    k = utils.zeroPadToLength(k, 32);
    var A = utils.calculateX25519Public(k);
    var key = {
      type: "curve25519",
      parts: [
        { name: "A", data: utils.zeroPadToLength(A, 32) },
        { name: "k", data: utils.zeroPadToLength(k, 32) }
      ]
    };
    return new PrivateKey(key);
  }
  function pkcs8ToBuffer(key) {
    var der = new asn1.BerWriter;
    writePkcs8(der, key);
    return der.buffer;
  }
  function writePkcs8(der, key) {
    der.startSequence();
    if (PrivateKey.isPrivateKey(key)) {
      var version = 0;
      if (key.type === "ed25519")
        version = 1;
      var vbuf = Buffer2.from([version]);
      der.writeBuffer(vbuf, asn1.Ber.Integer);
    }
    der.startSequence();
    switch (key.type) {
      case "rsa":
        der.writeOID("1.2.840.113549.1.1.1");
        if (PrivateKey.isPrivateKey(key))
          writePkcs8RSAPrivate(key, der);
        else
          writePkcs8RSAPublic(key, der);
        break;
      case "dsa":
        der.writeOID("1.2.840.10040.4.1");
        if (PrivateKey.isPrivateKey(key))
          writePkcs8DSAPrivate(key, der);
        else
          writePkcs8DSAPublic(key, der);
        break;
      case "ecdsa":
        der.writeOID("1.2.840.10045.2.1");
        if (PrivateKey.isPrivateKey(key))
          writePkcs8ECDSAPrivate(key, der);
        else
          writePkcs8ECDSAPublic(key, der);
        break;
      case "ed25519":
        der.writeOID("1.3.101.112");
        if (PrivateKey.isPrivateKey(key))
          writePkcs8EdDSAPrivate(key, der);
        else
          writePkcs8EdDSAPublic(key, der);
        break;
      default:
        throw new Error("Unsupported key type: " + key.type);
    }
    der.endSequence();
  }
  function writePkcs8RSAPrivate(key, der) {
    der.writeNull();
    der.endSequence();
    der.startSequence(asn1.Ber.OctetString);
    der.startSequence();
    var version = Buffer2.from([0]);
    der.writeBuffer(version, asn1.Ber.Integer);
    der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.d.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
    if (!key.part.dmodp || !key.part.dmodq)
      utils.addRSAMissing(key);
    der.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);
    der.endSequence();
    der.endSequence();
  }
  function writePkcs8RSAPublic(key, der) {
    der.writeNull();
    der.endSequence();
    der.startSequence(asn1.Ber.BitString);
    der.writeByte(0);
    der.startSequence();
    der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
    der.endSequence();
    der.endSequence();
  }
  function writePkcs8DSAPrivate(key, der) {
    der.startSequence();
    der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
    der.endSequence();
    der.endSequence();
    der.startSequence(asn1.Ber.OctetString);
    der.writeBuffer(key.part.x.data, asn1.Ber.Integer);
    der.endSequence();
  }
  function writePkcs8DSAPublic(key, der) {
    der.startSequence();
    der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
    der.endSequence();
    der.endSequence();
    der.startSequence(asn1.Ber.BitString);
    der.writeByte(0);
    der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
    der.endSequence();
  }
  function writeECDSACurve(key, der) {
    var curve = algs.curves[key.curve];
    if (curve.pkcs8oid) {
      der.writeOID(curve.pkcs8oid);
    } else {
      der.startSequence();
      var version = Buffer2.from([1]);
      der.writeBuffer(version, asn1.Ber.Integer);
      der.startSequence();
      der.writeOID("1.2.840.10045.1.1");
      der.writeBuffer(curve.p, asn1.Ber.Integer);
      der.endSequence();
      der.startSequence();
      var a = curve.p;
      if (a[0] === 0)
        a = a.slice(1);
      der.writeBuffer(a, asn1.Ber.OctetString);
      der.writeBuffer(curve.b, asn1.Ber.OctetString);
      der.writeBuffer(curve.s, asn1.Ber.BitString);
      der.endSequence();
      der.writeBuffer(curve.G, asn1.Ber.OctetString);
      der.writeBuffer(curve.n, asn1.Ber.Integer);
      var h = curve.h;
      if (!h) {
        h = Buffer2.from([1]);
      }
      der.writeBuffer(h, asn1.Ber.Integer);
      der.endSequence();
    }
  }
  function writePkcs8ECDSAPublic(key, der) {
    writeECDSACurve(key, der);
    der.endSequence();
    var Q = utils.ecNormalize(key.part.Q.data, true);
    der.writeBuffer(Q, asn1.Ber.BitString);
  }
  function writePkcs8ECDSAPrivate(key, der) {
    writeECDSACurve(key, der);
    der.endSequence();
    der.startSequence(asn1.Ber.OctetString);
    der.startSequence();
    var version = Buffer2.from([1]);
    der.writeBuffer(version, asn1.Ber.Integer);
    der.writeBuffer(key.part.d.data, asn1.Ber.OctetString);
    der.startSequence(161);
    var Q = utils.ecNormalize(key.part.Q.data, true);
    der.writeBuffer(Q, asn1.Ber.BitString);
    der.endSequence();
    der.endSequence();
    der.endSequence();
  }
  function writePkcs8EdDSAPublic(key, der) {
    der.endSequence();
    utils.writeBitString(der, key.part.A.data);
  }
  function writePkcs8EdDSAPrivate(key, der) {
    der.endSequence();
    der.startSequence(asn1.Ber.OctetString);
    var k = utils.mpNormalize(key.part.k.data);
    while (k.length > 32 && k[0] === 0)
      k = k.slice(1);
    der.writeBuffer(k, asn1.Ber.OctetString);
    der.endSequence();
    utils.writeBitString(der, key.part.A.data, asn1.Ber.Context | 1);
  }
});

// backend/node_modules/sshpk/lib/formats/pkcs1.js
var require_pkcs1 = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    readPkcs1,
    write,
    writePkcs1
  };
  var assert = require_assert();
  var asn1 = require_lib3();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils4();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pem = require_pem();
  var pkcs8 = require_pkcs8();
  var readECDSACurve = pkcs8.readECDSACurve;
  function read(buf, options) {
    return pem.read(buf, options, "pkcs1");
  }
  function write(key, options) {
    return pem.write(key, options, "pkcs1");
  }
  function readMPInt(der, nm) {
    assert.strictEqual(der.peek(), asn1.Ber.Integer, nm + " is not an Integer");
    return utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
  }
  function readPkcs1(alg, type, der) {
    switch (alg) {
      case "RSA":
        if (type === "public")
          return readPkcs1RSAPublic(der);
        else if (type === "private")
          return readPkcs1RSAPrivate(der);
        throw new Error("Unknown key type: " + type);
      case "DSA":
        if (type === "public")
          return readPkcs1DSAPublic(der);
        else if (type === "private")
          return readPkcs1DSAPrivate(der);
        throw new Error("Unknown key type: " + type);
      case "EC":
      case "ECDSA":
        if (type === "private")
          return readPkcs1ECDSAPrivate(der);
        else if (type === "public")
          return readPkcs1ECDSAPublic(der);
        throw new Error("Unknown key type: " + type);
      case "EDDSA":
      case "EdDSA":
        if (type === "private")
          return readPkcs1EdDSAPrivate(der);
        throw new Error(type + " keys not supported with EdDSA");
      default:
        throw new Error("Unknown key algo: " + alg);
    }
  }
  function readPkcs1RSAPublic(der) {
    var n = readMPInt(der, "modulus");
    var e = readMPInt(der, "exponent");
    var key = {
      type: "rsa",
      parts: [
        { name: "e", data: e },
        { name: "n", data: n }
      ]
    };
    return new Key(key);
  }
  function readPkcs1RSAPrivate(der) {
    var version = readMPInt(der, "version");
    assert.strictEqual(version[0], 0);
    var n = readMPInt(der, "modulus");
    var e = readMPInt(der, "public exponent");
    var d = readMPInt(der, "private exponent");
    var p = readMPInt(der, "prime1");
    var q2 = readMPInt(der, "prime2");
    var dmodp = readMPInt(der, "exponent1");
    var dmodq = readMPInt(der, "exponent2");
    var iqmp = readMPInt(der, "iqmp");
    var key = {
      type: "rsa",
      parts: [
        { name: "n", data: n },
        { name: "e", data: e },
        { name: "d", data: d },
        { name: "iqmp", data: iqmp },
        { name: "p", data: p },
        { name: "q", data: q2 },
        { name: "dmodp", data: dmodp },
        { name: "dmodq", data: dmodq }
      ]
    };
    return new PrivateKey(key);
  }
  function readPkcs1DSAPrivate(der) {
    var version = readMPInt(der, "version");
    assert.strictEqual(version.readUInt8(0), 0);
    var p = readMPInt(der, "p");
    var q2 = readMPInt(der, "q");
    var g = readMPInt(der, "g");
    var y = readMPInt(der, "y");
    var x = readMPInt(der, "x");
    var key = {
      type: "dsa",
      parts: [
        { name: "p", data: p },
        { name: "q", data: q2 },
        { name: "g", data: g },
        { name: "y", data: y },
        { name: "x", data: x }
      ]
    };
    return new PrivateKey(key);
  }
  function readPkcs1EdDSAPrivate(der) {
    var version = readMPInt(der, "version");
    assert.strictEqual(version.readUInt8(0), 1);
    var k = der.readString(asn1.Ber.OctetString, true);
    der.readSequence(160);
    var oid = der.readOID();
    assert.strictEqual(oid, "1.3.101.112", "the ed25519 curve identifier");
    der.readSequence(161);
    var A = utils.readBitString(der);
    var key = {
      type: "ed25519",
      parts: [
        { name: "A", data: utils.zeroPadToLength(A, 32) },
        { name: "k", data: k }
      ]
    };
    return new PrivateKey(key);
  }
  function readPkcs1DSAPublic(der) {
    var y = readMPInt(der, "y");
    var p = readMPInt(der, "p");
    var q2 = readMPInt(der, "q");
    var g = readMPInt(der, "g");
    var key = {
      type: "dsa",
      parts: [
        { name: "y", data: y },
        { name: "p", data: p },
        { name: "q", data: q2 },
        { name: "g", data: g }
      ]
    };
    return new Key(key);
  }
  function readPkcs1ECDSAPublic(der) {
    der.readSequence();
    var oid = der.readOID();
    assert.strictEqual(oid, "1.2.840.10045.2.1", "must be ecPublicKey");
    var curveOid = der.readOID();
    var curve;
    var curves = Object.keys(algs.curves);
    for (var j = 0;j < curves.length; ++j) {
      var c = curves[j];
      var cd = algs.curves[c];
      if (cd.pkcs8oid === curveOid) {
        curve = c;
        break;
      }
    }
    assert.string(curve, "a known ECDSA named curve");
    var Q = der.readString(asn1.Ber.BitString, true);
    Q = utils.ecNormalize(Q);
    var key = {
      type: "ecdsa",
      parts: [
        { name: "curve", data: Buffer2.from(curve) },
        { name: "Q", data: Q }
      ]
    };
    return new Key(key);
  }
  function readPkcs1ECDSAPrivate(der) {
    var version = readMPInt(der, "version");
    assert.strictEqual(version.readUInt8(0), 1);
    var d = der.readString(asn1.Ber.OctetString, true);
    der.readSequence(160);
    var curve = readECDSACurve(der);
    assert.string(curve, "a known elliptic curve");
    der.readSequence(161);
    var Q = der.readString(asn1.Ber.BitString, true);
    Q = utils.ecNormalize(Q);
    var key = {
      type: "ecdsa",
      parts: [
        { name: "curve", data: Buffer2.from(curve) },
        { name: "Q", data: Q },
        { name: "d", data: d }
      ]
    };
    return new PrivateKey(key);
  }
  function writePkcs1(der, key) {
    der.startSequence();
    switch (key.type) {
      case "rsa":
        if (PrivateKey.isPrivateKey(key))
          writePkcs1RSAPrivate(der, key);
        else
          writePkcs1RSAPublic(der, key);
        break;
      case "dsa":
        if (PrivateKey.isPrivateKey(key))
          writePkcs1DSAPrivate(der, key);
        else
          writePkcs1DSAPublic(der, key);
        break;
      case "ecdsa":
        if (PrivateKey.isPrivateKey(key))
          writePkcs1ECDSAPrivate(der, key);
        else
          writePkcs1ECDSAPublic(der, key);
        break;
      case "ed25519":
        if (PrivateKey.isPrivateKey(key))
          writePkcs1EdDSAPrivate(der, key);
        else
          writePkcs1EdDSAPublic(der, key);
        break;
      default:
        throw new Error("Unknown key algo: " + key.type);
    }
    der.endSequence();
  }
  function writePkcs1RSAPublic(der, key) {
    der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
  }
  function writePkcs1RSAPrivate(der, key) {
    var ver = Buffer2.from([0]);
    der.writeBuffer(ver, asn1.Ber.Integer);
    der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.d.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
    if (!key.part.dmodp || !key.part.dmodq)
      utils.addRSAMissing(key);
    der.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);
  }
  function writePkcs1DSAPrivate(der, key) {
    var ver = Buffer2.from([0]);
    der.writeBuffer(ver, asn1.Ber.Integer);
    der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.x.data, asn1.Ber.Integer);
  }
  function writePkcs1DSAPublic(der, key) {
    der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
  }
  function writePkcs1ECDSAPublic(der, key) {
    der.startSequence();
    der.writeOID("1.2.840.10045.2.1");
    var curve = key.part.curve.data.toString();
    var curveOid = algs.curves[curve].pkcs8oid;
    assert.string(curveOid, "a known ECDSA named curve");
    der.writeOID(curveOid);
    der.endSequence();
    var Q = utils.ecNormalize(key.part.Q.data, true);
    der.writeBuffer(Q, asn1.Ber.BitString);
  }
  function writePkcs1ECDSAPrivate(der, key) {
    var ver = Buffer2.from([1]);
    der.writeBuffer(ver, asn1.Ber.Integer);
    der.writeBuffer(key.part.d.data, asn1.Ber.OctetString);
    der.startSequence(160);
    var curve = key.part.curve.data.toString();
    var curveOid = algs.curves[curve].pkcs8oid;
    assert.string(curveOid, "a known ECDSA named curve");
    der.writeOID(curveOid);
    der.endSequence();
    der.startSequence(161);
    var Q = utils.ecNormalize(key.part.Q.data, true);
    der.writeBuffer(Q, asn1.Ber.BitString);
    der.endSequence();
  }
  function writePkcs1EdDSAPrivate(der, key) {
    var ver = Buffer2.from([1]);
    der.writeBuffer(ver, asn1.Ber.Integer);
    der.writeBuffer(key.part.k.data, asn1.Ber.OctetString);
    der.startSequence(160);
    der.writeOID("1.3.101.112");
    der.endSequence();
    der.startSequence(161);
    utils.writeBitString(der, key.part.A.data);
    der.endSequence();
  }
  function writePkcs1EdDSAPublic(der, key) {
    throw new Error("Public keys are not supported for EdDSA PKCS#1");
  }
});

// backend/node_modules/sshpk/lib/formats/rfc4253.js
var require_rfc4253 = __commonJS((exports2, module2) => {
  module2.exports = {
    read: read.bind(undefined, false, undefined),
    readType: read.bind(undefined, false),
    write,
    readPartial: read.bind(undefined, true),
    readInternal: read,
    keyTypeToAlg,
    algToKeyType
  };
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils4();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var SSHBuffer = require_ssh_buffer();
  function algToKeyType(alg) {
    assert.string(alg);
    if (alg === "ssh-dss")
      return "dsa";
    else if (alg === "ssh-rsa")
      return "rsa";
    else if (alg === "ssh-ed25519")
      return "ed25519";
    else if (alg === "ssh-curve25519")
      return "curve25519";
    else if (alg.match(/^ecdsa-sha2-/))
      return "ecdsa";
    else
      throw new Error("Unknown algorithm " + alg);
  }
  function keyTypeToAlg(key) {
    assert.object(key);
    if (key.type === "dsa")
      return "ssh-dss";
    else if (key.type === "rsa")
      return "ssh-rsa";
    else if (key.type === "ed25519")
      return "ssh-ed25519";
    else if (key.type === "curve25519")
      return "ssh-curve25519";
    else if (key.type === "ecdsa")
      return "ecdsa-sha2-" + key.part.curve.data.toString();
    else
      throw new Error("Unknown key type " + key.type);
  }
  function read(partial, type, buf, options) {
    if (typeof buf === "string")
      buf = Buffer2.from(buf);
    assert.buffer(buf, "buf");
    var key = {};
    var parts = key.parts = [];
    var sshbuf = new SSHBuffer({ buffer: buf });
    var alg = sshbuf.readString();
    assert.ok(!sshbuf.atEnd(), "key must have at least one part");
    key.type = algToKeyType(alg);
    var partCount = algs.info[key.type].parts.length;
    if (type && type === "private")
      partCount = algs.privInfo[key.type].parts.length;
    while (!sshbuf.atEnd() && parts.length < partCount)
      parts.push(sshbuf.readPart());
    while (!partial && !sshbuf.atEnd())
      parts.push(sshbuf.readPart());
    assert.ok(parts.length >= 1, "key must have at least one part");
    assert.ok(partial || sshbuf.atEnd(), "leftover bytes at end of key");
    var Constructor = Key;
    var algInfo = algs.info[key.type];
    if (type === "private" || algInfo.parts.length !== parts.length) {
      algInfo = algs.privInfo[key.type];
      Constructor = PrivateKey;
    }
    assert.strictEqual(algInfo.parts.length, parts.length);
    if (key.type === "ecdsa") {
      var res = /^ecdsa-sha2-(.+)$/.exec(alg);
      assert.ok(res !== null);
      assert.strictEqual(res[1], parts[0].data.toString());
    }
    var normalized = true;
    for (var i = 0;i < algInfo.parts.length; ++i) {
      var p = parts[i];
      p.name = algInfo.parts[i];
      if (key.type === "ed25519" && p.name === "k")
        p.data = p.data.slice(0, 32);
      if (p.name !== "curve" && algInfo.normalize !== false) {
        var nd;
        if (key.type === "ed25519") {
          nd = utils.zeroPadToLength(p.data, 32);
        } else {
          nd = utils.mpNormalize(p.data);
        }
        if (nd.toString("binary") !== p.data.toString("binary")) {
          p.data = nd;
          normalized = false;
        }
      }
    }
    if (normalized)
      key._rfc4253Cache = sshbuf.toBuffer();
    if (partial && typeof partial === "object") {
      partial.remainder = sshbuf.remainder();
      partial.consumed = sshbuf._offset;
    }
    return new Constructor(key);
  }
  function write(key, options) {
    assert.object(key);
    var alg = keyTypeToAlg(key);
    var i;
    var algInfo = algs.info[key.type];
    if (PrivateKey.isPrivateKey(key))
      algInfo = algs.privInfo[key.type];
    var parts = algInfo.parts;
    var buf = new SSHBuffer({});
    buf.writeString(alg);
    for (i = 0;i < parts.length; ++i) {
      var data = key.part[parts[i]].data;
      if (algInfo.normalize !== false) {
        if (key.type === "ed25519")
          data = utils.zeroPadToLength(data, 32);
        else
          data = utils.mpNormalize(data);
      }
      if (key.type === "ed25519" && parts[i] === "k")
        data = Buffer2.concat([data, key.part.A.data]);
      buf.writeBuffer(data);
    }
    return buf.toBuffer();
  }
});

// backend/node_modules/bcrypt-pbkdf/index.js
var require_bcrypt_pbkdf = __commonJS((exports2, module2) => {
  var crypto_hash_sha512 = require_nacl_fast().lowlevel.crypto_hash;
  var BLF_J = 0;
  var Blowfish = function() {
    this.S = [
      new Uint32Array([
        3509652390,
        2564797868,
        805139163,
        3491422135,
        3101798381,
        1780907670,
        3128725573,
        4046225305,
        614570311,
        3012652279,
        134345442,
        2240740374,
        1667834072,
        1901547113,
        2757295779,
        4103290238,
        227898511,
        1921955416,
        1904987480,
        2182433518,
        2069144605,
        3260701109,
        2620446009,
        720527379,
        3318853667,
        677414384,
        3393288472,
        3101374703,
        2390351024,
        1614419982,
        1822297739,
        2954791486,
        3608508353,
        3174124327,
        2024746970,
        1432378464,
        3864339955,
        2857741204,
        1464375394,
        1676153920,
        1439316330,
        715854006,
        3033291828,
        289532110,
        2706671279,
        2087905683,
        3018724369,
        1668267050,
        732546397,
        1947742710,
        3462151702,
        2609353502,
        2950085171,
        1814351708,
        2050118529,
        680887927,
        999245976,
        1800124847,
        3300911131,
        1713906067,
        1641548236,
        4213287313,
        1216130144,
        1575780402,
        4018429277,
        3917837745,
        3693486850,
        3949271944,
        596196993,
        3549867205,
        258830323,
        2213823033,
        772490370,
        2760122372,
        1774776394,
        2652871518,
        566650946,
        4142492826,
        1728879713,
        2882767088,
        1783734482,
        3629395816,
        2517608232,
        2874225571,
        1861159788,
        326777828,
        3124490320,
        2130389656,
        2716951837,
        967770486,
        1724537150,
        2185432712,
        2364442137,
        1164943284,
        2105845187,
        998989502,
        3765401048,
        2244026483,
        1075463327,
        1455516326,
        1322494562,
        910128902,
        469688178,
        1117454909,
        936433444,
        3490320968,
        3675253459,
        1240580251,
        122909385,
        2157517691,
        634681816,
        4142456567,
        3825094682,
        3061402683,
        2540495037,
        79693498,
        3249098678,
        1084186820,
        1583128258,
        426386531,
        1761308591,
        1047286709,
        322548459,
        995290223,
        1845252383,
        2603652396,
        3431023940,
        2942221577,
        3202600964,
        3727903485,
        1712269319,
        422464435,
        3234572375,
        1170764815,
        3523960633,
        3117677531,
        1434042557,
        442511882,
        3600875718,
        1076654713,
        1738483198,
        4213154764,
        2393238008,
        3677496056,
        1014306527,
        4251020053,
        793779912,
        2902807211,
        842905082,
        4246964064,
        1395751752,
        1040244610,
        2656851899,
        3396308128,
        445077038,
        3742853595,
        3577915638,
        679411651,
        2892444358,
        2354009459,
        1767581616,
        3150600392,
        3791627101,
        3102740896,
        284835224,
        4246832056,
        1258075500,
        768725851,
        2589189241,
        3069724005,
        3532540348,
        1274779536,
        3789419226,
        2764799539,
        1660621633,
        3471099624,
        4011903706,
        913787905,
        3497959166,
        737222580,
        2514213453,
        2928710040,
        3937242737,
        1804850592,
        3499020752,
        2949064160,
        2386320175,
        2390070455,
        2415321851,
        4061277028,
        2290661394,
        2416832540,
        1336762016,
        1754252060,
        3520065937,
        3014181293,
        791618072,
        3188594551,
        3933548030,
        2332172193,
        3852520463,
        3043980520,
        413987798,
        3465142937,
        3030929376,
        4245938359,
        2093235073,
        3534596313,
        375366246,
        2157278981,
        2479649556,
        555357303,
        3870105701,
        2008414854,
        3344188149,
        4221384143,
        3956125452,
        2067696032,
        3594591187,
        2921233993,
        2428461,
        544322398,
        577241275,
        1471733935,
        610547355,
        4027169054,
        1432588573,
        1507829418,
        2025931657,
        3646575487,
        545086370,
        48609733,
        2200306550,
        1653985193,
        298326376,
        1316178497,
        3007786442,
        2064951626,
        458293330,
        2589141269,
        3591329599,
        3164325604,
        727753846,
        2179363840,
        146436021,
        1461446943,
        4069977195,
        705550613,
        3059967265,
        3887724982,
        4281599278,
        3313849956,
        1404054877,
        2845806497,
        146425753,
        1854211946
      ]),
      new Uint32Array([
        1266315497,
        3048417604,
        3681880366,
        3289982499,
        2909710000,
        1235738493,
        2632868024,
        2414719590,
        3970600049,
        1771706367,
        1449415276,
        3266420449,
        422970021,
        1963543593,
        2690192192,
        3826793022,
        1062508698,
        1531092325,
        1804592342,
        2583117782,
        2714934279,
        4024971509,
        1294809318,
        4028980673,
        1289560198,
        2221992742,
        1669523910,
        35572830,
        157838143,
        1052438473,
        1016535060,
        1802137761,
        1753167236,
        1386275462,
        3080475397,
        2857371447,
        1040679964,
        2145300060,
        2390574316,
        1461121720,
        2956646967,
        4031777805,
        4028374788,
        33600511,
        2920084762,
        1018524850,
        629373528,
        3691585981,
        3515945977,
        2091462646,
        2486323059,
        586499841,
        988145025,
        935516892,
        3367335476,
        2599673255,
        2839830854,
        265290510,
        3972581182,
        2759138881,
        3795373465,
        1005194799,
        847297441,
        406762289,
        1314163512,
        1332590856,
        1866599683,
        4127851711,
        750260880,
        613907577,
        1450815602,
        3165620655,
        3734664991,
        3650291728,
        3012275730,
        3704569646,
        1427272223,
        778793252,
        1343938022,
        2676280711,
        2052605720,
        1946737175,
        3164576444,
        3914038668,
        3967478842,
        3682934266,
        1661551462,
        3294938066,
        4011595847,
        840292616,
        3712170807,
        616741398,
        312560963,
        711312465,
        1351876610,
        322626781,
        1910503582,
        271666773,
        2175563734,
        1594956187,
        70604529,
        3617834859,
        1007753275,
        1495573769,
        4069517037,
        2549218298,
        2663038764,
        504708206,
        2263041392,
        3941167025,
        2249088522,
        1514023603,
        1998579484,
        1312622330,
        694541497,
        2582060303,
        2151582166,
        1382467621,
        776784248,
        2618340202,
        3323268794,
        2497899128,
        2784771155,
        503983604,
        4076293799,
        907881277,
        423175695,
        432175456,
        1378068232,
        4145222326,
        3954048622,
        3938656102,
        3820766613,
        2793130115,
        2977904593,
        26017576,
        3274890735,
        3194772133,
        1700274565,
        1756076034,
        4006520079,
        3677328699,
        720338349,
        1533947780,
        354530856,
        688349552,
        3973924725,
        1637815568,
        332179504,
        3949051286,
        53804574,
        2852348879,
        3044236432,
        1282449977,
        3583942155,
        3416972820,
        4006381244,
        1617046695,
        2628476075,
        3002303598,
        1686838959,
        431878346,
        2686675385,
        1700445008,
        1080580658,
        1009431731,
        832498133,
        3223435511,
        2605976345,
        2271191193,
        2516031870,
        1648197032,
        4164389018,
        2548247927,
        300782431,
        375919233,
        238389289,
        3353747414,
        2531188641,
        2019080857,
        1475708069,
        455242339,
        2609103871,
        448939670,
        3451063019,
        1395535956,
        2413381860,
        1841049896,
        1491858159,
        885456874,
        4264095073,
        4001119347,
        1565136089,
        3898914787,
        1108368660,
        540939232,
        1173283510,
        2745871338,
        3681308437,
        4207628240,
        3343053890,
        4016749493,
        1699691293,
        1103962373,
        3625875870,
        2256883143,
        3830138730,
        1031889488,
        3479347698,
        1535977030,
        4236805024,
        3251091107,
        2132092099,
        1774941330,
        1199868427,
        1452454533,
        157007616,
        2904115357,
        342012276,
        595725824,
        1480756522,
        206960106,
        497939518,
        591360097,
        863170706,
        2375253569,
        3596610801,
        1814182875,
        2094937945,
        3421402208,
        1082520231,
        3463918190,
        2785509508,
        435703966,
        3908032597,
        1641649973,
        2842273706,
        3305899714,
        1510255612,
        2148256476,
        2655287854,
        3276092548,
        4258621189,
        236887753,
        3681803219,
        274041037,
        1734335097,
        3815195456,
        3317970021,
        1899903192,
        1026095262,
        4050517792,
        356393447,
        2410691914,
        3873677099,
        3682840055
      ]),
      new Uint32Array([
        3913112168,
        2491498743,
        4132185628,
        2489919796,
        1091903735,
        1979897079,
        3170134830,
        3567386728,
        3557303409,
        857797738,
        1136121015,
        1342202287,
        507115054,
        2535736646,
        337727348,
        3213592640,
        1301675037,
        2528481711,
        1895095763,
        1721773893,
        3216771564,
        62756741,
        2142006736,
        835421444,
        2531993523,
        1442658625,
        3659876326,
        2882144922,
        676362277,
        1392781812,
        170690266,
        3921047035,
        1759253602,
        3611846912,
        1745797284,
        664899054,
        1329594018,
        3901205900,
        3045908486,
        2062866102,
        2865634940,
        3543621612,
        3464012697,
        1080764994,
        553557557,
        3656615353,
        3996768171,
        991055499,
        499776247,
        1265440854,
        648242737,
        3940784050,
        980351604,
        3713745714,
        1749149687,
        3396870395,
        4211799374,
        3640570775,
        1161844396,
        3125318951,
        1431517754,
        545492359,
        4268468663,
        3499529547,
        1437099964,
        2702547544,
        3433638243,
        2581715763,
        2787789398,
        1060185593,
        1593081372,
        2418618748,
        4260947970,
        69676912,
        2159744348,
        86519011,
        2512459080,
        3838209314,
        1220612927,
        3339683548,
        133810670,
        1090789135,
        1078426020,
        1569222167,
        845107691,
        3583754449,
        4072456591,
        1091646820,
        628848692,
        1613405280,
        3757631651,
        526609435,
        236106946,
        48312990,
        2942717905,
        3402727701,
        1797494240,
        859738849,
        992217954,
        4005476642,
        2243076622,
        3870952857,
        3732016268,
        765654824,
        3490871365,
        2511836413,
        1685915746,
        3888969200,
        1414112111,
        2273134842,
        3281911079,
        4080962846,
        172450625,
        2569994100,
        980381355,
        4109958455,
        2819808352,
        2716589560,
        2568741196,
        3681446669,
        3329971472,
        1835478071,
        660984891,
        3704678404,
        4045999559,
        3422617507,
        3040415634,
        1762651403,
        1719377915,
        3470491036,
        2693910283,
        3642056355,
        3138596744,
        1364962596,
        2073328063,
        1983633131,
        926494387,
        3423689081,
        2150032023,
        4096667949,
        1749200295,
        3328846651,
        309677260,
        2016342300,
        1779581495,
        3079819751,
        111262694,
        1274766160,
        443224088,
        298511866,
        1025883608,
        3806446537,
        1145181785,
        168956806,
        3641502830,
        3584813610,
        1689216846,
        3666258015,
        3200248200,
        1692713982,
        2646376535,
        4042768518,
        1618508792,
        1610833997,
        3523052358,
        4130873264,
        2001055236,
        3610705100,
        2202168115,
        4028541809,
        2961195399,
        1006657119,
        2006996926,
        3186142756,
        1430667929,
        3210227297,
        1314452623,
        4074634658,
        4101304120,
        2273951170,
        1399257539,
        3367210612,
        3027628629,
        1190975929,
        2062231137,
        2333990788,
        2221543033,
        2438960610,
        1181637006,
        548689776,
        2362791313,
        3372408396,
        3104550113,
        3145860560,
        296247880,
        1970579870,
        3078560182,
        3769228297,
        1714227617,
        3291629107,
        3898220290,
        166772364,
        1251581989,
        493813264,
        448347421,
        195405023,
        2709975567,
        677966185,
        3703036547,
        1463355134,
        2715995803,
        1338867538,
        1343315457,
        2802222074,
        2684532164,
        233230375,
        2599980071,
        2000651841,
        3277868038,
        1638401717,
        4028070440,
        3237316320,
        6314154,
        819756386,
        300326615,
        590932579,
        1405279636,
        3267499572,
        3150704214,
        2428286686,
        3959192993,
        3461946742,
        1862657033,
        1266418056,
        963775037,
        2089974820,
        2263052895,
        1917689273,
        448879540,
        3550394620,
        3981727096,
        150775221,
        3627908307,
        1303187396,
        508620638,
        2975983352,
        2726630617,
        1817252668,
        1876281319,
        1457606340,
        908771278,
        3720792119,
        3617206836,
        2455994898,
        1729034894,
        1080033504
      ]),
      new Uint32Array([
        976866871,
        3556439503,
        2881648439,
        1522871579,
        1555064734,
        1336096578,
        3548522304,
        2579274686,
        3574697629,
        3205460757,
        3593280638,
        3338716283,
        3079412587,
        564236357,
        2993598910,
        1781952180,
        1464380207,
        3163844217,
        3332601554,
        1699332808,
        1393555694,
        1183702653,
        3581086237,
        1288719814,
        691649499,
        2847557200,
        2895455976,
        3193889540,
        2717570544,
        1781354906,
        1676643554,
        2592534050,
        3230253752,
        1126444790,
        2770207658,
        2633158820,
        2210423226,
        2615765581,
        2414155088,
        3127139286,
        673620729,
        2805611233,
        1269405062,
        4015350505,
        3341807571,
        4149409754,
        1057255273,
        2012875353,
        2162469141,
        2276492801,
        2601117357,
        993977747,
        3918593370,
        2654263191,
        753973209,
        36408145,
        2530585658,
        25011837,
        3520020182,
        2088578344,
        530523599,
        2918365339,
        1524020338,
        1518925132,
        3760827505,
        3759777254,
        1202760957,
        3985898139,
        3906192525,
        674977740,
        4174734889,
        2031300136,
        2019492241,
        3983892565,
        4153806404,
        3822280332,
        352677332,
        2297720250,
        60907813,
        90501309,
        3286998549,
        1016092578,
        2535922412,
        2839152426,
        457141659,
        509813237,
        4120667899,
        652014361,
        1966332200,
        2975202805,
        55981186,
        2327461051,
        676427537,
        3255491064,
        2882294119,
        3433927263,
        1307055953,
        942726286,
        933058658,
        2468411793,
        3933900994,
        4215176142,
        1361170020,
        2001714738,
        2830558078,
        3274259782,
        1222529897,
        1679025792,
        2729314320,
        3714953764,
        1770335741,
        151462246,
        3013232138,
        1682292957,
        1483529935,
        471910574,
        1539241949,
        458788160,
        3436315007,
        1807016891,
        3718408830,
        978976581,
        1043663428,
        3165965781,
        1927990952,
        4200891579,
        2372276910,
        3208408903,
        3533431907,
        1412390302,
        2931980059,
        4132332400,
        1947078029,
        3881505623,
        4168226417,
        2941484381,
        1077988104,
        1320477388,
        886195818,
        18198404,
        3786409000,
        2509781533,
        112762804,
        3463356488,
        1866414978,
        891333506,
        18488651,
        661792760,
        1628790961,
        3885187036,
        3141171499,
        876946877,
        2693282273,
        1372485963,
        791857591,
        2686433993,
        3759982718,
        3167212022,
        3472953795,
        2716379847,
        445679433,
        3561995674,
        3504004811,
        3574258232,
        54117162,
        3331405415,
        2381918588,
        3769707343,
        4154350007,
        1140177722,
        4074052095,
        668550556,
        3214352940,
        367459370,
        261225585,
        2610173221,
        4209349473,
        3468074219,
        3265815641,
        314222801,
        3066103646,
        3808782860,
        282218597,
        3406013506,
        3773591054,
        379116347,
        1285071038,
        846784868,
        2669647154,
        3771962079,
        3550491691,
        2305946142,
        453669953,
        1268987020,
        3317592352,
        3279303384,
        3744833421,
        2610507566,
        3859509063,
        266596637,
        3847019092,
        517658769,
        3462560207,
        3443424879,
        370717030,
        4247526661,
        2224018117,
        4143653529,
        4112773975,
        2788324899,
        2477274417,
        1456262402,
        2901442914,
        1517677493,
        1846949527,
        2295493580,
        3734397586,
        2176403920,
        1280348187,
        1908823572,
        3871786941,
        846861322,
        1172426758,
        3287448474,
        3383383037,
        1655181056,
        3139813346,
        901632758,
        1897031941,
        2986607138,
        3066810236,
        3447102507,
        1393639104,
        373351379,
        950779232,
        625454576,
        3124240540,
        4148612726,
        2007998917,
        544563296,
        2244738638,
        2330496472,
        2058025392,
        1291430526,
        424198748,
        50039436,
        29584100,
        3605783033,
        2429876329,
        2791104160,
        1057563949,
        3255363231,
        3075367218,
        3463963227,
        1469046755,
        985887462
      ])
    ];
    this.P = new Uint32Array([
      608135816,
      2242054355,
      320440878,
      57701188,
      2752067618,
      698298832,
      137296536,
      3964562569,
      1160258022,
      953160567,
      3193202383,
      887688300,
      3232508343,
      3380367581,
      1065670069,
      3041331479,
      2450970073,
      2306472731
    ]);
  };
  function F(S, x8, i) {
    return (S[0][x8[i + 3]] + S[1][x8[i + 2]] ^ S[2][x8[i + 1]]) + S[3][x8[i]];
  }
  Blowfish.prototype.encipher = function(x, x8) {
    if (x8 === undefined) {
      x8 = new Uint8Array(x.buffer);
      if (x.byteOffset !== 0)
        x8 = x8.subarray(x.byteOffset);
    }
    x[0] ^= this.P[0];
    for (var i = 1;i < 16; i += 2) {
      x[1] ^= F(this.S, x8, 0) ^ this.P[i];
      x[0] ^= F(this.S, x8, 4) ^ this.P[i + 1];
    }
    var t = x[0];
    x[0] = x[1] ^ this.P[17];
    x[1] = t;
  };
  Blowfish.prototype.decipher = function(x) {
    var x8 = new Uint8Array(x.buffer);
    if (x.byteOffset !== 0)
      x8 = x8.subarray(x.byteOffset);
    x[0] ^= this.P[17];
    for (var i = 16;i > 0; i -= 2) {
      x[1] ^= F(this.S, x8, 0) ^ this.P[i];
      x[0] ^= F(this.S, x8, 4) ^ this.P[i - 1];
    }
    var t = x[0];
    x[0] = x[1] ^ this.P[0];
    x[1] = t;
  };
  function stream2word(data, databytes) {
    var i, temp = 0;
    for (i = 0;i < 4; i++, BLF_J++) {
      if (BLF_J >= databytes)
        BLF_J = 0;
      temp = temp << 8 | data[BLF_J];
    }
    return temp;
  }
  Blowfish.prototype.expand0state = function(key, keybytes) {
    var d = new Uint32Array(2), i, k;
    var d8 = new Uint8Array(d.buffer);
    for (i = 0, BLF_J = 0;i < 18; i++) {
      this.P[i] ^= stream2word(key, keybytes);
    }
    BLF_J = 0;
    for (i = 0;i < 18; i += 2) {
      this.encipher(d, d8);
      this.P[i] = d[0];
      this.P[i + 1] = d[1];
    }
    for (i = 0;i < 4; i++) {
      for (k = 0;k < 256; k += 2) {
        this.encipher(d, d8);
        this.S[i][k] = d[0];
        this.S[i][k + 1] = d[1];
      }
    }
  };
  Blowfish.prototype.expandstate = function(data, databytes, key, keybytes) {
    var d = new Uint32Array(2), i, k;
    for (i = 0, BLF_J = 0;i < 18; i++) {
      this.P[i] ^= stream2word(key, keybytes);
    }
    for (i = 0, BLF_J = 0;i < 18; i += 2) {
      d[0] ^= stream2word(data, databytes);
      d[1] ^= stream2word(data, databytes);
      this.encipher(d);
      this.P[i] = d[0];
      this.P[i + 1] = d[1];
    }
    for (i = 0;i < 4; i++) {
      for (k = 0;k < 256; k += 2) {
        d[0] ^= stream2word(data, databytes);
        d[1] ^= stream2word(data, databytes);
        this.encipher(d);
        this.S[i][k] = d[0];
        this.S[i][k + 1] = d[1];
      }
    }
    BLF_J = 0;
  };
  Blowfish.prototype.enc = function(data, blocks) {
    for (var i = 0;i < blocks; i++) {
      this.encipher(data.subarray(i * 2));
    }
  };
  Blowfish.prototype.dec = function(data, blocks) {
    for (var i = 0;i < blocks; i++) {
      this.decipher(data.subarray(i * 2));
    }
  };
  var BCRYPT_BLOCKS = 8;
  var BCRYPT_HASHSIZE = 32;
  function bcrypt_hash(sha2pass, sha2salt, out) {
    var state = new Blowfish, cdata = new Uint32Array(BCRYPT_BLOCKS), i, ciphertext = new Uint8Array([
      79,
      120,
      121,
      99,
      104,
      114,
      111,
      109,
      97,
      116,
      105,
      99,
      66,
      108,
      111,
      119,
      102,
      105,
      115,
      104,
      83,
      119,
      97,
      116,
      68,
      121,
      110,
      97,
      109,
      105,
      116,
      101
    ]);
    state.expandstate(sha2salt, 64, sha2pass, 64);
    for (i = 0;i < 64; i++) {
      state.expand0state(sha2salt, 64);
      state.expand0state(sha2pass, 64);
    }
    for (i = 0;i < BCRYPT_BLOCKS; i++)
      cdata[i] = stream2word(ciphertext, ciphertext.byteLength);
    for (i = 0;i < 64; i++)
      state.enc(cdata, cdata.byteLength / 8);
    for (i = 0;i < BCRYPT_BLOCKS; i++) {
      out[4 * i + 3] = cdata[i] >>> 24;
      out[4 * i + 2] = cdata[i] >>> 16;
      out[4 * i + 1] = cdata[i] >>> 8;
      out[4 * i + 0] = cdata[i];
    }
  }
  function bcrypt_pbkdf(pass, passlen, salt, saltlen, key, keylen, rounds) {
    var sha2pass = new Uint8Array(64), sha2salt = new Uint8Array(64), out = new Uint8Array(BCRYPT_HASHSIZE), tmpout = new Uint8Array(BCRYPT_HASHSIZE), countsalt = new Uint8Array(saltlen + 4), i, j, amt, stride, dest, count, origkeylen = keylen;
    if (rounds < 1)
      return -1;
    if (passlen === 0 || saltlen === 0 || keylen === 0 || keylen > out.byteLength * out.byteLength || saltlen > 1 << 20)
      return -1;
    stride = Math.floor((keylen + out.byteLength - 1) / out.byteLength);
    amt = Math.floor((keylen + stride - 1) / stride);
    for (i = 0;i < saltlen; i++)
      countsalt[i] = salt[i];
    crypto_hash_sha512(sha2pass, pass, passlen);
    for (count = 1;keylen > 0; count++) {
      countsalt[saltlen + 0] = count >>> 24;
      countsalt[saltlen + 1] = count >>> 16;
      countsalt[saltlen + 2] = count >>> 8;
      countsalt[saltlen + 3] = count;
      crypto_hash_sha512(sha2salt, countsalt, saltlen + 4);
      bcrypt_hash(sha2pass, sha2salt, tmpout);
      for (i = out.byteLength;i--; )
        out[i] = tmpout[i];
      for (i = 1;i < rounds; i++) {
        crypto_hash_sha512(sha2salt, tmpout, tmpout.byteLength);
        bcrypt_hash(sha2pass, sha2salt, tmpout);
        for (j = 0;j < out.byteLength; j++)
          out[j] ^= tmpout[j];
      }
      amt = Math.min(amt, keylen);
      for (i = 0;i < amt; i++) {
        dest = i * stride + (count - 1);
        if (dest >= origkeylen)
          break;
        key[dest] = out[i];
      }
      keylen -= i;
    }
    return 0;
  }
  module2.exports = {
    BLOCKS: BCRYPT_BLOCKS,
    HASHSIZE: BCRYPT_HASHSIZE,
    hash: bcrypt_hash,
    pbkdf: bcrypt_pbkdf
  };
});

// backend/node_modules/sshpk/lib/formats/ssh-private.js
var require_ssh_private = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    readSSHPrivate,
    write
  };
  var assert = require_assert();
  var asn1 = require_lib3();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils4();
  var crypto3 = require("crypto");
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pem = require_pem();
  var rfc4253 = require_rfc4253();
  var SSHBuffer = require_ssh_buffer();
  var errors = require_errors7();
  var bcrypt;
  function read(buf, options) {
    return pem.read(buf, options);
  }
  var MAGIC = "openssh-key-v1";
  function readSSHPrivate(type, buf, options) {
    buf = new SSHBuffer({ buffer: buf });
    var magic = buf.readCString();
    assert.strictEqual(magic, MAGIC, "bad magic string");
    var cipher = buf.readString();
    var kdf = buf.readString();
    var kdfOpts = buf.readBuffer();
    var nkeys = buf.readInt();
    if (nkeys !== 1) {
      throw new Error("OpenSSH-format key file contains " + "multiple keys: this is unsupported.");
    }
    var pubKey = buf.readBuffer();
    if (type === "public") {
      assert.ok(buf.atEnd(), "excess bytes left after key");
      return rfc4253.read(pubKey);
    }
    var privKeyBlob = buf.readBuffer();
    assert.ok(buf.atEnd(), "excess bytes left after key");
    var kdfOptsBuf = new SSHBuffer({ buffer: kdfOpts });
    switch (kdf) {
      case "none":
        if (cipher !== "none") {
          throw new Error('OpenSSH-format key uses KDF "none" ' + 'but specifies a cipher other than "none"');
        }
        break;
      case "bcrypt":
        var salt = kdfOptsBuf.readBuffer();
        var rounds = kdfOptsBuf.readInt();
        var cinf = utils.opensshCipherInfo(cipher);
        if (bcrypt === undefined) {
          bcrypt = require_bcrypt_pbkdf();
        }
        if (typeof options.passphrase === "string") {
          options.passphrase = Buffer2.from(options.passphrase, "utf-8");
        }
        if (!Buffer2.isBuffer(options.passphrase)) {
          throw new errors.KeyEncryptedError(options.filename, "OpenSSH");
        }
        var pass = new Uint8Array(options.passphrase);
        var salti = new Uint8Array(salt);
        var out = new Uint8Array(cinf.keySize + cinf.blockSize);
        var res = bcrypt.pbkdf(pass, pass.length, salti, salti.length, out, out.length, rounds);
        if (res !== 0) {
          throw new Error("bcrypt_pbkdf function returned " + "failure, parameters invalid");
        }
        out = Buffer2.from(out);
        var ckey = out.slice(0, cinf.keySize);
        var iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);
        var cipherStream = crypto3.createDecipheriv(cinf.opensslName, ckey, iv);
        cipherStream.setAutoPadding(false);
        var chunk, chunks = [];
        cipherStream.once("error", function(e) {
          if (e.toString().indexOf("bad decrypt") !== -1) {
            throw new Error("Incorrect passphrase " + "supplied, could not decrypt key");
          }
          throw e;
        });
        cipherStream.write(privKeyBlob);
        cipherStream.end();
        while ((chunk = cipherStream.read()) !== null)
          chunks.push(chunk);
        privKeyBlob = Buffer2.concat(chunks);
        break;
      default:
        throw new Error('OpenSSH-format key uses unknown KDF "' + kdf + '"');
    }
    buf = new SSHBuffer({ buffer: privKeyBlob });
    var checkInt1 = buf.readInt();
    var checkInt2 = buf.readInt();
    if (checkInt1 !== checkInt2) {
      throw new Error("Incorrect passphrase supplied, could not " + "decrypt key");
    }
    var ret = {};
    var key = rfc4253.readInternal(ret, "private", buf.remainder());
    buf.skip(ret.consumed);
    var comment = buf.readString();
    key.comment = comment;
    return key;
  }
  function write(key, options) {
    var pubKey;
    if (PrivateKey.isPrivateKey(key))
      pubKey = key.toPublic();
    else
      pubKey = key;
    var cipher = "none";
    var kdf = "none";
    var kdfopts = Buffer2.alloc(0);
    var cinf = { blockSize: 8 };
    var passphrase;
    if (options !== undefined) {
      passphrase = options.passphrase;
      if (typeof passphrase === "string")
        passphrase = Buffer2.from(passphrase, "utf-8");
      if (passphrase !== undefined) {
        assert.buffer(passphrase, "options.passphrase");
        assert.optionalString(options.cipher, "options.cipher");
        cipher = options.cipher;
        if (cipher === undefined)
          cipher = "aes128-ctr";
        cinf = utils.opensshCipherInfo(cipher);
        kdf = "bcrypt";
      }
    }
    var privBuf;
    if (PrivateKey.isPrivateKey(key)) {
      privBuf = new SSHBuffer({});
      var checkInt = crypto3.randomBytes(4).readUInt32BE(0);
      privBuf.writeInt(checkInt);
      privBuf.writeInt(checkInt);
      privBuf.write(key.toBuffer("rfc4253"));
      privBuf.writeString(key.comment || "");
      var n = 1;
      while (privBuf._offset % cinf.blockSize !== 0)
        privBuf.writeChar(n++);
      privBuf = privBuf.toBuffer();
    }
    switch (kdf) {
      case "none":
        break;
      case "bcrypt":
        var salt = crypto3.randomBytes(16);
        var rounds = 16;
        var kdfssh = new SSHBuffer({});
        kdfssh.writeBuffer(salt);
        kdfssh.writeInt(rounds);
        kdfopts = kdfssh.toBuffer();
        if (bcrypt === undefined) {
          bcrypt = require_bcrypt_pbkdf();
        }
        var pass = new Uint8Array(passphrase);
        var salti = new Uint8Array(salt);
        var out = new Uint8Array(cinf.keySize + cinf.blockSize);
        var res = bcrypt.pbkdf(pass, pass.length, salti, salti.length, out, out.length, rounds);
        if (res !== 0) {
          throw new Error("bcrypt_pbkdf function returned " + "failure, parameters invalid");
        }
        out = Buffer2.from(out);
        var ckey = out.slice(0, cinf.keySize);
        var iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);
        var cipherStream = crypto3.createCipheriv(cinf.opensslName, ckey, iv);
        cipherStream.setAutoPadding(false);
        var chunk, chunks = [];
        cipherStream.once("error", function(e) {
          throw e;
        });
        cipherStream.write(privBuf);
        cipherStream.end();
        while ((chunk = cipherStream.read()) !== null)
          chunks.push(chunk);
        privBuf = Buffer2.concat(chunks);
        break;
      default:
        throw new Error("Unsupported kdf " + kdf);
    }
    var buf = new SSHBuffer({});
    buf.writeCString(MAGIC);
    buf.writeString(cipher);
    buf.writeString(kdf);
    buf.writeBuffer(kdfopts);
    buf.writeInt(1);
    buf.writeBuffer(pubKey.toBuffer("rfc4253"));
    if (privBuf)
      buf.writeBuffer(privBuf);
    buf = buf.toBuffer();
    var header;
    if (PrivateKey.isPrivateKey(key))
      header = "OPENSSH PRIVATE KEY";
    else
      header = "OPENSSH PUBLIC KEY";
    var tmp = buf.toString("base64");
    var len = tmp.length + tmp.length / 70 + 18 + 16 + header.length * 2 + 10;
    buf = Buffer2.alloc(len);
    var o = 0;
    o += buf.write("-----BEGIN " + header + `-----
`, o);
    for (var i = 0;i < tmp.length; ) {
      var limit2 = i + 70;
      if (limit2 > tmp.length)
        limit2 = tmp.length;
      o += buf.write(tmp.slice(i, limit2), o);
      buf[o++] = 10;
      i = limit2;
    }
    o += buf.write("-----END " + header + `-----
`, o);
    return buf.slice(0, o);
  }
});

// backend/node_modules/sshpk/lib/formats/pem.js
var require_pem = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    write
  };
  var assert = require_assert();
  var asn1 = require_lib3();
  var crypto3 = require("crypto");
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils4();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pkcs1 = require_pkcs1();
  var pkcs8 = require_pkcs8();
  var sshpriv = require_ssh_private();
  var rfc4253 = require_rfc4253();
  var errors = require_errors7();
  var OID_PBES2 = "1.2.840.113549.1.5.13";
  var OID_PBKDF2 = "1.2.840.113549.1.5.12";
  var OID_TO_CIPHER = {
    "1.2.840.113549.3.7": "3des-cbc",
    "2.16.840.1.101.3.4.1.2": "aes128-cbc",
    "2.16.840.1.101.3.4.1.42": "aes256-cbc"
  };
  var CIPHER_TO_OID = {};
  Object.keys(OID_TO_CIPHER).forEach(function(k) {
    CIPHER_TO_OID[OID_TO_CIPHER[k]] = k;
  });
  var OID_TO_HASH = {
    "1.2.840.113549.2.7": "sha1",
    "1.2.840.113549.2.9": "sha256",
    "1.2.840.113549.2.11": "sha512"
  };
  var HASH_TO_OID = {};
  Object.keys(OID_TO_HASH).forEach(function(k) {
    HASH_TO_OID[OID_TO_HASH[k]] = k;
  });
  function read(buf, options, forceType) {
    var input = buf;
    if (typeof buf !== "string") {
      assert.buffer(buf, "buf");
      buf = buf.toString("ascii");
    }
    var lines = buf.trim().split(/[\r\n]+/g);
    var m;
    var si = -1;
    while (!m && si < lines.length) {
      m = lines[++si].match(/[-]+[ ]*BEGIN ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);
    }
    assert.ok(m, "invalid PEM header");
    var m2;
    var ei = lines.length;
    while (!m2 && ei > 0) {
      m2 = lines[--ei].match(/[-]+[ ]*END ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);
    }
    assert.ok(m2, "invalid PEM footer");
    assert.equal(m[2], m2[2]);
    var type = m[2].toLowerCase();
    var alg;
    if (m[1]) {
      assert.equal(m[1], m2[1], "PEM header and footer mismatch");
      alg = m[1].trim();
    }
    lines = lines.slice(si, ei + 1);
    var headers = {};
    while (true) {
      lines = lines.slice(1);
      m = lines[0].match(/^([A-Za-z0-9-]+): (.+)$/);
      if (!m)
        break;
      headers[m[1].toLowerCase()] = m[2];
    }
    lines = lines.slice(0, -1).join("");
    buf = Buffer2.from(lines, "base64");
    var cipher, key, iv;
    if (headers["proc-type"]) {
      var parts = headers["proc-type"].split(",");
      if (parts[0] === "4" && parts[1] === "ENCRYPTED") {
        if (typeof options.passphrase === "string") {
          options.passphrase = Buffer2.from(options.passphrase, "utf-8");
        }
        if (!Buffer2.isBuffer(options.passphrase)) {
          throw new errors.KeyEncryptedError(options.filename, "PEM");
        } else {
          parts = headers["dek-info"].split(",");
          assert.ok(parts.length === 2);
          cipher = parts[0].toLowerCase();
          iv = Buffer2.from(parts[1], "hex");
          key = utils.opensslKeyDeriv(cipher, iv, options.passphrase, 1).key;
        }
      }
    }
    if (alg && alg.toLowerCase() === "encrypted") {
      var eder = new asn1.BerReader(buf);
      var pbesEnd;
      eder.readSequence();
      eder.readSequence();
      pbesEnd = eder.offset + eder.length;
      var method = eder.readOID();
      if (method !== OID_PBES2) {
        throw new Error("Unsupported PEM/PKCS8 encryption " + "scheme: " + method);
      }
      eder.readSequence();
      eder.readSequence();
      var kdfEnd = eder.offset + eder.length;
      var kdfOid = eder.readOID();
      if (kdfOid !== OID_PBKDF2)
        throw new Error("Unsupported PBES2 KDF: " + kdfOid);
      eder.readSequence();
      var salt = eder.readString(asn1.Ber.OctetString, true);
      var iterations = eder.readInt();
      var hashAlg = "sha1";
      if (eder.offset < kdfEnd) {
        eder.readSequence();
        var hashAlgOid = eder.readOID();
        hashAlg = OID_TO_HASH[hashAlgOid];
        if (hashAlg === undefined) {
          throw new Error("Unsupported PBKDF2 hash: " + hashAlgOid);
        }
      }
      eder._offset = kdfEnd;
      eder.readSequence();
      var cipherOid = eder.readOID();
      cipher = OID_TO_CIPHER[cipherOid];
      if (cipher === undefined) {
        throw new Error("Unsupported PBES2 cipher: " + cipherOid);
      }
      iv = eder.readString(asn1.Ber.OctetString, true);
      eder._offset = pbesEnd;
      buf = eder.readString(asn1.Ber.OctetString, true);
      if (typeof options.passphrase === "string") {
        options.passphrase = Buffer2.from(options.passphrase, "utf-8");
      }
      if (!Buffer2.isBuffer(options.passphrase)) {
        throw new errors.KeyEncryptedError(options.filename, "PEM");
      }
      var cinfo = utils.opensshCipherInfo(cipher);
      cipher = cinfo.opensslName;
      key = utils.pbkdf2(hashAlg, salt, iterations, cinfo.keySize, options.passphrase);
      alg = undefined;
    }
    if (cipher && key && iv) {
      var cipherStream = crypto3.createDecipheriv(cipher, key, iv);
      var chunk, chunks = [];
      cipherStream.once("error", function(e) {
        if (e.toString().indexOf("bad decrypt") !== -1) {
          throw new Error("Incorrect passphrase " + "supplied, could not decrypt key");
        }
        throw e;
      });
      cipherStream.write(buf);
      cipherStream.end();
      while ((chunk = cipherStream.read()) !== null)
        chunks.push(chunk);
      buf = Buffer2.concat(chunks);
    }
    if (alg && alg.toLowerCase() === "openssh")
      return sshpriv.readSSHPrivate(type, buf, options);
    if (alg && alg.toLowerCase() === "ssh2")
      return rfc4253.readType(type, buf, options);
    var der = new asn1.BerReader(buf);
    der.originalInput = input;
    der.readSequence();
    if (alg) {
      if (forceType)
        assert.strictEqual(forceType, "pkcs1");
      return pkcs1.readPkcs1(alg, type, der);
    } else {
      if (forceType)
        assert.strictEqual(forceType, "pkcs8");
      return pkcs8.readPkcs8(alg, type, der);
    }
  }
  function write(key, options, type) {
    assert.object(key);
    var alg = {
      ecdsa: "EC",
      rsa: "RSA",
      dsa: "DSA",
      ed25519: "EdDSA"
    }[key.type];
    var header;
    var der = new asn1.BerWriter;
    if (PrivateKey.isPrivateKey(key)) {
      if (type && type === "pkcs8") {
        header = "PRIVATE KEY";
        pkcs8.writePkcs8(der, key);
      } else {
        if (type)
          assert.strictEqual(type, "pkcs1");
        header = alg + " PRIVATE KEY";
        pkcs1.writePkcs1(der, key);
      }
    } else if (Key.isKey(key)) {
      if (type && type === "pkcs1") {
        header = alg + " PUBLIC KEY";
        pkcs1.writePkcs1(der, key);
      } else {
        if (type)
          assert.strictEqual(type, "pkcs8");
        header = "PUBLIC KEY";
        pkcs8.writePkcs8(der, key);
      }
    } else {
      throw new Error("key is not a Key or PrivateKey");
    }
    var tmp = der.buffer.toString("base64");
    var len = tmp.length + tmp.length / 64 + 18 + 16 + header.length * 2 + 10;
    var buf = Buffer2.alloc(len);
    var o = 0;
    o += buf.write("-----BEGIN " + header + `-----
`, o);
    for (var i = 0;i < tmp.length; ) {
      var limit2 = i + 64;
      if (limit2 > tmp.length)
        limit2 = tmp.length;
      o += buf.write(tmp.slice(i, limit2), o);
      buf[o++] = 10;
      i = limit2;
    }
    o += buf.write("-----END " + header + `-----
`, o);
    return buf.slice(0, o);
  }
});

// backend/node_modules/sshpk/lib/formats/ssh.js
var require_ssh = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    write
  };
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var rfc4253 = require_rfc4253();
  var utils = require_utils4();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var sshpriv = require_ssh_private();
  var SSHKEY_RE = /^([a-z0-9-]+)[ \t]+([a-zA-Z0-9+\/]+[=]*)([ \t]+([^ \t][^\n]*[\n]*)?)?$/;
  var SSHKEY_RE2 = /^([a-z0-9-]+)[ \t\n]+([a-zA-Z0-9+\/][a-zA-Z0-9+\/ \t\n=]*)([^a-zA-Z0-9+\/ \t\n=].*)?$/;
  function read(buf, options) {
    if (typeof buf !== "string") {
      assert.buffer(buf, "buf");
      buf = buf.toString("ascii");
    }
    var trimmed = buf.trim().replace(/[\\\r]/g, "");
    var m = trimmed.match(SSHKEY_RE);
    if (!m)
      m = trimmed.match(SSHKEY_RE2);
    assert.ok(m, "key must match regex");
    var type = rfc4253.algToKeyType(m[1]);
    var kbuf = Buffer2.from(m[2], "base64");
    var key;
    var ret = {};
    if (m[4]) {
      try {
        key = rfc4253.read(kbuf);
      } catch (e) {
        m = trimmed.match(SSHKEY_RE2);
        assert.ok(m, "key must match regex");
        kbuf = Buffer2.from(m[2], "base64");
        key = rfc4253.readInternal(ret, "public", kbuf);
      }
    } else {
      key = rfc4253.readInternal(ret, "public", kbuf);
    }
    assert.strictEqual(type, key.type);
    if (m[4] && m[4].length > 0) {
      key.comment = m[4];
    } else if (ret.consumed) {
      var data = m[2] + (m[3] ? m[3] : "");
      var realOffset = Math.ceil(ret.consumed / 3) * 4;
      data = data.slice(0, realOffset - 2).replace(/[^a-zA-Z0-9+\/=]/g, "") + data.slice(realOffset - 2);
      var padding = ret.consumed % 3;
      if (padding > 0 && data.slice(realOffset - 1, realOffset) !== "=")
        realOffset--;
      while (data.slice(realOffset, realOffset + 1) === "=")
        realOffset++;
      var trailer = data.slice(realOffset);
      trailer = trailer.replace(/[\r\n]/g, " ").replace(/^\s+/, "");
      if (trailer.match(/^[a-zA-Z0-9]/))
        key.comment = trailer;
    }
    return key;
  }
  function write(key, options) {
    assert.object(key);
    if (!Key.isKey(key))
      throw new Error("Must be a public key");
    var parts = [];
    var alg = rfc4253.keyTypeToAlg(key);
    parts.push(alg);
    var buf = rfc4253.write(key);
    parts.push(buf.toString("base64"));
    if (key.comment)
      parts.push(key.comment);
    return Buffer2.from(parts.join(" "));
  }
});

// backend/node_modules/sshpk/lib/formats/dnssec.js
var require_dnssec = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    write
  };
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var Key = require_key();
  var PrivateKey = require_private_key();
  var utils = require_utils4();
  var SSHBuffer = require_ssh_buffer();
  var Dhe = require_dhe();
  var supportedAlgos = {
    "rsa-sha1": 5,
    "rsa-sha256": 8,
    "rsa-sha512": 10,
    "ecdsa-p256-sha256": 13,
    "ecdsa-p384-sha384": 14
  };
  var supportedAlgosById = {};
  Object.keys(supportedAlgos).forEach(function(k) {
    supportedAlgosById[supportedAlgos[k]] = k.toUpperCase();
  });
  function read(buf, options) {
    if (typeof buf !== "string") {
      assert.buffer(buf, "buf");
      buf = buf.toString("ascii");
    }
    var lines = buf.split(`
`);
    if (lines[0].match(/^Private-key-format\: v1/)) {
      var algElems = lines[1].split(" ");
      var algoNum = parseInt(algElems[1], 10);
      var algoName = algElems[2];
      if (!supportedAlgosById[algoNum])
        throw new Error("Unsupported algorithm: " + algoName);
      return readDNSSECPrivateKey(algoNum, lines.slice(2));
    }
    var line = 0;
    while (lines[line].match(/^\;/))
      line++;
    if ((lines[line].match(/\. IN KEY /) || lines[line].match(/\. IN DNSKEY /)) && lines[line + 1].length === 0) {
      return readRFC3110(lines[line]);
    }
    throw new Error("Cannot parse dnssec key");
  }
  function readRFC3110(keyString) {
    var elems = keyString.split(" ");
    var algorithm = parseInt(elems[5], 10);
    if (!supportedAlgosById[algorithm])
      throw new Error("Unsupported algorithm: " + algorithm);
    var base64key = elems.slice(6, elems.length).join();
    var keyBuffer = Buffer2.from(base64key, "base64");
    if (supportedAlgosById[algorithm].match(/^RSA-/)) {
      var publicExponentLen = keyBuffer.readUInt8(0);
      if (publicExponentLen != 3 && publicExponentLen != 1)
        throw new Error("Cannot parse dnssec key: " + "unsupported exponent length");
      var publicExponent = keyBuffer.slice(1, publicExponentLen + 1);
      publicExponent = utils.mpNormalize(publicExponent);
      var modulus = keyBuffer.slice(1 + publicExponentLen);
      modulus = utils.mpNormalize(modulus);
      var rsaKey = {
        type: "rsa",
        parts: []
      };
      rsaKey.parts.push({ name: "e", data: publicExponent });
      rsaKey.parts.push({ name: "n", data: modulus });
      return new Key(rsaKey);
    }
    if (supportedAlgosById[algorithm] === "ECDSA-P384-SHA384" || supportedAlgosById[algorithm] === "ECDSA-P256-SHA256") {
      var curve = "nistp384";
      var size = 384;
      if (supportedAlgosById[algorithm].match(/^ECDSA-P256-SHA256/)) {
        curve = "nistp256";
        size = 256;
      }
      var ecdsaKey = {
        type: "ecdsa",
        curve,
        size,
        parts: [
          { name: "curve", data: Buffer2.from(curve) },
          { name: "Q", data: utils.ecNormalize(keyBuffer) }
        ]
      };
      return new Key(ecdsaKey);
    }
    throw new Error("Unsupported algorithm: " + supportedAlgosById[algorithm]);
  }
  function elementToBuf(e) {
    return Buffer2.from(e.split(" ")[1], "base64");
  }
  function readDNSSECRSAPrivateKey(elements) {
    var rsaParams = {};
    elements.forEach(function(element) {
      if (element.split(" ")[0] === "Modulus:")
        rsaParams["n"] = elementToBuf(element);
      else if (element.split(" ")[0] === "PublicExponent:")
        rsaParams["e"] = elementToBuf(element);
      else if (element.split(" ")[0] === "PrivateExponent:")
        rsaParams["d"] = elementToBuf(element);
      else if (element.split(" ")[0] === "Prime1:")
        rsaParams["p"] = elementToBuf(element);
      else if (element.split(" ")[0] === "Prime2:")
        rsaParams["q"] = elementToBuf(element);
      else if (element.split(" ")[0] === "Exponent1:")
        rsaParams["dmodp"] = elementToBuf(element);
      else if (element.split(" ")[0] === "Exponent2:")
        rsaParams["dmodq"] = elementToBuf(element);
      else if (element.split(" ")[0] === "Coefficient:")
        rsaParams["iqmp"] = elementToBuf(element);
    });
    var key = {
      type: "rsa",
      parts: [
        { name: "e", data: utils.mpNormalize(rsaParams["e"]) },
        { name: "n", data: utils.mpNormalize(rsaParams["n"]) },
        { name: "d", data: utils.mpNormalize(rsaParams["d"]) },
        { name: "p", data: utils.mpNormalize(rsaParams["p"]) },
        { name: "q", data: utils.mpNormalize(rsaParams["q"]) },
        {
          name: "dmodp",
          data: utils.mpNormalize(rsaParams["dmodp"])
        },
        {
          name: "dmodq",
          data: utils.mpNormalize(rsaParams["dmodq"])
        },
        {
          name: "iqmp",
          data: utils.mpNormalize(rsaParams["iqmp"])
        }
      ]
    };
    return new PrivateKey(key);
  }
  function readDNSSECPrivateKey(alg, elements) {
    if (supportedAlgosById[alg].match(/^RSA-/)) {
      return readDNSSECRSAPrivateKey(elements);
    }
    if (supportedAlgosById[alg] === "ECDSA-P384-SHA384" || supportedAlgosById[alg] === "ECDSA-P256-SHA256") {
      var d = Buffer2.from(elements[0].split(" ")[1], "base64");
      var curve = "nistp384";
      var size = 384;
      if (supportedAlgosById[alg] === "ECDSA-P256-SHA256") {
        curve = "nistp256";
        size = 256;
      }
      var publicKey = utils.publicFromPrivateECDSA(curve, d);
      var Q = publicKey.part["Q"].data;
      var ecdsaKey = {
        type: "ecdsa",
        curve,
        size,
        parts: [
          { name: "curve", data: Buffer2.from(curve) },
          { name: "d", data: d },
          { name: "Q", data: Q }
        ]
      };
      return new PrivateKey(ecdsaKey);
    }
    throw new Error("Unsupported algorithm: " + supportedAlgosById[alg]);
  }
  function dnssecTimestamp(date) {
    var year = date.getFullYear() + "";
    var month = date.getMonth() + 1;
    var timestampStr = year + month + date.getUTCDate();
    timestampStr += "" + date.getUTCHours() + date.getUTCMinutes();
    timestampStr += date.getUTCSeconds();
    return timestampStr;
  }
  function rsaAlgFromOptions(opts) {
    if (!opts || !opts.hashAlgo || opts.hashAlgo === "sha1")
      return "5 (RSASHA1)";
    else if (opts.hashAlgo === "sha256")
      return "8 (RSASHA256)";
    else if (opts.hashAlgo === "sha512")
      return "10 (RSASHA512)";
    else
      throw new Error("Unknown or unsupported hash: " + opts.hashAlgo);
  }
  function writeRSA(key, options) {
    if (!key.part.dmodp || !key.part.dmodq) {
      utils.addRSAMissing(key);
    }
    var out = "";
    out += `Private-key-format: v1.3
`;
    out += "Algorithm: " + rsaAlgFromOptions(options) + `
`;
    var n = utils.mpDenormalize(key.part["n"].data);
    out += "Modulus: " + n.toString("base64") + `
`;
    var e = utils.mpDenormalize(key.part["e"].data);
    out += "PublicExponent: " + e.toString("base64") + `
`;
    var d = utils.mpDenormalize(key.part["d"].data);
    out += "PrivateExponent: " + d.toString("base64") + `
`;
    var p = utils.mpDenormalize(key.part["p"].data);
    out += "Prime1: " + p.toString("base64") + `
`;
    var q2 = utils.mpDenormalize(key.part["q"].data);
    out += "Prime2: " + q2.toString("base64") + `
`;
    var dmodp = utils.mpDenormalize(key.part["dmodp"].data);
    out += "Exponent1: " + dmodp.toString("base64") + `
`;
    var dmodq = utils.mpDenormalize(key.part["dmodq"].data);
    out += "Exponent2: " + dmodq.toString("base64") + `
`;
    var iqmp = utils.mpDenormalize(key.part["iqmp"].data);
    out += "Coefficient: " + iqmp.toString("base64") + `
`;
    var timestamp = new Date;
    out += "Created: " + dnssecTimestamp(timestamp) + `
`;
    out += "Publish: " + dnssecTimestamp(timestamp) + `
`;
    out += "Activate: " + dnssecTimestamp(timestamp) + `
`;
    return Buffer2.from(out, "ascii");
  }
  function writeECDSA(key, options) {
    var out = "";
    out += `Private-key-format: v1.3
`;
    if (key.curve === "nistp256") {
      out += `Algorithm: 13 (ECDSAP256SHA256)
`;
    } else if (key.curve === "nistp384") {
      out += `Algorithm: 14 (ECDSAP384SHA384)
`;
    } else {
      throw new Error("Unsupported curve");
    }
    var base64Key = key.part["d"].data.toString("base64");
    out += "PrivateKey: " + base64Key + `
`;
    var timestamp = new Date;
    out += "Created: " + dnssecTimestamp(timestamp) + `
`;
    out += "Publish: " + dnssecTimestamp(timestamp) + `
`;
    out += "Activate: " + dnssecTimestamp(timestamp) + `
`;
    return Buffer2.from(out, "ascii");
  }
  function write(key, options) {
    if (PrivateKey.isPrivateKey(key)) {
      if (key.type === "rsa") {
        return writeRSA(key, options);
      } else if (key.type === "ecdsa") {
        return writeECDSA(key, options);
      } else {
        throw new Error("Unsupported algorithm: " + key.type);
      }
    } else if (Key.isKey(key)) {
      throw new Error('Format "dnssec" only supports ' + "writing private keys");
    } else {
      throw new Error("key is not a Key or PrivateKey");
    }
  }
});

// backend/node_modules/sshpk/lib/formats/putty.js
var require_putty = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    write
  };
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var rfc4253 = require_rfc4253();
  var Key = require_key();
  var SSHBuffer = require_ssh_buffer();
  var crypto3 = require("crypto");
  var PrivateKey = require_private_key();
  var errors = require_errors7();
  function read(buf, options) {
    var lines = buf.toString("ascii").split(/[\r\n]+/);
    var found = false;
    var parts;
    var si = 0;
    var formatVersion;
    while (si < lines.length) {
      parts = splitHeader(lines[si++]);
      if (parts) {
        formatVersion = {
          "putty-user-key-file-2": 2,
          "putty-user-key-file-3": 3
        }[parts[0].toLowerCase()];
        if (formatVersion) {
          found = true;
          break;
        }
      }
    }
    if (!found) {
      throw new Error("No PuTTY format first line found");
    }
    var alg = parts[1];
    parts = splitHeader(lines[si++]);
    assert.equal(parts[0].toLowerCase(), "encryption");
    var encryption = parts[1];
    parts = splitHeader(lines[si++]);
    assert.equal(parts[0].toLowerCase(), "comment");
    var comment = parts[1];
    parts = splitHeader(lines[si++]);
    assert.equal(parts[0].toLowerCase(), "public-lines");
    var publicLines = parseInt(parts[1], 10);
    if (!isFinite(publicLines) || publicLines < 0 || publicLines > lines.length) {
      throw new Error("Invalid public-lines count");
    }
    var publicBuf = Buffer2.from(lines.slice(si, si + publicLines).join(""), "base64");
    var keyType = rfc4253.algToKeyType(alg);
    var key = rfc4253.read(publicBuf);
    if (key.type !== keyType) {
      throw new Error("Outer key algorithm mismatch");
    }
    si += publicLines;
    if (lines[si]) {
      parts = splitHeader(lines[si++]);
      assert.equal(parts[0].toLowerCase(), "private-lines");
      var privateLines = parseInt(parts[1], 10);
      if (!isFinite(privateLines) || privateLines < 0 || privateLines > lines.length) {
        throw new Error("Invalid private-lines count");
      }
      var privateBuf = Buffer2.from(lines.slice(si, si + privateLines).join(""), "base64");
      if (encryption !== "none" && formatVersion === 3) {
        throw new Error("Encrypted keys arenot supported for" + " PuTTY format version 3");
      }
      if (encryption === "aes256-cbc") {
        if (!options.passphrase) {
          throw new errors.KeyEncryptedError(options.filename, "PEM");
        }
        var iv = Buffer2.alloc(16, 0);
        var decipher = crypto3.createDecipheriv("aes-256-cbc", derivePPK2EncryptionKey(options.passphrase), iv);
        decipher.setAutoPadding(false);
        privateBuf = Buffer2.concat([
          decipher.update(privateBuf),
          decipher.final()
        ]);
      }
      key = new PrivateKey(key);
      if (key.type !== keyType) {
        throw new Error("Outer key algorithm mismatch");
      }
      var sshbuf = new SSHBuffer({ buffer: privateBuf });
      var privateKeyParts;
      if (alg === "ssh-dss") {
        privateKeyParts = [{
          name: "x",
          data: sshbuf.readBuffer()
        }];
      } else if (alg === "ssh-rsa") {
        privateKeyParts = [
          { name: "d", data: sshbuf.readBuffer() },
          { name: "p", data: sshbuf.readBuffer() },
          { name: "q", data: sshbuf.readBuffer() },
          { name: "iqmp", data: sshbuf.readBuffer() }
        ];
      } else if (alg.match(/^ecdsa-sha2-nistp/)) {
        privateKeyParts = [{
          name: "d",
          data: sshbuf.readBuffer()
        }];
      } else if (alg === "ssh-ed25519") {
        privateKeyParts = [{
          name: "k",
          data: sshbuf.readBuffer()
        }];
      } else {
        throw new Error("Unsupported PPK key type: " + alg);
      }
      key = new PrivateKey({
        type: key.type,
        parts: key.parts.concat(privateKeyParts)
      });
    }
    key.comment = comment;
    return key;
  }
  function derivePPK2EncryptionKey(passphrase) {
    var hash1 = crypto3.createHash("sha1").update(Buffer2.concat([
      Buffer2.from([0, 0, 0, 0]),
      Buffer2.from(passphrase)
    ])).digest();
    var hash2 = crypto3.createHash("sha1").update(Buffer2.concat([
      Buffer2.from([0, 0, 0, 1]),
      Buffer2.from(passphrase)
    ])).digest();
    return Buffer2.concat([hash1, hash2]).slice(0, 32);
  }
  function splitHeader(line) {
    var idx = line.indexOf(":");
    if (idx === -1)
      return null;
    var header = line.slice(0, idx);
    ++idx;
    while (line[idx] === " ")
      ++idx;
    var rest = line.slice(idx);
    return [header, rest];
  }
  function write(key, options) {
    assert.object(key);
    if (!Key.isKey(key))
      throw new Error("Must be a public key");
    var alg = rfc4253.keyTypeToAlg(key);
    var buf = rfc4253.write(key);
    var comment = key.comment || "";
    var b64 = buf.toString("base64");
    var lines = wrap(b64, 64);
    lines.unshift("Public-Lines: " + lines.length);
    lines.unshift("Comment: " + comment);
    lines.unshift("Encryption: none");
    lines.unshift("PuTTY-User-Key-File-2: " + alg);
    return Buffer2.from(lines.join(`
`) + `
`);
  }
  function wrap(txt, len) {
    var lines = [];
    var pos = 0;
    while (pos < txt.length) {
      lines.push(txt.slice(pos, pos + 64));
      pos += 64;
    }
    return lines;
  }
});

// backend/node_modules/sshpk/lib/formats/auto.js
var require_auto = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    write
  };
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var utils = require_utils4();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pem = require_pem();
  var ssh = require_ssh();
  var rfc4253 = require_rfc4253();
  var dnssec = require_dnssec();
  var putty = require_putty();
  var DNSSEC_PRIVKEY_HEADER_PREFIX = "Private-key-format: v1";
  function read(buf, options) {
    if (typeof buf === "string") {
      if (buf.trim().match(/^[-]+[ ]*BEGIN/))
        return pem.read(buf, options);
      if (buf.match(/^\s*ssh-[a-z]/))
        return ssh.read(buf, options);
      if (buf.match(/^\s*ecdsa-/))
        return ssh.read(buf, options);
      if (buf.match(/^putty-user-key-file-2:/i))
        return putty.read(buf, options);
      if (findDNSSECHeader(buf))
        return dnssec.read(buf, options);
      buf = Buffer2.from(buf, "binary");
    } else {
      assert.buffer(buf);
      if (findPEMHeader(buf))
        return pem.read(buf, options);
      if (findSSHHeader(buf))
        return ssh.read(buf, options);
      if (findPuTTYHeader(buf))
        return putty.read(buf, options);
      if (findDNSSECHeader(buf))
        return dnssec.read(buf, options);
    }
    if (buf.readUInt32BE(0) < buf.length)
      return rfc4253.read(buf, options);
    throw new Error("Failed to auto-detect format of key");
  }
  function findPuTTYHeader(buf) {
    var offset = 0;
    while (offset < buf.length && (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9))
      ++offset;
    if (offset + 22 <= buf.length && buf.slice(offset, offset + 22).toString("ascii").toLowerCase() === "putty-user-key-file-2:")
      return true;
    return false;
  }
  function findSSHHeader(buf) {
    var offset = 0;
    while (offset < buf.length && (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9))
      ++offset;
    if (offset + 4 <= buf.length && buf.slice(offset, offset + 4).toString("ascii") === "ssh-")
      return true;
    if (offset + 6 <= buf.length && buf.slice(offset, offset + 6).toString("ascii") === "ecdsa-")
      return true;
    return false;
  }
  function findPEMHeader(buf) {
    var offset = 0;
    while (offset < buf.length && (buf[offset] === 32 || buf[offset] === 10))
      ++offset;
    if (buf[offset] !== 45)
      return false;
    while (offset < buf.length && buf[offset] === 45)
      ++offset;
    while (offset < buf.length && buf[offset] === 32)
      ++offset;
    if (offset + 5 > buf.length || buf.slice(offset, offset + 5).toString("ascii") !== "BEGIN")
      return false;
    return true;
  }
  function findDNSSECHeader(buf) {
    if (buf.length <= DNSSEC_PRIVKEY_HEADER_PREFIX.length)
      return false;
    var headerCheck = buf.slice(0, DNSSEC_PRIVKEY_HEADER_PREFIX.length);
    if (headerCheck.toString("ascii") === DNSSEC_PRIVKEY_HEADER_PREFIX)
      return true;
    if (typeof buf !== "string") {
      buf = buf.toString("ascii");
    }
    var lines = buf.split(`
`);
    var line = 0;
    while (lines[line].match(/^\;/))
      line++;
    if (lines[line].toString("ascii").match(/\. IN KEY /))
      return true;
    if (lines[line].toString("ascii").match(/\. IN DNSKEY /))
      return true;
    return false;
  }
  function write(key, options) {
    throw new Error('"auto" format cannot be used for writing');
  }
});

// backend/node_modules/sshpk/lib/private-key.js
var require_private_key = __commonJS((exports2, module2) => {
  module2.exports = PrivateKey;
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var crypto3 = require("crypto");
  var Fingerprint = require_fingerprint();
  var Signature = require_signature();
  var errs = require_errors7();
  var util3 = require("util");
  var utils = require_utils4();
  var dhe = require_dhe();
  var generateECDSA = dhe.generateECDSA;
  var generateED25519 = dhe.generateED25519;
  var edCompat = require_ed_compat();
  var nacl = require_nacl_fast();
  var Key = require_key();
  var InvalidAlgorithmError = errs.InvalidAlgorithmError;
  var KeyParseError = errs.KeyParseError;
  var KeyEncryptedError = errs.KeyEncryptedError;
  var formats = {};
  formats["auto"] = require_auto();
  formats["pem"] = require_pem();
  formats["pkcs1"] = require_pkcs1();
  formats["pkcs8"] = require_pkcs8();
  formats["rfc4253"] = require_rfc4253();
  formats["ssh-private"] = require_ssh_private();
  formats["openssh"] = formats["ssh-private"];
  formats["ssh"] = formats["ssh-private"];
  formats["dnssec"] = require_dnssec();
  formats["putty"] = require_putty();
  function PrivateKey(opts) {
    assert.object(opts, "options");
    Key.call(this, opts);
    this._pubCache = undefined;
  }
  util3.inherits(PrivateKey, Key);
  PrivateKey.formats = formats;
  PrivateKey.prototype.toBuffer = function(format, options) {
    if (format === undefined)
      format = "pkcs1";
    assert.string(format, "format");
    assert.object(formats[format], "formats[format]");
    assert.optionalObject(options, "options");
    return formats[format].write(this, options);
  };
  PrivateKey.prototype.hash = function(algo, type) {
    return this.toPublic().hash(algo, type);
  };
  PrivateKey.prototype.fingerprint = function(algo, type) {
    return this.toPublic().fingerprint(algo, type);
  };
  PrivateKey.prototype.toPublic = function() {
    if (this._pubCache)
      return this._pubCache;
    var algInfo = algs.info[this.type];
    var pubParts = [];
    for (var i = 0;i < algInfo.parts.length; ++i) {
      var p = algInfo.parts[i];
      pubParts.push(this.part[p]);
    }
    this._pubCache = new Key({
      type: this.type,
      source: this,
      parts: pubParts
    });
    if (this.comment)
      this._pubCache.comment = this.comment;
    return this._pubCache;
  };
  PrivateKey.prototype.derive = function(newType) {
    assert.string(newType, "type");
    var priv, pub, pair;
    if (this.type === "ed25519" && newType === "curve25519") {
      priv = this.part.k.data;
      if (priv[0] === 0)
        priv = priv.slice(1);
      pair = nacl.box.keyPair.fromSecretKey(new Uint8Array(priv));
      pub = Buffer2.from(pair.publicKey);
      return new PrivateKey({
        type: "curve25519",
        parts: [
          { name: "A", data: utils.mpNormalize(pub) },
          { name: "k", data: utils.mpNormalize(priv) }
        ]
      });
    } else if (this.type === "curve25519" && newType === "ed25519") {
      priv = this.part.k.data;
      if (priv[0] === 0)
        priv = priv.slice(1);
      pair = nacl.sign.keyPair.fromSeed(new Uint8Array(priv));
      pub = Buffer2.from(pair.publicKey);
      return new PrivateKey({
        type: "ed25519",
        parts: [
          { name: "A", data: utils.mpNormalize(pub) },
          { name: "k", data: utils.mpNormalize(priv) }
        ]
      });
    }
    throw new Error("Key derivation not supported from " + this.type + " to " + newType);
  };
  PrivateKey.prototype.createVerify = function(hashAlgo) {
    return this.toPublic().createVerify(hashAlgo);
  };
  PrivateKey.prototype.createSign = function(hashAlgo) {
    if (hashAlgo === undefined)
      hashAlgo = this.defaultHashAlgorithm();
    assert.string(hashAlgo, "hash algorithm");
    if (this.type === "ed25519" && edCompat !== undefined)
      return new edCompat.Signer(this, hashAlgo);
    if (this.type === "curve25519")
      throw new Error("Curve25519 keys are not suitable for " + "signing or verification");
    var v, nm, err;
    try {
      nm = hashAlgo.toUpperCase();
      v = crypto3.createSign(nm);
    } catch (e) {
      err = e;
    }
    if (v === undefined || err instanceof Error && err.message.match(/Unknown message digest/)) {
      nm = "RSA-";
      nm += hashAlgo.toUpperCase();
      v = crypto3.createSign(nm);
    }
    assert.ok(v, "failed to create verifier");
    var oldSign = v.sign.bind(v);
    var key = this.toBuffer("pkcs1");
    var type = this.type;
    var curve = this.curve;
    v.sign = function() {
      var sig = oldSign(key);
      if (typeof sig === "string")
        sig = Buffer2.from(sig, "binary");
      sig = Signature.parse(sig, type, "asn1");
      sig.hashAlgorithm = hashAlgo;
      sig.curve = curve;
      return sig;
    };
    return v;
  };
  PrivateKey.parse = function(data, format, options) {
    if (typeof data !== "string")
      assert.buffer(data, "data");
    if (format === undefined)
      format = "auto";
    assert.string(format, "format");
    if (typeof options === "string")
      options = { filename: options };
    assert.optionalObject(options, "options");
    if (options === undefined)
      options = {};
    assert.optionalString(options.filename, "options.filename");
    if (options.filename === undefined)
      options.filename = "(unnamed)";
    assert.object(formats[format], "formats[format]");
    try {
      var k = formats[format].read(data, options);
      assert.ok(k instanceof PrivateKey, "key is not a private key");
      if (!k.comment)
        k.comment = options.filename;
      return k;
    } catch (e) {
      if (e.name === "KeyEncryptedError")
        throw e;
      throw new KeyParseError(options.filename, format, e);
    }
  };
  PrivateKey.isPrivateKey = function(obj2, ver) {
    return utils.isCompatible(obj2, PrivateKey, ver);
  };
  PrivateKey.generate = function(type, options) {
    if (options === undefined)
      options = {};
    assert.object(options, "options");
    switch (type) {
      case "ecdsa":
        if (options.curve === undefined)
          options.curve = "nistp256";
        assert.string(options.curve, "options.curve");
        return generateECDSA(options.curve);
      case "ed25519":
        return generateED25519();
      default:
        throw new Error("Key generation not supported with key " + 'type "' + type + '"');
    }
  };
  PrivateKey.prototype._sshpkApiVersion = [1, 6];
  PrivateKey._oldVersionDetect = function(obj2) {
    assert.func(obj2.toPublic);
    assert.func(obj2.createSign);
    if (obj2.derive)
      return [1, 3];
    if (obj2.defaultHashAlgorithm)
      return [1, 2];
    if (obj2.formats["auto"])
      return [1, 1];
    return [1, 0];
  };
});

// backend/node_modules/sshpk/lib/identity.js
var require_identity = __commonJS((exports2, module2) => {
  module2.exports = Identity;
  var assert = require_assert();
  var algs = require_algs();
  var crypto3 = require("crypto");
  var Fingerprint = require_fingerprint();
  var Signature = require_signature();
  var errs = require_errors7();
  var util3 = require("util");
  var utils = require_utils4();
  var asn1 = require_lib3();
  var Buffer2 = require_safer().Buffer;
  var DNS_NAME_RE = /^([*]|[a-z0-9][a-z0-9\-]{0,62})(?:\.([*]|[a-z0-9][a-z0-9\-]{0,62}))*$/i;
  var oids = {};
  oids.cn = "2.5.4.3";
  oids.o = "2.5.4.10";
  oids.ou = "2.5.4.11";
  oids.l = "2.5.4.7";
  oids.s = "2.5.4.8";
  oids.c = "2.5.4.6";
  oids.sn = "2.5.4.4";
  oids.postalCode = "2.5.4.17";
  oids.serialNumber = "2.5.4.5";
  oids.street = "2.5.4.9";
  oids.x500UniqueIdentifier = "2.5.4.45";
  oids.role = "2.5.4.72";
  oids.telephoneNumber = "2.5.4.20";
  oids.description = "2.5.4.13";
  oids.dc = "0.9.2342.19200300.100.1.25";
  oids.uid = "0.9.2342.19200300.100.1.1";
  oids.mail = "0.9.2342.19200300.100.1.3";
  oids.title = "2.5.4.12";
  oids.gn = "2.5.4.42";
  oids.initials = "2.5.4.43";
  oids.pseudonym = "2.5.4.65";
  oids.emailAddress = "1.2.840.113549.1.9.1";
  var unoids = {};
  Object.keys(oids).forEach(function(k) {
    unoids[oids[k]] = k;
  });
  function Identity(opts) {
    var self2 = this;
    assert.object(opts, "options");
    assert.arrayOfObject(opts.components, "options.components");
    this.components = opts.components;
    this.componentLookup = {};
    this.components.forEach(function(c) {
      if (c.name && !c.oid)
        c.oid = oids[c.name];
      if (c.oid && !c.name)
        c.name = unoids[c.oid];
      if (self2.componentLookup[c.name] === undefined)
        self2.componentLookup[c.name] = [];
      self2.componentLookup[c.name].push(c);
    });
    if (this.componentLookup.cn && this.componentLookup.cn.length > 0) {
      this.cn = this.componentLookup.cn[0].value;
    }
    assert.optionalString(opts.type, "options.type");
    if (opts.type === undefined) {
      if (this.components.length === 1 && this.componentLookup.cn && this.componentLookup.cn.length === 1 && this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {
        this.type = "host";
        this.hostname = this.componentLookup.cn[0].value;
      } else if (this.componentLookup.dc && this.components.length === this.componentLookup.dc.length) {
        this.type = "host";
        this.hostname = this.componentLookup.dc.map(function(c) {
          return c.value;
        }).join(".");
      } else if (this.componentLookup.uid && this.components.length === this.componentLookup.uid.length) {
        this.type = "user";
        this.uid = this.componentLookup.uid[0].value;
      } else if (this.componentLookup.cn && this.componentLookup.cn.length === 1 && this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {
        this.type = "host";
        this.hostname = this.componentLookup.cn[0].value;
      } else if (this.componentLookup.uid && this.componentLookup.uid.length === 1) {
        this.type = "user";
        this.uid = this.componentLookup.uid[0].value;
      } else if (this.componentLookup.mail && this.componentLookup.mail.length === 1) {
        this.type = "email";
        this.email = this.componentLookup.mail[0].value;
      } else if (this.componentLookup.cn && this.componentLookup.cn.length === 1) {
        this.type = "user";
        this.uid = this.componentLookup.cn[0].value;
      } else {
        this.type = "unknown";
      }
    } else {
      this.type = opts.type;
      if (this.type === "host")
        this.hostname = opts.hostname;
      else if (this.type === "user")
        this.uid = opts.uid;
      else if (this.type === "email")
        this.email = opts.email;
      else
        throw new Error("Unknown type " + this.type);
    }
  }
  Identity.prototype.toString = function() {
    return this.components.map(function(c) {
      var n = c.name.toUpperCase();
      n = n.replace(/=/g, "\\=");
      var v = c.value;
      v = v.replace(/,/g, "\\,");
      return n + "=" + v;
    }).join(", ");
  };
  Identity.prototype.get = function(name, asArray) {
    assert.string(name, "name");
    var arr = this.componentLookup[name];
    if (arr === undefined || arr.length === 0)
      return;
    if (!asArray && arr.length > 1)
      throw new Error("Multiple values for attribute " + name);
    if (!asArray)
      return arr[0].value;
    return arr.map(function(c) {
      return c.value;
    });
  };
  Identity.prototype.toArray = function(idx) {
    return this.components.map(function(c) {
      return {
        name: c.name,
        value: c.value
      };
    });
  };
  var NOT_PRINTABLE = /[^a-zA-Z0-9 '(),+.\/:=?-]/;
  var NOT_IA5 = /[^\x00-\x7f]/;
  Identity.prototype.toAsn1 = function(der, tag) {
    der.startSequence(tag);
    this.components.forEach(function(c) {
      der.startSequence(asn1.Ber.Constructor | asn1.Ber.Set);
      der.startSequence();
      der.writeOID(c.oid);
      if (c.asn1type === asn1.Ber.Utf8String || c.value.match(NOT_IA5)) {
        var v = Buffer2.from(c.value, "utf8");
        der.writeBuffer(v, asn1.Ber.Utf8String);
      } else if (c.asn1type === asn1.Ber.IA5String || c.value.match(NOT_PRINTABLE)) {
        der.writeString(c.value, asn1.Ber.IA5String);
      } else {
        var type = asn1.Ber.PrintableString;
        if (c.asn1type !== undefined)
          type = c.asn1type;
        der.writeString(c.value, type);
      }
      der.endSequence();
      der.endSequence();
    });
    der.endSequence();
  };
  function globMatch(a, b) {
    if (a === "**" || b === "**")
      return true;
    var aParts = a.split(".");
    var bParts = b.split(".");
    if (aParts.length !== bParts.length)
      return false;
    for (var i = 0;i < aParts.length; ++i) {
      if (aParts[i] === "*" || bParts[i] === "*")
        continue;
      if (aParts[i] !== bParts[i])
        return false;
    }
    return true;
  }
  Identity.prototype.equals = function(other) {
    if (!Identity.isIdentity(other, [1, 0]))
      return false;
    if (other.components.length !== this.components.length)
      return false;
    for (var i = 0;i < this.components.length; ++i) {
      if (this.components[i].oid !== other.components[i].oid)
        return false;
      if (!globMatch(this.components[i].value, other.components[i].value)) {
        return false;
      }
    }
    return true;
  };
  Identity.forHost = function(hostname) {
    assert.string(hostname, "hostname");
    return new Identity({
      type: "host",
      hostname,
      components: [{ name: "cn", value: hostname }]
    });
  };
  Identity.forUser = function(uid) {
    assert.string(uid, "uid");
    return new Identity({
      type: "user",
      uid,
      components: [{ name: "uid", value: uid }]
    });
  };
  Identity.forEmail = function(email) {
    assert.string(email, "email");
    return new Identity({
      type: "email",
      email,
      components: [{ name: "mail", value: email }]
    });
  };
  Identity.parseDN = function(dn) {
    assert.string(dn, "dn");
    var parts = [""];
    var idx = 0;
    var rem = dn;
    while (rem.length > 0) {
      var m;
      if ((m = /^,/.exec(rem)) !== null) {
        parts[++idx] = "";
        rem = rem.slice(m[0].length);
      } else if ((m = /^\\,/.exec(rem)) !== null) {
        parts[idx] += ",";
        rem = rem.slice(m[0].length);
      } else if ((m = /^\\./.exec(rem)) !== null) {
        parts[idx] += m[0];
        rem = rem.slice(m[0].length);
      } else if ((m = /^[^\\,]+/.exec(rem)) !== null) {
        parts[idx] += m[0];
        rem = rem.slice(m[0].length);
      } else {
        throw new Error("Failed to parse DN");
      }
    }
    var cmps = parts.map(function(c) {
      c = c.trim();
      var eqPos = c.indexOf("=");
      while (eqPos > 0 && c.charAt(eqPos - 1) === "\\")
        eqPos = c.indexOf("=", eqPos + 1);
      if (eqPos === -1) {
        throw new Error("Failed to parse DN");
      }
      var name = c.slice(0, eqPos).toLowerCase().replace(/\\=/g, "=");
      var value = c.slice(eqPos + 1);
      return { name, value };
    });
    return new Identity({ components: cmps });
  };
  Identity.fromArray = function(components) {
    assert.arrayOfObject(components, "components");
    components.forEach(function(cmp) {
      assert.object(cmp, "component");
      assert.string(cmp.name, "component.name");
      if (!Buffer2.isBuffer(cmp.value) && !(typeof cmp.value === "string")) {
        throw new Error("Invalid component value");
      }
    });
    return new Identity({ components });
  };
  Identity.parseAsn1 = function(der, top) {
    var components = [];
    der.readSequence(top);
    var end = der.offset + der.length;
    while (der.offset < end) {
      der.readSequence(asn1.Ber.Constructor | asn1.Ber.Set);
      var after = der.offset + der.length;
      der.readSequence();
      var oid = der.readOID();
      var type = der.peek();
      var value;
      switch (type) {
        case asn1.Ber.PrintableString:
        case asn1.Ber.IA5String:
        case asn1.Ber.OctetString:
        case asn1.Ber.T61String:
          value = der.readString(type);
          break;
        case asn1.Ber.Utf8String:
          value = der.readString(type, true);
          value = value.toString("utf8");
          break;
        case asn1.Ber.CharacterString:
        case asn1.Ber.BMPString:
          value = der.readString(type, true);
          value = value.toString("utf16le");
          break;
        default:
          throw new Error("Unknown asn1 type " + type);
      }
      components.push({ oid, asn1type: type, value });
      der._offset = after;
    }
    der._offset = end;
    return new Identity({
      components
    });
  };
  Identity.isIdentity = function(obj2, ver) {
    return utils.isCompatible(obj2, Identity, ver);
  };
  Identity.prototype._sshpkApiVersion = [1, 0];
  Identity._oldVersionDetect = function(obj2) {
    return [1, 0];
  };
});

// backend/node_modules/sshpk/lib/formats/openssh-cert.js
var require_openssh_cert = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    verify,
    sign,
    signAsync,
    write,
    fromBuffer,
    toBuffer
  };
  var assert = require_assert();
  var SSHBuffer = require_ssh_buffer();
  var crypto3 = require("crypto");
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var Identity = require_identity();
  var rfc4253 = require_rfc4253();
  var Signature = require_signature();
  var utils = require_utils4();
  var Certificate = require_certificate();
  function verify(cert, key) {
    return false;
  }
  var TYPES = {
    user: 1,
    host: 2
  };
  Object.keys(TYPES).forEach(function(k) {
    TYPES[TYPES[k]] = k;
  });
  var ECDSA_ALGO = /^ecdsa-sha2-([^@-]+)-cert-v01@openssh.com$/;
  function read(buf, options) {
    if (Buffer2.isBuffer(buf))
      buf = buf.toString("ascii");
    var parts = buf.trim().split(/[ \t\n]+/g);
    if (parts.length < 2 || parts.length > 3)
      throw new Error("Not a valid SSH certificate line");
    var algo = parts[0];
    var data = parts[1];
    data = Buffer2.from(data, "base64");
    return fromBuffer(data, algo);
  }
  function fromBuffer(data, algo, partial) {
    var sshbuf = new SSHBuffer({ buffer: data });
    var innerAlgo = sshbuf.readString();
    if (algo !== undefined && innerAlgo !== algo)
      throw new Error("SSH certificate algorithm mismatch");
    if (algo === undefined)
      algo = innerAlgo;
    var cert = {};
    cert.signatures = {};
    cert.signatures.openssh = {};
    cert.signatures.openssh.nonce = sshbuf.readBuffer();
    var key = {};
    var parts = key.parts = [];
    key.type = getAlg(algo);
    var partCount = algs.info[key.type].parts.length;
    while (parts.length < partCount)
      parts.push(sshbuf.readPart());
    assert.ok(parts.length >= 1, "key must have at least one part");
    var algInfo = algs.info[key.type];
    if (key.type === "ecdsa") {
      var res = ECDSA_ALGO.exec(algo);
      assert.ok(res !== null);
      assert.strictEqual(res[1], parts[0].data.toString());
    }
    for (var i = 0;i < algInfo.parts.length; ++i) {
      parts[i].name = algInfo.parts[i];
      if (parts[i].name !== "curve" && algInfo.normalize !== false) {
        var p = parts[i];
        p.data = utils.mpNormalize(p.data);
      }
    }
    cert.subjectKey = new Key(key);
    cert.serial = sshbuf.readInt64();
    var type = TYPES[sshbuf.readInt()];
    assert.string(type, "valid cert type");
    cert.signatures.openssh.keyId = sshbuf.readString();
    var principals = [];
    var pbuf = sshbuf.readBuffer();
    var psshbuf = new SSHBuffer({ buffer: pbuf });
    while (!psshbuf.atEnd())
      principals.push(psshbuf.readString());
    if (principals.length === 0)
      principals = ["*"];
    cert.subjects = principals.map(function(pr) {
      if (type === "user")
        return Identity.forUser(pr);
      else if (type === "host")
        return Identity.forHost(pr);
      throw new Error("Unknown identity type " + type);
    });
    cert.validFrom = int64ToDate(sshbuf.readInt64());
    cert.validUntil = int64ToDate(sshbuf.readInt64());
    var exts = [];
    var extbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });
    var ext;
    while (!extbuf.atEnd()) {
      ext = { critical: true };
      ext.name = extbuf.readString();
      ext.data = extbuf.readBuffer();
      exts.push(ext);
    }
    extbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });
    while (!extbuf.atEnd()) {
      ext = { critical: false };
      ext.name = extbuf.readString();
      ext.data = extbuf.readBuffer();
      exts.push(ext);
    }
    cert.signatures.openssh.exts = exts;
    sshbuf.readBuffer();
    var signingKeyBuf = sshbuf.readBuffer();
    cert.issuerKey = rfc4253.read(signingKeyBuf);
    cert.issuer = Identity.forHost("**");
    var sigBuf = sshbuf.readBuffer();
    cert.signatures.openssh.signature = Signature.parse(sigBuf, cert.issuerKey.type, "ssh");
    if (partial !== undefined) {
      partial.remainder = sshbuf.remainder();
      partial.consumed = sshbuf._offset;
    }
    return new Certificate(cert);
  }
  function int64ToDate(buf) {
    var i = buf.readUInt32BE(0) * 4294967296;
    i += buf.readUInt32BE(4);
    var d = new Date;
    d.setTime(i * 1000);
    d.sourceInt64 = buf;
    return d;
  }
  function dateToInt64(date) {
    if (date.sourceInt64 !== undefined)
      return date.sourceInt64;
    var i = Math.round(date.getTime() / 1000);
    var upper = Math.floor(i / 4294967296);
    var lower = Math.floor(i % 4294967296);
    var buf = Buffer2.alloc(8);
    buf.writeUInt32BE(upper, 0);
    buf.writeUInt32BE(lower, 4);
    return buf;
  }
  function sign(cert, key) {
    if (cert.signatures.openssh === undefined)
      cert.signatures.openssh = {};
    try {
      var blob = toBuffer(cert, true);
    } catch (e) {
      delete cert.signatures.openssh;
      return false;
    }
    var sig = cert.signatures.openssh;
    var hashAlgo = undefined;
    if (key.type === "rsa" || key.type === "dsa")
      hashAlgo = "sha1";
    var signer = key.createSign(hashAlgo);
    signer.write(blob);
    sig.signature = signer.sign();
    return true;
  }
  function signAsync(cert, signer, done) {
    if (cert.signatures.openssh === undefined)
      cert.signatures.openssh = {};
    try {
      var blob = toBuffer(cert, true);
    } catch (e) {
      delete cert.signatures.openssh;
      done(e);
      return;
    }
    var sig = cert.signatures.openssh;
    signer(blob, function(err, signature) {
      if (err) {
        done(err);
        return;
      }
      try {
        signature.toBuffer("ssh");
      } catch (e) {
        done(e);
        return;
      }
      sig.signature = signature;
      done();
    });
  }
  function write(cert, options) {
    if (options === undefined)
      options = {};
    var blob = toBuffer(cert);
    var out = getCertType(cert.subjectKey) + " " + blob.toString("base64");
    if (options.comment)
      out = out + " " + options.comment;
    return out;
  }
  function toBuffer(cert, noSig) {
    assert.object(cert.signatures.openssh, "signature for openssh format");
    var sig = cert.signatures.openssh;
    if (sig.nonce === undefined)
      sig.nonce = crypto3.randomBytes(16);
    var buf = new SSHBuffer({});
    buf.writeString(getCertType(cert.subjectKey));
    buf.writeBuffer(sig.nonce);
    var key = cert.subjectKey;
    var algInfo = algs.info[key.type];
    algInfo.parts.forEach(function(part) {
      buf.writePart(key.part[part]);
    });
    buf.writeInt64(cert.serial);
    var type = cert.subjects[0].type;
    assert.notStrictEqual(type, "unknown");
    cert.subjects.forEach(function(id) {
      assert.strictEqual(id.type, type);
    });
    type = TYPES[type];
    buf.writeInt(type);
    if (sig.keyId === undefined) {
      sig.keyId = cert.subjects[0].type + "_" + (cert.subjects[0].uid || cert.subjects[0].hostname);
    }
    buf.writeString(sig.keyId);
    var sub = new SSHBuffer({});
    cert.subjects.forEach(function(id) {
      if (type === TYPES.host)
        sub.writeString(id.hostname);
      else if (type === TYPES.user)
        sub.writeString(id.uid);
    });
    buf.writeBuffer(sub.toBuffer());
    buf.writeInt64(dateToInt64(cert.validFrom));
    buf.writeInt64(dateToInt64(cert.validUntil));
    var exts = sig.exts;
    if (exts === undefined)
      exts = [];
    var extbuf = new SSHBuffer({});
    exts.forEach(function(ext) {
      if (ext.critical !== true)
        return;
      extbuf.writeString(ext.name);
      extbuf.writeBuffer(ext.data);
    });
    buf.writeBuffer(extbuf.toBuffer());
    extbuf = new SSHBuffer({});
    exts.forEach(function(ext) {
      if (ext.critical === true)
        return;
      extbuf.writeString(ext.name);
      extbuf.writeBuffer(ext.data);
    });
    buf.writeBuffer(extbuf.toBuffer());
    buf.writeBuffer(Buffer2.alloc(0));
    sub = rfc4253.write(cert.issuerKey);
    buf.writeBuffer(sub);
    if (!noSig)
      buf.writeBuffer(sig.signature.toBuffer("ssh"));
    return buf.toBuffer();
  }
  function getAlg(certType) {
    if (certType === "ssh-rsa-cert-v01@openssh.com")
      return "rsa";
    if (certType === "ssh-dss-cert-v01@openssh.com")
      return "dsa";
    if (certType.match(ECDSA_ALGO))
      return "ecdsa";
    if (certType === "ssh-ed25519-cert-v01@openssh.com")
      return "ed25519";
    throw new Error("Unsupported cert type " + certType);
  }
  function getCertType(key) {
    if (key.type === "rsa")
      return "ssh-rsa-cert-v01@openssh.com";
    if (key.type === "dsa")
      return "ssh-dss-cert-v01@openssh.com";
    if (key.type === "ecdsa")
      return "ecdsa-sha2-" + key.curve + "-cert-v01@openssh.com";
    if (key.type === "ed25519")
      return "ssh-ed25519-cert-v01@openssh.com";
    throw new Error("Unsupported key type " + key.type);
  }
});

// backend/node_modules/sshpk/lib/formats/x509.js
var require_x509 = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    verify,
    sign,
    signAsync,
    write
  };
  var assert = require_assert();
  var asn1 = require_lib3();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils4();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pem = require_pem();
  var Identity = require_identity();
  var Signature = require_signature();
  var Certificate = require_certificate();
  var pkcs8 = require_pkcs8();
  function readMPInt(der, nm) {
    assert.strictEqual(der.peek(), asn1.Ber.Integer, nm + " is not an Integer");
    return utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
  }
  function verify(cert, key) {
    var sig = cert.signatures.x509;
    assert.object(sig, "x509 signature");
    var algParts = sig.algo.split("-");
    if (algParts[0] !== key.type)
      return false;
    var blob = sig.cache;
    if (blob === undefined) {
      var der = new asn1.BerWriter;
      writeTBSCert(cert, der);
      blob = der.buffer;
    }
    var verifier = key.createVerify(algParts[1]);
    verifier.write(blob);
    return verifier.verify(sig.signature);
  }
  function Local(i) {
    return asn1.Ber.Context | asn1.Ber.Constructor | i;
  }
  function Context2(i) {
    return asn1.Ber.Context | i;
  }
  var SIGN_ALGS = {
    "rsa-md5": "1.2.840.113549.1.1.4",
    "rsa-sha1": "1.2.840.113549.1.1.5",
    "rsa-sha256": "1.2.840.113549.1.1.11",
    "rsa-sha384": "1.2.840.113549.1.1.12",
    "rsa-sha512": "1.2.840.113549.1.1.13",
    "dsa-sha1": "1.2.840.10040.4.3",
    "dsa-sha256": "2.16.840.1.101.3.4.3.2",
    "ecdsa-sha1": "1.2.840.10045.4.1",
    "ecdsa-sha256": "1.2.840.10045.4.3.2",
    "ecdsa-sha384": "1.2.840.10045.4.3.3",
    "ecdsa-sha512": "1.2.840.10045.4.3.4",
    "ed25519-sha512": "1.3.101.112"
  };
  Object.keys(SIGN_ALGS).forEach(function(k) {
    SIGN_ALGS[SIGN_ALGS[k]] = k;
  });
  SIGN_ALGS["1.3.14.3.2.3"] = "rsa-md5";
  SIGN_ALGS["1.3.14.3.2.29"] = "rsa-sha1";
  var EXTS = {
    issuerKeyId: "2.5.29.35",
    altName: "2.5.29.17",
    basicConstraints: "2.5.29.19",
    keyUsage: "2.5.29.15",
    extKeyUsage: "2.5.29.37"
  };
  function read(buf, options) {
    if (typeof buf === "string") {
      buf = Buffer2.from(buf, "binary");
    }
    assert.buffer(buf, "buf");
    var der = new asn1.BerReader(buf);
    der.readSequence();
    if (Math.abs(der.length - der.remain) > 1) {
      throw new Error("DER sequence does not contain whole byte " + "stream");
    }
    var tbsStart = der.offset;
    der.readSequence();
    var sigOffset = der.offset + der.length;
    var tbsEnd = sigOffset;
    if (der.peek() === Local(0)) {
      der.readSequence(Local(0));
      var version = der.readInt();
      assert.ok(version <= 3, "only x.509 versions up to v3 supported");
    }
    var cert = {};
    cert.signatures = {};
    var sig = cert.signatures.x509 = {};
    sig.extras = {};
    cert.serial = readMPInt(der, "serial");
    der.readSequence();
    var after = der.offset + der.length;
    var certAlgOid = der.readOID();
    var certAlg = SIGN_ALGS[certAlgOid];
    if (certAlg === undefined)
      throw new Error("unknown signature algorithm " + certAlgOid);
    der._offset = after;
    cert.issuer = Identity.parseAsn1(der);
    der.readSequence();
    cert.validFrom = readDate(der);
    cert.validUntil = readDate(der);
    cert.subjects = [Identity.parseAsn1(der)];
    der.readSequence();
    after = der.offset + der.length;
    cert.subjectKey = pkcs8.readPkcs8(undefined, "public", der);
    der._offset = after;
    if (der.peek() === Local(1)) {
      der.readSequence(Local(1));
      sig.extras.issuerUniqueID = buf.slice(der.offset, der.offset + der.length);
      der._offset += der.length;
    }
    if (der.peek() === Local(2)) {
      der.readSequence(Local(2));
      sig.extras.subjectUniqueID = buf.slice(der.offset, der.offset + der.length);
      der._offset += der.length;
    }
    if (der.peek() === Local(3)) {
      der.readSequence(Local(3));
      var extEnd = der.offset + der.length;
      der.readSequence();
      while (der.offset < extEnd)
        readExtension(cert, buf, der);
      assert.strictEqual(der.offset, extEnd);
    }
    assert.strictEqual(der.offset, sigOffset);
    der.readSequence();
    after = der.offset + der.length;
    var sigAlgOid = der.readOID();
    var sigAlg = SIGN_ALGS[sigAlgOid];
    if (sigAlg === undefined)
      throw new Error("unknown signature algorithm " + sigAlgOid);
    der._offset = after;
    var sigData = der.readString(asn1.Ber.BitString, true);
    if (sigData[0] === 0)
      sigData = sigData.slice(1);
    var algParts = sigAlg.split("-");
    sig.signature = Signature.parse(sigData, algParts[0], "asn1");
    sig.signature.hashAlgorithm = algParts[1];
    sig.algo = sigAlg;
    sig.cache = buf.slice(tbsStart, tbsEnd);
    return new Certificate(cert);
  }
  function readDate(der) {
    if (der.peek() === asn1.Ber.UTCTime) {
      return utcTimeToDate(der.readString(asn1.Ber.UTCTime));
    } else if (der.peek() === asn1.Ber.GeneralizedTime) {
      return gTimeToDate(der.readString(asn1.Ber.GeneralizedTime));
    } else {
      throw new Error("Unsupported date format");
    }
  }
  function writeDate(der, date) {
    if (date.getUTCFullYear() >= 2050 || date.getUTCFullYear() < 1950) {
      der.writeString(dateToGTime(date), asn1.Ber.GeneralizedTime);
    } else {
      der.writeString(dateToUTCTime(date), asn1.Ber.UTCTime);
    }
  }
  var ALTNAME = {
    OtherName: Local(0),
    RFC822Name: Context2(1),
    DNSName: Context2(2),
    X400Address: Local(3),
    DirectoryName: Local(4),
    EDIPartyName: Local(5),
    URI: Context2(6),
    IPAddress: Context2(7),
    OID: Context2(8)
  };
  var EXTPURPOSE = {
    serverAuth: "1.3.6.1.5.5.7.3.1",
    clientAuth: "1.3.6.1.5.5.7.3.2",
    codeSigning: "1.3.6.1.5.5.7.3.3",
    joyentDocker: "1.3.6.1.4.1.38678.1.4.1",
    joyentCmon: "1.3.6.1.4.1.38678.1.4.2"
  };
  var EXTPURPOSE_REV = {};
  Object.keys(EXTPURPOSE).forEach(function(k) {
    EXTPURPOSE_REV[EXTPURPOSE[k]] = k;
  });
  var KEYUSEBITS = [
    "signature",
    "identity",
    "keyEncryption",
    "encryption",
    "keyAgreement",
    "ca",
    "crl"
  ];
  function readExtension(cert, buf, der) {
    der.readSequence();
    var after = der.offset + der.length;
    var extId = der.readOID();
    var id;
    var sig = cert.signatures.x509;
    if (!sig.extras.exts)
      sig.extras.exts = [];
    var critical;
    if (der.peek() === asn1.Ber.Boolean)
      critical = der.readBoolean();
    switch (extId) {
      case EXTS.basicConstraints:
        der.readSequence(asn1.Ber.OctetString);
        der.readSequence();
        var bcEnd = der.offset + der.length;
        var ca = false;
        if (der.peek() === asn1.Ber.Boolean)
          ca = der.readBoolean();
        if (cert.purposes === undefined)
          cert.purposes = [];
        if (ca === true)
          cert.purposes.push("ca");
        var bc = { oid: extId, critical };
        if (der.offset < bcEnd && der.peek() === asn1.Ber.Integer)
          bc.pathLen = der.readInt();
        sig.extras.exts.push(bc);
        break;
      case EXTS.extKeyUsage:
        der.readSequence(asn1.Ber.OctetString);
        der.readSequence();
        if (cert.purposes === undefined)
          cert.purposes = [];
        var ekEnd = der.offset + der.length;
        while (der.offset < ekEnd) {
          var oid = der.readOID();
          cert.purposes.push(EXTPURPOSE_REV[oid] || oid);
        }
        if (cert.purposes.indexOf("serverAuth") !== -1 && cert.purposes.indexOf("clientAuth") === -1) {
          cert.subjects.forEach(function(ide) {
            if (ide.type !== "host") {
              ide.type = "host";
              ide.hostname = ide.uid || ide.email || ide.components[0].value;
            }
          });
        } else if (cert.purposes.indexOf("clientAuth") !== -1 && cert.purposes.indexOf("serverAuth") === -1) {
          cert.subjects.forEach(function(ide) {
            if (ide.type !== "user") {
              ide.type = "user";
              ide.uid = ide.hostname || ide.email || ide.components[0].value;
            }
          });
        }
        sig.extras.exts.push({ oid: extId, critical });
        break;
      case EXTS.keyUsage:
        der.readSequence(asn1.Ber.OctetString);
        var bits = der.readString(asn1.Ber.BitString, true);
        var setBits = readBitField(bits, KEYUSEBITS);
        setBits.forEach(function(bit) {
          if (cert.purposes === undefined)
            cert.purposes = [];
          if (cert.purposes.indexOf(bit) === -1)
            cert.purposes.push(bit);
        });
        sig.extras.exts.push({
          oid: extId,
          critical,
          bits
        });
        break;
      case EXTS.altName:
        der.readSequence(asn1.Ber.OctetString);
        der.readSequence();
        var aeEnd = der.offset + der.length;
        while (der.offset < aeEnd) {
          switch (der.peek()) {
            case ALTNAME.OtherName:
            case ALTNAME.EDIPartyName:
              der.readSequence();
              der._offset += der.length;
              break;
            case ALTNAME.OID:
              der.readOID(ALTNAME.OID);
              break;
            case ALTNAME.RFC822Name:
              var email = der.readString(ALTNAME.RFC822Name);
              id = Identity.forEmail(email);
              if (!cert.subjects[0].equals(id))
                cert.subjects.push(id);
              break;
            case ALTNAME.DirectoryName:
              der.readSequence(ALTNAME.DirectoryName);
              id = Identity.parseAsn1(der);
              if (!cert.subjects[0].equals(id))
                cert.subjects.push(id);
              break;
            case ALTNAME.DNSName:
              var host = der.readString(ALTNAME.DNSName);
              id = Identity.forHost(host);
              if (!cert.subjects[0].equals(id))
                cert.subjects.push(id);
              break;
            default:
              der.readString(der.peek());
              break;
          }
        }
        sig.extras.exts.push({ oid: extId, critical });
        break;
      default:
        sig.extras.exts.push({
          oid: extId,
          critical,
          data: der.readString(asn1.Ber.OctetString, true)
        });
        break;
    }
    der._offset = after;
  }
  var UTCTIME_RE = /^([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;
  function utcTimeToDate(t) {
    var m = t.match(UTCTIME_RE);
    assert.ok(m, "timestamps must be in UTC");
    var d = new Date;
    var thisYear = d.getUTCFullYear();
    var century = Math.floor(thisYear / 100) * 100;
    var year = parseInt(m[1], 10);
    if (thisYear % 100 < 50 && year >= 60)
      year += century - 1;
    else
      year += century;
    d.setUTCFullYear(year, parseInt(m[2], 10) - 1, parseInt(m[3], 10));
    d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));
    if (m[6] && m[6].length > 0)
      d.setUTCSeconds(parseInt(m[6], 10));
    return d;
  }
  var GTIME_RE = /^([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;
  function gTimeToDate(t) {
    var m = t.match(GTIME_RE);
    assert.ok(m);
    var d = new Date;
    d.setUTCFullYear(parseInt(m[1], 10), parseInt(m[2], 10) - 1, parseInt(m[3], 10));
    d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));
    if (m[6] && m[6].length > 0)
      d.setUTCSeconds(parseInt(m[6], 10));
    return d;
  }
  function zeroPad(n, m) {
    if (m === undefined)
      m = 2;
    var s = "" + n;
    while (s.length < m)
      s = "0" + s;
    return s;
  }
  function dateToUTCTime(d) {
    var s = "";
    s += zeroPad(d.getUTCFullYear() % 100);
    s += zeroPad(d.getUTCMonth() + 1);
    s += zeroPad(d.getUTCDate());
    s += zeroPad(d.getUTCHours());
    s += zeroPad(d.getUTCMinutes());
    s += zeroPad(d.getUTCSeconds());
    s += "Z";
    return s;
  }
  function dateToGTime(d) {
    var s = "";
    s += zeroPad(d.getUTCFullYear(), 4);
    s += zeroPad(d.getUTCMonth() + 1);
    s += zeroPad(d.getUTCDate());
    s += zeroPad(d.getUTCHours());
    s += zeroPad(d.getUTCMinutes());
    s += zeroPad(d.getUTCSeconds());
    s += "Z";
    return s;
  }
  function sign(cert, key) {
    if (cert.signatures.x509 === undefined)
      cert.signatures.x509 = {};
    var sig = cert.signatures.x509;
    sig.algo = key.type + "-" + key.defaultHashAlgorithm();
    if (SIGN_ALGS[sig.algo] === undefined)
      return false;
    var der = new asn1.BerWriter;
    writeTBSCert(cert, der);
    var blob = der.buffer;
    sig.cache = blob;
    var signer = key.createSign();
    signer.write(blob);
    cert.signatures.x509.signature = signer.sign();
    return true;
  }
  function signAsync(cert, signer, done) {
    if (cert.signatures.x509 === undefined)
      cert.signatures.x509 = {};
    var sig = cert.signatures.x509;
    var der = new asn1.BerWriter;
    writeTBSCert(cert, der);
    var blob = der.buffer;
    sig.cache = blob;
    signer(blob, function(err, signature) {
      if (err) {
        done(err);
        return;
      }
      sig.algo = signature.type + "-" + signature.hashAlgorithm;
      if (SIGN_ALGS[sig.algo] === undefined) {
        done(new Error('Invalid signing algorithm "' + sig.algo + '"'));
        return;
      }
      sig.signature = signature;
      done();
    });
  }
  function write(cert, options) {
    var sig = cert.signatures.x509;
    assert.object(sig, "x509 signature");
    var der = new asn1.BerWriter;
    der.startSequence();
    if (sig.cache) {
      der._ensure(sig.cache.length);
      sig.cache.copy(der._buf, der._offset);
      der._offset += sig.cache.length;
    } else {
      writeTBSCert(cert, der);
    }
    der.startSequence();
    der.writeOID(SIGN_ALGS[sig.algo]);
    if (sig.algo.match(/^rsa-/))
      der.writeNull();
    der.endSequence();
    var sigData = sig.signature.toBuffer("asn1");
    var data = Buffer2.alloc(sigData.length + 1);
    data[0] = 0;
    sigData.copy(data, 1);
    der.writeBuffer(data, asn1.Ber.BitString);
    der.endSequence();
    return der.buffer;
  }
  function writeTBSCert(cert, der) {
    var sig = cert.signatures.x509;
    assert.object(sig, "x509 signature");
    der.startSequence();
    der.startSequence(Local(0));
    der.writeInt(2);
    der.endSequence();
    der.writeBuffer(utils.mpNormalize(cert.serial), asn1.Ber.Integer);
    der.startSequence();
    der.writeOID(SIGN_ALGS[sig.algo]);
    if (sig.algo.match(/^rsa-/))
      der.writeNull();
    der.endSequence();
    cert.issuer.toAsn1(der);
    der.startSequence();
    writeDate(der, cert.validFrom);
    writeDate(der, cert.validUntil);
    der.endSequence();
    var subject = cert.subjects[0];
    var altNames = cert.subjects.slice(1);
    subject.toAsn1(der);
    pkcs8.writePkcs8(der, cert.subjectKey);
    if (sig.extras && sig.extras.issuerUniqueID) {
      der.writeBuffer(sig.extras.issuerUniqueID, Local(1));
    }
    if (sig.extras && sig.extras.subjectUniqueID) {
      der.writeBuffer(sig.extras.subjectUniqueID, Local(2));
    }
    if (altNames.length > 0 || subject.type === "host" || cert.purposes !== undefined && cert.purposes.length > 0 || sig.extras && sig.extras.exts) {
      der.startSequence(Local(3));
      der.startSequence();
      var exts = [];
      if (cert.purposes !== undefined && cert.purposes.length > 0) {
        exts.push({
          oid: EXTS.basicConstraints,
          critical: true
        });
        exts.push({
          oid: EXTS.keyUsage,
          critical: true
        });
        exts.push({
          oid: EXTS.extKeyUsage,
          critical: true
        });
      }
      exts.push({ oid: EXTS.altName });
      if (sig.extras && sig.extras.exts)
        exts = sig.extras.exts;
      for (var i = 0;i < exts.length; ++i) {
        der.startSequence();
        der.writeOID(exts[i].oid);
        if (exts[i].critical !== undefined)
          der.writeBoolean(exts[i].critical);
        if (exts[i].oid === EXTS.altName) {
          der.startSequence(asn1.Ber.OctetString);
          der.startSequence();
          if (subject.type === "host") {
            der.writeString(subject.hostname, Context2(2));
          }
          for (var j = 0;j < altNames.length; ++j) {
            if (altNames[j].type === "host") {
              der.writeString(altNames[j].hostname, ALTNAME.DNSName);
            } else if (altNames[j].type === "email") {
              der.writeString(altNames[j].email, ALTNAME.RFC822Name);
            } else {
              der.startSequence(ALTNAME.DirectoryName);
              altNames[j].toAsn1(der);
              der.endSequence();
            }
          }
          der.endSequence();
          der.endSequence();
        } else if (exts[i].oid === EXTS.basicConstraints) {
          der.startSequence(asn1.Ber.OctetString);
          der.startSequence();
          var ca = cert.purposes.indexOf("ca") !== -1;
          var pathLen = exts[i].pathLen;
          der.writeBoolean(ca);
          if (pathLen !== undefined)
            der.writeInt(pathLen);
          der.endSequence();
          der.endSequence();
        } else if (exts[i].oid === EXTS.extKeyUsage) {
          der.startSequence(asn1.Ber.OctetString);
          der.startSequence();
          cert.purposes.forEach(function(purpose) {
            if (purpose === "ca")
              return;
            if (KEYUSEBITS.indexOf(purpose) !== -1)
              return;
            var oid = purpose;
            if (EXTPURPOSE[purpose] !== undefined)
              oid = EXTPURPOSE[purpose];
            der.writeOID(oid);
          });
          der.endSequence();
          der.endSequence();
        } else if (exts[i].oid === EXTS.keyUsage) {
          der.startSequence(asn1.Ber.OctetString);
          if (exts[i].bits !== undefined) {
            der.writeBuffer(exts[i].bits, asn1.Ber.BitString);
          } else {
            var bits = writeBitField(cert.purposes, KEYUSEBITS);
            der.writeBuffer(bits, asn1.Ber.BitString);
          }
          der.endSequence();
        } else {
          der.writeBuffer(exts[i].data, asn1.Ber.OctetString);
        }
        der.endSequence();
      }
      der.endSequence();
      der.endSequence();
    }
    der.endSequence();
  }
  function readBitField(bits, bitIndex) {
    var bitLen = 8 * (bits.length - 1) - bits[0];
    var setBits = {};
    for (var i = 0;i < bitLen; ++i) {
      var byteN = 1 + Math.floor(i / 8);
      var bit = 7 - i % 8;
      var mask = 1 << bit;
      var bitVal = (bits[byteN] & mask) !== 0;
      var name = bitIndex[i];
      if (bitVal && typeof name === "string") {
        setBits[name] = true;
      }
    }
    return Object.keys(setBits);
  }
  function writeBitField(setBits, bitIndex) {
    var bitLen = bitIndex.length;
    var blen = Math.ceil(bitLen / 8);
    var unused = blen * 8 - bitLen;
    var bits = Buffer2.alloc(1 + blen);
    bits[0] = unused;
    for (var i = 0;i < bitLen; ++i) {
      var byteN = 1 + Math.floor(i / 8);
      var bit = 7 - i % 8;
      var mask = 1 << bit;
      var name = bitIndex[i];
      if (name === undefined)
        continue;
      var bitVal = setBits.indexOf(name) !== -1;
      if (bitVal) {
        bits[byteN] |= mask;
      }
    }
    return bits;
  }
});

// backend/node_modules/sshpk/lib/formats/x509-pem.js
var require_x509_pem = __commonJS((exports2, module2) => {
  var x509 = require_x509();
  module2.exports = {
    read,
    verify: x509.verify,
    sign: x509.sign,
    write
  };
  var assert = require_assert();
  var asn1 = require_lib3();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils4();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pem = require_pem();
  var Identity = require_identity();
  var Signature = require_signature();
  var Certificate = require_certificate();
  function read(buf, options) {
    if (typeof buf !== "string") {
      assert.buffer(buf, "buf");
      buf = buf.toString("ascii");
    }
    var lines = buf.trim().split(/[\r\n]+/g);
    var m;
    var si = -1;
    while (!m && si < lines.length) {
      m = lines[++si].match(/[-]+[ ]*BEGIN CERTIFICATE[ ]*[-]+/);
    }
    assert.ok(m, "invalid PEM header");
    var m2;
    var ei = lines.length;
    while (!m2 && ei > 0) {
      m2 = lines[--ei].match(/[-]+[ ]*END CERTIFICATE[ ]*[-]+/);
    }
    assert.ok(m2, "invalid PEM footer");
    lines = lines.slice(si, ei + 1);
    var headers = {};
    while (true) {
      lines = lines.slice(1);
      m = lines[0].match(/^([A-Za-z0-9-]+): (.+)$/);
      if (!m)
        break;
      headers[m[1].toLowerCase()] = m[2];
    }
    lines = lines.slice(0, -1).join("");
    buf = Buffer2.from(lines, "base64");
    return x509.read(buf, options);
  }
  function write(cert, options) {
    var dbuf = x509.write(cert, options);
    var header = "CERTIFICATE";
    var tmp = dbuf.toString("base64");
    var len = tmp.length + tmp.length / 64 + 18 + 16 + header.length * 2 + 10;
    var buf = Buffer2.alloc(len);
    var o = 0;
    o += buf.write("-----BEGIN " + header + `-----
`, o);
    for (var i = 0;i < tmp.length; ) {
      var limit2 = i + 64;
      if (limit2 > tmp.length)
        limit2 = tmp.length;
      o += buf.write(tmp.slice(i, limit2), o);
      buf[o++] = 10;
      i = limit2;
    }
    o += buf.write("-----END " + header + `-----
`, o);
    return buf.slice(0, o);
  }
});

// backend/node_modules/sshpk/lib/certificate.js
var require_certificate = __commonJS((exports2, module2) => {
  module2.exports = Certificate;
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var crypto3 = require("crypto");
  var Fingerprint = require_fingerprint();
  var Signature = require_signature();
  var errs = require_errors7();
  var util3 = require("util");
  var utils = require_utils4();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var Identity = require_identity();
  var formats = {};
  formats["openssh"] = require_openssh_cert();
  formats["x509"] = require_x509();
  formats["pem"] = require_x509_pem();
  var CertificateParseError = errs.CertificateParseError;
  var InvalidAlgorithmError = errs.InvalidAlgorithmError;
  function Certificate(opts) {
    assert.object(opts, "options");
    assert.arrayOfObject(opts.subjects, "options.subjects");
    utils.assertCompatible(opts.subjects[0], Identity, [1, 0], "options.subjects");
    utils.assertCompatible(opts.subjectKey, Key, [1, 0], "options.subjectKey");
    utils.assertCompatible(opts.issuer, Identity, [1, 0], "options.issuer");
    if (opts.issuerKey !== undefined) {
      utils.assertCompatible(opts.issuerKey, Key, [1, 0], "options.issuerKey");
    }
    assert.object(opts.signatures, "options.signatures");
    assert.buffer(opts.serial, "options.serial");
    assert.date(opts.validFrom, "options.validFrom");
    assert.date(opts.validUntil, "optons.validUntil");
    assert.optionalArrayOfString(opts.purposes, "options.purposes");
    this._hashCache = {};
    this.subjects = opts.subjects;
    this.issuer = opts.issuer;
    this.subjectKey = opts.subjectKey;
    this.issuerKey = opts.issuerKey;
    this.signatures = opts.signatures;
    this.serial = opts.serial;
    this.validFrom = opts.validFrom;
    this.validUntil = opts.validUntil;
    this.purposes = opts.purposes;
  }
  Certificate.formats = formats;
  Certificate.prototype.toBuffer = function(format, options) {
    if (format === undefined)
      format = "x509";
    assert.string(format, "format");
    assert.object(formats[format], "formats[format]");
    assert.optionalObject(options, "options");
    return formats[format].write(this, options);
  };
  Certificate.prototype.toString = function(format, options) {
    if (format === undefined)
      format = "pem";
    return this.toBuffer(format, options).toString();
  };
  Certificate.prototype.fingerprint = function(algo) {
    if (algo === undefined)
      algo = "sha256";
    assert.string(algo, "algorithm");
    var opts = {
      type: "certificate",
      hash: this.hash(algo),
      algorithm: algo
    };
    return new Fingerprint(opts);
  };
  Certificate.prototype.hash = function(algo) {
    assert.string(algo, "algorithm");
    algo = algo.toLowerCase();
    if (algs.hashAlgs[algo] === undefined)
      throw new InvalidAlgorithmError(algo);
    if (this._hashCache[algo])
      return this._hashCache[algo];
    var hash = crypto3.createHash(algo).update(this.toBuffer("x509")).digest();
    this._hashCache[algo] = hash;
    return hash;
  };
  Certificate.prototype.isExpired = function(when) {
    if (when === undefined)
      when = new Date;
    return !(when.getTime() >= this.validFrom.getTime() && when.getTime() < this.validUntil.getTime());
  };
  Certificate.prototype.isSignedBy = function(issuerCert) {
    utils.assertCompatible(issuerCert, Certificate, [1, 0], "issuer");
    if (!this.issuer.equals(issuerCert.subjects[0]))
      return false;
    if (this.issuer.purposes && this.issuer.purposes.length > 0 && this.issuer.purposes.indexOf("ca") === -1) {
      return false;
    }
    return this.isSignedByKey(issuerCert.subjectKey);
  };
  Certificate.prototype.getExtension = function(keyOrOid) {
    assert.string(keyOrOid, "keyOrOid");
    var ext = this.getExtensions().filter(function(maybeExt) {
      if (maybeExt.format === "x509")
        return maybeExt.oid === keyOrOid;
      if (maybeExt.format === "openssh")
        return maybeExt.name === keyOrOid;
      return false;
    })[0];
    return ext;
  };
  Certificate.prototype.getExtensions = function() {
    var exts = [];
    var x509 = this.signatures.x509;
    if (x509 && x509.extras && x509.extras.exts) {
      x509.extras.exts.forEach(function(ext) {
        ext.format = "x509";
        exts.push(ext);
      });
    }
    var openssh = this.signatures.openssh;
    if (openssh && openssh.exts) {
      openssh.exts.forEach(function(ext) {
        ext.format = "openssh";
        exts.push(ext);
      });
    }
    return exts;
  };
  Certificate.prototype.isSignedByKey = function(issuerKey) {
    utils.assertCompatible(issuerKey, Key, [1, 2], "issuerKey");
    if (this.issuerKey !== undefined) {
      return this.issuerKey.fingerprint("sha512").matches(issuerKey);
    }
    var fmt = Object.keys(this.signatures)[0];
    var valid = formats[fmt].verify(this, issuerKey);
    if (valid)
      this.issuerKey = issuerKey;
    return valid;
  };
  Certificate.prototype.signWith = function(key) {
    utils.assertCompatible(key, PrivateKey, [1, 2], "key");
    var fmts = Object.keys(formats);
    var didOne = false;
    for (var i = 0;i < fmts.length; ++i) {
      if (fmts[i] !== "pem") {
        var ret = formats[fmts[i]].sign(this, key);
        if (ret === true)
          didOne = true;
      }
    }
    if (!didOne) {
      throw new Error("Failed to sign the certificate for any " + "available certificate formats");
    }
  };
  Certificate.createSelfSigned = function(subjectOrSubjects, key, options) {
    var subjects;
    if (Array.isArray(subjectOrSubjects))
      subjects = subjectOrSubjects;
    else
      subjects = [subjectOrSubjects];
    assert.arrayOfObject(subjects);
    subjects.forEach(function(subject) {
      utils.assertCompatible(subject, Identity, [1, 0], "subject");
    });
    utils.assertCompatible(key, PrivateKey, [1, 2], "private key");
    assert.optionalObject(options, "options");
    if (options === undefined)
      options = {};
    assert.optionalObject(options.validFrom, "options.validFrom");
    assert.optionalObject(options.validUntil, "options.validUntil");
    var validFrom = options.validFrom;
    var validUntil = options.validUntil;
    if (validFrom === undefined)
      validFrom = new Date;
    if (validUntil === undefined) {
      assert.optionalNumber(options.lifetime, "options.lifetime");
      var lifetime = options.lifetime;
      if (lifetime === undefined)
        lifetime = 10 * 365 * 24 * 3600;
      validUntil = new Date;
      validUntil.setTime(validUntil.getTime() + lifetime * 1000);
    }
    assert.optionalBuffer(options.serial, "options.serial");
    var serial = options.serial;
    if (serial === undefined)
      serial = Buffer2.from("0000000000000001", "hex");
    var purposes = options.purposes;
    if (purposes === undefined)
      purposes = [];
    if (purposes.indexOf("signature") === -1)
      purposes.push("signature");
    if (purposes.indexOf("ca") === -1)
      purposes.push("ca");
    if (purposes.indexOf("crl") === -1)
      purposes.push("crl");
    if (purposes.length <= 3) {
      var hostSubjects = subjects.filter(function(subject) {
        return subject.type === "host";
      });
      var userSubjects = subjects.filter(function(subject) {
        return subject.type === "user";
      });
      if (hostSubjects.length > 0) {
        if (purposes.indexOf("serverAuth") === -1)
          purposes.push("serverAuth");
      }
      if (userSubjects.length > 0) {
        if (purposes.indexOf("clientAuth") === -1)
          purposes.push("clientAuth");
      }
      if (userSubjects.length > 0 || hostSubjects.length > 0) {
        if (purposes.indexOf("keyAgreement") === -1)
          purposes.push("keyAgreement");
        if (key.type === "rsa" && purposes.indexOf("encryption") === -1)
          purposes.push("encryption");
      }
    }
    var cert = new Certificate({
      subjects,
      issuer: subjects[0],
      subjectKey: key.toPublic(),
      issuerKey: key.toPublic(),
      signatures: {},
      serial,
      validFrom,
      validUntil,
      purposes
    });
    cert.signWith(key);
    return cert;
  };
  Certificate.create = function(subjectOrSubjects, key, issuer, issuerKey, options) {
    var subjects;
    if (Array.isArray(subjectOrSubjects))
      subjects = subjectOrSubjects;
    else
      subjects = [subjectOrSubjects];
    assert.arrayOfObject(subjects);
    subjects.forEach(function(subject) {
      utils.assertCompatible(subject, Identity, [1, 0], "subject");
    });
    utils.assertCompatible(key, Key, [1, 0], "key");
    if (PrivateKey.isPrivateKey(key))
      key = key.toPublic();
    utils.assertCompatible(issuer, Identity, [1, 0], "issuer");
    utils.assertCompatible(issuerKey, PrivateKey, [1, 2], "issuer key");
    assert.optionalObject(options, "options");
    if (options === undefined)
      options = {};
    assert.optionalObject(options.validFrom, "options.validFrom");
    assert.optionalObject(options.validUntil, "options.validUntil");
    var validFrom = options.validFrom;
    var validUntil = options.validUntil;
    if (validFrom === undefined)
      validFrom = new Date;
    if (validUntil === undefined) {
      assert.optionalNumber(options.lifetime, "options.lifetime");
      var lifetime = options.lifetime;
      if (lifetime === undefined)
        lifetime = 10 * 365 * 24 * 3600;
      validUntil = new Date;
      validUntil.setTime(validUntil.getTime() + lifetime * 1000);
    }
    assert.optionalBuffer(options.serial, "options.serial");
    var serial = options.serial;
    if (serial === undefined)
      serial = Buffer2.from("0000000000000001", "hex");
    var purposes = options.purposes;
    if (purposes === undefined)
      purposes = [];
    if (purposes.indexOf("signature") === -1)
      purposes.push("signature");
    if (options.ca === true) {
      if (purposes.indexOf("ca") === -1)
        purposes.push("ca");
      if (purposes.indexOf("crl") === -1)
        purposes.push("crl");
    }
    var hostSubjects = subjects.filter(function(subject) {
      return subject.type === "host";
    });
    var userSubjects = subjects.filter(function(subject) {
      return subject.type === "user";
    });
    if (hostSubjects.length > 0) {
      if (purposes.indexOf("serverAuth") === -1)
        purposes.push("serverAuth");
    }
    if (userSubjects.length > 0) {
      if (purposes.indexOf("clientAuth") === -1)
        purposes.push("clientAuth");
    }
    if (userSubjects.length > 0 || hostSubjects.length > 0) {
      if (purposes.indexOf("keyAgreement") === -1)
        purposes.push("keyAgreement");
      if (key.type === "rsa" && purposes.indexOf("encryption") === -1)
        purposes.push("encryption");
    }
    var cert = new Certificate({
      subjects,
      issuer,
      subjectKey: key,
      issuerKey: issuerKey.toPublic(),
      signatures: {},
      serial,
      validFrom,
      validUntil,
      purposes
    });
    cert.signWith(issuerKey);
    return cert;
  };
  Certificate.parse = function(data, format, options) {
    if (typeof data !== "string")
      assert.buffer(data, "data");
    if (format === undefined)
      format = "auto";
    assert.string(format, "format");
    if (typeof options === "string")
      options = { filename: options };
    assert.optionalObject(options, "options");
    if (options === undefined)
      options = {};
    assert.optionalString(options.filename, "options.filename");
    if (options.filename === undefined)
      options.filename = "(unnamed)";
    assert.object(formats[format], "formats[format]");
    try {
      var k = formats[format].read(data, options);
      return k;
    } catch (e) {
      throw new CertificateParseError(options.filename, format, e);
    }
  };
  Certificate.isCertificate = function(obj2, ver) {
    return utils.isCompatible(obj2, Certificate, ver);
  };
  Certificate.prototype._sshpkApiVersion = [1, 1];
  Certificate._oldVersionDetect = function(obj2) {
    return [1, 0];
  };
});

// backend/node_modules/sshpk/lib/fingerprint.js
var require_fingerprint = __commonJS((exports2, module2) => {
  module2.exports = Fingerprint;
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var crypto3 = require("crypto");
  var errs = require_errors7();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var Certificate = require_certificate();
  var utils = require_utils4();
  var FingerprintFormatError = errs.FingerprintFormatError;
  var InvalidAlgorithmError = errs.InvalidAlgorithmError;
  function Fingerprint(opts) {
    assert.object(opts, "options");
    assert.string(opts.type, "options.type");
    assert.buffer(opts.hash, "options.hash");
    assert.string(opts.algorithm, "options.algorithm");
    this.algorithm = opts.algorithm.toLowerCase();
    if (algs.hashAlgs[this.algorithm] !== true)
      throw new InvalidAlgorithmError(this.algorithm);
    this.hash = opts.hash;
    this.type = opts.type;
    this.hashType = opts.hashType;
  }
  Fingerprint.prototype.toString = function(format) {
    if (format === undefined) {
      if (this.algorithm === "md5" || this.hashType === "spki")
        format = "hex";
      else
        format = "base64";
    }
    assert.string(format);
    switch (format) {
      case "hex":
        if (this.hashType === "spki")
          return this.hash.toString("hex");
        return addColons(this.hash.toString("hex"));
      case "base64":
        if (this.hashType === "spki")
          return this.hash.toString("base64");
        return sshBase64Format(this.algorithm, this.hash.toString("base64"));
      default:
        throw new FingerprintFormatError(undefined, format);
    }
  };
  Fingerprint.prototype.matches = function(other) {
    assert.object(other, "key or certificate");
    if (this.type === "key" && this.hashType !== "ssh") {
      utils.assertCompatible(other, Key, [1, 7], "key with spki");
      if (PrivateKey.isPrivateKey(other)) {
        utils.assertCompatible(other, PrivateKey, [1, 6], "privatekey with spki support");
      }
    } else if (this.type === "key") {
      utils.assertCompatible(other, Key, [1, 0], "key");
    } else {
      utils.assertCompatible(other, Certificate, [1, 0], "certificate");
    }
    var theirHash = other.hash(this.algorithm, this.hashType);
    var theirHash2 = crypto3.createHash(this.algorithm).update(theirHash).digest("base64");
    if (this.hash2 === undefined)
      this.hash2 = crypto3.createHash(this.algorithm).update(this.hash).digest("base64");
    return this.hash2 === theirHash2;
  };
  var base64RE = /^[A-Za-z0-9+\/=]+$/;
  var hexRE = /^[a-fA-F0-9]+$/;
  Fingerprint.parse = function(fp, options) {
    assert.string(fp, "fingerprint");
    var alg, hash, enAlgs;
    if (Array.isArray(options)) {
      enAlgs = options;
      options = {};
    }
    assert.optionalObject(options, "options");
    if (options === undefined)
      options = {};
    if (options.enAlgs !== undefined)
      enAlgs = options.enAlgs;
    if (options.algorithms !== undefined)
      enAlgs = options.algorithms;
    assert.optionalArrayOfString(enAlgs, "algorithms");
    var hashType = "ssh";
    if (options.hashType !== undefined)
      hashType = options.hashType;
    assert.string(hashType, "options.hashType");
    var parts = fp.split(":");
    if (parts.length == 2) {
      alg = parts[0].toLowerCase();
      if (!base64RE.test(parts[1]))
        throw new FingerprintFormatError(fp);
      try {
        hash = Buffer2.from(parts[1], "base64");
      } catch (e) {
        throw new FingerprintFormatError(fp);
      }
    } else if (parts.length > 2) {
      alg = "md5";
      if (parts[0].toLowerCase() === "md5")
        parts = parts.slice(1);
      parts = parts.map(function(p) {
        while (p.length < 2)
          p = "0" + p;
        if (p.length > 2)
          throw new FingerprintFormatError(fp);
        return p;
      });
      parts = parts.join("");
      if (!hexRE.test(parts) || parts.length % 2 !== 0)
        throw new FingerprintFormatError(fp);
      try {
        hash = Buffer2.from(parts, "hex");
      } catch (e) {
        throw new FingerprintFormatError(fp);
      }
    } else {
      if (hexRE.test(fp)) {
        hash = Buffer2.from(fp, "hex");
      } else if (base64RE.test(fp)) {
        hash = Buffer2.from(fp, "base64");
      } else {
        throw new FingerprintFormatError(fp);
      }
      switch (hash.length) {
        case 32:
          alg = "sha256";
          break;
        case 16:
          alg = "md5";
          break;
        case 20:
          alg = "sha1";
          break;
        case 64:
          alg = "sha512";
          break;
        default:
          throw new FingerprintFormatError(fp);
      }
      if (options.hashType === undefined)
        hashType = "spki";
    }
    if (alg === undefined)
      throw new FingerprintFormatError(fp);
    if (algs.hashAlgs[alg] === undefined)
      throw new InvalidAlgorithmError(alg);
    if (enAlgs !== undefined) {
      enAlgs = enAlgs.map(function(a) {
        return a.toLowerCase();
      });
      if (enAlgs.indexOf(alg) === -1)
        throw new InvalidAlgorithmError(alg);
    }
    return new Fingerprint({
      algorithm: alg,
      hash,
      type: options.type || "key",
      hashType
    });
  };
  function addColons(s) {
    return s.replace(/(.{2})(?=.)/g, "$1:");
  }
  function base64Strip(s) {
    return s.replace(/=*$/, "");
  }
  function sshBase64Format(alg, h) {
    return alg.toUpperCase() + ":" + base64Strip(h);
  }
  Fingerprint.isFingerprint = function(obj2, ver) {
    return utils.isCompatible(obj2, Fingerprint, ver);
  };
  Fingerprint.prototype._sshpkApiVersion = [1, 2];
  Fingerprint._oldVersionDetect = function(obj2) {
    assert.func(obj2.toString);
    assert.func(obj2.matches);
    return [1, 0];
  };
});

// backend/node_modules/sshpk/lib/key.js
var require_key = __commonJS((exports2, module2) => {
  module2.exports = Key;
  var assert = require_assert();
  var algs = require_algs();
  var crypto3 = require("crypto");
  var Fingerprint = require_fingerprint();
  var Signature = require_signature();
  var DiffieHellman = require_dhe().DiffieHellman;
  var errs = require_errors7();
  var utils = require_utils4();
  var PrivateKey = require_private_key();
  var edCompat;
  try {
    edCompat = require_ed_compat();
  } catch (e) {}
  var InvalidAlgorithmError = errs.InvalidAlgorithmError;
  var KeyParseError = errs.KeyParseError;
  var formats = {};
  formats["auto"] = require_auto();
  formats["pem"] = require_pem();
  formats["pkcs1"] = require_pkcs1();
  formats["pkcs8"] = require_pkcs8();
  formats["rfc4253"] = require_rfc4253();
  formats["ssh"] = require_ssh();
  formats["ssh-private"] = require_ssh_private();
  formats["openssh"] = formats["ssh-private"];
  formats["dnssec"] = require_dnssec();
  formats["putty"] = require_putty();
  formats["ppk"] = formats["putty"];
  function Key(opts) {
    assert.object(opts, "options");
    assert.arrayOfObject(opts.parts, "options.parts");
    assert.string(opts.type, "options.type");
    assert.optionalString(opts.comment, "options.comment");
    var algInfo = algs.info[opts.type];
    if (typeof algInfo !== "object")
      throw new InvalidAlgorithmError(opts.type);
    var partLookup = {};
    for (var i = 0;i < opts.parts.length; ++i) {
      var part = opts.parts[i];
      partLookup[part.name] = part;
    }
    this.type = opts.type;
    this.parts = opts.parts;
    this.part = partLookup;
    this.comment = undefined;
    this.source = opts.source;
    this._rfc4253Cache = opts._rfc4253Cache;
    this._hashCache = {};
    var sz;
    this.curve = undefined;
    if (this.type === "ecdsa") {
      var curve = this.part.curve.data.toString();
      this.curve = curve;
      sz = algs.curves[curve].size;
    } else if (this.type === "ed25519" || this.type === "curve25519") {
      sz = 256;
      this.curve = "curve25519";
    } else {
      var szPart = this.part[algInfo.sizePart];
      sz = szPart.data.length;
      sz = sz * 8 - utils.countZeros(szPart.data);
    }
    this.size = sz;
  }
  Key.formats = formats;
  Key.prototype.toBuffer = function(format, options) {
    if (format === undefined)
      format = "ssh";
    assert.string(format, "format");
    assert.object(formats[format], "formats[format]");
    assert.optionalObject(options, "options");
    if (format === "rfc4253") {
      if (this._rfc4253Cache === undefined)
        this._rfc4253Cache = formats["rfc4253"].write(this);
      return this._rfc4253Cache;
    }
    return formats[format].write(this, options);
  };
  Key.prototype.toString = function(format, options) {
    return this.toBuffer(format, options).toString();
  };
  Key.prototype.hash = function(algo, type) {
    assert.string(algo, "algorithm");
    assert.optionalString(type, "type");
    if (type === undefined)
      type = "ssh";
    algo = algo.toLowerCase();
    if (algs.hashAlgs[algo] === undefined)
      throw new InvalidAlgorithmError(algo);
    var cacheKey = algo + "||" + type;
    if (this._hashCache[cacheKey])
      return this._hashCache[cacheKey];
    var buf;
    if (type === "ssh") {
      buf = this.toBuffer("rfc4253");
    } else if (type === "spki") {
      buf = formats.pkcs8.pkcs8ToBuffer(this);
    } else {
      throw new Error("Hash type " + type + " not supported");
    }
    var hash = crypto3.createHash(algo).update(buf).digest();
    this._hashCache[cacheKey] = hash;
    return hash;
  };
  Key.prototype.fingerprint = function(algo, type) {
    if (algo === undefined)
      algo = "sha256";
    if (type === undefined)
      type = "ssh";
    assert.string(algo, "algorithm");
    assert.string(type, "type");
    var opts = {
      type: "key",
      hash: this.hash(algo, type),
      algorithm: algo,
      hashType: type
    };
    return new Fingerprint(opts);
  };
  Key.prototype.defaultHashAlgorithm = function() {
    var hashAlgo = "sha1";
    if (this.type === "rsa")
      hashAlgo = "sha256";
    if (this.type === "dsa" && this.size > 1024)
      hashAlgo = "sha256";
    if (this.type === "ed25519")
      hashAlgo = "sha512";
    if (this.type === "ecdsa") {
      if (this.size <= 256)
        hashAlgo = "sha256";
      else if (this.size <= 384)
        hashAlgo = "sha384";
      else
        hashAlgo = "sha512";
    }
    return hashAlgo;
  };
  Key.prototype.createVerify = function(hashAlgo) {
    if (hashAlgo === undefined)
      hashAlgo = this.defaultHashAlgorithm();
    assert.string(hashAlgo, "hash algorithm");
    if (this.type === "ed25519" && edCompat !== undefined)
      return new edCompat.Verifier(this, hashAlgo);
    if (this.type === "curve25519")
      throw new Error("Curve25519 keys are not suitable for " + "signing or verification");
    var v, nm, err;
    try {
      nm = hashAlgo.toUpperCase();
      v = crypto3.createVerify(nm);
    } catch (e) {
      err = e;
    }
    if (v === undefined || err instanceof Error && err.message.match(/Unknown message digest/)) {
      nm = "RSA-";
      nm += hashAlgo.toUpperCase();
      v = crypto3.createVerify(nm);
    }
    assert.ok(v, "failed to create verifier");
    var oldVerify = v.verify.bind(v);
    var key = this.toBuffer("pkcs8");
    var curve = this.curve;
    var self2 = this;
    v.verify = function(signature, fmt) {
      if (Signature.isSignature(signature, [2, 0])) {
        if (signature.type !== self2.type)
          return false;
        if (signature.hashAlgorithm && signature.hashAlgorithm !== hashAlgo)
          return false;
        if (signature.curve && self2.type === "ecdsa" && signature.curve !== curve)
          return false;
        return oldVerify(key, signature.toBuffer("asn1"));
      } else if (typeof signature === "string" || Buffer.isBuffer(signature)) {
        return oldVerify(key, signature, fmt);
      } else if (Signature.isSignature(signature, [1, 0])) {
        throw new Error("signature was created by too old " + "a version of sshpk and cannot be verified");
      } else {
        throw new TypeError("signature must be a string, " + "Buffer, or Signature object");
      }
    };
    return v;
  };
  Key.prototype.createDiffieHellman = function() {
    if (this.type === "rsa")
      throw new Error("RSA keys do not support Diffie-Hellman");
    return new DiffieHellman(this);
  };
  Key.prototype.createDH = Key.prototype.createDiffieHellman;
  Key.parse = function(data, format, options) {
    if (typeof data !== "string")
      assert.buffer(data, "data");
    if (format === undefined)
      format = "auto";
    assert.string(format, "format");
    if (typeof options === "string")
      options = { filename: options };
    assert.optionalObject(options, "options");
    if (options === undefined)
      options = {};
    assert.optionalString(options.filename, "options.filename");
    if (options.filename === undefined)
      options.filename = "(unnamed)";
    assert.object(formats[format], "formats[format]");
    try {
      var k = formats[format].read(data, options);
      if (k instanceof PrivateKey)
        k = k.toPublic();
      if (!k.comment)
        k.comment = options.filename;
      return k;
    } catch (e) {
      if (e.name === "KeyEncryptedError")
        throw e;
      throw new KeyParseError(options.filename, format, e);
    }
  };
  Key.isKey = function(obj2, ver) {
    return utils.isCompatible(obj2, Key, ver);
  };
  Key.prototype._sshpkApiVersion = [1, 7];
  Key._oldVersionDetect = function(obj2) {
    assert.func(obj2.toBuffer);
    assert.func(obj2.fingerprint);
    if (obj2.createDH)
      return [1, 4];
    if (obj2.defaultHashAlgorithm)
      return [1, 3];
    if (obj2.formats["auto"])
      return [1, 2];
    if (obj2.formats["pkcs1"])
      return [1, 1];
    return [1, 0];
  };
});

// backend/node_modules/sshpk/lib/index.js
var require_lib4 = __commonJS((exports2, module2) => {
  var Key = require_key();
  var Fingerprint = require_fingerprint();
  var Signature = require_signature();
  var PrivateKey = require_private_key();
  var Certificate = require_certificate();
  var Identity = require_identity();
  var errs = require_errors7();
  module2.exports = {
    Key,
    parseKey: Key.parse,
    Fingerprint,
    parseFingerprint: Fingerprint.parse,
    Signature,
    parseSignature: Signature.parse,
    PrivateKey,
    parsePrivateKey: PrivateKey.parse,
    generatePrivateKey: PrivateKey.generate,
    Certificate,
    parseCertificate: Certificate.parse,
    createSelfSignedCertificate: Certificate.createSelfSigned,
    createCertificate: Certificate.create,
    Identity,
    identityFromDN: Identity.parseDN,
    identityForHost: Identity.forHost,
    identityForUser: Identity.forUser,
    identityForEmail: Identity.forEmail,
    identityFromArray: Identity.fromArray,
    FingerprintFormatError: errs.FingerprintFormatError,
    InvalidAlgorithmError: errs.InvalidAlgorithmError,
    KeyParseError: errs.KeyParseError,
    SignatureParseError: errs.SignatureParseError,
    KeyEncryptedError: errs.KeyEncryptedError,
    CertificateParseError: errs.CertificateParseError
  };
});

// backend/node_modules/http-signature/lib/utils.js
var require_utils5 = __commonJS((exports2, module2) => {
  var assert = require_assert();
  var sshpk = require_lib4();
  var util3 = require("util");
  var HASH_ALGOS = {
    sha1: true,
    sha256: true,
    sha512: true
  };
  var PK_ALGOS = {
    rsa: true,
    dsa: true,
    ecdsa: true,
    ed25519: true
  };
  var HEADER = {
    AUTH: "authorization",
    SIG: "signature"
  };
  function HttpSignatureError(message, caller) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, caller || HttpSignatureError);
    this.message = message;
    this.name = caller.name;
  }
  util3.inherits(HttpSignatureError, Error);
  function InvalidAlgorithmError(message) {
    HttpSignatureError.call(this, message, InvalidAlgorithmError);
  }
  util3.inherits(InvalidAlgorithmError, HttpSignatureError);
  function validateAlgorithm(algorithm) {
    var alg = algorithm.toLowerCase().split("-");
    if (alg.length !== 2) {
      throw new InvalidAlgorithmError(alg[0].toUpperCase() + " is not a " + "valid algorithm");
    }
    if (alg[0] !== "hmac" && !PK_ALGOS[alg[0]]) {
      throw new InvalidAlgorithmError(alg[0].toUpperCase() + " type keys " + "are not supported");
    }
    if (!HASH_ALGOS[alg[1]]) {
      throw new InvalidAlgorithmError(alg[1].toUpperCase() + " is not a " + "supported hash algorithm");
    }
    return alg;
  }
  module2.exports = {
    HEADER,
    HASH_ALGOS,
    PK_ALGOS,
    HttpSignatureError,
    InvalidAlgorithmError,
    validateAlgorithm,
    sshKeyToPEM: function sshKeyToPEM(key) {
      assert.string(key, "ssh_key");
      var k = sshpk.parseKey(key, "ssh");
      return k.toString("pem");
    },
    fingerprint: function fingerprint(key) {
      assert.string(key, "ssh_key");
      var k = sshpk.parseKey(key, "ssh");
      return k.fingerprint("md5").toString("hex");
    },
    pemToRsaSSHKey: function pemToRsaSSHKey(pem, comment) {
      assert.equal("string", typeof pem, "typeof pem");
      var k = sshpk.parseKey(pem, "pem");
      k.comment = comment;
      return k.toString("ssh");
    }
  };
});

// backend/node_modules/http-signature/lib/parser.js
var require_parser = __commonJS((exports2, module2) => {
  var assert = require_assert();
  var util3 = require("util");
  var utils = require_utils5();
  var HASH_ALGOS = utils.HASH_ALGOS;
  var PK_ALGOS = utils.PK_ALGOS;
  var HttpSignatureError = utils.HttpSignatureError;
  var InvalidAlgorithmError = utils.InvalidAlgorithmError;
  var validateAlgorithm = utils.validateAlgorithm;
  var State = {
    New: 0,
    Params: 1
  };
  var ParamsState = {
    Name: 0,
    Quote: 1,
    Value: 2,
    Comma: 3,
    Number: 4
  };
  function ExpiredRequestError(message) {
    HttpSignatureError.call(this, message, ExpiredRequestError);
  }
  util3.inherits(ExpiredRequestError, HttpSignatureError);
  function InvalidHeaderError(message) {
    HttpSignatureError.call(this, message, InvalidHeaderError);
  }
  util3.inherits(InvalidHeaderError, HttpSignatureError);
  function InvalidParamsError(message) {
    HttpSignatureError.call(this, message, InvalidParamsError);
  }
  util3.inherits(InvalidParamsError, HttpSignatureError);
  function MissingHeaderError(message) {
    HttpSignatureError.call(this, message, MissingHeaderError);
  }
  util3.inherits(MissingHeaderError, HttpSignatureError);
  function StrictParsingError(message) {
    HttpSignatureError.call(this, message, StrictParsingError);
  }
  util3.inherits(StrictParsingError, HttpSignatureError);
  module2.exports = {
    parseRequest: function parseRequest(request, options) {
      assert.object(request, "request");
      assert.object(request.headers, "request.headers");
      if (options === undefined) {
        options = {};
      }
      assert.object(options, "options");
      assert.optionalFinite(options.clockSkew, "options.clockSkew");
      var headers = [request.headers["x-date"] ? "x-date" : "date"];
      if (options.headers !== undefined) {
        assert.arrayOfString(headers, "options.headers");
        headers = options.headers;
      }
      var authzHeaderName = options.authorizationHeaderName;
      var authz = request.headers[authzHeaderName] || request.headers[utils.HEADER.AUTH] || request.headers[utils.HEADER.SIG];
      if (!authz) {
        var errHeader = authzHeaderName ? authzHeaderName : utils.HEADER.AUTH + " or " + utils.HEADER.SIG;
        throw new MissingHeaderError("no " + errHeader + " header " + "present in the request");
      }
      options.clockSkew = options.clockSkew || 300;
      var i = 0;
      var state = authz === request.headers[utils.HEADER.SIG] ? State.Params : State.New;
      var substate = ParamsState.Name;
      var tmpName = "";
      var tmpValue = "";
      var parsed = {
        scheme: authz === request.headers[utils.HEADER.SIG] ? "Signature" : "",
        params: {},
        signingString: ""
      };
      for (i = 0;i < authz.length; i++) {
        var c = authz.charAt(i);
        switch (Number(state)) {
          case State.New:
            if (c !== " ")
              parsed.scheme += c;
            else
              state = State.Params;
            break;
          case State.Params:
            switch (Number(substate)) {
              case ParamsState.Name:
                var code = c.charCodeAt(0);
                if (code >= 65 && code <= 90 || code >= 97 && code <= 122) {
                  tmpName += c;
                } else if (c === "=") {
                  if (tmpName.length === 0)
                    throw new InvalidHeaderError("bad param format");
                  substate = ParamsState.Quote;
                } else {
                  throw new InvalidHeaderError("bad param format");
                }
                break;
              case ParamsState.Quote:
                if (c === '"') {
                  tmpValue = "";
                  substate = ParamsState.Value;
                } else {
                  substate = ParamsState.Number;
                  code = c.charCodeAt(0);
                  if (code < 48 || code > 57) {
                    throw new InvalidHeaderError("bad param format");
                  }
                  tmpValue = c;
                }
                break;
              case ParamsState.Value:
                if (c === '"') {
                  parsed.params[tmpName] = tmpValue;
                  substate = ParamsState.Comma;
                } else {
                  tmpValue += c;
                }
                break;
              case ParamsState.Number:
                if (c === ",") {
                  parsed.params[tmpName] = parseInt(tmpValue, 10);
                  tmpName = "";
                  substate = ParamsState.Name;
                } else {
                  code = c.charCodeAt(0);
                  if (code < 48 || code > 57) {
                    throw new InvalidHeaderError("bad param format");
                  }
                  tmpValue += c;
                }
                break;
              case ParamsState.Comma:
                if (c === ",") {
                  tmpName = "";
                  substate = ParamsState.Name;
                } else {
                  throw new InvalidHeaderError("bad param format");
                }
                break;
              default:
                throw new Error("Invalid substate");
            }
            break;
          default:
            throw new Error("Invalid substate");
        }
      }
      if (!parsed.params.headers || parsed.params.headers === "") {
        if (request.headers["x-date"]) {
          parsed.params.headers = ["x-date"];
        } else {
          parsed.params.headers = ["date"];
        }
      } else {
        parsed.params.headers = parsed.params.headers.split(" ");
      }
      if (!parsed.scheme || parsed.scheme !== "Signature")
        throw new InvalidHeaderError('scheme was not "Signature"');
      if (!parsed.params.keyId)
        throw new InvalidHeaderError("keyId was not specified");
      if (!parsed.params.algorithm)
        throw new InvalidHeaderError("algorithm was not specified");
      if (!parsed.params.signature)
        throw new InvalidHeaderError("signature was not specified");
      try {
        validateAlgorithm(parsed.params.algorithm);
      } catch (e) {
        if (e instanceof InvalidAlgorithmError)
          throw new InvalidParamsError(parsed.params.algorithm + " is not " + "supported");
        else
          throw e;
      }
      for (i = 0;i < parsed.params.headers.length; i++) {
        var h = parsed.params.headers[i].toLowerCase();
        parsed.params.headers[i] = h;
        if (h === "request-line") {
          if (!options.strict) {
            parsed.signingString += request.method + " " + request.url + " HTTP/" + request.httpVersion;
          } else {
            throw new StrictParsingError("request-line is not a valid header " + "with strict parsing enabled.");
          }
        } else if (h === "(request-target)") {
          parsed.signingString += "(request-target): " + request.method.toLowerCase() + " " + request.url;
        } else if (h === "(keyid)") {
          parsed.signingString += "(keyid): " + parsed.params.keyId;
        } else if (h === "(algorithm)") {
          parsed.signingString += "(algorithm): " + parsed.params.algorithm;
        } else if (h === "(opaque)") {
          var opaque = parsed.params.opaque;
          if (opaque === undefined) {
            throw new MissingHeaderError("opaque param was not in the " + authzHeaderName + " header");
          }
          parsed.signingString += "(opaque): " + opaque;
        } else if (h === "(created)") {
          parsed.signingString += "(created): " + parsed.params.created;
        } else if (h === "(expires)") {
          parsed.signingString += "(expires): " + parsed.params.expires;
        } else {
          var value = request.headers[h];
          if (value === undefined)
            throw new MissingHeaderError(h + " was not in the request");
          parsed.signingString += h + ": " + value;
        }
        if (i + 1 < parsed.params.headers.length)
          parsed.signingString += `
`;
      }
      var date;
      var skew;
      if (request.headers.date || request.headers["x-date"]) {
        if (request.headers["x-date"]) {
          date = new Date(request.headers["x-date"]);
        } else {
          date = new Date(request.headers.date);
        }
        var now = new Date;
        skew = Math.abs(now.getTime() - date.getTime());
        if (skew > options.clockSkew * 1000) {
          throw new ExpiredRequestError("clock skew of " + skew / 1000 + "s was greater than " + options.clockSkew + "s");
        }
      }
      if (parsed.params.created) {
        skew = parsed.params.created - Math.floor(Date.now() / 1000);
        if (skew > options.clockSkew) {
          throw new ExpiredRequestError("Created lies in the future (with " + "skew " + skew + "s greater than allowed " + options.clockSkew + "s");
        }
      }
      if (parsed.params.expires) {
        var expiredSince = Math.floor(Date.now() / 1000) - parsed.params.expires;
        if (expiredSince > options.clockSkew) {
          throw new ExpiredRequestError("Request expired with skew " + expiredSince + "s greater than allowed " + options.clockSkew + "s");
        }
      }
      headers.forEach(function(hdr) {
        if (parsed.params.headers.indexOf(hdr.toLowerCase()) < 0)
          throw new MissingHeaderError(hdr + " was not a signed header");
      });
      parsed.params.algorithm = parsed.params.algorithm.toLowerCase();
      if (options.algorithms) {
        if (options.algorithms.indexOf(parsed.params.algorithm) === -1)
          throw new InvalidParamsError(parsed.params.algorithm + " is not a supported algorithm");
      }
      parsed.algorithm = parsed.params.algorithm.toUpperCase();
      parsed.keyId = parsed.params.keyId;
      parsed.opaque = parsed.params.opaque;
      return parsed;
    }
  };
});

// backend/node_modules/extsprintf/lib/extsprintf.js
var require_extsprintf = __commonJS((exports2) => {
  var mod_assert = require("assert");
  var mod_util = require("util");
  exports2.sprintf = jsSprintf;
  exports2.printf = jsPrintf;
  exports2.fprintf = jsFprintf;
  function jsSprintf(fmt) {
    var regex = [
      "([^%]*)",
      "%",
      "(['\\-+ #0]*?)",
      "([1-9]\\d*)?",
      "(\\.([1-9]\\d*))?",
      "[lhjztL]*?",
      "([diouxXfFeEgGaAcCsSp%jr])"
    ].join("");
    var re = new RegExp(regex);
    var args = Array.prototype.slice.call(arguments, 1);
    var flags, width, precision, conversion;
    var left, pad, sign, arg, match2;
    var ret = "";
    var argn = 1;
    mod_assert.equal("string", typeof fmt);
    while ((match2 = re.exec(fmt)) !== null) {
      ret += match2[1];
      fmt = fmt.substring(match2[0].length);
      flags = match2[2] || "";
      width = match2[3] || 0;
      precision = match2[4] || "";
      conversion = match2[6];
      left = false;
      sign = false;
      pad = " ";
      if (conversion == "%") {
        ret += "%";
        continue;
      }
      if (args.length === 0)
        throw new Error("too few args to sprintf");
      arg = args.shift();
      argn++;
      if (flags.match(/[\' #]/))
        throw new Error("unsupported flags: " + flags);
      if (precision.length > 0)
        throw new Error("non-zero precision not supported");
      if (flags.match(/-/))
        left = true;
      if (flags.match(/0/))
        pad = "0";
      if (flags.match(/\+/))
        sign = true;
      switch (conversion) {
        case "s":
          if (arg === undefined || arg === null)
            throw new Error("argument " + argn + ": attempted to print undefined or null " + "as a string");
          ret += doPad(pad, width, left, arg.toString());
          break;
        case "d":
          arg = Math.floor(arg);
        case "f":
          sign = sign && arg > 0 ? "+" : "";
          ret += sign + doPad(pad, width, left, arg.toString());
          break;
        case "x":
          ret += doPad(pad, width, left, arg.toString(16));
          break;
        case "j":
          if (width === 0)
            width = 10;
          ret += mod_util.inspect(arg, false, width);
          break;
        case "r":
          ret += dumpException(arg);
          break;
        default:
          throw new Error("unsupported conversion: " + conversion);
      }
    }
    ret += fmt;
    return ret;
  }
  function jsPrintf() {
    var args = Array.prototype.slice.call(arguments);
    args.unshift(process.stdout);
    jsFprintf.apply(null, args);
  }
  function jsFprintf(stream4) {
    var args = Array.prototype.slice.call(arguments, 1);
    return stream4.write(jsSprintf.apply(this, args));
  }
  function doPad(chr, width, left, str2) {
    var ret = str2;
    while (ret.length < width) {
      if (left)
        ret += chr;
      else
        ret = chr + ret;
    }
    return ret;
  }
  function dumpException(ex) {
    var ret;
    if (!(ex instanceof Error))
      throw new Error(jsSprintf("invalid type for %%r: %j", ex));
    ret = "EXCEPTION: " + ex.constructor.name + ": " + ex.stack;
    if (ex.cause && typeof ex.cause === "function") {
      var cex = ex.cause();
      if (cex) {
        ret += `
Caused by: ` + dumpException(cex);
      }
    }
    return ret;
  }
});

// backend/node_modules/verror/node_modules/core-util-is/lib/util.js
var require_util3 = __commonJS((exports2) => {
  function isArray3(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString(arg) === "[object Array]";
  }
  exports2.isArray = isArray3;
  function isBoolean2(arg) {
    return typeof arg === "boolean";
  }
  exports2.isBoolean = isBoolean2;
  function isNull(arg) {
    return arg === null;
  }
  exports2.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports2.isNullOrUndefined = isNullOrUndefined;
  function isNumber2(arg) {
    return typeof arg === "number";
  }
  exports2.isNumber = isNumber2;
  function isString2(arg) {
    return typeof arg === "string";
  }
  exports2.isString = isString2;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  exports2.isSymbol = isSymbol;
  function isUndefined2(arg) {
    return arg === undefined;
  }
  exports2.isUndefined = isUndefined2;
  function isRegExp2(re) {
    return objectToString(re) === "[object RegExp]";
  }
  exports2.isRegExp = isRegExp2;
  function isObject2(arg) {
    return typeof arg === "object" && arg !== null;
  }
  exports2.isObject = isObject2;
  function isDate2(d) {
    return objectToString(d) === "[object Date]";
  }
  exports2.isDate = isDate2;
  function isError(e) {
    return objectToString(e) === "[object Error]" || e instanceof Error;
  }
  exports2.isError = isError;
  function isFunction3(arg) {
    return typeof arg === "function";
  }
  exports2.isFunction = isFunction3;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
  }
  exports2.isPrimitive = isPrimitive;
  exports2.isBuffer = Buffer.isBuffer;
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
});

// backend/node_modules/verror/lib/verror.js
var require_verror = __commonJS((exports2, module2) => {
  var mod_assertplus = require_assert();
  var mod_util = require("util");
  var mod_extsprintf = require_extsprintf();
  var mod_isError = require_util3().isError;
  var sprintf = mod_extsprintf.sprintf;
  module2.exports = VError;
  VError.VError = VError;
  VError.SError = SError;
  VError.WError = WError;
  VError.MultiError = MultiError;
  function parseConstructorArguments(args) {
    var argv, options, sprintf_args, shortmessage, k;
    mod_assertplus.object(args, "args");
    mod_assertplus.bool(args.strict, "args.strict");
    mod_assertplus.array(args.argv, "args.argv");
    argv = args.argv;
    if (argv.length === 0) {
      options = {};
      sprintf_args = [];
    } else if (mod_isError(argv[0])) {
      options = { cause: argv[0] };
      sprintf_args = argv.slice(1);
    } else if (typeof argv[0] === "object") {
      options = {};
      for (k in argv[0]) {
        options[k] = argv[0][k];
      }
      sprintf_args = argv.slice(1);
    } else {
      mod_assertplus.string(argv[0], "first argument to VError, SError, or WError " + "constructor must be a string, object, or Error");
      options = {};
      sprintf_args = argv;
    }
    mod_assertplus.object(options);
    if (!options.strict && !args.strict) {
      sprintf_args = sprintf_args.map(function(a) {
        return a === null ? "null" : a === undefined ? "undefined" : a;
      });
    }
    if (sprintf_args.length === 0) {
      shortmessage = "";
    } else {
      shortmessage = sprintf.apply(null, sprintf_args);
    }
    return {
      options,
      shortmessage
    };
  }
  function VError() {
    var args, obj2, parsed, cause, ctor, message, k;
    args = Array.prototype.slice.call(arguments, 0);
    if (!(this instanceof VError)) {
      obj2 = Object.create(VError.prototype);
      VError.apply(obj2, arguments);
      return obj2;
    }
    parsed = parseConstructorArguments({
      argv: args,
      strict: false
    });
    if (parsed.options.name) {
      mod_assertplus.string(parsed.options.name, `error's "name" must be a string`);
      this.name = parsed.options.name;
    }
    this.jse_shortmsg = parsed.shortmessage;
    message = parsed.shortmessage;
    cause = parsed.options.cause;
    if (cause) {
      mod_assertplus.ok(mod_isError(cause), "cause is not an Error");
      this.jse_cause = cause;
      if (!parsed.options.skipCauseMessage) {
        message += ": " + cause.message;
      }
    }
    this.jse_info = {};
    if (parsed.options.info) {
      for (k in parsed.options.info) {
        this.jse_info[k] = parsed.options.info[k];
      }
    }
    this.message = message;
    Error.call(this, message);
    if (Error.captureStackTrace) {
      ctor = parsed.options.constructorOpt || this.constructor;
      Error.captureStackTrace(this, ctor);
    }
    return this;
  }
  mod_util.inherits(VError, Error);
  VError.prototype.name = "VError";
  VError.prototype.toString = function ve_toString() {
    var str2 = this.hasOwnProperty("name") && this.name || this.constructor.name || this.constructor.prototype.name;
    if (this.message)
      str2 += ": " + this.message;
    return str2;
  };
  VError.prototype.cause = function ve_cause() {
    var cause = VError.cause(this);
    return cause === null ? undefined : cause;
  };
  VError.cause = function(err) {
    mod_assertplus.ok(mod_isError(err), "err must be an Error");
    return mod_isError(err.jse_cause) ? err.jse_cause : null;
  };
  VError.info = function(err) {
    var rv, cause, k;
    mod_assertplus.ok(mod_isError(err), "err must be an Error");
    cause = VError.cause(err);
    if (cause !== null) {
      rv = VError.info(cause);
    } else {
      rv = {};
    }
    if (typeof err.jse_info == "object" && err.jse_info !== null) {
      for (k in err.jse_info) {
        rv[k] = err.jse_info[k];
      }
    }
    return rv;
  };
  VError.findCauseByName = function(err, name) {
    var cause;
    mod_assertplus.ok(mod_isError(err), "err must be an Error");
    mod_assertplus.string(name, "name");
    mod_assertplus.ok(name.length > 0, "name cannot be empty");
    for (cause = err;cause !== null; cause = VError.cause(cause)) {
      mod_assertplus.ok(mod_isError(cause));
      if (cause.name == name) {
        return cause;
      }
    }
    return null;
  };
  VError.hasCauseWithName = function(err, name) {
    return VError.findCauseByName(err, name) !== null;
  };
  VError.fullStack = function(err) {
    mod_assertplus.ok(mod_isError(err), "err must be an Error");
    var cause = VError.cause(err);
    if (cause) {
      return err.stack + `
caused by: ` + VError.fullStack(cause);
    }
    return err.stack;
  };
  VError.errorFromList = function(errors) {
    mod_assertplus.arrayOfObject(errors, "errors");
    if (errors.length === 0) {
      return null;
    }
    errors.forEach(function(e) {
      mod_assertplus.ok(mod_isError(e));
    });
    if (errors.length == 1) {
      return errors[0];
    }
    return new MultiError(errors);
  };
  VError.errorForEach = function(err, func) {
    mod_assertplus.ok(mod_isError(err), "err must be an Error");
    mod_assertplus.func(func, "func");
    if (err instanceof MultiError) {
      err.errors().forEach(function iterError(e) {
        func(e);
      });
    } else {
      func(err);
    }
  };
  function SError() {
    var args, obj2, parsed, options;
    args = Array.prototype.slice.call(arguments, 0);
    if (!(this instanceof SError)) {
      obj2 = Object.create(SError.prototype);
      SError.apply(obj2, arguments);
      return obj2;
    }
    parsed = parseConstructorArguments({
      argv: args,
      strict: true
    });
    options = parsed.options;
    VError.call(this, options, "%s", parsed.shortmessage);
    return this;
  }
  mod_util.inherits(SError, VError);
  function MultiError(errors) {
    mod_assertplus.array(errors, "list of errors");
    mod_assertplus.ok(errors.length > 0, "must be at least one error");
    this.ase_errors = errors;
    VError.call(this, {
      cause: errors[0]
    }, "first of %d error%s", errors.length, errors.length == 1 ? "" : "s");
  }
  mod_util.inherits(MultiError, VError);
  MultiError.prototype.name = "MultiError";
  MultiError.prototype.errors = function me_errors() {
    return this.ase_errors.slice(0);
  };
  function WError() {
    var args, obj2, parsed, options;
    args = Array.prototype.slice.call(arguments, 0);
    if (!(this instanceof WError)) {
      obj2 = Object.create(WError.prototype);
      WError.apply(obj2, args);
      return obj2;
    }
    parsed = parseConstructorArguments({
      argv: args,
      strict: false
    });
    options = parsed.options;
    options["skipCauseMessage"] = true;
    VError.call(this, options, "%s", parsed.shortmessage);
    return this;
  }
  mod_util.inherits(WError, VError);
  WError.prototype.name = "WError";
  WError.prototype.toString = function we_toString() {
    var str2 = this.hasOwnProperty("name") && this.name || this.constructor.name || this.constructor.prototype.name;
    if (this.message)
      str2 += ": " + this.message;
    if (this.jse_cause && this.jse_cause.message)
      str2 += "; caused by " + this.jse_cause.toString();
    return str2;
  };
  WError.prototype.cause = function we_cause(c) {
    if (mod_isError(c))
      this.jse_cause = c;
    return this.jse_cause;
  };
});

// backend/node_modules/json-schema/lib/validate.js
var require_validate = __commonJS((exports2, module2) => {
  (function(root, factory2) {
    if (typeof define === "function" && define.amd) {
      define([], function() {
        return factory2();
      });
    } else if (typeof module2 === "object" && module2.exports) {
      module2.exports = factory2();
    } else {
      root.jsonSchema = factory2();
    }
  })(exports2, function() {
    var exports3 = validate;
    exports3.Integer = { type: "integer" };
    var primitiveConstructors = {
      String,
      Boolean,
      Number,
      Object,
      Array,
      Date
    };
    exports3.validate = validate;
    function validate(instance, schema) {
      return validate(instance, schema, { changing: false });
    }
    exports3.checkPropertyChange = function(value, schema, property) {
      return validate(value, schema, { changing: property || "property" });
    };
    var validate = exports3._validate = function(instance, schema, options) {
      if (!options)
        options = {};
      var _changing = options.changing;
      function getType(schema2) {
        return schema2.type || primitiveConstructors[schema2.name] == schema2 && schema2.name.toLowerCase();
      }
      var errors = [];
      function checkProp(value, schema2, path2, i) {
        var l;
        path2 += path2 ? typeof i == "number" ? "[" + i + "]" : typeof i == "undefined" ? "" : "." + i : i;
        function addError(message) {
          errors.push({ property: path2, message });
        }
        if ((typeof schema2 != "object" || schema2 instanceof Array) && (path2 || typeof schema2 != "function") && !(schema2 && getType(schema2))) {
          if (typeof schema2 == "function") {
            if (!(value instanceof schema2)) {
              addError("is not an instance of the class/constructor " + schema2.name);
            }
          } else if (schema2) {
            addError("Invalid schema/property definition " + schema2);
          }
          return null;
        }
        if (_changing && schema2.readonly) {
          addError("is a readonly field, it can not be changed");
        }
        if (schema2["extends"]) {
          checkProp(value, schema2["extends"], path2, i);
        }
        function checkType(type, value2) {
          if (type) {
            if (typeof type == "string" && type != "any" && (type == "null" ? value2 !== null : typeof value2 != type) && !(value2 instanceof Array && type == "array") && !(value2 instanceof Date && type == "date") && !(type == "integer" && value2 % 1 === 0)) {
              return [{ property: path2, message: value2 + " - " + typeof value2 + " value found, but a " + type + " is required" }];
            }
            if (type instanceof Array) {
              var unionErrors = [];
              for (var j2 = 0;j2 < type.length; j2++) {
                if (!(unionErrors = checkType(type[j2], value2)).length) {
                  break;
                }
              }
              if (unionErrors.length) {
                return unionErrors;
              }
            } else if (typeof type == "object") {
              var priorErrors = errors;
              errors = [];
              checkProp(value2, type, path2);
              var theseErrors = errors;
              errors = priorErrors;
              return theseErrors;
            }
          }
          return [];
        }
        if (value === undefined) {
          if (schema2.required) {
            addError("is missing and it is required");
          }
        } else {
          errors = errors.concat(checkType(getType(schema2), value));
          if (schema2.disallow && !checkType(schema2.disallow, value).length) {
            addError(" disallowed value was matched");
          }
          if (value !== null) {
            if (value instanceof Array) {
              if (schema2.items) {
                var itemsIsArray = schema2.items instanceof Array;
                var propDef = schema2.items;
                for (i = 0, l = value.length;i < l; i += 1) {
                  if (itemsIsArray)
                    propDef = schema2.items[i];
                  if (options.coerce)
                    value[i] = options.coerce(value[i], propDef);
                  errors.concat(checkProp(value[i], propDef, path2, i));
                }
              }
              if (schema2.minItems && value.length < schema2.minItems) {
                addError("There must be a minimum of " + schema2.minItems + " in the array");
              }
              if (schema2.maxItems && value.length > schema2.maxItems) {
                addError("There must be a maximum of " + schema2.maxItems + " in the array");
              }
            } else if (schema2.properties || schema2.additionalProperties) {
              errors.concat(checkObj(value, schema2.properties, path2, schema2.additionalProperties));
            }
            if (schema2.pattern && typeof value == "string" && !value.match(schema2.pattern)) {
              addError("does not match the regex pattern " + schema2.pattern);
            }
            if (schema2.maxLength && typeof value == "string" && value.length > schema2.maxLength) {
              addError("may only be " + schema2.maxLength + " characters long");
            }
            if (schema2.minLength && typeof value == "string" && value.length < schema2.minLength) {
              addError("must be at least " + schema2.minLength + " characters long");
            }
            if (typeof schema2.minimum !== "undefined" && typeof value == typeof schema2.minimum && schema2.minimum > value) {
              addError("must have a minimum value of " + schema2.minimum);
            }
            if (typeof schema2.maximum !== "undefined" && typeof value == typeof schema2.maximum && schema2.maximum < value) {
              addError("must have a maximum value of " + schema2.maximum);
            }
            if (schema2["enum"]) {
              var enumer = schema2["enum"];
              l = enumer.length;
              var found;
              for (var j = 0;j < l; j++) {
                if (enumer[j] === value) {
                  found = 1;
                  break;
                }
              }
              if (!found) {
                addError("does not have a value in the enumeration " + enumer.join(", "));
              }
            }
            if (typeof schema2.maxDecimal == "number" && value.toString().match(new RegExp("\\.[0-9]{" + (schema2.maxDecimal + 1) + ",}"))) {
              addError("may only have " + schema2.maxDecimal + " digits of decimal places");
            }
          }
        }
        return null;
      }
      function checkObj(instance2, objTypeDef, path2, additionalProp) {
        if (typeof objTypeDef == "object") {
          if (typeof instance2 != "object" || instance2 instanceof Array) {
            errors.push({ property: path2, message: "an object is required" });
          }
          for (var i in objTypeDef) {
            if (objTypeDef.hasOwnProperty(i) && i != "__proto__" && i != "constructor") {
              var value = instance2.hasOwnProperty(i) ? instance2[i] : undefined;
              if (value === undefined && options.existingOnly)
                continue;
              var propDef = objTypeDef[i];
              if (value === undefined && propDef["default"]) {
                value = instance2[i] = propDef["default"];
              }
              if (options.coerce && i in instance2) {
                value = instance2[i] = options.coerce(value, propDef);
              }
              checkProp(value, propDef, path2, i);
            }
          }
        }
        for (i in instance2) {
          if (instance2.hasOwnProperty(i) && !(i.charAt(0) == "_" && i.charAt(1) == "_") && objTypeDef && !objTypeDef[i] && additionalProp === false) {
            if (options.filter) {
              delete instance2[i];
              continue;
            } else {
              errors.push({ property: path2, message: "The property " + i + " is not defined in the schema and the schema does not allow additional properties" });
            }
          }
          var requires = objTypeDef && objTypeDef[i] && objTypeDef[i].requires;
          if (requires && !(requires in instance2)) {
            errors.push({ property: path2, message: "the presence of the property " + i + " requires that " + requires + " also be present" });
          }
          value = instance2[i];
          if (additionalProp && (!(objTypeDef && typeof objTypeDef == "object") || !(i in objTypeDef))) {
            if (options.coerce) {
              value = instance2[i] = options.coerce(value, additionalProp);
            }
            checkProp(value, additionalProp, path2, i);
          }
          if (!_changing && value && value.$schema) {
            errors = errors.concat(checkProp(value, value.$schema, path2, i));
          }
        }
        return errors;
      }
      if (schema) {
        checkProp(instance, schema, "", _changing || "");
      }
      if (!_changing && instance && instance.$schema) {
        checkProp(instance, instance.$schema, "", "");
      }
      return { valid: !errors.length, errors };
    };
    exports3.mustBeValid = function(result) {
      if (!result.valid) {
        throw new TypeError(result.errors.map(function(error2) {
          return "for property " + error2.property + ": " + error2.message;
        }).join(`, 
`));
      }
    };
    return exports3;
  });
});

// backend/node_modules/jsprim/lib/jsprim.js
var require_jsprim = __commonJS((exports2) => {
  var mod_assert = require_assert();
  var mod_util = require("util");
  var mod_extsprintf = require_extsprintf();
  var mod_verror = require_verror();
  var mod_jsonschema = require_validate();
  exports2.deepCopy = deepCopy;
  exports2.deepEqual = deepEqual;
  exports2.isEmpty = isEmpty;
  exports2.hasKey = hasKey;
  exports2.forEachKey = forEachKey;
  exports2.pluck = pluck;
  exports2.flattenObject = flattenObject;
  exports2.flattenIter = flattenIter;
  exports2.validateJsonObject = validateJsonObjectJS;
  exports2.validateJsonObjectJS = validateJsonObjectJS;
  exports2.randElt = randElt;
  exports2.extraProperties = extraProperties;
  exports2.mergeObjects = mergeObjects;
  exports2.startsWith = startsWith;
  exports2.endsWith = endsWith2;
  exports2.parseInteger = parseInteger;
  exports2.iso8601 = iso8601;
  exports2.rfc1123 = rfc1123;
  exports2.parseDateTime = parseDateTime;
  exports2.hrtimediff = hrtimeDiff;
  exports2.hrtimeDiff = hrtimeDiff;
  exports2.hrtimeAccum = hrtimeAccum;
  exports2.hrtimeAdd = hrtimeAdd;
  exports2.hrtimeNanosec = hrtimeNanosec;
  exports2.hrtimeMicrosec = hrtimeMicrosec;
  exports2.hrtimeMillisec = hrtimeMillisec;
  function deepCopy(obj2) {
    var ret, key;
    var marker = "__deepCopy";
    if (obj2 && obj2[marker])
      throw new Error("attempted deep copy of cyclic object");
    if (obj2 && obj2.constructor == Object) {
      ret = {};
      obj2[marker] = true;
      for (key in obj2) {
        if (key == marker)
          continue;
        ret[key] = deepCopy(obj2[key]);
      }
      delete obj2[marker];
      return ret;
    }
    if (obj2 && obj2.constructor == Array) {
      ret = [];
      obj2[marker] = true;
      for (key = 0;key < obj2.length; key++)
        ret.push(deepCopy(obj2[key]));
      delete obj2[marker];
      return ret;
    }
    return obj2;
  }
  function deepEqual(obj1, obj2) {
    if (typeof obj1 != typeof obj2)
      return false;
    if (obj1 === null || obj2 === null || typeof obj1 != "object")
      return obj1 === obj2;
    if (obj1.constructor != obj2.constructor)
      return false;
    var k;
    for (k in obj1) {
      if (!(k in obj2))
        return false;
      if (!deepEqual(obj1[k], obj2[k]))
        return false;
    }
    for (k in obj2) {
      if (!(k in obj1))
        return false;
    }
    return true;
  }
  function isEmpty(obj2) {
    var key;
    for (key in obj2)
      return false;
    return true;
  }
  function hasKey(obj2, key) {
    mod_assert.equal(typeof key, "string");
    return Object.prototype.hasOwnProperty.call(obj2, key);
  }
  function forEachKey(obj2, callback) {
    for (var key in obj2) {
      if (hasKey(obj2, key)) {
        callback(key, obj2[key]);
      }
    }
  }
  function pluck(obj2, key) {
    mod_assert.equal(typeof key, "string");
    return pluckv(obj2, key);
  }
  function pluckv(obj2, key) {
    if (obj2 === null || typeof obj2 !== "object")
      return;
    if (obj2.hasOwnProperty(key))
      return obj2[key];
    var i = key.indexOf(".");
    if (i == -1)
      return;
    var key1 = key.substr(0, i);
    if (!obj2.hasOwnProperty(key1))
      return;
    return pluckv(obj2[key1], key.substr(i + 1));
  }
  function flattenIter(data, depth, callback) {
    doFlattenIter(data, depth, [], callback);
  }
  function doFlattenIter(data, depth, accum, callback) {
    var each;
    var key;
    if (depth === 0) {
      each = accum.slice(0);
      each.push(data);
      callback(each);
      return;
    }
    mod_assert.ok(data !== null);
    mod_assert.equal(typeof data, "object");
    mod_assert.equal(typeof depth, "number");
    mod_assert.ok(depth >= 0);
    for (key in data) {
      each = accum.slice(0);
      each.push(key);
      doFlattenIter(data[key], depth - 1, each, callback);
    }
  }
  function flattenObject(data, depth) {
    if (depth === 0)
      return [data];
    mod_assert.ok(data !== null);
    mod_assert.equal(typeof data, "object");
    mod_assert.equal(typeof depth, "number");
    mod_assert.ok(depth >= 0);
    var rv = [];
    var key;
    for (key in data) {
      flattenObject(data[key], depth - 1).forEach(function(p) {
        rv.push([key].concat(p));
      });
    }
    return rv;
  }
  function startsWith(str2, prefix) {
    return str2.substr(0, prefix.length) == prefix;
  }
  function endsWith2(str2, suffix) {
    return str2.substr(str2.length - suffix.length, suffix.length) == suffix;
  }
  function iso8601(d) {
    if (typeof d == "number")
      d = new Date(d);
    mod_assert.ok(d.constructor === Date);
    return mod_extsprintf.sprintf("%4d-%02d-%02dT%02d:%02d:%02d.%03dZ", d.getUTCFullYear(), d.getUTCMonth() + 1, d.getUTCDate(), d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds());
  }
  var RFC1123_MONTHS = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  var RFC1123_DAYS = [
    "Sun",
    "Mon",
    "Tue",
    "Wed",
    "Thu",
    "Fri",
    "Sat"
  ];
  function rfc1123(date) {
    return mod_extsprintf.sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT", RFC1123_DAYS[date.getUTCDay()], date.getUTCDate(), RFC1123_MONTHS[date.getUTCMonth()], date.getUTCFullYear(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
  }
  function parseDateTime(str2) {
    var numeric = +str2;
    if (!isNaN(numeric)) {
      return new Date(numeric);
    } else {
      return new Date(str2);
    }
  }
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
  var PI_DEFAULTS = {
    base: 10,
    allowSign: true,
    allowPrefix: false,
    allowTrailing: false,
    allowImprecise: false,
    trimWhitespace: false,
    leadingZeroIsOctal: false
  };
  var CP_0 = 48;
  var CP_9 = 57;
  var CP_A = 65;
  var CP_B = 66;
  var CP_O = 79;
  var CP_T = 84;
  var CP_X = 88;
  var CP_Z = 90;
  var CP_a = 97;
  var CP_b = 98;
  var CP_o = 111;
  var CP_t = 116;
  var CP_x = 120;
  var CP_z = 122;
  var PI_CONV_DEC = 48;
  var PI_CONV_UC = 55;
  var PI_CONV_LC = 87;
  function parseInteger(str2, uopts) {
    mod_assert.string(str2, "str");
    mod_assert.optionalObject(uopts, "options");
    var baseOverride = false;
    var options = PI_DEFAULTS;
    if (uopts) {
      baseOverride = hasKey(uopts, "base");
      options = mergeObjects(options, uopts);
      mod_assert.number(options.base, "options.base");
      mod_assert.ok(options.base >= 2, "options.base >= 2");
      mod_assert.ok(options.base <= 36, "options.base <= 36");
      mod_assert.bool(options.allowSign, "options.allowSign");
      mod_assert.bool(options.allowPrefix, "options.allowPrefix");
      mod_assert.bool(options.allowTrailing, "options.allowTrailing");
      mod_assert.bool(options.allowImprecise, "options.allowImprecise");
      mod_assert.bool(options.trimWhitespace, "options.trimWhitespace");
      mod_assert.bool(options.leadingZeroIsOctal, "options.leadingZeroIsOctal");
      if (options.leadingZeroIsOctal) {
        mod_assert.ok(!baseOverride, '"base" and "leadingZeroIsOctal" are ' + "mutually exclusive");
      }
    }
    var c;
    var pbase = -1;
    var base = options.base;
    var start;
    var mult = 1;
    var value = 0;
    var idx = 0;
    var len = str2.length;
    if (options.trimWhitespace) {
      while (idx < len && isSpace(str2.charCodeAt(idx))) {
        ++idx;
      }
    }
    if (options.allowSign) {
      if (str2[idx] === "-") {
        idx += 1;
        mult = -1;
      } else if (str2[idx] === "+") {
        idx += 1;
      }
    }
    if (str2[idx] === "0") {
      if (options.allowPrefix) {
        pbase = prefixToBase(str2.charCodeAt(idx + 1));
        if (pbase !== -1 && (!baseOverride || pbase === base)) {
          base = pbase;
          idx += 2;
        }
      }
      if (pbase === -1 && options.leadingZeroIsOctal) {
        base = 8;
      }
    }
    for (start = idx;idx < len; ++idx) {
      c = translateDigit(str2.charCodeAt(idx));
      if (c !== -1 && c < base) {
        value *= base;
        value += c;
      } else {
        break;
      }
    }
    if (start === idx) {
      return new Error("invalid number: " + JSON.stringify(str2));
    }
    if (options.trimWhitespace) {
      while (idx < len && isSpace(str2.charCodeAt(idx))) {
        ++idx;
      }
    }
    if (idx < len && !options.allowTrailing) {
      return new Error("trailing characters after number: " + JSON.stringify(str2.slice(idx)));
    }
    if (value === 0) {
      return 0;
    }
    var result = value * mult;
    if (!options.allowImprecise && (value > MAX_SAFE_INTEGER || result < MIN_SAFE_INTEGER)) {
      return new Error("number is outside of the supported range: " + JSON.stringify(str2.slice(start, idx)));
    }
    return result;
  }
  function translateDigit(d) {
    if (d >= CP_0 && d <= CP_9) {
      return d - PI_CONV_DEC;
    } else if (d >= CP_A && d <= CP_Z) {
      return d - PI_CONV_UC;
    } else if (d >= CP_a && d <= CP_z) {
      return d - PI_CONV_LC;
    } else {
      return -1;
    }
  }
  function isSpace(c) {
    return c === 32 || c >= 9 && c <= 13 || c === 160 || c === 5760 || c === 6158 || c >= 8192 && c <= 8202 || c === 8232 || c === 8233 || c === 8239 || c === 8287 || c === 12288 || c === 65279;
  }
  function prefixToBase(c) {
    if (c === CP_b || c === CP_B) {
      return 2;
    } else if (c === CP_o || c === CP_O) {
      return 8;
    } else if (c === CP_t || c === CP_T) {
      return 10;
    } else if (c === CP_x || c === CP_X) {
      return 16;
    } else {
      return -1;
    }
  }
  function validateJsonObjectJS(schema, input) {
    var report = mod_jsonschema.validate(input, schema);
    if (report.errors.length === 0)
      return null;
    var error2 = report.errors[0];
    var propname = error2["property"];
    var reason = error2["message"].toLowerCase();
    var i, j;
    if ((i = reason.indexOf("the property ")) != -1 && (j = reason.indexOf(" is not defined in the schema and the " + "schema does not allow additional properties")) != -1) {
      i += "the property ".length;
      if (propname === "")
        propname = reason.substr(i, j - i);
      else
        propname = propname + "." + reason.substr(i, j - i);
      reason = "unsupported property";
    }
    var rv = new mod_verror.VError('property "%s": %s', propname, reason);
    rv.jsv_details = error2;
    return rv;
  }
  function randElt(arr) {
    mod_assert.ok(Array.isArray(arr) && arr.length > 0, "randElt argument must be a non-empty array");
    return arr[Math.floor(Math.random() * arr.length)];
  }
  function assertHrtime(a) {
    mod_assert.ok(a[0] >= 0 && a[1] >= 0, "negative numbers not allowed in hrtimes");
    mod_assert.ok(a[1] < 1e9, "nanoseconds column overflow");
  }
  function hrtimeDiff(a, b) {
    assertHrtime(a);
    assertHrtime(b);
    mod_assert.ok(a[0] > b[0] || a[0] == b[0] && a[1] >= b[1], "negative differences not allowed");
    var rv = [a[0] - b[0], 0];
    if (a[1] >= b[1]) {
      rv[1] = a[1] - b[1];
    } else {
      rv[0]--;
      rv[1] = 1e9 - (b[1] - a[1]);
    }
    return rv;
  }
  function hrtimeNanosec(a) {
    assertHrtime(a);
    return Math.floor(a[0] * 1e9 + a[1]);
  }
  function hrtimeMicrosec(a) {
    assertHrtime(a);
    return Math.floor(a[0] * 1e6 + a[1] / 1000);
  }
  function hrtimeMillisec(a) {
    assertHrtime(a);
    return Math.floor(a[0] * 1000 + a[1] / 1e6);
  }
  function hrtimeAccum(a, b) {
    assertHrtime(a);
    assertHrtime(b);
    a[1] += b[1];
    if (a[1] >= 1e9) {
      a[0]++;
      a[1] -= 1e9;
    }
    a[0] += b[0];
    return a;
  }
  function hrtimeAdd(a, b) {
    assertHrtime(a);
    var rv = [a[0], a[1]];
    return hrtimeAccum(rv, b);
  }
  function extraProperties(obj2, allowed) {
    mod_assert.ok(typeof obj2 === "object" && obj2 !== null, "obj argument must be a non-null object");
    mod_assert.ok(Array.isArray(allowed), "allowed argument must be an array of strings");
    for (var i = 0;i < allowed.length; i++) {
      mod_assert.ok(typeof allowed[i] === "string", "allowed argument must be an array of strings");
    }
    return Object.keys(obj2).filter(function(key) {
      return allowed.indexOf(key) === -1;
    });
  }
  function mergeObjects(provided, overrides, defaults3) {
    var rv, k;
    rv = {};
    if (defaults3) {
      for (k in defaults3)
        rv[k] = defaults3[k];
    }
    if (provided) {
      for (k in provided)
        rv[k] = provided[k];
    }
    if (overrides) {
      for (k in overrides)
        rv[k] = overrides[k];
    }
    return rv;
  }
});

// backend/node_modules/http-signature/lib/signer.js
var require_signer = __commonJS((exports2, module2) => {
  var assert = require_assert();
  var crypto3 = require("crypto");
  var util3 = require("util");
  var sshpk = require_lib4();
  var jsprim = require_jsprim();
  var utils = require_utils5();
  var sprintf = require("util").format;
  var HASH_ALGOS = utils.HASH_ALGOS;
  var PK_ALGOS = utils.PK_ALGOS;
  var InvalidAlgorithmError = utils.InvalidAlgorithmError;
  var HttpSignatureError = utils.HttpSignatureError;
  var validateAlgorithm = utils.validateAlgorithm;
  var AUTHZ_PARAMS = [
    "keyId",
    "algorithm",
    "created",
    "expires",
    "opaque",
    "headers",
    "signature"
  ];
  function MissingHeaderError(message) {
    HttpSignatureError.call(this, message, MissingHeaderError);
  }
  util3.inherits(MissingHeaderError, HttpSignatureError);
  function StrictParsingError(message) {
    HttpSignatureError.call(this, message, StrictParsingError);
  }
  util3.inherits(StrictParsingError, HttpSignatureError);
  function FormatAuthz(prefix, params) {
    assert.string(prefix, "prefix");
    assert.object(params, "params");
    var authz = "";
    for (var i = 0;i < AUTHZ_PARAMS.length; i++) {
      var param = AUTHZ_PARAMS[i];
      var value = params[param];
      if (value === undefined)
        continue;
      if (typeof value === "number") {
        authz += prefix + sprintf("%s=%d", param, value);
      } else {
        assert.string(value, "params." + param);
        authz += prefix + sprintf('%s="%s"', param, value);
      }
      prefix = ",";
    }
    return authz;
  }
  function RequestSigner(options) {
    assert.object(options, "options");
    var alg = [];
    if (options.algorithm !== undefined) {
      assert.string(options.algorithm, "options.algorithm");
      alg = validateAlgorithm(options.algorithm);
    }
    this.rs_alg = alg;
    if (options.sign !== undefined) {
      assert.func(options.sign, "options.sign");
      this.rs_signFunc = options.sign;
    } else if (alg[0] === "hmac" && options.key !== undefined) {
      assert.string(options.keyId, "options.keyId");
      this.rs_keyId = options.keyId;
      if (typeof options.key !== "string" && !Buffer.isBuffer(options.key))
        throw new TypeError("options.key for HMAC must be a string or Buffer");
      this.rs_signer = crypto3.createHmac(alg[1].toUpperCase(), options.key);
      this.rs_signer.sign = function() {
        var digest = this.digest("base64");
        return {
          hashAlgorithm: alg[1],
          toString: function() {
            return digest;
          }
        };
      };
    } else if (options.key !== undefined) {
      var key = options.key;
      if (typeof key === "string" || Buffer.isBuffer(key))
        assert.optionalString(options.keyPassphrase, "options.keyPassphrase");
      key = sshpk.parsePrivateKey(key, "auto", {
        passphrase: options.keyPassphrase
      });
      assert.ok(sshpk.PrivateKey.isPrivateKey(key, [1, 2]), "options.key must be a sshpk.PrivateKey");
      this.rs_key = key;
      assert.string(options.keyId, "options.keyId");
      this.rs_keyId = options.keyId;
      if (!PK_ALGOS[key.type]) {
        throw new InvalidAlgorithmError(key.type.toUpperCase() + " type " + "keys are not supported");
      }
      if (alg[0] !== undefined && key.type !== alg[0]) {
        throw new InvalidAlgorithmError("options.key must be a " + alg[0].toUpperCase() + " key, was given a " + key.type.toUpperCase() + " key instead");
      }
      this.rs_signer = key.createSign(alg[1]);
    } else {
      throw new TypeError("options.sign (func) or options.key is required");
    }
    this.rs_headers = [];
    this.rs_lines = [];
  }
  RequestSigner.prototype.writeHeader = function(header, value) {
    assert.string(header, "header");
    header = header.toLowerCase();
    assert.string(value, "value");
    this.rs_headers.push(header);
    if (this.rs_signFunc) {
      this.rs_lines.push(header + ": " + value);
    } else {
      var line = header + ": " + value;
      if (this.rs_headers.length > 0)
        line = `
` + line;
      this.rs_signer.update(line);
    }
    return value;
  };
  RequestSigner.prototype.writeDateHeader = function() {
    return this.writeHeader("date", jsprim.rfc1123(new Date));
  };
  RequestSigner.prototype.writeTarget = function(method, path2) {
    assert.string(method, "method");
    assert.string(path2, "path");
    method = method.toLowerCase();
    this.writeHeader("(request-target)", method + " " + path2);
  };
  RequestSigner.prototype.sign = function(cb) {
    assert.func(cb, "callback");
    if (this.rs_headers.length < 1)
      throw new Error("At least one header must be signed");
    var alg, authz;
    if (this.rs_signFunc) {
      var data = this.rs_lines.join(`
`);
      var self2 = this;
      this.rs_signFunc(data, function(err, sig) {
        if (err) {
          cb(err);
          return;
        }
        try {
          assert.object(sig, "signature");
          assert.string(sig.keyId, "signature.keyId");
          assert.string(sig.algorithm, "signature.algorithm");
          assert.string(sig.signature, "signature.signature");
          alg = validateAlgorithm(sig.algorithm);
          authz = FormatAuthz("Signature ", {
            keyId: sig.keyId,
            algorithm: sig.algorithm,
            headers: self2.rs_headers.join(" "),
            signature: sig.signature
          });
        } catch (e) {
          cb(e);
          return;
        }
        cb(null, authz);
      });
    } else {
      try {
        var sigObj = this.rs_signer.sign();
      } catch (e) {
        cb(e);
        return;
      }
      alg = (this.rs_alg[0] || this.rs_key.type) + "-" + sigObj.hashAlgorithm;
      var signature = sigObj.toString();
      authz = FormatAuthz("Signature ", {
        keyId: this.rs_keyId,
        algorithm: alg,
        headers: this.rs_headers.join(" "),
        signature
      });
      cb(null, authz);
    }
  };
  module2.exports = {
    isSigner: function(obj2) {
      if (typeof obj2 === "object" && obj2 instanceof RequestSigner)
        return true;
      return false;
    },
    createSigner: function createSigner(options) {
      return new RequestSigner(options);
    },
    signRequest: function signRequest(request, options) {
      assert.object(request, "request");
      assert.object(options, "options");
      assert.optionalString(options.algorithm, "options.algorithm");
      assert.string(options.keyId, "options.keyId");
      assert.optionalString(options.opaque, "options.opaque");
      assert.optionalArrayOfString(options.headers, "options.headers");
      assert.optionalString(options.httpVersion, "options.httpVersion");
      assert.optionalNumber(options.expiresIn, "options.expiresIn");
      assert.optionalString(options.keyPassphrase, "options.keyPassphrase");
      if (!request.getHeader("Date"))
        request.setHeader("Date", jsprim.rfc1123(new Date));
      var headers = ["date"];
      if (options.headers)
        headers = options.headers;
      if (!options.httpVersion)
        options.httpVersion = "1.1";
      var alg = [];
      if (options.algorithm) {
        options.algorithm = options.algorithm.toLowerCase();
        alg = validateAlgorithm(options.algorithm);
      }
      var key = options.key;
      if (alg[0] === "hmac") {
        if (typeof key !== "string" && !Buffer.isBuffer(key))
          throw new TypeError("options.key must be a string or Buffer");
      } else {
        if (typeof key === "string" || Buffer.isBuffer(key))
          key = sshpk.parsePrivateKey(options.key, "auto", {
            passphrase: options.keyPassphrase
          });
        assert.ok(sshpk.PrivateKey.isPrivateKey(key, [1, 2]), "options.key must be a sshpk.PrivateKey");
        if (!PK_ALGOS[key.type]) {
          throw new InvalidAlgorithmError(key.type.toUpperCase() + " type " + "keys are not supported");
        }
        if (alg[0] === undefined) {
          alg[0] = key.type;
        } else if (key.type !== alg[0]) {
          throw new InvalidAlgorithmError("options.key must be a " + alg[0].toUpperCase() + " key, was given a " + key.type.toUpperCase() + " key instead");
        }
        if (alg[1] === undefined) {
          alg[1] = key.defaultHashAlgorithm();
        }
        options.algorithm = alg[0] + "-" + alg[1];
      }
      var params = {
        keyId: options.keyId,
        algorithm: options.algorithm
      };
      var i;
      var stringToSign = "";
      for (i = 0;i < headers.length; i++) {
        if (typeof headers[i] !== "string")
          throw new TypeError("options.headers must be an array of Strings");
        var h = headers[i].toLowerCase();
        if (h === "request-line") {
          if (!options.strict) {
            stringToSign += request.method + " " + request.path + " HTTP/" + options.httpVersion;
          } else {
            throw new StrictParsingError("request-line is not a valid header " + "with strict parsing enabled.");
          }
        } else if (h === "(request-target)") {
          stringToSign += "(request-target): " + request.method.toLowerCase() + " " + request.path;
        } else if (h === "(keyid)") {
          stringToSign += "(keyid): " + options.keyId;
        } else if (h === "(algorithm)") {
          stringToSign += "(algorithm): " + options.algorithm;
        } else if (h === "(opaque)") {
          var opaque = options.opaque;
          if (opaque == undefined || opaque === "") {
            throw new MissingHeaderError("options.opaque was not in the request");
          }
          stringToSign += "(opaque): " + opaque;
        } else if (h === "(created)") {
          var created = Math.floor(Date.now() / 1000);
          params.created = created;
          stringToSign += "(created): " + created;
        } else if (h === "(expires)") {
          var expiresIn = options.expiresIn;
          if (expiresIn === undefined) {
            expiresIn = 60;
          }
          const expires = Math.floor(Date.now() / 1000) + expiresIn;
          params.expires = expires;
          stringToSign += "(expires): " + expires;
        } else {
          var value = request.getHeader(h);
          if (value === undefined || value === "") {
            throw new MissingHeaderError(h + " was not in the request");
          }
          stringToSign += h + ": " + value;
        }
        if (i + 1 < headers.length)
          stringToSign += `
`;
      }
      if (request.hasOwnProperty("_stringToSign")) {
        request._stringToSign = stringToSign;
      }
      var signature;
      if (alg[0] === "hmac") {
        var hmac = crypto3.createHmac(alg[1].toUpperCase(), key);
        hmac.update(stringToSign);
        signature = hmac.digest("base64");
      } else {
        var signer = key.createSign(alg[1]);
        signer.update(stringToSign);
        var sigObj = signer.sign();
        if (!HASH_ALGOS[sigObj.hashAlgorithm]) {
          throw new InvalidAlgorithmError(sigObj.hashAlgorithm.toUpperCase() + " is not a supported hash algorithm");
        }
        assert.strictEqual(alg[1], sigObj.hashAlgorithm, "hash algorithm mismatch");
        signature = sigObj.toString();
        assert.notStrictEqual(signature, "", "empty signature produced");
      }
      var authzHeaderName = options.authorizationHeaderName || "Authorization";
      var prefix = authzHeaderName.toLowerCase() === utils.HEADER.SIG ? "" : "Signature ";
      params.signature = signature;
      if (options.opaque)
        params.opaque = options.opaque;
      if (options.headers)
        params.headers = options.headers.join(" ");
      request.setHeader(authzHeaderName, FormatAuthz(prefix, params));
      return true;
    }
  };
});

// backend/node_modules/http-signature/lib/verify.js
var require_verify = __commonJS((exports2, module2) => {
  var assert = require_assert();
  var crypto3 = require("crypto");
  var sshpk = require_lib4();
  var utils = require_utils5();
  var HASH_ALGOS = utils.HASH_ALGOS;
  var PK_ALGOS = utils.PK_ALGOS;
  var InvalidAlgorithmError = utils.InvalidAlgorithmError;
  var HttpSignatureError = utils.HttpSignatureError;
  var validateAlgorithm = utils.validateAlgorithm;
  module2.exports = {
    verifySignature: function verifySignature(parsedSignature, pubkey) {
      assert.object(parsedSignature, "parsedSignature");
      if (typeof pubkey === "string" || Buffer.isBuffer(pubkey))
        pubkey = sshpk.parseKey(pubkey);
      assert.ok(sshpk.Key.isKey(pubkey, [1, 1]), "pubkey must be a sshpk.Key");
      var alg = validateAlgorithm(parsedSignature.algorithm);
      if (alg[0] === "hmac" || alg[0] !== pubkey.type)
        return false;
      var v = pubkey.createVerify(alg[1]);
      v.update(parsedSignature.signingString);
      return v.verify(parsedSignature.params.signature, "base64");
    },
    verifyHMAC: function verifyHMAC(parsedSignature, secret) {
      assert.object(parsedSignature, "parsedHMAC");
      assert(typeof secret === "string" || Buffer.isBuffer(secret));
      var alg = validateAlgorithm(parsedSignature.algorithm);
      if (alg[0] !== "hmac")
        return false;
      var hashAlg = alg[1].toUpperCase();
      var hmac = crypto3.createHmac(hashAlg, secret);
      hmac.update(parsedSignature.signingString);
      var h1 = crypto3.createHmac(hashAlg, secret);
      h1.update(hmac.digest());
      h1 = h1.digest();
      var h2 = crypto3.createHmac(hashAlg, secret);
      h2.update(new Buffer(parsedSignature.params.signature, "base64"));
      h2 = h2.digest();
      if (typeof h1 === "string")
        return h1 === h2;
      if (Buffer.isBuffer(h1) && !h1.equals)
        return h1.toString("binary") === h2.toString("binary");
      return h1.equals(h2);
    }
  };
});

// backend/node_modules/http-signature/lib/index.js
var require_lib5 = __commonJS((exports2, module2) => {
  var parser = require_parser();
  var signer = require_signer();
  var verify = require_verify();
  var utils = require_utils5();
  module2.exports = {
    parse: parser.parseRequest,
    parseRequest: parser.parseRequest,
    sign: signer.signRequest,
    signRequest: signer.signRequest,
    createSigner: signer.createSigner,
    isSigner: signer.isSigner,
    sshKeyToPEM: utils.sshKeyToPEM,
    sshKeyFingerprint: utils.fingerprint,
    pemToRsaSSHKey: utils.pemToRsaSSHKey,
    verify: verify.verifySignature,
    verifySignature: verify.verifySignature,
    verifyHMAC: verify.verifyHMAC
  };
});

// backend/node_modules/caseless/index.js
var require_caseless = __commonJS((exports2, module2) => {
  function Caseless(dict) {
    this.dict = dict || {};
  }
  Caseless.prototype.set = function(name, value, clobber) {
    if (typeof name === "object") {
      for (var i in name) {
        this.set(i, name[i], value);
      }
    } else {
      if (typeof clobber === "undefined")
        clobber = true;
      var has2 = this.has(name);
      if (!clobber && has2)
        this.dict[has2] = this.dict[has2] + "," + value;
      else
        this.dict[has2 || name] = value;
      return has2;
    }
  };
  Caseless.prototype.has = function(name) {
    var keys = Object.keys(this.dict), name = name.toLowerCase();
    for (var i = 0;i < keys.length; i++) {
      if (keys[i].toLowerCase() === name)
        return keys[i];
    }
    return false;
  };
  Caseless.prototype.get = function(name) {
    name = name.toLowerCase();
    var result, _key;
    var headers = this.dict;
    Object.keys(headers).forEach(function(key) {
      _key = key.toLowerCase();
      if (name === _key)
        result = headers[key];
    });
    return result;
  };
  Caseless.prototype.swap = function(name) {
    var has2 = this.has(name);
    if (has2 === name)
      return;
    if (!has2)
      throw new Error('There is no header than matches "' + name + '"');
    this.dict[name] = this.dict[has2];
    delete this.dict[has2];
  };
  Caseless.prototype.del = function(name) {
    var has2 = this.has(name);
    return delete this.dict[has2 || name];
  };
  module2.exports = function(dict) {
    return new Caseless(dict);
  };
  module2.exports.httpify = function(resp, headers) {
    var c = new Caseless(headers);
    resp.setHeader = function(key, value, clobber) {
      if (typeof value === "undefined")
        return;
      return c.set(key, value, clobber);
    };
    resp.hasHeader = function(key) {
      return c.has(key);
    };
    resp.getHeader = function(key) {
      return c.get(key);
    };
    resp.removeHeader = function(key) {
      return c.del(key);
    };
    resp.headers = c.dict;
    return c;
  };
});

// backend/node_modules/forever-agent/index.js
var require_forever_agent = __commonJS((exports2, module2) => {
  module2.exports = ForeverAgent;
  ForeverAgent.SSL = ForeverAgentSSL;
  var util3 = require("util");
  var Agent = require("http").Agent;
  var net = require("net");
  var tls = require("tls");
  var AgentSSL = require("https").Agent;
  function getConnectionName(host, port) {
    var name = "";
    if (typeof host === "string") {
      name = host + ":" + port;
    } else {
      name = host.host + ":" + host.port + ":" + (host.localAddress ? host.localAddress + ":" : ":");
    }
    return name;
  }
  function ForeverAgent(options) {
    var self2 = this;
    self2.options = options || {};
    self2.requests = {};
    self2.sockets = {};
    self2.freeSockets = {};
    self2.maxSockets = self2.options.maxSockets || Agent.defaultMaxSockets;
    self2.minSockets = self2.options.minSockets || ForeverAgent.defaultMinSockets;
    self2.on("free", function(socket, host, port) {
      var name = getConnectionName(host, port);
      if (self2.requests[name] && self2.requests[name].length) {
        self2.requests[name].shift().onSocket(socket);
      } else if (self2.sockets[name].length < self2.minSockets) {
        if (!self2.freeSockets[name])
          self2.freeSockets[name] = [];
        self2.freeSockets[name].push(socket);
        var onIdleError = function() {
          socket.destroy();
        };
        socket._onIdleError = onIdleError;
        socket.on("error", onIdleError);
      } else {
        socket.destroy();
      }
    });
  }
  util3.inherits(ForeverAgent, Agent);
  ForeverAgent.defaultMinSockets = 5;
  ForeverAgent.prototype.createConnection = net.createConnection;
  ForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest;
  ForeverAgent.prototype.addRequest = function(req, host, port) {
    var name = getConnectionName(host, port);
    if (typeof host !== "string") {
      var options = host;
      port = options.port;
      host = options.host;
    }
    if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {
      var idleSocket = this.freeSockets[name].pop();
      idleSocket.removeListener("error", idleSocket._onIdleError);
      delete idleSocket._onIdleError;
      req._reusedSocket = true;
      req.onSocket(idleSocket);
    } else {
      this.addRequestNoreuse(req, host, port);
    }
  };
  ForeverAgent.prototype.removeSocket = function(s, name, host, port) {
    if (this.sockets[name]) {
      var index = this.sockets[name].indexOf(s);
      if (index !== -1) {
        this.sockets[name].splice(index, 1);
      }
    } else if (this.sockets[name] && this.sockets[name].length === 0) {
      delete this.sockets[name];
      delete this.requests[name];
    }
    if (this.freeSockets[name]) {
      var index = this.freeSockets[name].indexOf(s);
      if (index !== -1) {
        this.freeSockets[name].splice(index, 1);
        if (this.freeSockets[name].length === 0) {
          delete this.freeSockets[name];
        }
      }
    }
    if (this.requests[name] && this.requests[name].length) {
      this.createSocket(name, host, port).emit("free");
    }
  };
  function ForeverAgentSSL(options) {
    ForeverAgent.call(this, options);
  }
  util3.inherits(ForeverAgentSSL, ForeverAgent);
  ForeverAgentSSL.prototype.createConnection = createConnectionSSL;
  ForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest;
  function createConnectionSSL(port, host, options) {
    if (typeof port === "object") {
      options = port;
    } else if (typeof host === "object") {
      options = host;
    } else if (typeof options === "object") {
      options = options;
    } else {
      options = {};
    }
    if (typeof port === "number") {
      options.port = port;
    }
    if (typeof host === "string") {
      options.host = host;
    }
    return tls.connect(options);
  }
});

// backend/node_modules/isstream/isstream.js
var require_isstream = __commonJS((exports2, module2) => {
  var stream4 = require("stream");
  function isStream2(obj2) {
    return obj2 instanceof stream4.Stream;
  }
  function isReadable(obj2) {
    return isStream2(obj2) && typeof obj2._read == "function" && typeof obj2._readableState == "object";
  }
  function isWritable(obj2) {
    return isStream2(obj2) && typeof obj2._write == "function" && typeof obj2._writableState == "object";
  }
  function isDuplex(obj2) {
    return isReadable(obj2) && isWritable(obj2);
  }
  module2.exports = isStream2;
  module2.exports.isReadable = isReadable;
  module2.exports.isWritable = isWritable;
  module2.exports.isDuplex = isDuplex;
});

// backend/node_modules/is-typedarray/index.js
var require_is_typedarray = __commonJS((exports2, module2) => {
  module2.exports = isTypedArray2;
  isTypedArray2.strict = isStrictTypedArray;
  isTypedArray2.loose = isLooseTypedArray;
  var toString3 = Object.prototype.toString;
  var names = {
    "[object Int8Array]": true,
    "[object Int16Array]": true,
    "[object Int32Array]": true,
    "[object Uint8Array]": true,
    "[object Uint8ClampedArray]": true,
    "[object Uint16Array]": true,
    "[object Uint32Array]": true,
    "[object Float32Array]": true,
    "[object Float64Array]": true
  };
  function isTypedArray2(arr) {
    return isStrictTypedArray(arr) || isLooseTypedArray(arr);
  }
  function isStrictTypedArray(arr) {
    return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
  }
  function isLooseTypedArray(arr) {
    return names[toString3.call(arr)];
  }
});

// backend/node_modules/@cypress/request/lib/getProxyFromURI.js
var require_getProxyFromURI = __commonJS((exports2, module2) => {
  function formatHostname(hostname) {
    return hostname.replace(/^\.*/, ".").toLowerCase();
  }
  function parseNoProxyZone(zone) {
    zone = zone.trim().toLowerCase();
    var zoneParts = zone.split(":", 2);
    var zoneHost = formatHostname(zoneParts[0]);
    var zonePort = zoneParts[1];
    var hasPort = zone.indexOf(":") > -1;
    return { hostname: zoneHost, port: zonePort, hasPort };
  }
  function uriInNoProxy(uri, noProxy) {
    var port = uri.port || (uri.protocol === "https:" ? "443" : "80");
    var hostname = formatHostname(uri.hostname);
    var noProxyList = noProxy.split(",");
    return noProxyList.map(parseNoProxyZone).some(function(noProxyZone) {
      var isMatchedAt = hostname.indexOf(noProxyZone.hostname);
      var hostnameMatched = isMatchedAt > -1 && isMatchedAt === hostname.length - noProxyZone.hostname.length;
      if (noProxyZone.hasPort) {
        return port === noProxyZone.port && hostnameMatched;
      }
      return hostnameMatched;
    });
  }
  function getProxyFromURI(uri) {
    var noProxy = process.env.NO_PROXY || process.env.no_proxy || "";
    if (noProxy === "*") {
      return null;
    }
    if (noProxy !== "" && uriInNoProxy(uri, noProxy)) {
      return null;
    }
    if (uri.protocol === "http:") {
      return process.env.HTTP_PROXY || process.env.http_proxy || null;
    }
    if (uri.protocol === "https:") {
      return process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy || null;
    }
    return null;
  }
  module2.exports = getProxyFromURI;
});

// backend/node_modules/side-channel-list/index.js
var require_side_channel_list = __commonJS((exports2, module2) => {
  var inspect = require_object_inspect();
  var $TypeError = require_type();
  var listGetNode = function(list, key, isDelete) {
    var prev = list;
    var curr;
    for (;(curr = prev.next) != null; prev = curr) {
      if (curr.key === key) {
        prev.next = curr.next;
        if (!isDelete) {
          curr.next = list.next;
          list.next = curr;
        }
        return curr;
      }
    }
  };
  var listGet = function(objects, key) {
    if (!objects) {
      return;
    }
    var node = listGetNode(objects, key);
    return node && node.value;
  };
  var listSet = function(objects, key, value) {
    var node = listGetNode(objects, key);
    if (node) {
      node.value = value;
    } else {
      objects.next = {
        key,
        next: objects.next,
        value
      };
    }
  };
  var listHas = function(objects, key) {
    if (!objects) {
      return false;
    }
    return !!listGetNode(objects, key);
  };
  var listDelete = function(objects, key) {
    if (objects) {
      return listGetNode(objects, key, true);
    }
  };
  module2.exports = function getSideChannelList() {
    var $o;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect(key));
        }
      },
      delete: function(key) {
        var root = $o && $o.next;
        var deletedNode = listDelete($o, key);
        if (deletedNode && root && root === deletedNode) {
          $o = undefined;
        }
        return !!deletedNode;
      },
      get: function(key) {
        return listGet($o, key);
      },
      has: function(key) {
        return listHas($o, key);
      },
      set: function(key, value) {
        if (!$o) {
          $o = {
            next: undefined
          };
        }
        listSet($o, key, value);
      }
    };
    return channel;
  };
});

// backend/node_modules/side-channel-map/index.js
var require_side_channel_map = __commonJS((exports2, module2) => {
  var GetIntrinsic = require_get_intrinsic();
  var callBound = require_call_bound();
  var inspect = require_object_inspect();
  var $TypeError = require_type();
  var $Map = GetIntrinsic("%Map%", true);
  var $mapGet = callBound("Map.prototype.get", true);
  var $mapSet = callBound("Map.prototype.set", true);
  var $mapHas = callBound("Map.prototype.has", true);
  var $mapDelete = callBound("Map.prototype.delete", true);
  var $mapSize = callBound("Map.prototype.size", true);
  module2.exports = !!$Map && function getSideChannelMap() {
    var $m;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect(key));
        }
      },
      delete: function(key) {
        if ($m) {
          var result = $mapDelete($m, key);
          if ($mapSize($m) === 0) {
            $m = undefined;
          }
          return result;
        }
        return false;
      },
      get: function(key) {
        if ($m) {
          return $mapGet($m, key);
        }
      },
      has: function(key) {
        if ($m) {
          return $mapHas($m, key);
        }
        return false;
      },
      set: function(key, value) {
        if (!$m) {
          $m = new $Map;
        }
        $mapSet($m, key, value);
      }
    };
    return channel;
  };
});

// backend/node_modules/side-channel-weakmap/index.js
var require_side_channel_weakmap = __commonJS((exports2, module2) => {
  var GetIntrinsic = require_get_intrinsic();
  var callBound = require_call_bound();
  var inspect = require_object_inspect();
  var getSideChannelMap = require_side_channel_map();
  var $TypeError = require_type();
  var $WeakMap = GetIntrinsic("%WeakMap%", true);
  var $weakMapGet = callBound("WeakMap.prototype.get", true);
  var $weakMapSet = callBound("WeakMap.prototype.set", true);
  var $weakMapHas = callBound("WeakMap.prototype.has", true);
  var $weakMapDelete = callBound("WeakMap.prototype.delete", true);
  module2.exports = $WeakMap ? function getSideChannelWeakMap() {
    var $wm;
    var $m;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect(key));
        }
      },
      delete: function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapDelete($wm, key);
          }
        } else if (getSideChannelMap) {
          if ($m) {
            return $m["delete"](key);
          }
        }
        return false;
      },
      get: function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapGet($wm, key);
          }
        }
        return $m && $m.get(key);
      },
      has: function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapHas($wm, key);
          }
        }
        return !!$m && $m.has(key);
      },
      set: function(key, value) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if (!$wm) {
            $wm = new $WeakMap;
          }
          $weakMapSet($wm, key, value);
        } else if (getSideChannelMap) {
          if (!$m) {
            $m = getSideChannelMap();
          }
          $m.set(key, value);
        }
      }
    };
    return channel;
  } : getSideChannelMap;
});

// backend/node_modules/side-channel/index.js
var require_side_channel = __commonJS((exports2, module2) => {
  var $TypeError = require_type();
  var inspect = require_object_inspect();
  var getSideChannelList = require_side_channel_list();
  var getSideChannelMap = require_side_channel_map();
  var getSideChannelWeakMap = require_side_channel_weakmap();
  var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
  module2.exports = function getSideChannel() {
    var $channelData;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect(key));
        }
      },
      delete: function(key) {
        return !!$channelData && $channelData["delete"](key);
      },
      get: function(key) {
        return $channelData && $channelData.get(key);
      },
      has: function(key) {
        return !!$channelData && $channelData.has(key);
      },
      set: function(key, value) {
        if (!$channelData) {
          $channelData = makeChannel();
        }
        $channelData.set(key, value);
      }
    };
    return channel;
  };
});

// backend/node_modules/qs/lib/formats.js
var require_formats = __commonJS((exports2, module2) => {
  var replace = String.prototype.replace;
  var percentTwenties = /%20/g;
  var Format = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  };
  module2.exports = {
    default: Format.RFC3986,
    formatters: {
      RFC1738: function(value) {
        return replace.call(value, percentTwenties, "+");
      },
      RFC3986: function(value) {
        return String(value);
      }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
  };
});

// backend/node_modules/qs/lib/utils.js
var require_utils6 = __commonJS((exports2, module2) => {
  var formats = require_formats();
  var has2 = Object.prototype.hasOwnProperty;
  var isArray3 = Array.isArray;
  var hexTable = function() {
    var array = [];
    for (var i = 0;i < 256; ++i) {
      array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
    }
    return array;
  }();
  var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
      var item = queue.pop();
      var obj2 = item.obj[item.prop];
      if (isArray3(obj2)) {
        var compacted = [];
        for (var j = 0;j < obj2.length; ++j) {
          if (typeof obj2[j] !== "undefined") {
            compacted.push(obj2[j]);
          }
        }
        item.obj[item.prop] = compacted;
      }
    }
  };
  var arrayToObject2 = function arrayToObject(source, options) {
    var obj2 = options && options.plainObjects ? { __proto__: null } : {};
    for (var i = 0;i < source.length; ++i) {
      if (typeof source[i] !== "undefined") {
        obj2[i] = source[i];
      }
    }
    return obj2;
  };
  var merge2 = function merge(target, source, options) {
    if (!source) {
      return target;
    }
    if (typeof source !== "object" && typeof source !== "function") {
      if (isArray3(target)) {
        target.push(source);
      } else if (target && typeof target === "object") {
        if (options && (options.plainObjects || options.allowPrototypes) || !has2.call(Object.prototype, source)) {
          target[source] = true;
        }
      } else {
        return [target, source];
      }
      return target;
    }
    if (!target || typeof target !== "object") {
      return [target].concat(source);
    }
    var mergeTarget = target;
    if (isArray3(target) && !isArray3(source)) {
      mergeTarget = arrayToObject2(target, options);
    }
    if (isArray3(target) && isArray3(source)) {
      source.forEach(function(item, i) {
        if (has2.call(target, i)) {
          var targetItem = target[i];
          if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
            target[i] = merge(targetItem, item, options);
          } else {
            target.push(item);
          }
        } else {
          target[i] = item;
        }
      });
      return target;
    }
    return Object.keys(source).reduce(function(acc, key) {
      var value = source[key];
      if (has2.call(acc, key)) {
        acc[key] = merge(acc[key], value, options);
      } else {
        acc[key] = value;
      }
      return acc;
    }, mergeTarget);
  };
  var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function(acc, key) {
      acc[key] = source[key];
      return acc;
    }, target);
  };
  var decode = function(str2, defaultDecoder, charset) {
    var strWithoutPlus = str2.replace(/\+/g, " ");
    if (charset === "iso-8859-1") {
      return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    try {
      return decodeURIComponent(strWithoutPlus);
    } catch (e) {
      return strWithoutPlus;
    }
  };
  var limit2 = 1024;
  var encode4 = function encode(str2, defaultEncoder, charset, kind, format) {
    if (str2.length === 0) {
      return str2;
    }
    var string = str2;
    if (typeof str2 === "symbol") {
      string = Symbol.prototype.toString.call(str2);
    } else if (typeof str2 !== "string") {
      string = String(str2);
    }
    if (charset === "iso-8859-1") {
      return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
        return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
      });
    }
    var out = "";
    for (var j = 0;j < string.length; j += limit2) {
      var segment = string.length >= limit2 ? string.slice(j, j + limit2) : string;
      var arr = [];
      for (var i = 0;i < segment.length; ++i) {
        var c = segment.charCodeAt(i);
        if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
          arr[arr.length] = segment.charAt(i);
          continue;
        }
        if (c < 128) {
          arr[arr.length] = hexTable[c];
          continue;
        }
        if (c < 2048) {
          arr[arr.length] = hexTable[192 | c >> 6] + hexTable[128 | c & 63];
          continue;
        }
        if (c < 55296 || c >= 57344) {
          arr[arr.length] = hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
          continue;
        }
        i += 1;
        c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
        arr[arr.length] = hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
      out += arr.join("");
    }
    return out;
  };
  var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: "o" }];
    var refs = [];
    for (var i = 0;i < queue.length; ++i) {
      var item = queue[i];
      var obj2 = item.obj[item.prop];
      var keys = Object.keys(obj2);
      for (var j = 0;j < keys.length; ++j) {
        var key = keys[j];
        var val = obj2[key];
        if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
          queue.push({ obj: obj2, prop: key });
          refs.push(val);
        }
      }
    }
    compactQueue(queue);
    return value;
  };
  var isRegExp2 = function isRegExp(obj2) {
    return Object.prototype.toString.call(obj2) === "[object RegExp]";
  };
  var isBuffer2 = function isBuffer(obj2) {
    if (!obj2 || typeof obj2 !== "object") {
      return false;
    }
    return !!(obj2.constructor && obj2.constructor.isBuffer && obj2.constructor.isBuffer(obj2));
  };
  var combine = function combine(a, b) {
    return [].concat(a, b);
  };
  var maybeMap = function maybeMap(val, fn) {
    if (isArray3(val)) {
      var mapped = [];
      for (var i = 0;i < val.length; i += 1) {
        mapped.push(fn(val[i]));
      }
      return mapped;
    }
    return fn(val);
  };
  module2.exports = {
    arrayToObject: arrayToObject2,
    assign,
    combine,
    compact,
    decode,
    encode: encode4,
    isBuffer: isBuffer2,
    isRegExp: isRegExp2,
    maybeMap,
    merge: merge2
  };
});

// backend/node_modules/qs/lib/stringify.js
var require_stringify2 = __commonJS((exports2, module2) => {
  var getSideChannel = require_side_channel();
  var utils = require_utils6();
  var formats = require_formats();
  var has2 = Object.prototype.hasOwnProperty;
  var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
      return prefix + "[]";
    },
    comma: "comma",
    indices: function indices(prefix, key) {
      return prefix + "[" + key + "]";
    },
    repeat: function repeat(prefix) {
      return prefix;
    }
  };
  var isArray3 = Array.isArray;
  var push = Array.prototype.push;
  var pushToArray = function(arr, valueOrArray) {
    push.apply(arr, isArray3(valueOrArray) ? valueOrArray : [valueOrArray]);
  };
  var toISO = Date.prototype.toISOString;
  var defaultFormat = formats["default"];
  var defaults3 = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: "indices",
    charset: "utf-8",
    charsetSentinel: false,
    commaRoundTrip: false,
    delimiter: "&",
    encode: true,
    encodeDotInKeys: false,
    encoder: utils.encode,
    encodeValuesOnly: false,
    filter: undefined,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    indices: false,
    serializeDate: function serializeDate(date) {
      return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
  };
  var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
  };
  var sentinel2 = {};
  var stringify2 = function stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter2, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
    var obj2 = object;
    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel2)) !== undefined && !findFlag) {
      var pos = tmpSc.get(object);
      step += 1;
      if (typeof pos !== "undefined") {
        if (pos === step) {
          throw new RangeError("Cyclic object value");
        } else {
          findFlag = true;
        }
      }
      if (typeof tmpSc.get(sentinel2) === "undefined") {
        step = 0;
      }
    }
    if (typeof filter2 === "function") {
      obj2 = filter2(prefix, obj2);
    } else if (obj2 instanceof Date) {
      obj2 = serializeDate(obj2);
    } else if (generateArrayPrefix === "comma" && isArray3(obj2)) {
      obj2 = utils.maybeMap(obj2, function(value2) {
        if (value2 instanceof Date) {
          return serializeDate(value2);
        }
        return value2;
      });
    }
    if (obj2 === null) {
      if (strictNullHandling) {
        return encoder && !encodeValuesOnly ? encoder(prefix, defaults3.encoder, charset, "key", format) : prefix;
      }
      obj2 = "";
    }
    if (isNonNullishPrimitive(obj2) || utils.isBuffer(obj2)) {
      if (encoder) {
        var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults3.encoder, charset, "key", format);
        return [formatter(keyValue) + "=" + formatter(encoder(obj2, defaults3.encoder, charset, "value", format))];
      }
      return [formatter(prefix) + "=" + formatter(String(obj2))];
    }
    var values2 = [];
    if (typeof obj2 === "undefined") {
      return values2;
    }
    var objKeys;
    if (generateArrayPrefix === "comma" && isArray3(obj2)) {
      if (encodeValuesOnly && encoder) {
        obj2 = utils.maybeMap(obj2, encoder);
      }
      objKeys = [{ value: obj2.length > 0 ? obj2.join(",") || null : undefined }];
    } else if (isArray3(filter2)) {
      objKeys = filter2;
    } else {
      var keys = Object.keys(obj2);
      objKeys = sort ? keys.sort(sort) : keys;
    }
    var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
    var adjustedPrefix = commaRoundTrip && isArray3(obj2) && obj2.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
    if (allowEmptyArrays && isArray3(obj2) && obj2.length === 0) {
      return adjustedPrefix + "[]";
    }
    for (var j = 0;j < objKeys.length; ++j) {
      var key = objKeys[j];
      var value = typeof key === "object" && key && typeof key.value !== "undefined" ? key.value : obj2[key];
      if (skipNulls && value === null) {
        continue;
      }
      var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, "%2E") : String(key);
      var keyPrefix = isArray3(obj2) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
      sideChannel.set(object, step);
      var valueSideChannel = getSideChannel();
      valueSideChannel.set(sentinel2, sideChannel);
      pushToArray(values2, stringify(value, keyPrefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, generateArrayPrefix === "comma" && encodeValuesOnly && isArray3(obj2) ? null : encoder, filter2, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));
    }
    return values2;
  };
  var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
      return defaults3;
    }
    if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    }
    if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
      throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
    }
    if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
      throw new TypeError("Encoder has to be a function.");
    }
    var charset = opts.charset || defaults3.charset;
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var format = formats["default"];
    if (typeof opts.format !== "undefined") {
      if (!has2.call(formats.formatters, opts.format)) {
        throw new TypeError("Unknown format option provided.");
      }
      format = opts.format;
    }
    var formatter = formats.formatters[format];
    var filter2 = defaults3.filter;
    if (typeof opts.filter === "function" || isArray3(opts.filter)) {
      filter2 = opts.filter;
    }
    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
      arrayFormat = opts.arrayFormat;
    } else if ("indices" in opts) {
      arrayFormat = opts.indices ? "indices" : "repeat";
    } else {
      arrayFormat = defaults3.arrayFormat;
    }
    if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    }
    var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults3.allowDots : !!opts.allowDots;
    return {
      addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults3.addQueryPrefix,
      allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults3.allowEmptyArrays,
      arrayFormat,
      charset,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults3.charsetSentinel,
      commaRoundTrip: !!opts.commaRoundTrip,
      delimiter: typeof opts.delimiter === "undefined" ? defaults3.delimiter : opts.delimiter,
      encode: typeof opts.encode === "boolean" ? opts.encode : defaults3.encode,
      encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults3.encodeDotInKeys,
      encoder: typeof opts.encoder === "function" ? opts.encoder : defaults3.encoder,
      encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults3.encodeValuesOnly,
      filter: filter2,
      format,
      formatter,
      serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults3.serializeDate,
      skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults3.skipNulls,
      sort: typeof opts.sort === "function" ? opts.sort : null,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults3.strictNullHandling
    };
  };
  module2.exports = function(object, opts) {
    var obj2 = object;
    var options = normalizeStringifyOptions(opts);
    var objKeys;
    var filter2;
    if (typeof options.filter === "function") {
      filter2 = options.filter;
      obj2 = filter2("", obj2);
    } else if (isArray3(options.filter)) {
      filter2 = options.filter;
      objKeys = filter2;
    }
    var keys = [];
    if (typeof obj2 !== "object" || obj2 === null) {
      return "";
    }
    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
    if (!objKeys) {
      objKeys = Object.keys(obj2);
    }
    if (options.sort) {
      objKeys.sort(options.sort);
    }
    var sideChannel = getSideChannel();
    for (var i = 0;i < objKeys.length; ++i) {
      var key = objKeys[i];
      var value = obj2[key];
      if (options.skipNulls && value === null) {
        continue;
      }
      pushToArray(keys, stringify2(value, key, generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
    }
    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? "?" : "";
    if (options.charsetSentinel) {
      if (options.charset === "iso-8859-1") {
        prefix += "utf8=%26%2310003%3B&";
      } else {
        prefix += "utf8=%E2%9C%93&";
      }
    }
    return joined.length > 0 ? prefix + joined : "";
  };
});

// backend/node_modules/qs/lib/parse.js
var require_parse2 = __commonJS((exports2, module2) => {
  var utils = require_utils6();
  var has2 = Object.prototype.hasOwnProperty;
  var isArray3 = Array.isArray;
  var defaults3 = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils.decode,
    delimiter: "&",
    depth: 5,
    duplicates: "combine",
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false,
    throwOnLimitExceeded: false
  };
  var interpretNumericEntities = function(str2) {
    return str2.replace(/&#(\d+);/g, function($0, numberStr) {
      return String.fromCharCode(parseInt(numberStr, 10));
    });
  };
  var parseArrayValue = function(val, options, currentArrayLength) {
    if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
      return val.split(",");
    }
    if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
      throw new RangeError("Array limit exceeded. Only " + options.arrayLimit + " element" + (options.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
    }
    return val;
  };
  var isoSentinel = "utf8=%26%2310003%3B";
  var charsetSentinel = "utf8=%E2%9C%93";
  var parseValues = function parseQueryStringValues(str2, options) {
    var obj2 = { __proto__: null };
    var cleanStr = options.ignoreQueryPrefix ? str2.replace(/^\?/, "") : str2;
    cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    var limit2 = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, options.throwOnLimitExceeded ? limit2 + 1 : limit2);
    if (options.throwOnLimitExceeded && parts.length > limit2) {
      throw new RangeError("Parameter limit exceeded. Only " + limit2 + " parameter" + (limit2 === 1 ? "" : "s") + " allowed.");
    }
    var skipIndex = -1;
    var i;
    var charset = options.charset;
    if (options.charsetSentinel) {
      for (i = 0;i < parts.length; ++i) {
        if (parts[i].indexOf("utf8=") === 0) {
          if (parts[i] === charsetSentinel) {
            charset = "utf-8";
          } else if (parts[i] === isoSentinel) {
            charset = "iso-8859-1";
          }
          skipIndex = i;
          i = parts.length;
        }
      }
    }
    for (i = 0;i < parts.length; ++i) {
      if (i === skipIndex) {
        continue;
      }
      var part = parts[i];
      var bracketEqualsPos = part.indexOf("]=");
      var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
      var key;
      var val;
      if (pos === -1) {
        key = options.decoder(part, defaults3.decoder, charset, "key");
        val = options.strictNullHandling ? null : "";
      } else {
        key = options.decoder(part.slice(0, pos), defaults3.decoder, charset, "key");
        val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options, isArray3(obj2[key]) ? obj2[key].length : 0), function(encodedVal) {
          return options.decoder(encodedVal, defaults3.decoder, charset, "value");
        });
      }
      if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
        val = interpretNumericEntities(String(val));
      }
      if (part.indexOf("[]=") > -1) {
        val = isArray3(val) ? [val] : val;
      }
      var existing = has2.call(obj2, key);
      if (existing && options.duplicates === "combine") {
        obj2[key] = utils.combine(obj2[key], val);
      } else if (!existing || options.duplicates === "last") {
        obj2[key] = val;
      }
    }
    return obj2;
  };
  var parseObject = function(chain, val, options, valuesParsed) {
    var currentArrayLength = 0;
    if (chain.length > 0 && chain[chain.length - 1] === "[]") {
      var parentKey = chain.slice(0, -1).join("");
      currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
    }
    var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);
    for (var i = chain.length - 1;i >= 0; --i) {
      var obj2;
      var root = chain[i];
      if (root === "[]" && options.parseArrays) {
        obj2 = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : utils.combine([], leaf);
      } else {
        obj2 = options.plainObjects ? { __proto__: null } : {};
        var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
        var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
        var index = parseInt(decodedRoot, 10);
        if (!options.parseArrays && decodedRoot === "") {
          obj2 = { 0: leaf };
        } else if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
          obj2 = [];
          obj2[index] = leaf;
        } else if (decodedRoot !== "__proto__") {
          obj2[decodedRoot] = leaf;
        }
      }
      leaf = obj2;
    }
    return leaf;
  };
  var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
      return;
    }
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;
    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;
    var keys = [];
    if (parent) {
      if (!options.plainObjects && has2.call(Object.prototype, parent)) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(parent);
    }
    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
      i += 1;
      if (!options.plainObjects && has2.call(Object.prototype, segment[1].slice(1, -1))) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(segment[1]);
    }
    if (segment) {
      if (options.strictDepth === true) {
        throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
      }
      keys.push("[" + key.slice(segment.index) + "]");
    }
    return parseObject(keys, val, options, valuesParsed);
  };
  var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
      return defaults3;
    }
    if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    }
    if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
      throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
    }
    if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
      throw new TypeError("Decoder has to be a function.");
    }
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    if (typeof opts.throwOnLimitExceeded !== "undefined" && typeof opts.throwOnLimitExceeded !== "boolean") {
      throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
    }
    var charset = typeof opts.charset === "undefined" ? defaults3.charset : opts.charset;
    var duplicates = typeof opts.duplicates === "undefined" ? defaults3.duplicates : opts.duplicates;
    if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
      throw new TypeError("The duplicates option must be either combine, first, or last");
    }
    var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults3.allowDots : !!opts.allowDots;
    return {
      allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults3.allowEmptyArrays,
      allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults3.allowPrototypes,
      allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults3.allowSparse,
      arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults3.arrayLimit,
      charset,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults3.charsetSentinel,
      comma: typeof opts.comma === "boolean" ? opts.comma : defaults3.comma,
      decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults3.decodeDotInKeys,
      decoder: typeof opts.decoder === "function" ? opts.decoder : defaults3.decoder,
      delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults3.delimiter,
      depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults3.depth,
      duplicates,
      ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
      interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults3.interpretNumericEntities,
      parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults3.parameterLimit,
      parseArrays: opts.parseArrays !== false,
      plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults3.plainObjects,
      strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults3.strictDepth,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults3.strictNullHandling,
      throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === "boolean" ? opts.throwOnLimitExceeded : false
    };
  };
  module2.exports = function(str2, opts) {
    var options = normalizeParseOptions(opts);
    if (str2 === "" || str2 === null || typeof str2 === "undefined") {
      return options.plainObjects ? { __proto__: null } : {};
    }
    var tempObj = typeof str2 === "string" ? parseValues(str2, options) : str2;
    var obj2 = options.plainObjects ? { __proto__: null } : {};
    var keys = Object.keys(tempObj);
    for (var i = 0;i < keys.length; ++i) {
      var key = keys[i];
      var newObj = parseKeys(key, tempObj[key], options, typeof str2 === "string");
      obj2 = utils.merge(obj2, newObj, options);
    }
    if (options.allowSparse === true) {
      return obj2;
    }
    return utils.compact(obj2);
  };
});

// backend/node_modules/qs/lib/index.js
var require_lib6 = __commonJS((exports2, module2) => {
  var stringify2 = require_stringify2();
  var parse = require_parse2();
  var formats = require_formats();
  module2.exports = {
    formats,
    parse,
    stringify: stringify2
  };
});

// backend/node_modules/@cypress/request/lib/querystring.js
var require_querystring = __commonJS((exports2) => {
  var qs = require_lib6();
  var querystring = require("querystring");
  function Querystring(request) {
    this.request = request;
    this.lib = null;
    this.useQuerystring = null;
    this.parseOptions = null;
    this.stringifyOptions = null;
  }
  Querystring.prototype.init = function(options) {
    if (this.lib) {
      return;
    }
    this.useQuerystring = options.useQuerystring;
    this.lib = this.useQuerystring ? querystring : qs;
    this.parseOptions = options.qsParseOptions || {};
    this.stringifyOptions = options.qsStringifyOptions || {};
  };
  Querystring.prototype.stringify = function(obj2) {
    return this.useQuerystring ? this.rfc3986(this.lib.stringify(obj2, this.stringifyOptions.sep || null, this.stringifyOptions.eq || null, this.stringifyOptions)) : this.lib.stringify(obj2, this.stringifyOptions);
  };
  Querystring.prototype.parse = function(str2) {
    return this.useQuerystring ? this.lib.parse(str2, this.parseOptions.sep || null, this.parseOptions.eq || null, this.parseOptions) : this.lib.parse(str2, this.parseOptions);
  };
  Querystring.prototype.rfc3986 = function(str2) {
    return str2.replace(/[!'()*]/g, function(c) {
      return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
  };
  Querystring.prototype.unescape = querystring.unescape;
  exports2.Querystring = Querystring;
});

// backend/node_modules/@cypress/request/lib/har.js
var require_har = __commonJS((exports2) => {
  var fs = require("fs");
  var qs = require("querystring");
  var extend2 = require_extend();
  function Har(request) {
    this.request = request;
  }
  Har.prototype.reducer = function(obj2, pair) {
    if (obj2[pair.name] === undefined) {
      obj2[pair.name] = pair.value;
      return obj2;
    }
    var arr = [
      obj2[pair.name],
      pair.value
    ];
    obj2[pair.name] = arr;
    return obj2;
  };
  Har.prototype.prep = function(data) {
    data.queryObj = {};
    data.headersObj = {};
    data.postData.jsonObj = false;
    data.postData.paramsObj = false;
    if (data.queryString && data.queryString.length) {
      data.queryObj = data.queryString.reduce(this.reducer, {});
    }
    if (data.headers && data.headers.length) {
      data.headersObj = data.headers.reduceRight(function(headers, header) {
        headers[header.name] = header.value;
        return headers;
      }, {});
    }
    if (data.cookies && data.cookies.length) {
      var cookies = data.cookies.map(function(cookie) {
        return cookie.name + "=" + cookie.value;
      });
      if (cookies.length) {
        data.headersObj.cookie = cookies.join("; ");
      }
    }
    function some(arr) {
      return arr.some(function(type) {
        return data.postData.mimeType.indexOf(type) === 0;
      });
    }
    if (some([
      "multipart/mixed",
      "multipart/related",
      "multipart/form-data",
      "multipart/alternative"
    ])) {
      data.postData.mimeType = "multipart/form-data";
    } else if (some([
      "application/x-www-form-urlencoded"
    ])) {
      if (!data.postData.params) {
        data.postData.text = "";
      } else {
        data.postData.paramsObj = data.postData.params.reduce(this.reducer, {});
        data.postData.text = qs.stringify(data.postData.paramsObj);
      }
    } else if (some([
      "text/json",
      "text/x-json",
      "application/json",
      "application/x-json"
    ])) {
      data.postData.mimeType = "application/json";
      if (data.postData.text) {
        try {
          data.postData.jsonObj = JSON.parse(data.postData.text);
        } catch (e) {
          this.request.debug(e);
          data.postData.mimeType = "text/plain";
        }
      }
    }
    return data;
  };
  Har.prototype.options = function(options) {
    if (!options.har) {
      return options;
    }
    var har = {};
    extend2(har, options.har);
    if (har.log && har.log.entries) {
      har = har.log.entries[0];
    }
    har.url = har.url || options.url || options.uri || options.baseUrl || "/";
    har.httpVersion = har.httpVersion || "HTTP/1.1";
    har.queryString = har.queryString || [];
    har.headers = har.headers || [];
    har.cookies = har.cookies || [];
    har.postData = har.postData || {};
    har.postData.mimeType = har.postData.mimeType || "application/octet-stream";
    har.bodySize = 0;
    har.headersSize = 0;
    har.postData.size = 0;
    var req = this.prep(har);
    if (req.url) {
      options.url = req.url;
    }
    if (req.method) {
      options.method = req.method;
    }
    if (Object.keys(req.queryObj).length) {
      options.qs = req.queryObj;
    }
    if (Object.keys(req.headersObj).length) {
      options.headers = req.headersObj;
    }
    function test2(type) {
      return req.postData.mimeType.indexOf(type) === 0;
    }
    if (test2("application/x-www-form-urlencoded")) {
      options.form = req.postData.paramsObj;
    } else if (test2("application/json")) {
      if (req.postData.jsonObj) {
        options.body = req.postData.jsonObj;
        options.json = true;
      }
    } else if (test2("multipart/form-data")) {
      options.formData = {};
      req.postData.params.forEach(function(param) {
        var attachment = {};
        if (!param.fileName && !param.contentType) {
          options.formData[param.name] = param.value;
          return;
        }
        if (param.fileName && !param.value) {
          attachment.value = fs.createReadStream(param.fileName);
        } else if (param.value) {
          attachment.value = param.value;
        }
        if (param.fileName) {
          attachment.options = {
            filename: param.fileName,
            contentType: param.contentType ? param.contentType : null
          };
        }
        options.formData[param.name] = attachment;
      });
    } else {
      if (req.postData.text) {
        options.body = req.postData.text;
      }
    }
    return options;
  };
  exports2.Har = Har;
});

// backend/node_modules/uuid/dist/rng.js
var require_rng = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = rng;
  var _crypto = _interopRequireDefault(require("crypto"));
  function _interopRequireDefault(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  var rnds8Pool = new Uint8Array(256);
  var poolPtr = rnds8Pool.length;
  function rng() {
    if (poolPtr > rnds8Pool.length - 16) {
      _crypto.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  }
});

// backend/node_modules/uuid/dist/regex.js
var require_regex = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = undefined;
  var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  exports2.default = _default;
});

// backend/node_modules/uuid/dist/validate.js
var require_validate2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = undefined;
  var _regex = _interopRequireDefault(require_regex());
  function _interopRequireDefault(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  function validate(uuid2) {
    return typeof uuid2 === "string" && _regex.default.test(uuid2);
  }
  var _default = validate;
  exports2.default = _default;
});

// backend/node_modules/uuid/dist/stringify.js
var require_stringify3 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = undefined;
  var _validate = _interopRequireDefault(require_validate2());
  function _interopRequireDefault(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  var byteToHex = [];
  for (let i = 0;i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).substr(1));
  }
  function stringify2(arr, offset = 0) {
    const uuid2 = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    if (!(0, _validate.default)(uuid2)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid2;
  }
  var _default = stringify2;
  exports2.default = _default;
});

// backend/node_modules/uuid/dist/v1.js
var require_v1 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = _interopRequireDefault(require_stringify3());
  function _interopRequireDefault(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  function v1(options, buf, offset) {
    let i = buf && offset || 0;
    const b = buf || new Array(16);
    options = options || {};
    let node = options.node || _nodeId;
    let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;
    if (node == null || clockseq == null) {
      const seedBytes = options.random || (options.rng || _rng.default)();
      if (node == null) {
        node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    let msecs = options.msecs !== undefined ? options.msecs : Date.now();
    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255;
    b[i++] = tl >>> 16 & 255;
    b[i++] = tl >>> 8 & 255;
    b[i++] = tl & 255;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i++] = tmh >>> 8 & 255;
    b[i++] = tmh & 255;
    b[i++] = tmh >>> 24 & 15 | 16;
    b[i++] = tmh >>> 16 & 255;
    b[i++] = clockseq >>> 8 | 128;
    b[i++] = clockseq & 255;
    for (let n = 0;n < 6; ++n) {
      b[i + n] = node[n];
    }
    return buf || (0, _stringify.default)(b);
  }
  var _default = v1;
  exports2.default = _default;
});

// backend/node_modules/uuid/dist/parse.js
var require_parse3 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = undefined;
  var _validate = _interopRequireDefault(require_validate2());
  function _interopRequireDefault(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  function parse(uuid2) {
    if (!(0, _validate.default)(uuid2)) {
      throw TypeError("Invalid UUID");
    }
    let v;
    const arr = new Uint8Array(16);
    arr[0] = (v = parseInt(uuid2.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 255;
    arr[2] = v >>> 8 & 255;
    arr[3] = v & 255;
    arr[4] = (v = parseInt(uuid2.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 255;
    arr[6] = (v = parseInt(uuid2.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 255;
    arr[8] = (v = parseInt(uuid2.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 255;
    arr[10] = (v = parseInt(uuid2.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v / 4294967296 & 255;
    arr[12] = v >>> 24 & 255;
    arr[13] = v >>> 16 & 255;
    arr[14] = v >>> 8 & 255;
    arr[15] = v & 255;
    return arr;
  }
  var _default = parse;
  exports2.default = _default;
});

// backend/node_modules/uuid/dist/v35.js
var require_v35 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = _default;
  exports2.URL = exports2.DNS = undefined;
  var _stringify = _interopRequireDefault(require_stringify3());
  var _parse = _interopRequireDefault(require_parse3());
  function _interopRequireDefault(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  function stringToBytes(str2) {
    str2 = unescape(encodeURIComponent(str2));
    const bytes = [];
    for (let i = 0;i < str2.length; ++i) {
      bytes.push(str2.charCodeAt(i));
    }
    return bytes;
  }
  var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  exports2.DNS = DNS;
  var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  exports2.URL = URL2;
  function _default(name, version, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
      if (typeof value === "string") {
        value = stringToBytes(value);
      }
      if (typeof namespace === "string") {
        namespace = (0, _parse.default)(namespace);
      }
      if (namespace.length !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes = new Uint8Array(16 + value.length);
      bytes.set(namespace);
      bytes.set(value, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 15 | version;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0;i < 16; ++i) {
          buf[offset + i] = bytes[i];
        }
        return buf;
      }
      return (0, _stringify.default)(bytes);
    }
    try {
      generateUUID.name = name;
    } catch (err) {}
    generateUUID.DNS = DNS;
    generateUUID.URL = URL2;
    return generateUUID;
  }
});

// backend/node_modules/uuid/dist/md5.js
var require_md5 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = undefined;
  var _crypto = _interopRequireDefault(require("crypto"));
  function _interopRequireDefault(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  function md5(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("md5").update(bytes).digest();
  }
  var _default = md5;
  exports2.default = _default;
});

// backend/node_modules/uuid/dist/v3.js
var require_v3 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _md = _interopRequireDefault(require_md5());
  function _interopRequireDefault(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  var v3 = (0, _v.default)("v3", 48, _md.default);
  var _default = v3;
  exports2.default = _default;
});

// backend/node_modules/uuid/dist/v4.js
var require_v4 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = _interopRequireDefault(require_stringify3());
  function _interopRequireDefault(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  function v4(options, buf, offset) {
    options = options || {};
    const rnds = options.random || (options.rng || _rng.default)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0;i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return (0, _stringify.default)(rnds);
  }
  var _default = v4;
  exports2.default = _default;
});

// backend/node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = undefined;
  var _crypto = _interopRequireDefault(require("crypto"));
  function _interopRequireDefault(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  function sha1(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("sha1").update(bytes).digest();
  }
  var _default = sha1;
  exports2.default = _default;
});

// backend/node_modules/uuid/dist/v5.js
var require_v5 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _sha = _interopRequireDefault(require_sha1());
  function _interopRequireDefault(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  var v5 = (0, _v.default)("v5", 80, _sha.default);
  var _default = v5;
  exports2.default = _default;
});

// backend/node_modules/uuid/dist/nil.js
var require_nil = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = undefined;
  var _default = "00000000-0000-0000-0000-000000000000";
  exports2.default = _default;
});

// backend/node_modules/uuid/dist/version.js
var require_version6 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = undefined;
  var _validate = _interopRequireDefault(require_validate2());
  function _interopRequireDefault(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  function version(uuid2) {
    if (!(0, _validate.default)(uuid2)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid2.substr(14, 1), 16);
  }
  var _default = version;
  exports2.default = _default;
});

// backend/node_modules/uuid/dist/index.js
var require_dist2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  Object.defineProperty(exports2, "v1", {
    enumerable: true,
    get: function() {
      return _v.default;
    }
  });
  Object.defineProperty(exports2, "v3", {
    enumerable: true,
    get: function() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports2, "v4", {
    enumerable: true,
    get: function() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports2, "v5", {
    enumerable: true,
    get: function() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports2, "NIL", {
    enumerable: true,
    get: function() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports2, "version", {
    enumerable: true,
    get: function() {
      return _version.default;
    }
  });
  Object.defineProperty(exports2, "validate", {
    enumerable: true,
    get: function() {
      return _validate.default;
    }
  });
  Object.defineProperty(exports2, "stringify", {
    enumerable: true,
    get: function() {
      return _stringify.default;
    }
  });
  Object.defineProperty(exports2, "parse", {
    enumerable: true,
    get: function() {
      return _parse.default;
    }
  });
  var _v = _interopRequireDefault(require_v1());
  var _v2 = _interopRequireDefault(require_v3());
  var _v3 = _interopRequireDefault(require_v4());
  var _v4 = _interopRequireDefault(require_v5());
  var _nil = _interopRequireDefault(require_nil());
  var _version = _interopRequireDefault(require_version6());
  var _validate = _interopRequireDefault(require_validate2());
  var _stringify = _interopRequireDefault(require_stringify3());
  var _parse = _interopRequireDefault(require_parse3());
  function _interopRequireDefault(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
});

// backend/node_modules/@cypress/request/lib/auth.js
var require_auth = __commonJS((exports2) => {
  var caseless = require_caseless();
  var { v4: uuid2 } = require_dist2();
  var helpers = require_helpers5();
  var md5 = helpers.md5;
  var toBase64 = helpers.toBase64;
  function Auth(request) {
    this.request = request;
    this.hasAuth = false;
    this.sentAuth = false;
    this.bearerToken = null;
    this.user = null;
    this.pass = null;
  }
  Auth.prototype.basic = function(user, pass, sendImmediately) {
    var self2 = this;
    if (typeof user !== "string" || pass !== undefined && typeof pass !== "string") {
      self2.request.emit("error", new Error("auth() received invalid user or password"));
    }
    self2.user = user;
    self2.pass = pass;
    self2.hasAuth = true;
    var header = user + ":" + (pass || "");
    if (sendImmediately || typeof sendImmediately === "undefined") {
      var authHeader = "Basic " + toBase64(header);
      self2.sentAuth = true;
      return authHeader;
    }
  };
  Auth.prototype.bearer = function(bearer, sendImmediately) {
    var self2 = this;
    self2.bearerToken = bearer;
    self2.hasAuth = true;
    if (sendImmediately || typeof sendImmediately === "undefined") {
      if (typeof bearer === "function") {
        bearer = bearer();
      }
      var authHeader = "Bearer " + (bearer || "");
      self2.sentAuth = true;
      return authHeader;
    }
  };
  Auth.prototype.digest = function(method, path2, authHeader) {
    var self2 = this;
    var challenge = {};
    var re = /([a-z0-9_-]+)=(?:"([^"]+)"|([a-z0-9_-]+))/gi;
    while (true) {
      var match2 = re.exec(authHeader);
      if (!match2) {
        break;
      }
      challenge[match2[1]] = match2[2] || match2[3];
    }
    var ha1Compute = function(algorithm, user, realm, pass, nonce, cnonce2) {
      var ha12 = md5(user + ":" + realm + ":" + pass);
      if (algorithm && algorithm.toLowerCase() === "md5-sess") {
        return md5(ha12 + ":" + nonce + ":" + cnonce2);
      } else {
        return ha12;
      }
    };
    var qop = /(^|,)\s*auth\s*($|,)/.test(challenge.qop) && "auth";
    var nc = qop && "00000001";
    var cnonce = qop && uuid2().replace(/-/g, "");
    var ha1 = ha1Compute(challenge.algorithm, self2.user, challenge.realm, self2.pass, challenge.nonce, cnonce);
    var ha2 = md5(method + ":" + path2);
    var digestResponse = qop ? md5(ha1 + ":" + challenge.nonce + ":" + nc + ":" + cnonce + ":" + qop + ":" + ha2) : md5(ha1 + ":" + challenge.nonce + ":" + ha2);
    var authValues = {
      username: self2.user,
      realm: challenge.realm,
      nonce: challenge.nonce,
      uri: path2,
      qop,
      response: digestResponse,
      nc,
      cnonce,
      algorithm: challenge.algorithm,
      opaque: challenge.opaque
    };
    authHeader = [];
    for (var k in authValues) {
      if (authValues[k]) {
        if (k === "qop" || k === "nc" || k === "algorithm") {
          authHeader.push(k + "=" + authValues[k]);
        } else {
          authHeader.push(k + '="' + authValues[k] + '"');
        }
      }
    }
    authHeader = "Digest " + authHeader.join(", ");
    self2.sentAuth = true;
    return authHeader;
  };
  Auth.prototype.onRequest = function(user, pass, sendImmediately, bearer) {
    var self2 = this;
    var request = self2.request;
    var authHeader;
    if (bearer === undefined && user === undefined) {
      self2.request.emit("error", new Error("no auth mechanism defined"));
    } else if (bearer !== undefined) {
      authHeader = self2.bearer(bearer, sendImmediately);
    } else {
      authHeader = self2.basic(user, pass, sendImmediately);
    }
    if (authHeader) {
      request.setHeader("authorization", authHeader);
    }
  };
  Auth.prototype.onResponse = function(response) {
    var self2 = this;
    var request = self2.request;
    if (!self2.hasAuth || self2.sentAuth) {
      return null;
    }
    var c = caseless(response.headers);
    var authHeader = c.get("www-authenticate");
    var authVerb = authHeader && authHeader.split(" ")[0].toLowerCase();
    request.debug("reauth", authVerb);
    switch (authVerb) {
      case "basic":
        return self2.basic(self2.user, self2.pass, true);
      case "bearer":
        return self2.bearer(self2.bearerToken, true);
      case "digest":
        return self2.digest(request.method, request.path, authHeader);
    }
  };
  exports2.Auth = Auth;
});

// backend/node_modules/@cypress/request/lib/hawk.js
var require_hawk = __commonJS((exports2) => {
  var crypto3 = require("crypto");
  function randomString(size) {
    var bits = (size + 1) * 6;
    var buffer = crypto3.randomBytes(Math.ceil(bits / 8));
    var string = buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
    return string.slice(0, size);
  }
  function calculatePayloadHash(payload, algorithm, contentType) {
    var hash = crypto3.createHash(algorithm);
    hash.update(`hawk.1.payload
`);
    hash.update((contentType ? contentType.split(";")[0].trim().toLowerCase() : "") + `
`);
    hash.update(payload || "");
    hash.update(`
`);
    return hash.digest("base64");
  }
  exports2.calculateMac = function(credentials, opts) {
    var normalized = `hawk.1.header
` + opts.ts + `
` + opts.nonce + `
` + (opts.method || "").toUpperCase() + `
` + opts.resource + `
` + opts.host.toLowerCase() + `
` + opts.port + `
` + (opts.hash || "") + `
`;
    if (opts.ext) {
      normalized = normalized + opts.ext.replace("\\", "\\\\").replace(`
`, "\\n");
    }
    normalized = normalized + `
`;
    if (opts.app) {
      normalized = normalized + opts.app + `
` + (opts.dlg || "") + `
`;
    }
    var hmac = crypto3.createHmac(credentials.algorithm, credentials.key).update(normalized);
    var digest = hmac.digest("base64");
    return digest;
  };
  exports2.header = function(uri, method, opts) {
    var timestamp = opts.timestamp || Math.floor((Date.now() + (opts.localtimeOffsetMsec || 0)) / 1000);
    var credentials = opts.credentials;
    if (!credentials || !credentials.id || !credentials.key || !credentials.algorithm) {
      return "";
    }
    if (["sha1", "sha256"].indexOf(credentials.algorithm) === -1) {
      return "";
    }
    var artifacts = {
      ts: timestamp,
      nonce: opts.nonce || randomString(6),
      method,
      resource: uri.pathname + (uri.search || ""),
      host: uri.hostname,
      port: uri.port || (uri.protocol === "http:" ? 80 : 443),
      hash: opts.hash,
      ext: opts.ext,
      app: opts.app,
      dlg: opts.dlg
    };
    if (!artifacts.hash && (opts.payload || opts.payload === "")) {
      artifacts.hash = calculatePayloadHash(opts.payload, credentials.algorithm, opts.contentType);
    }
    var mac = exports2.calculateMac(credentials, artifacts);
    var hasExt = artifacts.ext !== null && artifacts.ext !== undefined && artifacts.ext !== "";
    var header = 'Hawk id="' + credentials.id + '", ts="' + artifacts.ts + '", nonce="' + artifacts.nonce + (artifacts.hash ? '", hash="' + artifacts.hash : "") + (hasExt ? '", ext="' + artifacts.ext.replace(/\\/g, "\\\\").replace(/"/g, "\\\"") : "") + '", mac="' + mac + '"';
    if (artifacts.app) {
      header = header + ', app="' + artifacts.app + (artifacts.dlg ? '", dlg="' + artifacts.dlg : "") + '"';
    }
    return header;
  };
});

// backend/node_modules/@cypress/request/lib/multipart.js
var require_multipart = __commonJS((exports2) => {
  var { v4: uuid2 } = require_dist2();
  var CombinedStream = require_combined_stream();
  var isstream = require_isstream();
  var Buffer2 = require_safe_buffer3().Buffer;
  function Multipart(request) {
    this.request = request;
    this.boundary = uuid2();
    this.chunked = false;
    this.body = null;
  }
  Multipart.prototype.isChunked = function(options) {
    var self2 = this;
    var chunked = false;
    var parts = options.data || options;
    if (!parts.forEach) {
      self2.request.emit("error", new Error("Argument error, options.multipart."));
    }
    if (options.chunked !== undefined) {
      chunked = options.chunked;
    }
    if (self2.request.getHeader("transfer-encoding") === "chunked") {
      chunked = true;
    }
    if (!chunked) {
      parts.forEach(function(part) {
        if (typeof part.body === "undefined") {
          self2.request.emit("error", new Error("Body attribute missing in multipart."));
        }
        if (isstream(part.body)) {
          chunked = true;
        }
      });
    }
    return chunked;
  };
  Multipart.prototype.setHeaders = function(chunked) {
    var self2 = this;
    if (chunked && !self2.request.hasHeader("transfer-encoding")) {
      self2.request.setHeader("transfer-encoding", "chunked");
    }
    var header = self2.request.getHeader("content-type");
    if (!header || header.indexOf("multipart") === -1) {
      self2.request.setHeader("content-type", "multipart/related; boundary=" + self2.boundary);
    } else {
      if (header.indexOf("boundary") !== -1) {
        self2.boundary = header.replace(/.*boundary=([^\s;]+).*/, "$1");
      } else {
        self2.request.setHeader("content-type", header + "; boundary=" + self2.boundary);
      }
    }
  };
  Multipart.prototype.build = function(parts, chunked) {
    var self2 = this;
    var body = chunked ? new CombinedStream : [];
    function add(part) {
      if (typeof part === "number") {
        part = part.toString();
      }
      return chunked ? body.append(part) : body.push(Buffer2.from(part));
    }
    if (self2.request.preambleCRLF) {
      add(`\r
`);
    }
    parts.forEach(function(part) {
      var preamble = "--" + self2.boundary + `\r
`;
      Object.keys(part).forEach(function(key) {
        if (key === "body") {
          return;
        }
        preamble += key + ": " + part[key] + `\r
`;
      });
      preamble += `\r
`;
      add(preamble);
      add(part.body);
      add(`\r
`);
    });
    add("--" + self2.boundary + "--");
    if (self2.request.postambleCRLF) {
      add(`\r
`);
    }
    return body;
  };
  Multipart.prototype.onRequest = function(options) {
    var self2 = this;
    var chunked = self2.isChunked(options);
    var parts = options.data || options;
    self2.setHeaders(chunked);
    self2.chunked = chunked;
    self2.body = self2.build(parts, chunked);
  };
  exports2.Multipart = Multipart;
});

// backend/node_modules/@cypress/request/lib/redirect.js
var require_redirect = __commonJS((exports2) => {
  var url2 = require("url");
  var isUrl = /^https?:/;
  function Redirect(request) {
    this.request = request;
    this.followRedirect = true;
    this.followRedirects = true;
    this.followAllRedirects = false;
    this.followOriginalHttpMethod = false;
    this.allowRedirect = function() {
      return true;
    };
    this.maxRedirects = 10;
    this.redirects = [];
    this.redirectsFollowed = 0;
    this.removeRefererHeader = false;
    this.allowInsecureRedirect = false;
  }
  Redirect.prototype.onRequest = function(options) {
    var self2 = this;
    if (options.maxRedirects !== undefined) {
      self2.maxRedirects = options.maxRedirects;
    }
    if (typeof options.followRedirect === "function") {
      self2.allowRedirect = options.followRedirect;
    }
    if (options.followRedirect !== undefined) {
      self2.followRedirects = !!options.followRedirect;
    }
    if (options.followAllRedirects !== undefined) {
      self2.followAllRedirects = options.followAllRedirects;
    }
    if (self2.followRedirects || self2.followAllRedirects) {
      self2.redirects = self2.redirects || [];
    }
    if (options.removeRefererHeader !== undefined) {
      self2.removeRefererHeader = options.removeRefererHeader;
    }
    if (options.followOriginalHttpMethod !== undefined) {
      self2.followOriginalHttpMethod = options.followOriginalHttpMethod;
    }
    if (options.allowInsecureRedirect !== undefined) {
      self2.allowInsecureRedirect = options.allowInsecureRedirect;
    }
  };
  Redirect.prototype.redirectTo = function(response) {
    var self2 = this;
    var request = self2.request;
    var redirectTo = null;
    if (response.statusCode >= 300 && response.statusCode < 400 && response.caseless.has("location")) {
      var location = response.caseless.get("location");
      request.debug("redirect", location);
      if (self2.followAllRedirects) {
        redirectTo = location;
      } else if (self2.followRedirects) {
        switch (request.method) {
          case "PATCH":
          case "PUT":
          case "POST":
          case "DELETE":
            break;
          default:
            redirectTo = location;
            break;
        }
      }
    } else if (response.statusCode === 401) {
      var authHeader = request._auth.onResponse(response);
      if (authHeader) {
        request.setHeader("authorization", authHeader);
        redirectTo = request.uri;
      }
    }
    return redirectTo;
  };
  Redirect.prototype.onResponse = function(response, callback) {
    var self2 = this;
    var request = self2.request;
    var redirectTo = self2.redirectTo(response);
    if (!redirectTo)
      return callback(null, false);
    function processRedirect(shouldRedirect) {
      if (!shouldRedirect)
        return callback(null, false);
      if (typeof shouldRedirect === "string") {
        request.debug("redirect overridden", redirectTo);
        redirectTo = shouldRedirect;
      }
      request.debug("redirect to", redirectTo);
      if (response.resume) {
        response.resume();
      }
      if (self2.redirectsFollowed >= self2.maxRedirects) {
        return callback(new Error("Exceeded maxRedirects. Probably stuck in a redirect loop " + request.uri.href));
      }
      self2.redirectsFollowed += 1;
      if (!isUrl.test(redirectTo)) {
        redirectTo = url2.resolve(request.uri.href, redirectTo);
      }
      var uriPrev = request.uri;
      request.uri = url2.parse(redirectTo);
      if (request.uri.protocol !== uriPrev.protocol && self2.allowInsecureRedirect) {
        delete request.agent;
      }
      self2.redirects.push({ statusCode: response.statusCode, redirectUri: redirectTo });
      if (self2.followAllRedirects && request.method !== "HEAD" && response.statusCode !== 401 && response.statusCode !== 307) {
        request.method = self2.followOriginalHttpMethod ? request.method : "GET";
      }
      delete request.src;
      delete request.req;
      delete request._started;
      if (response.statusCode !== 401 && response.statusCode !== 307) {
        delete request.body;
        delete request._form;
        if (request.headers) {
          request.removeHeader("host");
          request.removeHeader("content-type");
          request.removeHeader("content-length");
          if (request.uri.hostname !== request.originalHost.split(":")[0]) {
            request.removeHeader("authorization");
          }
        }
      }
      if (!self2.removeRefererHeader) {
        request.setHeader("referer", uriPrev.href);
      }
      request.emit("redirect");
      request.init();
      callback(null, true);
    }
    if (self2.allowRedirect.length > 1) {
      return self2.allowRedirect.call(request, response, function(err, result) {
        if (err)
          return callback(err);
        processRedirect(result);
      });
    }
    var allowsRedirect = self2.allowRedirect.call(request, response);
    if (allowsRedirect && allowsRedirect.then) {
      return allowsRedirect.then(processRedirect, callback);
    }
    processRedirect(allowsRedirect);
  };
  exports2.Redirect = Redirect;
});

// backend/node_modules/tunnel-agent/index.js
var require_tunnel_agent = __commonJS((exports2) => {
  var net = require("net");
  var tls = require("tls");
  var http3 = require("http");
  var https2 = require("https");
  var events = require("events");
  var assert = require("assert");
  var util3 = require("util");
  var Buffer2 = require_safe_buffer3().Buffer;
  exports2.httpOverHttp = httpOverHttp;
  exports2.httpsOverHttp = httpsOverHttp;
  exports2.httpOverHttps = httpOverHttps;
  exports2.httpsOverHttps = httpsOverHttps;
  function httpOverHttp(options) {
    var agent = new TunnelingAgent(options);
    agent.request = http3.request;
    return agent;
  }
  function httpsOverHttp(options) {
    var agent = new TunnelingAgent(options);
    agent.request = http3.request;
    agent.createSocket = createSecureSocket;
    agent.defaultPort = 443;
    return agent;
  }
  function httpOverHttps(options) {
    var agent = new TunnelingAgent(options);
    agent.request = https2.request;
    return agent;
  }
  function httpsOverHttps(options) {
    var agent = new TunnelingAgent(options);
    agent.request = https2.request;
    agent.createSocket = createSecureSocket;
    agent.defaultPort = 443;
    return agent;
  }
  function TunnelingAgent(options) {
    var self2 = this;
    self2.options = options || {};
    self2.proxyOptions = self2.options.proxy || {};
    self2.maxSockets = self2.options.maxSockets || http3.Agent.defaultMaxSockets;
    self2.requests = [];
    self2.sockets = [];
    self2.on("free", function onFree(socket, host, port) {
      for (var i = 0, len = self2.requests.length;i < len; ++i) {
        var pending = self2.requests[i];
        if (pending.host === host && pending.port === port) {
          self2.requests.splice(i, 1);
          pending.request.onSocket(socket);
          return;
        }
      }
      socket.destroy();
      self2.removeSocket(socket);
    });
  }
  util3.inherits(TunnelingAgent, events.EventEmitter);
  TunnelingAgent.prototype.addRequest = function addRequest(req, options) {
    var self2 = this;
    if (typeof options === "string") {
      options = {
        host: options,
        port: arguments[2],
        path: arguments[3]
      };
    }
    if (self2.sockets.length >= this.maxSockets) {
      self2.requests.push({ host: options.host, port: options.port, request: req });
      return;
    }
    self2.createConnection({ host: options.host, port: options.port, request: req });
  };
  TunnelingAgent.prototype.createConnection = function createConnection(pending) {
    var self2 = this;
    self2.createSocket(pending, function(socket) {
      socket.on("free", onFree);
      socket.on("close", onCloseOrRemove);
      socket.on("agentRemove", onCloseOrRemove);
      pending.request.onSocket(socket);
      function onFree() {
        self2.emit("free", socket, pending.host, pending.port);
      }
      function onCloseOrRemove(err) {
        self2.removeSocket(socket);
        socket.removeListener("free", onFree);
        socket.removeListener("close", onCloseOrRemove);
        socket.removeListener("agentRemove", onCloseOrRemove);
      }
    });
  };
  TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
    var self2 = this;
    var placeholder = {};
    self2.sockets.push(placeholder);
    var connectOptions = mergeOptions({}, self2.proxyOptions, {
      method: "CONNECT",
      path: options.host + ":" + options.port,
      agent: false
    });
    if (connectOptions.proxyAuth) {
      connectOptions.headers = connectOptions.headers || {};
      connectOptions.headers["Proxy-Authorization"] = "Basic " + Buffer2.from(connectOptions.proxyAuth).toString("base64");
    }
    debug("making CONNECT request");
    var connectReq = self2.request(connectOptions);
    connectReq.useChunkedEncodingByDefault = false;
    connectReq.once("response", onResponse);
    connectReq.once("upgrade", onUpgrade);
    connectReq.once("connect", onConnect);
    connectReq.once("error", onError);
    connectReq.end();
    function onResponse(res) {
      res.upgrade = true;
    }
    function onUpgrade(res, socket, head) {
      process.nextTick(function() {
        onConnect(res, socket, head);
      });
    }
    function onConnect(res, socket, head) {
      connectReq.removeAllListeners();
      socket.removeAllListeners();
      if (res.statusCode === 200) {
        assert.equal(head.length, 0);
        debug("tunneling connection has established");
        self2.sockets[self2.sockets.indexOf(placeholder)] = socket;
        cb(socket);
      } else {
        debug("tunneling socket could not be established, statusCode=%d", res.statusCode);
        var error2 = new Error("tunneling socket could not be established, " + "statusCode=" + res.statusCode);
        error2.code = "ECONNRESET";
        options.request.emit("error", error2);
        self2.removeSocket(placeholder);
      }
    }
    function onError(cause) {
      connectReq.removeAllListeners();
      debug(`tunneling socket could not be established, cause=%s
`, cause.message, cause.stack);
      var error2 = new Error("tunneling socket could not be established, " + "cause=" + cause.message);
      error2.code = "ECONNRESET";
      options.request.emit("error", error2);
      self2.removeSocket(placeholder);
    }
  };
  TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
    var pos = this.sockets.indexOf(socket);
    if (pos === -1)
      return;
    this.sockets.splice(pos, 1);
    var pending = this.requests.shift();
    if (pending) {
      this.createConnection(pending);
    }
  };
  function createSecureSocket(options, cb) {
    var self2 = this;
    TunnelingAgent.prototype.createSocket.call(self2, options, function(socket) {
      var secureSocket = tls.connect(0, mergeOptions({}, self2.options, {
        servername: options.host,
        socket
      }));
      self2.sockets[self2.sockets.indexOf(socket)] = secureSocket;
      cb(secureSocket);
    });
  }
  function mergeOptions(target) {
    for (var i = 1, len = arguments.length;i < len; ++i) {
      var overrides = arguments[i];
      if (typeof overrides === "object") {
        var keys = Object.keys(overrides);
        for (var j = 0, keyLen = keys.length;j < keyLen; ++j) {
          var k = keys[j];
          if (overrides[k] !== undefined) {
            target[k] = overrides[k];
          }
        }
      }
    }
    return target;
  }
  var debug;
  if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments);
      if (typeof args[0] === "string") {
        args[0] = "TUNNEL: " + args[0];
      } else {
        args.unshift("TUNNEL:");
      }
      console.error.apply(console, args);
    };
  } else {
    debug = function() {};
  }
  exports2.debug = debug;
});

// backend/node_modules/@cypress/request/lib/tunnel.js
var require_tunnel = __commonJS((exports2) => {
  var url2 = require("url");
  var tunnel = require_tunnel_agent();
  var defaultProxyHeaderWhiteList = [
    "accept",
    "accept-charset",
    "accept-encoding",
    "accept-language",
    "accept-ranges",
    "cache-control",
    "content-encoding",
    "content-language",
    "content-location",
    "content-md5",
    "content-range",
    "content-type",
    "connection",
    "date",
    "expect",
    "max-forwards",
    "pragma",
    "referer",
    "te",
    "user-agent",
    "via"
  ];
  var defaultProxyHeaderExclusiveList = [
    "proxy-authorization"
  ];
  function constructProxyHost(uriObject) {
    var port = uriObject.port;
    var protocol = uriObject.protocol;
    var proxyHost = uriObject.hostname + ":";
    if (port) {
      proxyHost += port;
    } else if (protocol === "https:") {
      proxyHost += "443";
    } else {
      proxyHost += "80";
    }
    return proxyHost;
  }
  function constructProxyHeaderWhiteList(headers, proxyHeaderWhiteList) {
    var whiteList = proxyHeaderWhiteList.reduce(function(set, header) {
      set[header.toLowerCase()] = true;
      return set;
    }, {});
    return Object.keys(headers).filter(function(header) {
      return whiteList[header.toLowerCase()];
    }).reduce(function(set, header) {
      set[header] = headers[header];
      return set;
    }, {});
  }
  function constructTunnelOptions(request, proxyHeaders) {
    var proxy = request.proxy;
    var tunnelOptions = {
      proxy: {
        host: proxy.hostname,
        port: +proxy.port,
        proxyAuth: proxy.auth,
        headers: proxyHeaders
      },
      headers: request.headers,
      ca: request.ca,
      cert: request.cert,
      key: request.key,
      passphrase: request.passphrase,
      pfx: request.pfx,
      ciphers: request.ciphers,
      rejectUnauthorized: request.rejectUnauthorized,
      secureOptions: request.secureOptions,
      secureProtocol: request.secureProtocol
    };
    return tunnelOptions;
  }
  function constructTunnelFnName(uri, proxy) {
    var uriProtocol = uri.protocol === "https:" ? "https" : "http";
    var proxyProtocol = proxy.protocol === "https:" ? "Https" : "Http";
    return [uriProtocol, proxyProtocol].join("Over");
  }
  function getTunnelFn(request) {
    var uri = request.uri;
    var proxy = request.proxy;
    var tunnelFnName = constructTunnelFnName(uri, proxy);
    return tunnel[tunnelFnName];
  }
  function Tunnel(request) {
    this.request = request;
    this.proxyHeaderWhiteList = defaultProxyHeaderWhiteList;
    this.proxyHeaderExclusiveList = [];
    if (typeof request.tunnel !== "undefined") {
      this.tunnelOverride = request.tunnel;
    }
  }
  Tunnel.prototype.isEnabled = function() {
    var self2 = this;
    var request = self2.request;
    if (typeof self2.tunnelOverride !== "undefined") {
      return self2.tunnelOverride;
    }
    if (request.uri.protocol === "https:") {
      return true;
    }
    return false;
  };
  Tunnel.prototype.setup = function(options) {
    var self2 = this;
    var request = self2.request;
    options = options || {};
    if (typeof request.proxy === "string") {
      request.proxy = url2.parse(request.proxy);
    }
    if (!request.proxy || !request.tunnel) {
      return false;
    }
    if (options.proxyHeaderWhiteList) {
      self2.proxyHeaderWhiteList = options.proxyHeaderWhiteList;
    }
    if (options.proxyHeaderExclusiveList) {
      self2.proxyHeaderExclusiveList = options.proxyHeaderExclusiveList;
    }
    var proxyHeaderExclusiveList = self2.proxyHeaderExclusiveList.concat(defaultProxyHeaderExclusiveList);
    var proxyHeaderWhiteList = self2.proxyHeaderWhiteList.concat(proxyHeaderExclusiveList);
    var proxyHeaders = constructProxyHeaderWhiteList(request.headers, proxyHeaderWhiteList);
    proxyHeaders.host = constructProxyHost(request.uri);
    proxyHeaderExclusiveList.forEach(request.removeHeader, request);
    var tunnelFn = getTunnelFn(request);
    var tunnelOptions = constructTunnelOptions(request, proxyHeaders);
    request.agent = tunnelFn(tunnelOptions);
    return true;
  };
  Tunnel.defaultProxyHeaderWhiteList = defaultProxyHeaderWhiteList;
  Tunnel.defaultProxyHeaderExclusiveList = defaultProxyHeaderExclusiveList;
  exports2.Tunnel = Tunnel;
});

// backend/node_modules/performance-now/lib/performance-now.js
var require_performance_now = __commonJS((exports2, module2) => {
  (function() {
    var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
    if (typeof performance !== "undefined" && performance !== null && performance.now) {
      module2.exports = function() {
        return performance.now();
      };
    } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
      module2.exports = function() {
        return (getNanoSeconds() - nodeLoadTime) / 1e6;
      };
      hrtime = process.hrtime;
      getNanoSeconds = function() {
        var hr;
        hr = hrtime();
        return hr[0] * 1e9 + hr[1];
      };
      moduleLoadTime = getNanoSeconds();
      upTime = process.uptime() * 1e9;
      nodeLoadTime = moduleLoadTime - upTime;
    } else if (Date.now) {
      module2.exports = function() {
        return Date.now() - loadTime;
      };
      loadTime = Date.now();
    } else {
      module2.exports = function() {
        return new Date().getTime() - loadTime;
      };
      loadTime = new Date().getTime();
    }
  }).call(exports2);
});

// backend/node_modules/@cypress/request/request.js
var require_request = __commonJS((exports2, module2) => {
  var http3 = require("http");
  var https2 = require("https");
  var url2 = require("url");
  var util3 = require("util");
  var stream4 = require("stream");
  var zlib2 = require("zlib");
  var aws2 = require_aws_sign2();
  var aws4 = require_aws4();
  var httpSignature = require_lib5();
  var mime = require_mime_types();
  var caseless = require_caseless();
  var ForeverAgent = require_forever_agent();
  var FormData4 = require_form_data();
  var extend2 = require_extend();
  var isstream = require_isstream();
  var isTypedArray2 = require_is_typedarray().strict;
  var helpers = require_helpers5();
  var cookies = require_cookies();
  var getProxyFromURI = require_getProxyFromURI();
  var Querystring = require_querystring().Querystring;
  var Har = require_har().Har;
  var Auth = require_auth().Auth;
  var hawk = require_hawk();
  var Multipart = require_multipart().Multipart;
  var Redirect = require_redirect().Redirect;
  var Tunnel = require_tunnel().Tunnel;
  var now = require_performance_now();
  var Buffer2 = require_safe_buffer3().Buffer;
  var safeStringify = helpers.safeStringify;
  var isReadStream = helpers.isReadStream;
  var toBase64 = helpers.toBase64;
  var defer = helpers.defer;
  var copy = helpers.copy;
  var version = helpers.version;
  var globalCookieJar = cookies.jar();
  var globalPool = {};
  function filterForNonReserved(reserved, options) {
    var object = {};
    for (var i in options) {
      var notReserved = reserved.indexOf(i) === -1;
      if (notReserved) {
        object[i] = options[i];
      }
    }
    return object;
  }
  function filterOutReservedFunctions(reserved, options) {
    var object = {};
    for (var i in options) {
      var isReserved = !(reserved.indexOf(i) === -1);
      var isFunction3 = typeof options[i] === "function";
      if (!(isReserved && isFunction3)) {
        object[i] = options[i];
      }
    }
    return object;
  }
  function requestToJSON() {
    var self2 = this;
    return {
      uri: self2.uri,
      method: self2.method,
      headers: self2.headers
    };
  }
  function responseToJSON() {
    var self2 = this;
    return {
      statusCode: self2.statusCode,
      body: self2.body,
      headers: self2.headers,
      request: requestToJSON.call(self2.request)
    };
  }
  function Request2(options) {
    var self2 = this;
    if (options.har) {
      self2._har = new Har(self2);
      options = self2._har.options(options);
    }
    stream4.Stream.call(self2);
    var reserved = Object.keys(Request2.prototype);
    var nonReserved = filterForNonReserved(reserved, options);
    extend2(self2, nonReserved);
    options = filterOutReservedFunctions(reserved, options);
    self2.readable = true;
    self2.writable = true;
    if (options.method) {
      self2.explicitMethod = true;
    }
    self2._qs = new Querystring(self2);
    self2._auth = new Auth(self2);
    self2._multipart = new Multipart(self2);
    self2._redirect = new Redirect(self2);
    self2._tunnel = new Tunnel(self2);
    self2.init(options);
  }
  util3.inherits(Request2, stream4.Stream);
  Request2.debug = process.env.NODE_DEBUG && /\brequest\b/.test(process.env.NODE_DEBUG);
  function debug() {
    if (Request2.debug) {
      console.error("REQUEST %s", util3.format.apply(util3, arguments));
    }
  }
  Request2.prototype.debug = debug;
  Request2.prototype.init = function(options) {
    var self2 = this;
    if (!options) {
      options = {};
    }
    self2.headers = self2.headers ? copy(self2.headers) : {};
    for (var headerName in self2.headers) {
      if (typeof self2.headers[headerName] === "undefined") {
        delete self2.headers[headerName];
      }
    }
    caseless.httpify(self2, self2.headers);
    if (!self2.method) {
      self2.method = options.method || "GET";
    }
    if (!self2.localAddress) {
      self2.localAddress = options.localAddress;
    }
    self2._qs.init(options);
    debug(options);
    if (!self2.pool && self2.pool !== false) {
      self2.pool = globalPool;
    }
    self2.dests = self2.dests || [];
    self2.__isRequestRequest = true;
    if (!self2._callback && self2.callback) {
      self2._callback = self2.callback;
      self2.callback = function() {
        if (self2._callbackCalled) {
          return;
        }
        self2._callbackCalled = true;
        self2._callback.apply(self2, arguments);
      };
      self2.on("error", self2.callback.bind());
      self2.on("complete", self2.callback.bind(self2, null));
    }
    if (!self2.uri && self2.url) {
      self2.uri = self2.url;
      delete self2.url;
    }
    if (self2.baseUrl) {
      if (typeof self2.baseUrl !== "string") {
        return self2.emit("error", new Error("options.baseUrl must be a string"));
      }
      if (typeof self2.uri !== "string") {
        return self2.emit("error", new Error("options.uri must be a string when using options.baseUrl"));
      }
      if (self2.uri.indexOf("//") === 0 || self2.uri.indexOf("://") !== -1) {
        return self2.emit("error", new Error("options.uri must be a path when using options.baseUrl"));
      }
      var baseUrlEndsWithSlash = self2.baseUrl.lastIndexOf("/") === self2.baseUrl.length - 1;
      var uriStartsWithSlash = self2.uri.indexOf("/") === 0;
      if (baseUrlEndsWithSlash && uriStartsWithSlash) {
        self2.uri = self2.baseUrl + self2.uri.slice(1);
      } else if (baseUrlEndsWithSlash || uriStartsWithSlash) {
        self2.uri = self2.baseUrl + self2.uri;
      } else if (self2.uri === "") {
        self2.uri = self2.baseUrl;
      } else {
        self2.uri = self2.baseUrl + "/" + self2.uri;
      }
      delete self2.baseUrl;
    }
    if (!self2.uri) {
      return self2.emit("error", new Error("options.uri is a required argument"));
    }
    if (typeof self2.uri === "string") {
      self2.uri = url2.parse(self2.uri);
    }
    if (!self2.uri.href) {
      self2.uri.href = url2.format(self2.uri);
    }
    if (self2.uri.protocol === "unix:") {
      return self2.emit("error", new Error("`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`"));
    }
    if (self2.uri.host === "unix") {
      self2.enableUnixSocket();
    }
    if (self2.strictSSL === false) {
      self2.rejectUnauthorized = false;
    }
    if (!self2.uri.pathname) {
      self2.uri.pathname = "/";
    }
    if (!(self2.uri.host || self2.uri.hostname && self2.uri.port) && !self2.uri.isUnix) {
      var faultyUri = url2.format(self2.uri);
      var message = 'Invalid URI "' + faultyUri + '"';
      if (Object.keys(options).length === 0) {
        message += ". This can be caused by a crappy redirection.";
      }
      self2.abort();
      return self2.emit("error", new Error(message));
    }
    if (!self2.hasOwnProperty("proxy")) {
      self2.proxy = getProxyFromURI(self2.uri);
    }
    self2.tunnel = self2._tunnel.isEnabled();
    if (self2.proxy) {
      self2._tunnel.setup(options);
    }
    self2._redirect.onRequest(options);
    self2.setHost = false;
    if (!self2.hasHeader("host")) {
      var hostHeaderName = self2.originalHostHeaderName || "host";
      self2.setHeader(hostHeaderName, self2.uri.host);
      if (self2.uri.port) {
        if (self2.uri.port === "80" && self2.uri.protocol === "http:" || self2.uri.port === "443" && self2.uri.protocol === "https:") {
          self2.setHeader(hostHeaderName, self2.uri.hostname);
        }
      }
      self2.setHost = true;
    }
    self2.jar(self2._jar || options.jar);
    if (!self2.uri.port) {
      if (self2.uri.protocol === "http:") {
        self2.uri.port = 80;
      } else if (self2.uri.protocol === "https:") {
        self2.uri.port = 443;
      }
    }
    if (self2.proxy && !self2.tunnel) {
      self2.port = self2.proxy.port;
      self2.host = self2.proxy.hostname;
    } else {
      self2.port = self2.uri.port;
      self2.host = self2.uri.hostname;
    }
    if (options.form) {
      self2.form(options.form);
    }
    if (options.formData) {
      var formData = options.formData;
      var requestForm = self2.form();
      var appendFormValue = function(key, value) {
        if (value && value.hasOwnProperty("value") && value.hasOwnProperty("options")) {
          requestForm.append(key, value.value, value.options);
        } else {
          requestForm.append(key, value);
        }
      };
      for (var formKey in formData) {
        if (formData.hasOwnProperty(formKey)) {
          var formValue = formData[formKey];
          if (formValue instanceof Array) {
            for (var j = 0;j < formValue.length; j++) {
              appendFormValue(formKey, formValue[j]);
            }
          } else {
            appendFormValue(formKey, formValue);
          }
        }
      }
    }
    if (options.qs) {
      self2.qs(options.qs);
    }
    if (self2.uri.path) {
      self2.path = self2.uri.path;
    } else {
      self2.path = self2.uri.pathname + (self2.uri.search || "");
    }
    if (self2.path.length === 0) {
      self2.path = "/";
    }
    if (options.aws) {
      self2.aws(options.aws);
    }
    if (options.hawk) {
      self2.hawk(options.hawk);
    }
    if (options.httpSignature) {
      self2.httpSignature(options.httpSignature);
    }
    if (options.auth) {
      if (Object.prototype.hasOwnProperty.call(options.auth, "username")) {
        options.auth.user = options.auth.username;
      }
      if (Object.prototype.hasOwnProperty.call(options.auth, "password")) {
        options.auth.pass = options.auth.password;
      }
      self2.auth(options.auth.user, options.auth.pass, options.auth.sendImmediately, options.auth.bearer);
    }
    if (self2.gzip && !self2.hasHeader("accept-encoding")) {
      self2.setHeader("accept-encoding", "gzip, deflate");
    }
    if (self2.uri.auth && !self2.hasHeader("authorization")) {
      var uriAuthPieces = self2.uri.auth.split(":").map(function(item) {
        return self2._qs.unescape(item);
      });
      self2.auth(uriAuthPieces[0], uriAuthPieces.slice(1).join(":"), true);
    }
    if (!self2.tunnel && self2.proxy && self2.proxy.auth && !self2.hasHeader("proxy-authorization")) {
      var proxyAuthPieces = self2.proxy.auth.split(":").map(function(item) {
        return self2._qs.unescape(item);
      });
      var authHeader = "Basic " + toBase64(proxyAuthPieces.join(":"));
      self2.setHeader("proxy-authorization", authHeader);
    }
    if (self2.proxy && !self2.tunnel) {
      self2.path = self2.uri.protocol + "//" + self2.uri.host + self2.path;
    }
    if (options.json) {
      self2.json(options.json);
    }
    if (options.multipart) {
      self2.multipart(options.multipart);
    }
    if (options.time) {
      self2.timing = true;
      self2.elapsedTime = self2.elapsedTime || 0;
    }
    function setContentLength() {
      if (isTypedArray2(self2.body)) {
        self2.body = Buffer2.from(self2.body);
      }
      if (!self2.hasHeader("content-length")) {
        var length;
        if (typeof self2.body === "string") {
          length = Buffer2.byteLength(self2.body);
        } else if (Array.isArray(self2.body)) {
          length = self2.body.reduce(function(a, b) {
            return a + b.length;
          }, 0);
        } else {
          length = self2.body.length;
        }
        if (length) {
          self2.setHeader("content-length", length);
        } else {
          self2.emit("error", new Error("Argument error, options.body."));
        }
      }
    }
    if (self2.body && !isstream(self2.body)) {
      setContentLength();
    }
    var protocol = self2.proxy && !self2.tunnel ? self2.proxy.protocol : self2.uri.protocol;
    var defaultModules = { "http:": http3, "https:": https2 };
    var httpModules = self2.httpModules || {};
    self2.httpModule = httpModules[protocol] || defaultModules[protocol];
    if (!self2.httpModule) {
      return self2.emit("error", new Error("Invalid protocol: " + protocol));
    }
    if (options.ca) {
      self2.ca = options.ca;
    }
    if (!self2.agent) {
      if (options.agentOptions) {
        self2.agentOptions = options.agentOptions;
      }
      if (options.agentClass) {
        self2.agentClass = options.agentClass;
      } else if (options.forever) {
        var v = version();
        if (v.major === 0 && v.minor <= 10) {
          self2.agentClass = protocol === "http:" ? ForeverAgent : ForeverAgent.SSL;
        } else {
          self2.agentClass = self2.httpModule.Agent;
          self2.agentOptions = self2.agentOptions || {};
          self2.agentOptions.keepAlive = true;
        }
      } else {
        self2.agentClass = self2.httpModule.Agent;
      }
    }
    if (self2.pool === false) {
      self2.agent = false;
    } else {
      self2.agent = self2.agent || self2.getNewAgent();
    }
    self2.on("pipe", function(src) {
      if (self2.ntick && self2._started) {
        self2.emit("error", new Error("You cannot pipe to this stream after the outbound request has started."));
      }
      self2.src = src;
      if (isReadStream(src)) {
        if (!self2.hasHeader("content-type")) {
          self2.setHeader("content-type", mime.lookup(src.path));
        }
      } else {
        if (src.headers) {
          for (var i in src.headers) {
            if (!self2.hasHeader(i)) {
              self2.setHeader(i, src.headers[i]);
            }
          }
        }
        if (self2._json && !self2.hasHeader("content-type")) {
          self2.setHeader("content-type", "application/json");
        }
        if (src.method && !self2.explicitMethod) {
          self2.method = src.method;
        }
      }
    });
    defer(function() {
      if (self2._aborted) {
        return;
      }
      var end = function() {
        if (self2._form) {
          if (!self2._auth.hasAuth) {
            self2._form.pipe(self2);
          } else if (self2._auth.hasAuth && self2._auth.sentAuth) {
            self2._form.pipe(self2);
          }
        }
        if (self2._multipart && self2._multipart.chunked) {
          self2._multipart.body.pipe(self2);
        }
        if (self2.body) {
          if (isstream(self2.body)) {
            self2.body.pipe(self2);
          } else {
            setContentLength();
            if (Array.isArray(self2.body)) {
              self2.body.forEach(function(part) {
                self2.write(part);
              });
            } else {
              self2.write(self2.body);
            }
            self2.end();
          }
        } else if (self2.requestBodyStream) {
          console.warn("options.requestBodyStream is deprecated, please pass the request object to stream.pipe.");
          self2.requestBodyStream.pipe(self2);
        } else if (!self2.src) {
          if (self2._auth.hasAuth && !self2._auth.sentAuth) {
            self2.end();
            return;
          }
          if (self2.method !== "GET" && typeof self2.method !== "undefined") {
            self2.setHeader("content-length", 0);
          }
          self2.end();
        }
      };
      if (self2._form && !self2.hasHeader("content-length")) {
        self2.setHeader(self2._form.getHeaders(), true);
        self2._form.getLength(function(err, length) {
          if (!err && !isNaN(length)) {
            self2.setHeader("content-length", length);
          }
          end();
        });
      } else {
        end();
      }
      self2.ntick = true;
    });
  };
  Request2.prototype.getNewAgent = function() {
    var self2 = this;
    var Agent = self2.agentClass;
    var options = {};
    if (self2.agentOptions) {
      for (var i in self2.agentOptions) {
        options[i] = self2.agentOptions[i];
      }
    }
    if (self2.ca) {
      options.ca = self2.ca;
    }
    if (self2.ciphers) {
      options.ciphers = self2.ciphers;
    }
    if (self2.secureProtocol) {
      options.secureProtocol = self2.secureProtocol;
    }
    if (self2.secureOptions) {
      options.secureOptions = self2.secureOptions;
    }
    if (typeof self2.rejectUnauthorized !== "undefined") {
      options.rejectUnauthorized = self2.rejectUnauthorized;
    }
    if (self2.cert && self2.key) {
      options.key = self2.key;
      options.cert = self2.cert;
    }
    if (self2.pfx) {
      options.pfx = self2.pfx;
    }
    if (self2.passphrase) {
      options.passphrase = self2.passphrase;
    }
    var poolKey = "";
    if (Agent !== self2.httpModule.Agent) {
      poolKey += Agent.name;
    }
    var proxy = self2.proxy;
    if (typeof proxy === "string") {
      proxy = url2.parse(proxy);
    }
    var isHttps2 = proxy && proxy.protocol === "https:" || this.uri.protocol === "https:";
    if (isHttps2) {
      if (options.ca) {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.ca;
      }
      if (typeof options.rejectUnauthorized !== "undefined") {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.rejectUnauthorized;
      }
      if (options.cert) {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.cert.toString("ascii") + options.key.toString("ascii");
      }
      if (options.pfx) {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.pfx.toString("ascii");
      }
      if (options.ciphers) {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.ciphers;
      }
      if (options.secureProtocol) {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.secureProtocol;
      }
      if (options.secureOptions) {
        if (poolKey) {
          poolKey += ":";
        }
        poolKey += options.secureOptions;
      }
    }
    if (self2.pool === globalPool && !poolKey && Object.keys(options).length === 0 && self2.httpModule.globalAgent) {
      return self2.httpModule.globalAgent;
    }
    poolKey = self2.uri.protocol + poolKey;
    if (!self2.pool[poolKey]) {
      self2.pool[poolKey] = new Agent(options);
      if (self2.pool.maxSockets) {
        self2.pool[poolKey].maxSockets = self2.pool.maxSockets;
      }
    }
    return self2.pool[poolKey];
  };
  Request2.prototype.start = function() {
    var self2 = this;
    if (self2.timing) {
      var startTime = new Date().getTime();
      var startTimeNow = now();
    }
    if (self2._aborted) {
      return;
    }
    self2._started = true;
    self2.method = self2.method || "GET";
    self2.href = self2.uri.href;
    if (self2.src && self2.src.stat && self2.src.stat.size && !self2.hasHeader("content-length")) {
      self2.setHeader("content-length", self2.src.stat.size);
    }
    if (self2._aws) {
      self2.aws(self2._aws, true);
    }
    var reqOptions = copy(self2);
    delete reqOptions.auth;
    debug("make request", self2.uri.href);
    delete reqOptions.timeout;
    try {
      self2.req = self2.httpModule.request(reqOptions);
    } catch (err) {
      self2.emit("error", err);
      return;
    }
    if (self2.timing) {
      self2.startTime = startTime;
      self2.startTimeNow = startTimeNow;
      self2.timings = {};
    }
    var timeout;
    if (self2.timeout && !self2.timeoutTimer) {
      if (self2.timeout < 0) {
        timeout = 0;
      } else if (typeof self2.timeout === "number" && isFinite(self2.timeout)) {
        timeout = self2.timeout;
      }
    }
    self2.req.on("response", self2.onRequestResponse.bind(self2));
    self2.req.on("error", self2.onRequestError.bind(self2));
    self2.req.on("drain", function() {
      self2.emit("drain");
    });
    self2.req.on("socket", function(socket) {
      var isConnecting = socket._connecting || socket.connecting;
      if (self2.timing) {
        self2.timings.socket = now() - self2.startTimeNow;
        if (isConnecting) {
          var onLookupTiming = function() {
            self2.timings.lookup = now() - self2.startTimeNow;
          };
          var onConnectTiming = function() {
            self2.timings.connect = now() - self2.startTimeNow;
          };
          socket.once("lookup", onLookupTiming);
          socket.once("connect", onConnectTiming);
          self2.req.once("error", function() {
            socket.removeListener("lookup", onLookupTiming);
            socket.removeListener("connect", onConnectTiming);
          });
        }
      }
      var setReqTimeout = function() {
        self2.req.setTimeout(timeout, function() {
          if (self2.req) {
            self2.abort();
            var e = new Error("ESOCKETTIMEDOUT");
            e.code = "ESOCKETTIMEDOUT";
            e.connect = false;
            self2.emit("error", e);
          }
        });
      };
      if (timeout !== undefined) {
        if (isConnecting) {
          var onReqSockConnect = function() {
            socket.removeListener("connect", onReqSockConnect);
            self2.clearTimeout();
            setReqTimeout();
          };
          socket.on("connect", onReqSockConnect);
          self2.req.on("error", function(err) {
            socket.removeListener("connect", onReqSockConnect);
          });
          self2.timeoutTimer = setTimeout(function() {
            socket.removeListener("connect", onReqSockConnect);
            self2.abort();
            var e = new Error("ETIMEDOUT");
            e.code = "ETIMEDOUT";
            e.connect = true;
            self2.emit("error", e);
          }, timeout);
        } else {
          setReqTimeout();
        }
      }
      self2.emit("socket", socket);
    });
    self2.emit("request", self2.req);
  };
  Request2.prototype.onRequestError = function(error2) {
    var self2 = this;
    if (self2._aborted) {
      return;
    }
    if (self2.req && self2.req._reusedSocket && error2.code === "ECONNRESET" && self2.agent.addRequestNoreuse) {
      self2.agent = { addRequest: self2.agent.addRequestNoreuse.bind(self2.agent) };
      self2.start();
      self2.req.end();
      return;
    }
    self2.clearTimeout();
    self2.emit("error", error2);
  };
  Request2.prototype.onRequestResponse = function(response) {
    var self2 = this;
    if (self2.timing) {
      self2.timings.response = now() - self2.startTimeNow;
    }
    debug("onRequestResponse", self2.uri.href, response.statusCode, response.headers);
    response.on("end", function() {
      if (self2.timing) {
        self2.timings.end = now() - self2.startTimeNow;
        response.timingStart = self2.startTime;
        if (!self2.timings.socket) {
          self2.timings.socket = 0;
        }
        if (!self2.timings.lookup) {
          self2.timings.lookup = self2.timings.socket;
        }
        if (!self2.timings.connect) {
          self2.timings.connect = self2.timings.lookup;
        }
        if (!self2.timings.response) {
          self2.timings.response = self2.timings.connect;
        }
        debug("elapsed time", self2.timings.end);
        self2.elapsedTime += Math.round(self2.timings.end);
        response.elapsedTime = self2.elapsedTime;
        response.timings = self2.timings;
        response.timingPhases = {
          wait: self2.timings.socket,
          dns: self2.timings.lookup - self2.timings.socket,
          tcp: self2.timings.connect - self2.timings.lookup,
          firstByte: self2.timings.response - self2.timings.connect,
          download: self2.timings.end - self2.timings.response,
          total: self2.timings.end
        };
      }
      debug("response end", self2.uri.href, response.statusCode, response.headers);
    });
    if (self2._aborted) {
      debug("aborted", self2.uri.href);
      response.resume();
      return;
    }
    self2.response = response;
    response.request = self2;
    response.toJSON = responseToJSON;
    if (self2.httpModule === https2 && self2.strictSSL && (!response.hasOwnProperty("socket") || !response.socket.authorized)) {
      debug("strict ssl error", self2.uri.href);
      var sslErr = response.hasOwnProperty("socket") ? response.socket.authorizationError : self2.uri.href + " does not support SSL";
      self2.emit("error", new Error("SSL Error: " + sslErr));
      return;
    }
    self2.originalHost = self2.getHeader("host");
    if (!self2.originalHostHeaderName) {
      self2.originalHostHeaderName = self2.hasHeader("host");
    }
    if (self2.setHost) {
      self2.removeHeader("host");
    }
    self2.clearTimeout();
    var targetCookieJar = self2._jar && self2._jar.setCookie ? self2._jar : globalCookieJar;
    var addCookie = function(cookie) {
      try {
        targetCookieJar.setCookie(cookie, self2.uri.href, { ignoreError: true });
      } catch (e) {
        self2.emit("error", e);
      }
    };
    response.caseless = caseless(response.headers);
    if (response.caseless.has("set-cookie") && !self2._disableCookies) {
      var headerName = response.caseless.has("set-cookie");
      if (Array.isArray(response.headers[headerName])) {
        response.headers[headerName].forEach(addCookie);
      } else {
        addCookie(response.headers[headerName]);
      }
    }
    self2._redirect.onResponse(response, function(err, followingRedirect) {
      if (!err && followingRedirect)
        return;
      if (err)
        self2.emit("error", err);
      response.on("close", function() {
        if (!self2._ended) {
          self2._ended = true;
          self2.response.emit("end");
        }
      });
      response.once("end", function() {
        self2._ended = true;
      });
      var noBody = function(code) {
        return self2.method === "HEAD" || code >= 100 && code < 200 || code === 204 || code === 304;
      };
      var responseContent;
      if (self2.gzip && !noBody(response.statusCode)) {
        var contentEncoding = response.headers["content-encoding"] || "identity";
        contentEncoding = contentEncoding.trim().toLowerCase();
        var zlibOptions2 = {
          flush: zlib2.Z_SYNC_FLUSH,
          finishFlush: zlib2.Z_SYNC_FLUSH
        };
        if (contentEncoding === "gzip") {
          responseContent = zlib2.createGunzip(zlibOptions2);
          response.pipe(responseContent);
        } else if (contentEncoding === "deflate") {
          responseContent = zlib2.createInflate(zlibOptions2);
          response.pipe(responseContent);
        } else {
          if (contentEncoding !== "identity") {
            debug("ignoring unrecognized Content-Encoding " + contentEncoding);
          }
          responseContent = response;
        }
      } else {
        responseContent = response;
      }
      if (self2.encoding) {
        if (self2.dests.length !== 0) {
          console.error("Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.");
        } else {
          responseContent.setEncoding(self2.encoding);
        }
      }
      if (self2._paused) {
        responseContent.pause();
      }
      self2.responseContent = responseContent;
      self2.emit("response", response);
      self2.dests.forEach(function(dest) {
        self2.pipeDest(dest);
      });
      responseContent.on("data", function(chunk) {
        if (self2.timing && !self2.responseStarted) {
          self2.responseStartTime = new Date().getTime();
          response.responseStartTime = self2.responseStartTime;
        }
        self2._destdata = true;
        self2.emit("data", chunk);
      });
      responseContent.once("end", function(chunk) {
        self2.emit("end", chunk);
      });
      responseContent.on("error", function(error2) {
        if (error2.code === "ECONNRESET" && error2.message === "aborted" && self2.listenerCount("error") === 0) {
          return;
        }
        self2.emit("error", error2);
      });
      responseContent.on("close", function() {
        self2.emit("close");
      });
      if (self2.callback) {
        self2.readResponseBody(response);
      } else {
        self2.on("end", function() {
          if (self2._aborted) {
            debug("aborted", self2.uri.href);
            return;
          }
          self2.emit("complete", response);
        });
      }
      debug("finish init function", self2.uri.href);
    });
  };
  Request2.prototype.readResponseBody = function(response) {
    var self2 = this;
    debug("reading response's body");
    var buffers = [];
    var bufferLength = 0;
    var strings = [];
    self2.on("data", function(chunk) {
      if (!Buffer2.isBuffer(chunk)) {
        strings.push(chunk);
      } else if (chunk.length) {
        bufferLength += chunk.length;
        buffers.push(chunk);
      }
    });
    self2.on("end", function() {
      debug("end event", self2.uri.href);
      if (self2._aborted) {
        debug("aborted", self2.uri.href);
        buffers = [];
        bufferLength = 0;
        return;
      }
      if (bufferLength) {
        debug("has body", self2.uri.href, bufferLength);
        response.body = Buffer2.concat(buffers, bufferLength);
        if (self2.encoding !== null) {
          response.body = response.body.toString(self2.encoding);
        }
        buffers = [];
        bufferLength = 0;
      } else if (strings.length) {
        if (self2.encoding === "utf8" && strings[0].length > 0 && strings[0][0] === "\uFEFF") {
          strings[0] = strings[0].substring(1);
        }
        response.body = strings.join("");
      }
      if (self2._json) {
        try {
          response.body = JSON.parse(response.body, self2._jsonReviver);
        } catch (e) {
          debug("invalid JSON received", self2.uri.href);
        }
      }
      debug("emitting complete", self2.uri.href);
      if (typeof response.body === "undefined" && !self2._json) {
        response.body = self2.encoding === null ? Buffer2.alloc(0) : "";
      }
      self2.emit("complete", response, response.body);
    });
  };
  Request2.prototype.abort = function() {
    var self2 = this;
    self2._aborted = true;
    if (self2.req) {
      self2.req.abort();
    } else if (self2.response) {
      self2.response.destroy();
    }
    self2.clearTimeout();
    self2.emit("abort");
  };
  Request2.prototype.pipeDest = function(dest) {
    var self2 = this;
    var response = self2.response;
    if (dest.headers && !dest.headersSent) {
      if (response.caseless.has("content-type")) {
        var ctname = response.caseless.has("content-type");
        if (dest.setHeader) {
          dest.setHeader(ctname, response.headers[ctname]);
        } else {
          dest.headers[ctname] = response.headers[ctname];
        }
      }
      if (response.caseless.has("content-length")) {
        var clname = response.caseless.has("content-length");
        if (dest.setHeader) {
          dest.setHeader(clname, response.headers[clname]);
        } else {
          dest.headers[clname] = response.headers[clname];
        }
      }
    }
    if (dest.setHeader && !dest.headersSent) {
      for (var i in response.headers) {
        if (!self2.gzip || i !== "content-encoding") {
          dest.setHeader(i, response.headers[i]);
        }
      }
      dest.statusCode = response.statusCode;
    }
    if (self2.pipefilter) {
      self2.pipefilter(response, dest);
    }
  };
  Request2.prototype.qs = function(q2, clobber) {
    var self2 = this;
    var base;
    if (!clobber && self2.uri.query) {
      base = self2._qs.parse(self2.uri.query);
    } else {
      base = {};
    }
    for (var i in q2) {
      base[i] = q2[i];
    }
    var qs = self2._qs.stringify(base);
    if (qs === "") {
      return self2;
    }
    self2.uri = url2.parse(self2.uri.href.split("?")[0] + "?" + qs);
    self2.url = self2.uri;
    self2.path = self2.uri.path;
    if (self2.uri.host === "unix") {
      self2.enableUnixSocket();
    }
    return self2;
  };
  Request2.prototype.form = function(form) {
    var self2 = this;
    if (form) {
      if (!/^application\/x-www-form-urlencoded\b/.test(self2.getHeader("content-type"))) {
        self2.setHeader("content-type", "application/x-www-form-urlencoded");
      }
      self2.body = typeof form === "string" ? self2._qs.rfc3986(form.toString("utf8")) : self2._qs.stringify(form).toString("utf8");
      return self2;
    }
    self2._form = new FormData4;
    self2._form.on("error", function(err) {
      err.message = "form-data: " + err.message;
      self2.emit("error", err);
      self2.abort();
    });
    return self2._form;
  };
  Request2.prototype.multipart = function(multipart) {
    var self2 = this;
    self2._multipart.onRequest(multipart);
    if (!self2._multipart.chunked) {
      self2.body = self2._multipart.body;
    }
    return self2;
  };
  Request2.prototype.json = function(val) {
    var self2 = this;
    if (!self2.hasHeader("accept")) {
      self2.setHeader("accept", "application/json");
    }
    if (typeof self2.jsonReplacer === "function") {
      self2._jsonReplacer = self2.jsonReplacer;
    }
    self2._json = true;
    if (typeof val === "boolean") {
      if (self2.body !== undefined) {
        if (!/^application\/x-www-form-urlencoded\b/.test(self2.getHeader("content-type"))) {
          self2.body = safeStringify(self2.body, self2._jsonReplacer);
        } else {
          self2.body = self2._qs.rfc3986(self2.body);
        }
        if (!self2.hasHeader("content-type")) {
          self2.setHeader("content-type", "application/json");
        }
      }
    } else {
      self2.body = safeStringify(val, self2._jsonReplacer);
      if (!self2.hasHeader("content-type")) {
        self2.setHeader("content-type", "application/json");
      }
    }
    if (typeof self2.jsonReviver === "function") {
      self2._jsonReviver = self2.jsonReviver;
    }
    return self2;
  };
  Request2.prototype.getHeader = function(name, headers) {
    var self2 = this;
    var result, re, match2;
    if (!headers) {
      headers = self2.headers;
    }
    Object.keys(headers).forEach(function(key) {
      if (key.length !== name.length) {
        return;
      }
      re = new RegExp(name, "i");
      match2 = key.match(re);
      if (match2) {
        result = headers[key];
      }
    });
    return result;
  };
  Request2.prototype.enableUnixSocket = function() {
    var unixParts = this.uri.path.split(":");
    var host = unixParts[0];
    var path2 = unixParts[1];
    this.socketPath = host;
    this.uri.pathname = path2;
    this.uri.path = path2;
    this.uri.host = host;
    this.uri.hostname = host;
    this.uri.isUnix = true;
  };
  Request2.prototype.auth = function(user, pass, sendImmediately, bearer) {
    var self2 = this;
    self2._auth.onRequest(user, pass, sendImmediately, bearer);
    return self2;
  };
  Request2.prototype.aws = function(opts, now2) {
    var self2 = this;
    if (!now2) {
      self2._aws = opts;
      return self2;
    }
    if (opts.sign_version === 4 || opts.sign_version === "4") {
      var options = {
        host: self2.uri.host,
        path: self2.uri.path,
        method: self2.method,
        headers: self2.headers,
        body: self2.body
      };
      if (opts.service) {
        options.service = opts.service;
      }
      var signRes = aws4.sign(options, {
        accessKeyId: opts.key,
        secretAccessKey: opts.secret,
        sessionToken: opts.session
      });
      self2.setHeader("authorization", signRes.headers.Authorization);
      self2.setHeader("x-amz-date", signRes.headers["X-Amz-Date"]);
      if (signRes.headers["X-Amz-Security-Token"]) {
        self2.setHeader("x-amz-security-token", signRes.headers["X-Amz-Security-Token"]);
      }
    } else {
      var date = new Date;
      self2.setHeader("date", date.toUTCString());
      var auth2 = {
        key: opts.key,
        secret: opts.secret,
        verb: self2.method.toUpperCase(),
        date,
        contentType: self2.getHeader("content-type") || "",
        md5: self2.getHeader("content-md5") || "",
        amazonHeaders: aws2.canonicalizeHeaders(self2.headers)
      };
      var path2 = self2.uri.path;
      if (opts.bucket && path2) {
        auth2.resource = "/" + opts.bucket + path2;
      } else if (opts.bucket && !path2) {
        auth2.resource = "/" + opts.bucket;
      } else if (!opts.bucket && path2) {
        auth2.resource = path2;
      } else if (!opts.bucket && !path2) {
        auth2.resource = "/";
      }
      auth2.resource = aws2.canonicalizeResource(auth2.resource);
      self2.setHeader("authorization", aws2.authorization(auth2));
    }
    return self2;
  };
  Request2.prototype.httpSignature = function(opts) {
    var self2 = this;
    httpSignature.signRequest({
      getHeader: function(header) {
        return self2.getHeader(header, self2.headers);
      },
      setHeader: function(header, value) {
        self2.setHeader(header, value);
      },
      method: self2.method,
      path: self2.path
    }, opts);
    debug("httpSignature authorization", self2.getHeader("authorization"));
    return self2;
  };
  Request2.prototype.hawk = function(opts) {
    var self2 = this;
    self2.setHeader("Authorization", hawk.header(self2.uri, self2.method, opts));
  };
  Request2.prototype.jar = function(jar) {
    var self2 = this;
    var cookies2;
    if (self2._redirect.redirectsFollowed === 0) {
      self2.originalCookieHeader = self2.getHeader("cookie");
    }
    if (!jar) {
      cookies2 = false;
      self2._disableCookies = true;
    } else {
      var targetCookieJar = jar.getCookieString ? jar : globalCookieJar;
      var urihref = self2.uri.href;
      if (targetCookieJar) {
        cookies2 = targetCookieJar.getCookieString(urihref);
      }
    }
    if (cookies2 && cookies2.length) {
      if (self2.originalCookieHeader) {
        self2.setHeader("cookie", self2.originalCookieHeader + "; " + cookies2);
      } else {
        self2.setHeader("cookie", cookies2);
      }
    }
    self2._jar = jar;
    return self2;
  };
  Request2.prototype.pipe = function(dest, opts) {
    var self2 = this;
    if (self2.response) {
      if (self2._destdata) {
        self2.emit("error", new Error("You cannot pipe after data has been emitted from the response."));
      } else if (self2._ended) {
        self2.emit("error", new Error("You cannot pipe after the response has been ended."));
      } else {
        stream4.Stream.prototype.pipe.call(self2, dest, opts);
        self2.pipeDest(dest);
        return dest;
      }
    } else {
      self2.dests.push(dest);
      stream4.Stream.prototype.pipe.call(self2, dest, opts);
      return dest;
    }
  };
  Request2.prototype.write = function() {
    var self2 = this;
    if (self2._aborted) {
      return;
    }
    if (!self2._started) {
      self2.start();
    }
    if (self2.req) {
      return self2.req.write.apply(self2.req, arguments);
    }
  };
  Request2.prototype.end = function(chunk) {
    var self2 = this;
    if (self2._aborted) {
      return;
    }
    if (chunk) {
      self2.write(chunk);
    }
    if (!self2._started) {
      self2.start();
    }
    if (self2.req) {
      self2.req.end();
    }
  };
  Request2.prototype.pause = function() {
    var self2 = this;
    if (!self2.responseContent) {
      self2._paused = true;
    } else {
      self2.responseContent.pause.apply(self2.responseContent, arguments);
    }
  };
  Request2.prototype.resume = function() {
    var self2 = this;
    if (!self2.responseContent) {
      self2._paused = false;
    } else {
      self2.responseContent.resume.apply(self2.responseContent, arguments);
    }
  };
  Request2.prototype.destroy = function() {
    var self2 = this;
    this.clearTimeout();
    if (!self2._ended) {
      self2.end();
    } else if (self2.response) {
      self2.response.destroy();
    }
  };
  Request2.prototype.clearTimeout = function() {
    if (this.timeoutTimer) {
      clearTimeout(this.timeoutTimer);
      this.timeoutTimer = null;
    }
  };
  Request2.defaultProxyHeaderWhiteList = Tunnel.defaultProxyHeaderWhiteList.slice();
  Request2.defaultProxyHeaderExclusiveList = Tunnel.defaultProxyHeaderExclusiveList.slice();
  Request2.prototype.toJSON = requestToJSON;
  module2.exports = Request2;
});

// backend/node_modules/@cypress/request/index.js
var require_request3 = __commonJS((exports2, module2) => {
  var extend2 = require_extend();
  var cookies = require_cookies();
  var helpers = require_helpers5();
  var paramsHaveRequestBody = helpers.paramsHaveRequestBody;
  function initParams(uri, options, callback) {
    if (typeof options === "function") {
      callback = options;
    }
    var params = {};
    if (options !== null && typeof options === "object") {
      extend2(params, options, { uri });
    } else if (typeof uri === "string") {
      extend2(params, { uri });
    } else {
      extend2(params, uri);
    }
    params.callback = callback || params.callback;
    return params;
  }
  function request(uri, options, callback) {
    if (typeof uri === "undefined") {
      throw new Error("undefined is not a valid uri or options object.");
    }
    var params = initParams(uri, options, callback);
    if (params.method === "HEAD" && paramsHaveRequestBody(params)) {
      throw new Error("HTTP HEAD requests MUST NOT include a request body.");
    }
    return new request.Request(params);
  }
  function verbFunc(verb) {
    var method = verb.toUpperCase();
    return function(uri, options, callback) {
      var params = initParams(uri, options, callback);
      params.method = method;
      return request(params, params.callback);
    };
  }
  request.get = verbFunc("get");
  request.head = verbFunc("head");
  request.options = verbFunc("options");
  request.post = verbFunc("post");
  request.put = verbFunc("put");
  request.patch = verbFunc("patch");
  request.del = verbFunc("delete");
  request["delete"] = verbFunc("delete");
  request.jar = function(store) {
    return cookies.jar(store);
  };
  request.cookie = function(str2) {
    return cookies.parse(str2);
  };
  function wrapRequestMethod(method, options, requester, verb) {
    return function(uri, opts, callback) {
      var params = initParams(uri, opts, callback);
      var target = {};
      extend2(true, target, options, params);
      target.pool = params.pool || options.pool;
      if (verb) {
        target.method = verb.toUpperCase();
      }
      if (typeof requester === "function") {
        method = requester;
      }
      return method(target, target.callback);
    };
  }
  request.defaults = function(options, requester) {
    var self2 = this;
    options = options || {};
    if (typeof options === "function") {
      requester = options;
      options = {};
    }
    var defaults3 = wrapRequestMethod(self2, options, requester);
    var verbs = ["get", "head", "post", "put", "patch", "del", "delete"];
    verbs.forEach(function(verb) {
      defaults3[verb] = wrapRequestMethod(self2[verb], options, requester, verb);
    });
    defaults3.cookie = wrapRequestMethod(self2.cookie, options, requester);
    defaults3.jar = self2.jar;
    defaults3.defaults = self2.defaults;
    return defaults3;
  };
  request.forever = function(agentOptions, optionsArg) {
    var options = {};
    if (optionsArg) {
      extend2(options, optionsArg);
    }
    if (agentOptions) {
      options.agentOptions = agentOptions;
    }
    options.forever = true;
    return request.defaults(options);
  };
  module2.exports = request;
  request.Request = require_request();
  request.initParams = initParams;
  Object.defineProperty(request, "debug", {
    enumerable: true,
    get: function() {
      return request.Request.debug;
    },
    set: function(debug) {
      request.Request.debug = debug;
    }
  });
});

// backend/node_modules/punycode/punycode.js
var require_punycode = __commonJS((exports2, module2) => {
  var maxInt = 2147483647;
  var base = 36;
  var tMin = 1;
  var tMax = 26;
  var skew = 38;
  var damp = 700;
  var initialBias = 72;
  var initialN = 128;
  var delimiter = "-";
  var regexPunycode = /^xn--/;
  var regexNonASCII = /[^\0-\x7F]/;
  var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
  var errors = {
    overflow: "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
  };
  var baseMinusTMin = base - tMin;
  var floor = Math.floor;
  var stringFromCharCode = String.fromCharCode;
  function error2(type) {
    throw new RangeError(errors[type]);
  }
  function map(array, callback) {
    const result = [];
    let length = array.length;
    while (length--) {
      result[length] = callback(array[length]);
    }
    return result;
  }
  function mapDomain(domain, callback) {
    const parts = domain.split("@");
    let result = "";
    if (parts.length > 1) {
      result = parts[0] + "@";
      domain = parts[1];
    }
    domain = domain.replace(regexSeparators, ".");
    const labels = domain.split(".");
    const encoded = map(labels, callback).join(".");
    return result + encoded;
  }
  function ucs2decode(string) {
    const output = [];
    let counter = 0;
    const length = string.length;
    while (counter < length) {
      const value = string.charCodeAt(counter++);
      if (value >= 55296 && value <= 56319 && counter < length) {
        const extra = string.charCodeAt(counter++);
        if ((extra & 64512) == 56320) {
          output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  }
  var ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
  var basicToDigit = function(codePoint) {
    if (codePoint >= 48 && codePoint < 58) {
      return 26 + (codePoint - 48);
    }
    if (codePoint >= 65 && codePoint < 91) {
      return codePoint - 65;
    }
    if (codePoint >= 97 && codePoint < 123) {
      return codePoint - 97;
    }
    return base;
  };
  var digitToBasic = function(digit, flag) {
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  };
  var adapt = function(delta, numPoints, firstTime) {
    let k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);
    for (;delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }
    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  };
  var decode = function(input) {
    const output = [];
    const inputLength = input.length;
    let i = 0;
    let n = initialN;
    let bias = initialBias;
    let basic = input.lastIndexOf(delimiter);
    if (basic < 0) {
      basic = 0;
    }
    for (let j = 0;j < basic; ++j) {
      if (input.charCodeAt(j) >= 128) {
        error2("not-basic");
      }
      output.push(input.charCodeAt(j));
    }
    for (let index = basic > 0 ? basic + 1 : 0;index < inputLength; ) {
      const oldi = i;
      for (let w = 1, k = base;; k += base) {
        if (index >= inputLength) {
          error2("invalid-input");
        }
        const digit = basicToDigit(input.charCodeAt(index++));
        if (digit >= base) {
          error2("invalid-input");
        }
        if (digit > floor((maxInt - i) / w)) {
          error2("overflow");
        }
        i += digit * w;
        const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
        if (digit < t) {
          break;
        }
        const baseMinusT = base - t;
        if (w > floor(maxInt / baseMinusT)) {
          error2("overflow");
        }
        w *= baseMinusT;
      }
      const out = output.length + 1;
      bias = adapt(i - oldi, out, oldi == 0);
      if (floor(i / out) > maxInt - n) {
        error2("overflow");
      }
      n += floor(i / out);
      i %= out;
      output.splice(i++, 0, n);
    }
    return String.fromCodePoint(...output);
  };
  var encode4 = function(input) {
    const output = [];
    input = ucs2decode(input);
    const inputLength = input.length;
    let n = initialN;
    let delta = 0;
    let bias = initialBias;
    for (const currentValue of input) {
      if (currentValue < 128) {
        output.push(stringFromCharCode(currentValue));
      }
    }
    const basicLength = output.length;
    let handledCPCount = basicLength;
    if (basicLength) {
      output.push(delimiter);
    }
    while (handledCPCount < inputLength) {
      let m = maxInt;
      for (const currentValue of input) {
        if (currentValue >= n && currentValue < m) {
          m = currentValue;
        }
      }
      const handledCPCountPlusOne = handledCPCount + 1;
      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error2("overflow");
      }
      delta += (m - n) * handledCPCountPlusOne;
      n = m;
      for (const currentValue of input) {
        if (currentValue < n && ++delta > maxInt) {
          error2("overflow");
        }
        if (currentValue === n) {
          let q2 = delta;
          for (let k = base;; k += base) {
            const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (q2 < t) {
              break;
            }
            const qMinusT = q2 - t;
            const baseMinusT = base - t;
            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
            q2 = floor(qMinusT / baseMinusT);
          }
          output.push(stringFromCharCode(digitToBasic(q2, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }
      ++delta;
      ++n;
    }
    return output.join("");
  };
  var toUnicode = function(input) {
    return mapDomain(input, function(string) {
      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    });
  };
  var toASCII = function(input) {
    return mapDomain(input, function(string) {
      return regexNonASCII.test(string) ? "xn--" + encode4(string) : string;
    });
  };
  var punycode = {
    version: "2.3.1",
    ucs2: {
      decode: ucs2decode,
      encode: ucs2encode
    },
    decode,
    encode: encode4,
    toASCII,
    toUnicode
  };
  module2.exports = punycode;
});

// backend/node_modules/requires-port/index.js
var require_requires_port = __commonJS((exports2, module2) => {
  module2.exports = function required(port, protocol) {
    protocol = protocol.split(":")[0];
    port = +port;
    if (!port)
      return false;
    switch (protocol) {
      case "http":
      case "ws":
        return port !== 80;
      case "https":
      case "wss":
        return port !== 443;
      case "ftp":
        return port !== 21;
      case "gopher":
        return port !== 70;
      case "file":
        return false;
    }
    return port !== 0;
  };
});

// backend/node_modules/querystringify/index.js
var require_querystringify = __commonJS((exports2) => {
  var has2 = Object.prototype.hasOwnProperty;
  var undef;
  function decode(input) {
    try {
      return decodeURIComponent(input.replace(/\+/g, " "));
    } catch (e) {
      return null;
    }
  }
  function encode4(input) {
    try {
      return encodeURIComponent(input);
    } catch (e) {
      return null;
    }
  }
  function querystring(query) {
    var parser = /([^=?#&]+)=?([^&]*)/g, result = {}, part;
    while (part = parser.exec(query)) {
      var key = decode(part[1]), value = decode(part[2]);
      if (key === null || value === null || key in result)
        continue;
      result[key] = value;
    }
    return result;
  }
  function querystringify(obj2, prefix) {
    prefix = prefix || "";
    var pairs = [], value, key;
    if (typeof prefix !== "string")
      prefix = "?";
    for (key in obj2) {
      if (has2.call(obj2, key)) {
        value = obj2[key];
        if (!value && (value === null || value === undef || isNaN(value))) {
          value = "";
        }
        key = encode4(key);
        value = encode4(value);
        if (key === null || value === null)
          continue;
        pairs.push(key + "=" + value);
      }
    }
    return pairs.length ? prefix + pairs.join("&") : "";
  }
  exports2.stringify = querystringify;
  exports2.parse = querystring;
});

// backend/node_modules/url-parse/index.js
var require_url_parse = __commonJS((exports2, module2) => {
  var required = require_requires_port();
  var qs = require_querystringify();
  var controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
  var CRHTLF = /[\n\r\t]/g;
  var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;
  var port = /:\d+$/;
  var protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i;
  var windowsDriveLetter = /^[a-zA-Z]:/;
  function trimLeft(str2) {
    return (str2 ? str2 : "").toString().replace(controlOrWhitespace, "");
  }
  var rules = [
    ["#", "hash"],
    ["?", "query"],
    function sanitize(address, url2) {
      return isSpecial(url2.protocol) ? address.replace(/\\/g, "/") : address;
    },
    ["/", "pathname"],
    ["@", "auth", 1],
    [NaN, "host", undefined, 1, 1],
    [/:(\d*)$/, "port", undefined, 1],
    [NaN, "hostname", undefined, 1, 1]
  ];
  var ignore = { hash: 1, query: 1 };
  function lolcation(loc) {
    var globalVar;
    if (typeof window !== "undefined")
      globalVar = window;
    else if (typeof global !== "undefined")
      globalVar = global;
    else if (typeof self !== "undefined")
      globalVar = self;
    else
      globalVar = {};
    var location = globalVar.location || {};
    loc = loc || location;
    var finaldestination = {}, type = typeof loc, key;
    if (loc.protocol === "blob:") {
      finaldestination = new Url(unescape(loc.pathname), {});
    } else if (type === "string") {
      finaldestination = new Url(loc, {});
      for (key in ignore)
        delete finaldestination[key];
    } else if (type === "object") {
      for (key in loc) {
        if (key in ignore)
          continue;
        finaldestination[key] = loc[key];
      }
      if (finaldestination.slashes === undefined) {
        finaldestination.slashes = slashes.test(loc.href);
      }
    }
    return finaldestination;
  }
  function isSpecial(scheme) {
    return scheme === "file:" || scheme === "ftp:" || scheme === "http:" || scheme === "https:" || scheme === "ws:" || scheme === "wss:";
  }
  function extractProtocol(address, location) {
    address = trimLeft(address);
    address = address.replace(CRHTLF, "");
    location = location || {};
    var match2 = protocolre.exec(address);
    var protocol = match2[1] ? match2[1].toLowerCase() : "";
    var forwardSlashes = !!match2[2];
    var otherSlashes = !!match2[3];
    var slashesCount = 0;
    var rest;
    if (forwardSlashes) {
      if (otherSlashes) {
        rest = match2[2] + match2[3] + match2[4];
        slashesCount = match2[2].length + match2[3].length;
      } else {
        rest = match2[2] + match2[4];
        slashesCount = match2[2].length;
      }
    } else {
      if (otherSlashes) {
        rest = match2[3] + match2[4];
        slashesCount = match2[3].length;
      } else {
        rest = match2[4];
      }
    }
    if (protocol === "file:") {
      if (slashesCount >= 2) {
        rest = rest.slice(2);
      }
    } else if (isSpecial(protocol)) {
      rest = match2[4];
    } else if (protocol) {
      if (forwardSlashes) {
        rest = rest.slice(2);
      }
    } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
      rest = match2[4];
    }
    return {
      protocol,
      slashes: forwardSlashes || isSpecial(protocol),
      slashesCount,
      rest
    };
  }
  function resolve(relative, base) {
    if (relative === "")
      return base;
    var path2 = (base || "/").split("/").slice(0, -1).concat(relative.split("/")), i = path2.length, last = path2[i - 1], unshift = false, up = 0;
    while (i--) {
      if (path2[i] === ".") {
        path2.splice(i, 1);
      } else if (path2[i] === "..") {
        path2.splice(i, 1);
        up++;
      } else if (up) {
        if (i === 0)
          unshift = true;
        path2.splice(i, 1);
        up--;
      }
    }
    if (unshift)
      path2.unshift("");
    if (last === "." || last === "..")
      path2.push("");
    return path2.join("/");
  }
  function Url(address, location, parser) {
    address = trimLeft(address);
    address = address.replace(CRHTLF, "");
    if (!(this instanceof Url)) {
      return new Url(address, location, parser);
    }
    var relative, extracted, parse, instruction, index, key, instructions = rules.slice(), type = typeof location, url2 = this, i = 0;
    if (type !== "object" && type !== "string") {
      parser = location;
      location = null;
    }
    if (parser && typeof parser !== "function")
      parser = qs.parse;
    location = lolcation(location);
    extracted = extractProtocol(address || "", location);
    relative = !extracted.protocol && !extracted.slashes;
    url2.slashes = extracted.slashes || relative && location.slashes;
    url2.protocol = extracted.protocol || location.protocol || "";
    address = extracted.rest;
    if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url2.protocol))) {
      instructions[3] = [/(.*)/, "pathname"];
    }
    for (;i < instructions.length; i++) {
      instruction = instructions[i];
      if (typeof instruction === "function") {
        address = instruction(address, url2);
        continue;
      }
      parse = instruction[0];
      key = instruction[1];
      if (parse !== parse) {
        url2[key] = address;
      } else if (typeof parse === "string") {
        index = parse === "@" ? address.lastIndexOf(parse) : address.indexOf(parse);
        if (~index) {
          if (typeof instruction[2] === "number") {
            url2[key] = address.slice(0, index);
            address = address.slice(index + instruction[2]);
          } else {
            url2[key] = address.slice(index);
            address = address.slice(0, index);
          }
        }
      } else if (index = parse.exec(address)) {
        url2[key] = index[1];
        address = address.slice(0, index.index);
      }
      url2[key] = url2[key] || (relative && instruction[3] ? location[key] || "" : "");
      if (instruction[4])
        url2[key] = url2[key].toLowerCase();
    }
    if (parser)
      url2.query = parser(url2.query);
    if (relative && location.slashes && url2.pathname.charAt(0) !== "/" && (url2.pathname !== "" || location.pathname !== "")) {
      url2.pathname = resolve(url2.pathname, location.pathname);
    }
    if (url2.pathname.charAt(0) !== "/" && isSpecial(url2.protocol)) {
      url2.pathname = "/" + url2.pathname;
    }
    if (!required(url2.port, url2.protocol)) {
      url2.host = url2.hostname;
      url2.port = "";
    }
    url2.username = url2.password = "";
    if (url2.auth) {
      index = url2.auth.indexOf(":");
      if (~index) {
        url2.username = url2.auth.slice(0, index);
        url2.username = encodeURIComponent(decodeURIComponent(url2.username));
        url2.password = url2.auth.slice(index + 1);
        url2.password = encodeURIComponent(decodeURIComponent(url2.password));
      } else {
        url2.username = encodeURIComponent(decodeURIComponent(url2.auth));
      }
      url2.auth = url2.password ? url2.username + ":" + url2.password : url2.username;
    }
    url2.origin = url2.protocol !== "file:" && isSpecial(url2.protocol) && url2.host ? url2.protocol + "//" + url2.host : "null";
    url2.href = url2.toString();
  }
  function set(part, value, fn) {
    var url2 = this;
    switch (part) {
      case "query":
        if (typeof value === "string" && value.length) {
          value = (fn || qs.parse)(value);
        }
        url2[part] = value;
        break;
      case "port":
        url2[part] = value;
        if (!required(value, url2.protocol)) {
          url2.host = url2.hostname;
          url2[part] = "";
        } else if (value) {
          url2.host = url2.hostname + ":" + value;
        }
        break;
      case "hostname":
        url2[part] = value;
        if (url2.port)
          value += ":" + url2.port;
        url2.host = value;
        break;
      case "host":
        url2[part] = value;
        if (port.test(value)) {
          value = value.split(":");
          url2.port = value.pop();
          url2.hostname = value.join(":");
        } else {
          url2.hostname = value;
          url2.port = "";
        }
        break;
      case "protocol":
        url2.protocol = value.toLowerCase();
        url2.slashes = !fn;
        break;
      case "pathname":
      case "hash":
        if (value) {
          var char = part === "pathname" ? "/" : "#";
          url2[part] = value.charAt(0) !== char ? char + value : value;
        } else {
          url2[part] = value;
        }
        break;
      case "username":
      case "password":
        url2[part] = encodeURIComponent(value);
        break;
      case "auth":
        var index = value.indexOf(":");
        if (~index) {
          url2.username = value.slice(0, index);
          url2.username = encodeURIComponent(decodeURIComponent(url2.username));
          url2.password = value.slice(index + 1);
          url2.password = encodeURIComponent(decodeURIComponent(url2.password));
        } else {
          url2.username = encodeURIComponent(decodeURIComponent(value));
        }
    }
    for (var i = 0;i < rules.length; i++) {
      var ins = rules[i];
      if (ins[4])
        url2[ins[1]] = url2[ins[1]].toLowerCase();
    }
    url2.auth = url2.password ? url2.username + ":" + url2.password : url2.username;
    url2.origin = url2.protocol !== "file:" && isSpecial(url2.protocol) && url2.host ? url2.protocol + "//" + url2.host : "null";
    url2.href = url2.toString();
    return url2;
  }
  function toString3(stringify2) {
    if (!stringify2 || typeof stringify2 !== "function")
      stringify2 = qs.stringify;
    var query, url2 = this, host = url2.host, protocol = url2.protocol;
    if (protocol && protocol.charAt(protocol.length - 1) !== ":")
      protocol += ":";
    var result = protocol + (url2.protocol && url2.slashes || isSpecial(url2.protocol) ? "//" : "");
    if (url2.username) {
      result += url2.username;
      if (url2.password)
        result += ":" + url2.password;
      result += "@";
    } else if (url2.password) {
      result += ":" + url2.password;
      result += "@";
    } else if (url2.protocol !== "file:" && isSpecial(url2.protocol) && !host && url2.pathname !== "/") {
      result += "@";
    }
    if (host[host.length - 1] === ":" || port.test(url2.hostname) && !url2.port) {
      host += ":";
    }
    result += host + url2.pathname;
    query = typeof url2.query === "object" ? stringify2(url2.query) : url2.query;
    if (query)
      result += query.charAt(0) !== "?" ? "?" + query : query;
    if (url2.hash)
      result += url2.hash;
    return result;
  }
  Url.prototype = { set, toString: toString3 };
  Url.extractProtocol = extractProtocol;
  Url.location = lolcation;
  Url.trimLeft = trimLeft;
  Url.qs = qs;
  module2.exports = Url;
});

// backend/node_modules/psl/dist/psl.cjs
var require_psl = __commonJS((exports2) => {
  Object.defineProperties(exports2, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
  function K(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
  }
  var O;
  var F;
  function Q() {
    if (F)
      return O;
    F = 1;
    const e = 2147483647, s = 36, c = 1, o = 26, t = 38, d = 700, z = 72, y = 128, g = "-", P = /^xn--/, V = /[^\0-\x7F]/, G = /[\x2E\u3002\uFF0E\uFF61]/g, W = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, C = s - c, h = Math.floor, I = String.fromCharCode;
    function v(a) {
      throw new RangeError(W[a]);
    }
    function U(a, i) {
      const m = [];
      let n = a.length;
      for (;n--; )
        m[n] = i(a[n]);
      return m;
    }
    function S(a, i) {
      const m = a.split("@");
      let n = "";
      m.length > 1 && (n = m[0] + "@", a = m[1]), a = a.replace(G, ".");
      const r = a.split("."), p = U(r, i).join(".");
      return n + p;
    }
    function L(a) {
      const i = [];
      let m = 0;
      const n = a.length;
      for (;m < n; ) {
        const r = a.charCodeAt(m++);
        if (r >= 55296 && r <= 56319 && m < n) {
          const p = a.charCodeAt(m++);
          (p & 64512) == 56320 ? i.push(((r & 1023) << 10) + (p & 1023) + 65536) : (i.push(r), m--);
        } else
          i.push(r);
      }
      return i;
    }
    const $ = (a) => String.fromCodePoint(...a), J = function(a) {
      return a >= 48 && a < 58 ? 26 + (a - 48) : a >= 65 && a < 91 ? a - 65 : a >= 97 && a < 123 ? a - 97 : s;
    }, D = function(a, i) {
      return a + 22 + 75 * (a < 26) - ((i != 0) << 5);
    }, T = function(a, i, m) {
      let n = 0;
      for (a = m ? h(a / d) : a >> 1, a += h(a / i);a > C * o >> 1; n += s)
        a = h(a / C);
      return h(n + (C + 1) * a / (a + t));
    }, E = function(a) {
      const i = [], m = a.length;
      let n = 0, r = y, p = z, j = a.lastIndexOf(g);
      j < 0 && (j = 0);
      for (let u = 0;u < j; ++u)
        a.charCodeAt(u) >= 128 && v("not-basic"), i.push(a.charCodeAt(u));
      for (let u = j > 0 ? j + 1 : 0;u < m; ) {
        const k = n;
        for (let l = 1, b = s;; b += s) {
          u >= m && v("invalid-input");
          const w = J(a.charCodeAt(u++));
          w >= s && v("invalid-input"), w > h((e - n) / l) && v("overflow"), n += w * l;
          const x = b <= p ? c : b >= p + o ? o : b - p;
          if (w < x)
            break;
          const q2 = s - x;
          l > h(e / q2) && v("overflow"), l *= q2;
        }
        const f = i.length + 1;
        p = T(n - k, f, k == 0), h(n / f) > e - r && v("overflow"), r += h(n / f), n %= f, i.splice(n++, 0, r);
      }
      return String.fromCodePoint(...i);
    }, B = function(a) {
      const i = [];
      a = L(a);
      const m = a.length;
      let n = y, r = 0, p = z;
      for (const k of a)
        k < 128 && i.push(I(k));
      const j = i.length;
      let u = j;
      for (j && i.push(g);u < m; ) {
        let k = e;
        for (const l of a)
          l >= n && l < k && (k = l);
        const f = u + 1;
        k - n > h((e - r) / f) && v("overflow"), r += (k - n) * f, n = k;
        for (const l of a)
          if (l < n && ++r > e && v("overflow"), l === n) {
            let b = r;
            for (let w = s;; w += s) {
              const x = w <= p ? c : w >= p + o ? o : w - p;
              if (b < x)
                break;
              const q2 = b - x, M = s - x;
              i.push(I(D(x + q2 % M, 0))), b = h(q2 / M);
            }
            i.push(I(D(b, 0))), p = T(r, f, u === j), r = 0, ++u;
          }
        ++r, ++n;
      }
      return i.join("");
    };
    return O = { version: "2.3.1", ucs2: { decode: L, encode: $ }, decode: E, encode: B, toASCII: function(a) {
      return S(a, function(i) {
        return V.test(i) ? "xn--" + B(i) : i;
      });
    }, toUnicode: function(a) {
      return S(a, function(i) {
        return P.test(i) ? E(i.slice(4).toLowerCase()) : i;
      });
    } }, O;
  }
  var X = Q();
  var A = K(X);
  var Y = ["ac", "com.ac", "edu.ac", "gov.ac", "mil.ac", "net.ac", "org.ac", "ad", "ae", "ac.ae", "co.ae", "gov.ae", "mil.ae", "net.ae", "org.ae", "sch.ae", "aero", "airline.aero", "airport.aero", "accident-investigation.aero", "accident-prevention.aero", "aerobatic.aero", "aeroclub.aero", "aerodrome.aero", "agents.aero", "air-surveillance.aero", "air-traffic-control.aero", "aircraft.aero", "airtraffic.aero", "ambulance.aero", "association.aero", "author.aero", "ballooning.aero", "broker.aero", "caa.aero", "cargo.aero", "catering.aero", "certification.aero", "championship.aero", "charter.aero", "civilaviation.aero", "club.aero", "conference.aero", "consultant.aero", "consulting.aero", "control.aero", "council.aero", "crew.aero", "design.aero", "dgca.aero", "educator.aero", "emergency.aero", "engine.aero", "engineer.aero", "entertainment.aero", "equipment.aero", "exchange.aero", "express.aero", "federation.aero", "flight.aero", "freight.aero", "fuel.aero", "gliding.aero", "government.aero", "groundhandling.aero", "group.aero", "hanggliding.aero", "homebuilt.aero", "insurance.aero", "journal.aero", "journalist.aero", "leasing.aero", "logistics.aero", "magazine.aero", "maintenance.aero", "marketplace.aero", "media.aero", "microlight.aero", "modelling.aero", "navigation.aero", "parachuting.aero", "paragliding.aero", "passenger-association.aero", "pilot.aero", "press.aero", "production.aero", "recreation.aero", "repbody.aero", "res.aero", "research.aero", "rotorcraft.aero", "safety.aero", "scientist.aero", "services.aero", "show.aero", "skydiving.aero", "software.aero", "student.aero", "taxi.aero", "trader.aero", "trading.aero", "trainer.aero", "union.aero", "workinggroup.aero", "works.aero", "af", "com.af", "edu.af", "gov.af", "net.af", "org.af", "ag", "co.ag", "com.ag", "net.ag", "nom.ag", "org.ag", "ai", "com.ai", "net.ai", "off.ai", "org.ai", "al", "com.al", "edu.al", "gov.al", "mil.al", "net.al", "org.al", "am", "co.am", "com.am", "commune.am", "net.am", "org.am", "ao", "co.ao", "ed.ao", "edu.ao", "gov.ao", "gv.ao", "it.ao", "og.ao", "org.ao", "pb.ao", "aq", "ar", "bet.ar", "com.ar", "coop.ar", "edu.ar", "gob.ar", "gov.ar", "int.ar", "mil.ar", "musica.ar", "mutual.ar", "net.ar", "org.ar", "senasa.ar", "tur.ar", "arpa", "e164.arpa", "home.arpa", "in-addr.arpa", "ip6.arpa", "iris.arpa", "uri.arpa", "urn.arpa", "as", "gov.as", "asia", "at", "ac.at", "sth.ac.at", "co.at", "gv.at", "or.at", "au", "asn.au", "com.au", "edu.au", "gov.au", "id.au", "net.au", "org.au", "conf.au", "oz.au", "act.au", "nsw.au", "nt.au", "qld.au", "sa.au", "tas.au", "vic.au", "wa.au", "act.edu.au", "catholic.edu.au", "nsw.edu.au", "nt.edu.au", "qld.edu.au", "sa.edu.au", "tas.edu.au", "vic.edu.au", "wa.edu.au", "qld.gov.au", "sa.gov.au", "tas.gov.au", "vic.gov.au", "wa.gov.au", "schools.nsw.edu.au", "aw", "com.aw", "ax", "az", "biz.az", "com.az", "edu.az", "gov.az", "info.az", "int.az", "mil.az", "name.az", "net.az", "org.az", "pp.az", "pro.az", "ba", "com.ba", "edu.ba", "gov.ba", "mil.ba", "net.ba", "org.ba", "bb", "biz.bb", "co.bb", "com.bb", "edu.bb", "gov.bb", "info.bb", "net.bb", "org.bb", "store.bb", "tv.bb", "*.bd", "be", "ac.be", "bf", "gov.bf", "bg", "0.bg", "1.bg", "2.bg", "3.bg", "4.bg", "5.bg", "6.bg", "7.bg", "8.bg", "9.bg", "a.bg", "b.bg", "c.bg", "d.bg", "e.bg", "f.bg", "g.bg", "h.bg", "i.bg", "j.bg", "k.bg", "l.bg", "m.bg", "n.bg", "o.bg", "p.bg", "q.bg", "r.bg", "s.bg", "t.bg", "u.bg", "v.bg", "w.bg", "x.bg", "y.bg", "z.bg", "bh", "com.bh", "edu.bh", "gov.bh", "net.bh", "org.bh", "bi", "co.bi", "com.bi", "edu.bi", "or.bi", "org.bi", "biz", "bj", "africa.bj", "agro.bj", "architectes.bj", "assur.bj", "avocats.bj", "co.bj", "com.bj", "eco.bj", "econo.bj", "edu.bj", "info.bj", "loisirs.bj", "money.bj", "net.bj", "org.bj", "ote.bj", "restaurant.bj", "resto.bj", "tourism.bj", "univ.bj", "bm", "com.bm", "edu.bm", "gov.bm", "net.bm", "org.bm", "bn", "com.bn", "edu.bn", "gov.bn", "net.bn", "org.bn", "bo", "com.bo", "edu.bo", "gob.bo", "int.bo", "mil.bo", "net.bo", "org.bo", "tv.bo", "web.bo", "academia.bo", "agro.bo", "arte.bo", "blog.bo", "bolivia.bo", "ciencia.bo", "cooperativa.bo", "democracia.bo", "deporte.bo", "ecologia.bo", "economia.bo", "empresa.bo", "indigena.bo", "industria.bo", "info.bo", "medicina.bo", "movimiento.bo", "musica.bo", "natural.bo", "nombre.bo", "noticias.bo", "patria.bo", "plurinacional.bo", "politica.bo", "profesional.bo", "pueblo.bo", "revista.bo", "salud.bo", "tecnologia.bo", "tksat.bo", "transporte.bo", "wiki.bo", "br", "9guacu.br", "abc.br", "adm.br", "adv.br", "agr.br", "aju.br", "am.br", "anani.br", "aparecida.br", "app.br", "arq.br", "art.br", "ato.br", "b.br", "barueri.br", "belem.br", "bet.br", "bhz.br", "bib.br", "bio.br", "blog.br", "bmd.br", "boavista.br", "bsb.br", "campinagrande.br", "campinas.br", "caxias.br", "cim.br", "cng.br", "cnt.br", "com.br", "contagem.br", "coop.br", "coz.br", "cri.br", "cuiaba.br", "curitiba.br", "def.br", "des.br", "det.br", "dev.br", "ecn.br", "eco.br", "edu.br", "emp.br", "enf.br", "eng.br", "esp.br", "etc.br", "eti.br", "far.br", "feira.br", "flog.br", "floripa.br", "fm.br", "fnd.br", "fortal.br", "fot.br", "foz.br", "fst.br", "g12.br", "geo.br", "ggf.br", "goiania.br", "gov.br", "ac.gov.br", "al.gov.br", "am.gov.br", "ap.gov.br", "ba.gov.br", "ce.gov.br", "df.gov.br", "es.gov.br", "go.gov.br", "ma.gov.br", "mg.gov.br", "ms.gov.br", "mt.gov.br", "pa.gov.br", "pb.gov.br", "pe.gov.br", "pi.gov.br", "pr.gov.br", "rj.gov.br", "rn.gov.br", "ro.gov.br", "rr.gov.br", "rs.gov.br", "sc.gov.br", "se.gov.br", "sp.gov.br", "to.gov.br", "gru.br", "imb.br", "ind.br", "inf.br", "jab.br", "jampa.br", "jdf.br", "joinville.br", "jor.br", "jus.br", "leg.br", "leilao.br", "lel.br", "log.br", "londrina.br", "macapa.br", "maceio.br", "manaus.br", "maringa.br", "mat.br", "med.br", "mil.br", "morena.br", "mp.br", "mus.br", "natal.br", "net.br", "niteroi.br", "*.nom.br", "not.br", "ntr.br", "odo.br", "ong.br", "org.br", "osasco.br", "palmas.br", "poa.br", "ppg.br", "pro.br", "psc.br", "psi.br", "pvh.br", "qsl.br", "radio.br", "rec.br", "recife.br", "rep.br", "ribeirao.br", "rio.br", "riobranco.br", "riopreto.br", "salvador.br", "sampa.br", "santamaria.br", "santoandre.br", "saobernardo.br", "saogonca.br", "seg.br", "sjc.br", "slg.br", "slz.br", "sorocaba.br", "srv.br", "taxi.br", "tc.br", "tec.br", "teo.br", "the.br", "tmp.br", "trd.br", "tur.br", "tv.br", "udi.br", "vet.br", "vix.br", "vlog.br", "wiki.br", "zlg.br", "bs", "com.bs", "edu.bs", "gov.bs", "net.bs", "org.bs", "bt", "com.bt", "edu.bt", "gov.bt", "net.bt", "org.bt", "bv", "bw", "co.bw", "org.bw", "by", "gov.by", "mil.by", "com.by", "of.by", "bz", "co.bz", "com.bz", "edu.bz", "gov.bz", "net.bz", "org.bz", "ca", "ab.ca", "bc.ca", "mb.ca", "nb.ca", "nf.ca", "nl.ca", "ns.ca", "nt.ca", "nu.ca", "on.ca", "pe.ca", "qc.ca", "sk.ca", "yk.ca", "gc.ca", "cat", "cc", "cd", "gov.cd", "cf", "cg", "ch", "ci", "ac.ci", "aroport.ci", "asso.ci", "co.ci", "com.ci", "ed.ci", "edu.ci", "go.ci", "gouv.ci", "int.ci", "net.ci", "or.ci", "org.ci", "*.ck", "!www.ck", "cl", "co.cl", "gob.cl", "gov.cl", "mil.cl", "cm", "co.cm", "com.cm", "gov.cm", "net.cm", "cn", "ac.cn", "com.cn", "edu.cn", "gov.cn", "mil.cn", "net.cn", "org.cn", ".cn", ".cn", ".cn", "ah.cn", "bj.cn", "cq.cn", "fj.cn", "gd.cn", "gs.cn", "gx.cn", "gz.cn", "ha.cn", "hb.cn", "he.cn", "hi.cn", "hk.cn", "hl.cn", "hn.cn", "jl.cn", "js.cn", "jx.cn", "ln.cn", "mo.cn", "nm.cn", "nx.cn", "qh.cn", "sc.cn", "sd.cn", "sh.cn", "sn.cn", "sx.cn", "tj.cn", "tw.cn", "xj.cn", "xz.cn", "yn.cn", "zj.cn", "co", "com.co", "edu.co", "gov.co", "mil.co", "net.co", "nom.co", "org.co", "com", "coop", "cr", "ac.cr", "co.cr", "ed.cr", "fi.cr", "go.cr", "or.cr", "sa.cr", "cu", "com.cu", "edu.cu", "gob.cu", "inf.cu", "nat.cu", "net.cu", "org.cu", "cv", "com.cv", "edu.cv", "id.cv", "int.cv", "net.cv", "nome.cv", "org.cv", "publ.cv", "cw", "com.cw", "edu.cw", "net.cw", "org.cw", "cx", "gov.cx", "cy", "ac.cy", "biz.cy", "com.cy", "ekloges.cy", "gov.cy", "ltd.cy", "mil.cy", "net.cy", "org.cy", "press.cy", "pro.cy", "tm.cy", "cz", "de", "dj", "dk", "dm", "co.dm", "com.dm", "edu.dm", "gov.dm", "net.dm", "org.dm", "do", "art.do", "com.do", "edu.do", "gob.do", "gov.do", "mil.do", "net.do", "org.do", "sld.do", "web.do", "dz", "art.dz", "asso.dz", "com.dz", "edu.dz", "gov.dz", "net.dz", "org.dz", "pol.dz", "soc.dz", "tm.dz", "ec", "com.ec", "edu.ec", "fin.ec", "gob.ec", "gov.ec", "info.ec", "k12.ec", "med.ec", "mil.ec", "net.ec", "org.ec", "pro.ec", "edu", "ee", "aip.ee", "com.ee", "edu.ee", "fie.ee", "gov.ee", "lib.ee", "med.ee", "org.ee", "pri.ee", "riik.ee", "eg", "ac.eg", "com.eg", "edu.eg", "eun.eg", "gov.eg", "info.eg", "me.eg", "mil.eg", "name.eg", "net.eg", "org.eg", "sci.eg", "sport.eg", "tv.eg", "*.er", "es", "com.es", "edu.es", "gob.es", "nom.es", "org.es", "et", "biz.et", "com.et", "edu.et", "gov.et", "info.et", "name.et", "net.et", "org.et", "eu", "fi", "aland.fi", "fj", "ac.fj", "biz.fj", "com.fj", "gov.fj", "info.fj", "mil.fj", "name.fj", "net.fj", "org.fj", "pro.fj", "*.fk", "fm", "com.fm", "edu.fm", "net.fm", "org.fm", "fo", "fr", "asso.fr", "com.fr", "gouv.fr", "nom.fr", "prd.fr", "tm.fr", "avoues.fr", "cci.fr", "greta.fr", "huissier-justice.fr", "ga", "gb", "gd", "edu.gd", "gov.gd", "ge", "com.ge", "edu.ge", "gov.ge", "net.ge", "org.ge", "pvt.ge", "school.ge", "gf", "gg", "co.gg", "net.gg", "org.gg", "gh", "com.gh", "edu.gh", "gov.gh", "mil.gh", "org.gh", "gi", "com.gi", "edu.gi", "gov.gi", "ltd.gi", "mod.gi", "org.gi", "gl", "co.gl", "com.gl", "edu.gl", "net.gl", "org.gl", "gm", "gn", "ac.gn", "com.gn", "edu.gn", "gov.gn", "net.gn", "org.gn", "gov", "gp", "asso.gp", "com.gp", "edu.gp", "mobi.gp", "net.gp", "org.gp", "gq", "gr", "com.gr", "edu.gr", "gov.gr", "net.gr", "org.gr", "gs", "gt", "com.gt", "edu.gt", "gob.gt", "ind.gt", "mil.gt", "net.gt", "org.gt", "gu", "com.gu", "edu.gu", "gov.gu", "guam.gu", "info.gu", "net.gu", "org.gu", "web.gu", "gw", "gy", "co.gy", "com.gy", "edu.gy", "gov.gy", "net.gy", "org.gy", "hk", "com.hk", "edu.hk", "gov.hk", "idv.hk", "net.hk", "org.hk", ".hk", ".hk", ".hk", ".hk", ".hk", ".hk", ".hk", ".hk", ".hk", ".hk", ".hk", ".hk", ".hk", ".hk", ".hk", "hm", "hn", "com.hn", "edu.hn", "gob.hn", "mil.hn", "net.hn", "org.hn", "hr", "com.hr", "from.hr", "iz.hr", "name.hr", "ht", "adult.ht", "art.ht", "asso.ht", "com.ht", "coop.ht", "edu.ht", "firm.ht", "gouv.ht", "info.ht", "med.ht", "net.ht", "org.ht", "perso.ht", "pol.ht", "pro.ht", "rel.ht", "shop.ht", "hu", "2000.hu", "agrar.hu", "bolt.hu", "casino.hu", "city.hu", "co.hu", "erotica.hu", "erotika.hu", "film.hu", "forum.hu", "games.hu", "hotel.hu", "info.hu", "ingatlan.hu", "jogasz.hu", "konyvelo.hu", "lakas.hu", "media.hu", "news.hu", "org.hu", "priv.hu", "reklam.hu", "sex.hu", "shop.hu", "sport.hu", "suli.hu", "szex.hu", "tm.hu", "tozsde.hu", "utazas.hu", "video.hu", "id", "ac.id", "biz.id", "co.id", "desa.id", "go.id", "mil.id", "my.id", "net.id", "or.id", "ponpes.id", "sch.id", "web.id", "ie", "gov.ie", "il", "ac.il", "co.il", "gov.il", "idf.il", "k12.il", "muni.il", "net.il", "org.il", "", ".", ".", ".", ".", "im", "ac.im", "co.im", "ltd.co.im", "plc.co.im", "com.im", "net.im", "org.im", "tt.im", "tv.im", "in", "5g.in", "6g.in", "ac.in", "ai.in", "am.in", "bihar.in", "biz.in", "business.in", "ca.in", "cn.in", "co.in", "com.in", "coop.in", "cs.in", "delhi.in", "dr.in", "edu.in", "er.in", "firm.in", "gen.in", "gov.in", "gujarat.in", "ind.in", "info.in", "int.in", "internet.in", "io.in", "me.in", "mil.in", "net.in", "nic.in", "org.in", "pg.in", "post.in", "pro.in", "res.in", "travel.in", "tv.in", "uk.in", "up.in", "us.in", "info", "int", "eu.int", "io", "co.io", "com.io", "edu.io", "gov.io", "mil.io", "net.io", "nom.io", "org.io", "iq", "com.iq", "edu.iq", "gov.iq", "mil.iq", "net.iq", "org.iq", "ir", "ac.ir", "co.ir", "gov.ir", "id.ir", "net.ir", "org.ir", "sch.ir", ".ir", ".ir", "is", "it", "edu.it", "gov.it", "abr.it", "abruzzo.it", "aosta-valley.it", "aostavalley.it", "bas.it", "basilicata.it", "cal.it", "calabria.it", "cam.it", "campania.it", "emilia-romagna.it", "emiliaromagna.it", "emr.it", "friuli-v-giulia.it", "friuli-ve-giulia.it", "friuli-vegiulia.it", "friuli-venezia-giulia.it", "friuli-veneziagiulia.it", "friuli-vgiulia.it", "friuliv-giulia.it", "friulive-giulia.it", "friulivegiulia.it", "friulivenezia-giulia.it", "friuliveneziagiulia.it", "friulivgiulia.it", "fvg.it", "laz.it", "lazio.it", "lig.it", "liguria.it", "lom.it", "lombardia.it", "lombardy.it", "lucania.it", "mar.it", "marche.it", "mol.it", "molise.it", "piedmont.it", "piemonte.it", "pmn.it", "pug.it", "puglia.it", "sar.it", "sardegna.it", "sardinia.it", "sic.it", "sicilia.it", "sicily.it", "taa.it", "tos.it", "toscana.it", "trentin-sud-tirol.it", "trentin-sd-tirol.it", "trentin-sudtirol.it", "trentin-sdtirol.it", "trentin-sued-tirol.it", "trentin-suedtirol.it", "trentino.it", "trentino-a-adige.it", "trentino-aadige.it", "trentino-alto-adige.it", "trentino-altoadige.it", "trentino-s-tirol.it", "trentino-stirol.it", "trentino-sud-tirol.it", "trentino-sd-tirol.it", "trentino-sudtirol.it", "trentino-sdtirol.it", "trentino-sued-tirol.it", "trentino-suedtirol.it", "trentinoa-adige.it", "trentinoaadige.it", "trentinoalto-adige.it", "trentinoaltoadige.it", "trentinos-tirol.it", "trentinostirol.it", "trentinosud-tirol.it", "trentinosd-tirol.it", "trentinosudtirol.it", "trentinosdtirol.it", "trentinosued-tirol.it", "trentinosuedtirol.it", "trentinsud-tirol.it", "trentinsd-tirol.it", "trentinsudtirol.it", "trentinsdtirol.it", "trentinsued-tirol.it", "trentinsuedtirol.it", "tuscany.it", "umb.it", "umbria.it", "val-d-aosta.it", "val-daosta.it", "vald-aosta.it", "valdaosta.it", "valle-aosta.it", "valle-d-aosta.it", "valle-daosta.it", "valleaosta.it", "valled-aosta.it", "valledaosta.it", "vallee-aoste.it", "valle-aoste.it", "vallee-d-aoste.it", "valle-d-aoste.it", "valleeaoste.it", "valleaoste.it", "valleedaoste.it", "valledaoste.it", "vao.it", "vda.it", "ven.it", "veneto.it", "ag.it", "agrigento.it", "al.it", "alessandria.it", "alto-adige.it", "altoadige.it", "an.it", "ancona.it", "andria-barletta-trani.it", "andria-trani-barletta.it", "andriabarlettatrani.it", "andriatranibarletta.it", "ao.it", "aosta.it", "aoste.it", "ap.it", "aq.it", "aquila.it", "ar.it", "arezzo.it", "ascoli-piceno.it", "ascolipiceno.it", "asti.it", "at.it", "av.it", "avellino.it", "ba.it", "balsan.it", "balsan-sudtirol.it", "balsan-sdtirol.it", "balsan-suedtirol.it", "bari.it", "barletta-trani-andria.it", "barlettatraniandria.it", "belluno.it", "benevento.it", "bergamo.it", "bg.it", "bi.it", "biella.it", "bl.it", "bn.it", "bo.it", "bologna.it", "bolzano.it", "bolzano-altoadige.it", "bozen.it", "bozen-sudtirol.it", "bozen-sdtirol.it", "bozen-suedtirol.it", "br.it", "brescia.it", "brindisi.it", "bs.it", "bt.it", "bulsan.it", "bulsan-sudtirol.it", "bulsan-sdtirol.it", "bulsan-suedtirol.it", "bz.it", "ca.it", "cagliari.it", "caltanissetta.it", "campidano-medio.it", "campidanomedio.it", "campobasso.it", "carbonia-iglesias.it", "carboniaiglesias.it", "carrara-massa.it", "carraramassa.it", "caserta.it", "catania.it", "catanzaro.it", "cb.it", "ce.it", "cesena-forli.it", "cesena-forl.it", "cesenaforli.it", "cesenaforl.it", "ch.it", "chieti.it", "ci.it", "cl.it", "cn.it", "co.it", "como.it", "cosenza.it", "cr.it", "cremona.it", "crotone.it", "cs.it", "ct.it", "cuneo.it", "cz.it", "dell-ogliastra.it", "dellogliastra.it", "en.it", "enna.it", "fc.it", "fe.it", "fermo.it", "ferrara.it", "fg.it", "fi.it", "firenze.it", "florence.it", "fm.it", "foggia.it", "forli-cesena.it", "forl-cesena.it", "forlicesena.it", "forlcesena.it", "fr.it", "frosinone.it", "ge.it", "genoa.it", "genova.it", "go.it", "gorizia.it", "gr.it", "grosseto.it", "iglesias-carbonia.it", "iglesiascarbonia.it", "im.it", "imperia.it", "is.it", "isernia.it", "kr.it", "la-spezia.it", "laquila.it", "laspezia.it", "latina.it", "lc.it", "le.it", "lecce.it", "lecco.it", "li.it", "livorno.it", "lo.it", "lodi.it", "lt.it", "lu.it", "lucca.it", "macerata.it", "mantova.it", "massa-carrara.it", "massacarrara.it", "matera.it", "mb.it", "mc.it", "me.it", "medio-campidano.it", "mediocampidano.it", "messina.it", "mi.it", "milan.it", "milano.it", "mn.it", "mo.it", "modena.it", "monza.it", "monza-brianza.it", "monza-e-della-brianza.it", "monzabrianza.it", "monzaebrianza.it", "monzaedellabrianza.it", "ms.it", "mt.it", "na.it", "naples.it", "napoli.it", "no.it", "novara.it", "nu.it", "nuoro.it", "og.it", "ogliastra.it", "olbia-tempio.it", "olbiatempio.it", "or.it", "oristano.it", "ot.it", "pa.it", "padova.it", "padua.it", "palermo.it", "parma.it", "pavia.it", "pc.it", "pd.it", "pe.it", "perugia.it", "pesaro-urbino.it", "pesarourbino.it", "pescara.it", "pg.it", "pi.it", "piacenza.it", "pisa.it", "pistoia.it", "pn.it", "po.it", "pordenone.it", "potenza.it", "pr.it", "prato.it", "pt.it", "pu.it", "pv.it", "pz.it", "ra.it", "ragusa.it", "ravenna.it", "rc.it", "re.it", "reggio-calabria.it", "reggio-emilia.it", "reggiocalabria.it", "reggioemilia.it", "rg.it", "ri.it", "rieti.it", "rimini.it", "rm.it", "rn.it", "ro.it", "roma.it", "rome.it", "rovigo.it", "sa.it", "salerno.it", "sassari.it", "savona.it", "si.it", "siena.it", "siracusa.it", "so.it", "sondrio.it", "sp.it", "sr.it", "ss.it", "sdtirol.it", "suedtirol.it", "sv.it", "ta.it", "taranto.it", "te.it", "tempio-olbia.it", "tempioolbia.it", "teramo.it", "terni.it", "tn.it", "to.it", "torino.it", "tp.it", "tr.it", "trani-andria-barletta.it", "trani-barletta-andria.it", "traniandriabarletta.it", "tranibarlettaandria.it", "trapani.it", "trento.it", "treviso.it", "trieste.it", "ts.it", "turin.it", "tv.it", "ud.it", "udine.it", "urbino-pesaro.it", "urbinopesaro.it", "va.it", "varese.it", "vb.it", "vc.it", "ve.it", "venezia.it", "venice.it", "verbania.it", "vercelli.it", "verona.it", "vi.it", "vibo-valentia.it", "vibovalentia.it", "vicenza.it", "viterbo.it", "vr.it", "vs.it", "vt.it", "vv.it", "je", "co.je", "net.je", "org.je", "*.jm", "jo", "agri.jo", "ai.jo", "com.jo", "edu.jo", "eng.jo", "fm.jo", "gov.jo", "mil.jo", "net.jo", "org.jo", "per.jo", "phd.jo", "sch.jo", "tv.jo", "jobs", "jp", "ac.jp", "ad.jp", "co.jp", "ed.jp", "go.jp", "gr.jp", "lg.jp", "ne.jp", "or.jp", "aichi.jp", "akita.jp", "aomori.jp", "chiba.jp", "ehime.jp", "fukui.jp", "fukuoka.jp", "fukushima.jp", "gifu.jp", "gunma.jp", "hiroshima.jp", "hokkaido.jp", "hyogo.jp", "ibaraki.jp", "ishikawa.jp", "iwate.jp", "kagawa.jp", "kagoshima.jp", "kanagawa.jp", "kochi.jp", "kumamoto.jp", "kyoto.jp", "mie.jp", "miyagi.jp", "miyazaki.jp", "nagano.jp", "nagasaki.jp", "nara.jp", "niigata.jp", "oita.jp", "okayama.jp", "okinawa.jp", "osaka.jp", "saga.jp", "saitama.jp", "shiga.jp", "shimane.jp", "shizuoka.jp", "tochigi.jp", "tokushima.jp", "tokyo.jp", "tottori.jp", "toyama.jp", "wakayama.jp", "yamagata.jp", "yamaguchi.jp", "yamanashi.jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", ".jp", "*.kawasaki.jp", "!city.kawasaki.jp", "*.kitakyushu.jp", "!city.kitakyushu.jp", "*.kobe.jp", "!city.kobe.jp", "*.nagoya.jp", "!city.nagoya.jp", "*.sapporo.jp", "!city.sapporo.jp", "*.sendai.jp", "!city.sendai.jp", "*.yokohama.jp", "!city.yokohama.jp", "aisai.aichi.jp", "ama.aichi.jp", "anjo.aichi.jp", "asuke.aichi.jp", "chiryu.aichi.jp", "chita.aichi.jp", "fuso.aichi.jp", "gamagori.aichi.jp", "handa.aichi.jp", "hazu.aichi.jp", "hekinan.aichi.jp", "higashiura.aichi.jp", "ichinomiya.aichi.jp", "inazawa.aichi.jp", "inuyama.aichi.jp", "isshiki.aichi.jp", "iwakura.aichi.jp", "kanie.aichi.jp", "kariya.aichi.jp", "kasugai.aichi.jp", "kira.aichi.jp", "kiyosu.aichi.jp", "komaki.aichi.jp", "konan.aichi.jp", "kota.aichi.jp", "mihama.aichi.jp", "miyoshi.aichi.jp", "nishio.aichi.jp", "nisshin.aichi.jp", "obu.aichi.jp", "oguchi.aichi.jp", "oharu.aichi.jp", "okazaki.aichi.jp", "owariasahi.aichi.jp", "seto.aichi.jp", "shikatsu.aichi.jp", "shinshiro.aichi.jp", "shitara.aichi.jp", "tahara.aichi.jp", "takahama.aichi.jp", "tobishima.aichi.jp", "toei.aichi.jp", "togo.aichi.jp", "tokai.aichi.jp", "tokoname.aichi.jp", "toyoake.aichi.jp", "toyohashi.aichi.jp", "toyokawa.aichi.jp", "toyone.aichi.jp", "toyota.aichi.jp", "tsushima.aichi.jp", "yatomi.aichi.jp", "akita.akita.jp", "daisen.akita.jp", "fujisato.akita.jp", "gojome.akita.jp", "hachirogata.akita.jp", "happou.akita.jp", "higashinaruse.akita.jp", "honjo.akita.jp", "honjyo.akita.jp", "ikawa.akita.jp", "kamikoani.akita.jp", "kamioka.akita.jp", "katagami.akita.jp", "kazuno.akita.jp", "kitaakita.akita.jp", "kosaka.akita.jp", "kyowa.akita.jp", "misato.akita.jp", "mitane.akita.jp", "moriyoshi.akita.jp", "nikaho.akita.jp", "noshiro.akita.jp", "odate.akita.jp", "oga.akita.jp", "ogata.akita.jp", "semboku.akita.jp", "yokote.akita.jp", "yurihonjo.akita.jp", "aomori.aomori.jp", "gonohe.aomori.jp", "hachinohe.aomori.jp", "hashikami.aomori.jp", "hiranai.aomori.jp", "hirosaki.aomori.jp", "itayanagi.aomori.jp", "kuroishi.aomori.jp", "misawa.aomori.jp", "mutsu.aomori.jp", "nakadomari.aomori.jp", "noheji.aomori.jp", "oirase.aomori.jp", "owani.aomori.jp", "rokunohe.aomori.jp", "sannohe.aomori.jp", "shichinohe.aomori.jp", "shingo.aomori.jp", "takko.aomori.jp", "towada.aomori.jp", "tsugaru.aomori.jp", "tsuruta.aomori.jp", "abiko.chiba.jp", "asahi.chiba.jp", "chonan.chiba.jp", "chosei.chiba.jp", "choshi.chiba.jp", "chuo.chiba.jp", "funabashi.chiba.jp", "futtsu.chiba.jp", "hanamigawa.chiba.jp", "ichihara.chiba.jp", "ichikawa.chiba.jp", "ichinomiya.chiba.jp", "inzai.chiba.jp", "isumi.chiba.jp", "kamagaya.chiba.jp", "kamogawa.chiba.jp", "kashiwa.chiba.jp", "katori.chiba.jp", "katsuura.chiba.jp", "kimitsu.chiba.jp", "kisarazu.chiba.jp", "kozaki.chiba.jp", "kujukuri.chiba.jp", "kyonan.chiba.jp", "matsudo.chiba.jp", "midori.chiba.jp", "mihama.chiba.jp", "minamiboso.chiba.jp", "mobara.chiba.jp", "mutsuzawa.chiba.jp", "nagara.chiba.jp", "nagareyama.chiba.jp", "narashino.chiba.jp", "narita.chiba.jp", "noda.chiba.jp", "oamishirasato.chiba.jp", "omigawa.chiba.jp", "onjuku.chiba.jp", "otaki.chiba.jp", "sakae.chiba.jp", "sakura.chiba.jp", "shimofusa.chiba.jp", "shirako.chiba.jp", "shiroi.chiba.jp", "shisui.chiba.jp", "sodegaura.chiba.jp", "sosa.chiba.jp", "tako.chiba.jp", "tateyama.chiba.jp", "togane.chiba.jp", "tohnosho.chiba.jp", "tomisato.chiba.jp", "urayasu.chiba.jp", "yachimata.chiba.jp", "yachiyo.chiba.jp", "yokaichiba.chiba.jp", "yokoshibahikari.chiba.jp", "yotsukaido.chiba.jp", "ainan.ehime.jp", "honai.ehime.jp", "ikata.ehime.jp", "imabari.ehime.jp", "iyo.ehime.jp", "kamijima.ehime.jp", "kihoku.ehime.jp", "kumakogen.ehime.jp", "masaki.ehime.jp", "matsuno.ehime.jp", "matsuyama.ehime.jp", "namikata.ehime.jp", "niihama.ehime.jp", "ozu.ehime.jp", "saijo.ehime.jp", "seiyo.ehime.jp", "shikokuchuo.ehime.jp", "tobe.ehime.jp", "toon.ehime.jp", "uchiko.ehime.jp", "uwajima.ehime.jp", "yawatahama.ehime.jp", "echizen.fukui.jp", "eiheiji.fukui.jp", "fukui.fukui.jp", "ikeda.fukui.jp", "katsuyama.fukui.jp", "mihama.fukui.jp", "minamiechizen.fukui.jp", "obama.fukui.jp", "ohi.fukui.jp", "ono.fukui.jp", "sabae.fukui.jp", "sakai.fukui.jp", "takahama.fukui.jp", "tsuruga.fukui.jp", "wakasa.fukui.jp", "ashiya.fukuoka.jp", "buzen.fukuoka.jp", "chikugo.fukuoka.jp", "chikuho.fukuoka.jp", "chikujo.fukuoka.jp", "chikushino.fukuoka.jp", "chikuzen.fukuoka.jp", "chuo.fukuoka.jp", "dazaifu.fukuoka.jp", "fukuchi.fukuoka.jp", "hakata.fukuoka.jp", "higashi.fukuoka.jp", "hirokawa.fukuoka.jp", "hisayama.fukuoka.jp", "iizuka.fukuoka.jp", "inatsuki.fukuoka.jp", "kaho.fukuoka.jp", "kasuga.fukuoka.jp", "kasuya.fukuoka.jp", "kawara.fukuoka.jp", "keisen.fukuoka.jp", "koga.fukuoka.jp", "kurate.fukuoka.jp", "kurogi.fukuoka.jp", "kurume.fukuoka.jp", "minami.fukuoka.jp", "miyako.fukuoka.jp", "miyama.fukuoka.jp", "miyawaka.fukuoka.jp", "mizumaki.fukuoka.jp", "munakata.fukuoka.jp", "nakagawa.fukuoka.jp", "nakama.fukuoka.jp", "nishi.fukuoka.jp", "nogata.fukuoka.jp", "ogori.fukuoka.jp", "okagaki.fukuoka.jp", "okawa.fukuoka.jp", "oki.fukuoka.jp", "omuta.fukuoka.jp", "onga.fukuoka.jp", "onojo.fukuoka.jp", "oto.fukuoka.jp", "saigawa.fukuoka.jp", "sasaguri.fukuoka.jp", "shingu.fukuoka.jp", "shinyoshitomi.fukuoka.jp", "shonai.fukuoka.jp", "soeda.fukuoka.jp", "sue.fukuoka.jp", "tachiarai.fukuoka.jp", "tagawa.fukuoka.jp", "takata.fukuoka.jp", "toho.fukuoka.jp", "toyotsu.fukuoka.jp", "tsuiki.fukuoka.jp", "ukiha.fukuoka.jp", "umi.fukuoka.jp", "usui.fukuoka.jp", "yamada.fukuoka.jp", "yame.fukuoka.jp", "yanagawa.fukuoka.jp", "yukuhashi.fukuoka.jp", "aizubange.fukushima.jp", "aizumisato.fukushima.jp", "aizuwakamatsu.fukushima.jp", "asakawa.fukushima.jp", "bandai.fukushima.jp", "date.fukushima.jp", "fukushima.fukushima.jp", "furudono.fukushima.jp", "futaba.fukushima.jp", "hanawa.fukushima.jp", "higashi.fukushima.jp", "hirata.fukushima.jp", "hirono.fukushima.jp", "iitate.fukushima.jp", "inawashiro.fukushima.jp", "ishikawa.fukushima.jp", "iwaki.fukushima.jp", "izumizaki.fukushima.jp", "kagamiishi.fukushima.jp", "kaneyama.fukushima.jp", "kawamata.fukushima.jp", "kitakata.fukushima.jp", "kitashiobara.fukushima.jp", "koori.fukushima.jp", "koriyama.fukushima.jp", "kunimi.fukushima.jp", "miharu.fukushima.jp", "mishima.fukushima.jp", "namie.fukushima.jp", "nango.fukushima.jp", "nishiaizu.fukushima.jp", "nishigo.fukushima.jp", "okuma.fukushima.jp", "omotego.fukushima.jp", "ono.fukushima.jp", "otama.fukushima.jp", "samegawa.fukushima.jp", "shimogo.fukushima.jp", "shirakawa.fukushima.jp", "showa.fukushima.jp", "soma.fukushima.jp", "sukagawa.fukushima.jp", "taishin.fukushima.jp", "tamakawa.fukushima.jp", "tanagura.fukushima.jp", "tenei.fukushima.jp", "yabuki.fukushima.jp", "yamato.fukushima.jp", "yamatsuri.fukushima.jp", "yanaizu.fukushima.jp", "yugawa.fukushima.jp", "anpachi.gifu.jp", "ena.gifu.jp", "gifu.gifu.jp", "ginan.gifu.jp", "godo.gifu.jp", "gujo.gifu.jp", "hashima.gifu.jp", "hichiso.gifu.jp", "hida.gifu.jp", "higashishirakawa.gifu.jp", "ibigawa.gifu.jp", "ikeda.gifu.jp", "kakamigahara.gifu.jp", "kani.gifu.jp", "kasahara.gifu.jp", "kasamatsu.gifu.jp", "kawaue.gifu.jp", "kitagata.gifu.jp", "mino.gifu.jp", "minokamo.gifu.jp", "mitake.gifu.jp", "mizunami.gifu.jp", "motosu.gifu.jp", "nakatsugawa.gifu.jp", "ogaki.gifu.jp", "sakahogi.gifu.jp", "seki.gifu.jp", "sekigahara.gifu.jp", "shirakawa.gifu.jp", "tajimi.gifu.jp", "takayama.gifu.jp", "tarui.gifu.jp", "toki.gifu.jp", "tomika.gifu.jp", "wanouchi.gifu.jp", "yamagata.gifu.jp", "yaotsu.gifu.jp", "yoro.gifu.jp", "annaka.gunma.jp", "chiyoda.gunma.jp", "fujioka.gunma.jp", "higashiagatsuma.gunma.jp", "isesaki.gunma.jp", "itakura.gunma.jp", "kanna.gunma.jp", "kanra.gunma.jp", "katashina.gunma.jp", "kawaba.gunma.jp", "kiryu.gunma.jp", "kusatsu.gunma.jp", "maebashi.gunma.jp", "meiwa.gunma.jp", "midori.gunma.jp", "minakami.gunma.jp", "naganohara.gunma.jp", "nakanojo.gunma.jp", "nanmoku.gunma.jp", "numata.gunma.jp", "oizumi.gunma.jp", "ora.gunma.jp", "ota.gunma.jp", "shibukawa.gunma.jp", "shimonita.gunma.jp", "shinto.gunma.jp", "showa.gunma.jp", "takasaki.gunma.jp", "takayama.gunma.jp", "tamamura.gunma.jp", "tatebayashi.gunma.jp", "tomioka.gunma.jp", "tsukiyono.gunma.jp", "tsumagoi.gunma.jp", "ueno.gunma.jp", "yoshioka.gunma.jp", "asaminami.hiroshima.jp", "daiwa.hiroshima.jp", "etajima.hiroshima.jp", "fuchu.hiroshima.jp", "fukuyama.hiroshima.jp", "hatsukaichi.hiroshima.jp", "higashihiroshima.hiroshima.jp", "hongo.hiroshima.jp", "jinsekikogen.hiroshima.jp", "kaita.hiroshima.jp", "kui.hiroshima.jp", "kumano.hiroshima.jp", "kure.hiroshima.jp", "mihara.hiroshima.jp", "miyoshi.hiroshima.jp", "naka.hiroshima.jp", "onomichi.hiroshima.jp", "osakikamijima.hiroshima.jp", "otake.hiroshima.jp", "saka.hiroshima.jp", "sera.hiroshima.jp", "seranishi.hiroshima.jp", "shinichi.hiroshima.jp", "shobara.hiroshima.jp", "takehara.hiroshima.jp", "abashiri.hokkaido.jp", "abira.hokkaido.jp", "aibetsu.hokkaido.jp", "akabira.hokkaido.jp", "akkeshi.hokkaido.jp", "asahikawa.hokkaido.jp", "ashibetsu.hokkaido.jp", "ashoro.hokkaido.jp", "assabu.hokkaido.jp", "atsuma.hokkaido.jp", "bibai.hokkaido.jp", "biei.hokkaido.jp", "bifuka.hokkaido.jp", "bihoro.hokkaido.jp", "biratori.hokkaido.jp", "chippubetsu.hokkaido.jp", "chitose.hokkaido.jp", "date.hokkaido.jp", "ebetsu.hokkaido.jp", "embetsu.hokkaido.jp", "eniwa.hokkaido.jp", "erimo.hokkaido.jp", "esan.hokkaido.jp", "esashi.hokkaido.jp", "fukagawa.hokkaido.jp", "fukushima.hokkaido.jp", "furano.hokkaido.jp", "furubira.hokkaido.jp", "haboro.hokkaido.jp", "hakodate.hokkaido.jp", "hamatonbetsu.hokkaido.jp", "hidaka.hokkaido.jp", "higashikagura.hokkaido.jp", "higashikawa.hokkaido.jp", "hiroo.hokkaido.jp", "hokuryu.hokkaido.jp", "hokuto.hokkaido.jp", "honbetsu.hokkaido.jp", "horokanai.hokkaido.jp", "horonobe.hokkaido.jp", "ikeda.hokkaido.jp", "imakane.hokkaido.jp", "ishikari.hokkaido.jp", "iwamizawa.hokkaido.jp", "iwanai.hokkaido.jp", "kamifurano.hokkaido.jp", "kamikawa.hokkaido.jp", "kamishihoro.hokkaido.jp", "kamisunagawa.hokkaido.jp", "kamoenai.hokkaido.jp", "kayabe.hokkaido.jp", "kembuchi.hokkaido.jp", "kikonai.hokkaido.jp", "kimobetsu.hokkaido.jp", "kitahiroshima.hokkaido.jp", "kitami.hokkaido.jp", "kiyosato.hokkaido.jp", "koshimizu.hokkaido.jp", "kunneppu.hokkaido.jp", "kuriyama.hokkaido.jp", "kuromatsunai.hokkaido.jp", "kushiro.hokkaido.jp", "kutchan.hokkaido.jp", "kyowa.hokkaido.jp", "mashike.hokkaido.jp", "matsumae.hokkaido.jp", "mikasa.hokkaido.jp", "minamifurano.hokkaido.jp", "mombetsu.hokkaido.jp", "moseushi.hokkaido.jp", "mukawa.hokkaido.jp", "muroran.hokkaido.jp", "naie.hokkaido.jp", "nakagawa.hokkaido.jp", "nakasatsunai.hokkaido.jp", "nakatombetsu.hokkaido.jp", "nanae.hokkaido.jp", "nanporo.hokkaido.jp", "nayoro.hokkaido.jp", "nemuro.hokkaido.jp", "niikappu.hokkaido.jp", "niki.hokkaido.jp", "nishiokoppe.hokkaido.jp", "noboribetsu.hokkaido.jp", "numata.hokkaido.jp", "obihiro.hokkaido.jp", "obira.hokkaido.jp", "oketo.hokkaido.jp", "okoppe.hokkaido.jp", "otaru.hokkaido.jp", "otobe.hokkaido.jp", "otofuke.hokkaido.jp", "otoineppu.hokkaido.jp", "oumu.hokkaido.jp", "ozora.hokkaido.jp", "pippu.hokkaido.jp", "rankoshi.hokkaido.jp", "rebun.hokkaido.jp", "rikubetsu.hokkaido.jp", "rishiri.hokkaido.jp", "rishirifuji.hokkaido.jp", "saroma.hokkaido.jp", "sarufutsu.hokkaido.jp", "shakotan.hokkaido.jp", "shari.hokkaido.jp", "shibecha.hokkaido.jp", "shibetsu.hokkaido.jp", "shikabe.hokkaido.jp", "shikaoi.hokkaido.jp", "shimamaki.hokkaido.jp", "shimizu.hokkaido.jp", "shimokawa.hokkaido.jp", "shinshinotsu.hokkaido.jp", "shintoku.hokkaido.jp", "shiranuka.hokkaido.jp", "shiraoi.hokkaido.jp", "shiriuchi.hokkaido.jp", "sobetsu.hokkaido.jp", "sunagawa.hokkaido.jp", "taiki.hokkaido.jp", "takasu.hokkaido.jp", "takikawa.hokkaido.jp", "takinoue.hokkaido.jp", "teshikaga.hokkaido.jp", "tobetsu.hokkaido.jp", "tohma.hokkaido.jp", "tomakomai.hokkaido.jp", "tomari.hokkaido.jp", "toya.hokkaido.jp", "toyako.hokkaido.jp", "toyotomi.hokkaido.jp", "toyoura.hokkaido.jp", "tsubetsu.hokkaido.jp", "tsukigata.hokkaido.jp", "urakawa.hokkaido.jp", "urausu.hokkaido.jp", "uryu.hokkaido.jp", "utashinai.hokkaido.jp", "wakkanai.hokkaido.jp", "wassamu.hokkaido.jp", "yakumo.hokkaido.jp", "yoichi.hokkaido.jp", "aioi.hyogo.jp", "akashi.hyogo.jp", "ako.hyogo.jp", "amagasaki.hyogo.jp", "aogaki.hyogo.jp", "asago.hyogo.jp", "ashiya.hyogo.jp", "awaji.hyogo.jp", "fukusaki.hyogo.jp", "goshiki.hyogo.jp", "harima.hyogo.jp", "himeji.hyogo.jp", "ichikawa.hyogo.jp", "inagawa.hyogo.jp", "itami.hyogo.jp", "kakogawa.hyogo.jp", "kamigori.hyogo.jp", "kamikawa.hyogo.jp", "kasai.hyogo.jp", "kasuga.hyogo.jp", "kawanishi.hyogo.jp", "miki.hyogo.jp", "minamiawaji.hyogo.jp", "nishinomiya.hyogo.jp", "nishiwaki.hyogo.jp", "ono.hyogo.jp", "sanda.hyogo.jp", "sannan.hyogo.jp", "sasayama.hyogo.jp", "sayo.hyogo.jp", "shingu.hyogo.jp", "shinonsen.hyogo.jp", "shiso.hyogo.jp", "sumoto.hyogo.jp", "taishi.hyogo.jp", "taka.hyogo.jp", "takarazuka.hyogo.jp", "takasago.hyogo.jp", "takino.hyogo.jp", "tamba.hyogo.jp", "tatsuno.hyogo.jp", "toyooka.hyogo.jp", "yabu.hyogo.jp", "yashiro.hyogo.jp", "yoka.hyogo.jp", "yokawa.hyogo.jp", "ami.ibaraki.jp", "asahi.ibaraki.jp", "bando.ibaraki.jp", "chikusei.ibaraki.jp", "daigo.ibaraki.jp", "fujishiro.ibaraki.jp", "hitachi.ibaraki.jp", "hitachinaka.ibaraki.jp", "hitachiomiya.ibaraki.jp", "hitachiota.ibaraki.jp", "ibaraki.ibaraki.jp", "ina.ibaraki.jp", "inashiki.ibaraki.jp", "itako.ibaraki.jp", "iwama.ibaraki.jp", "joso.ibaraki.jp", "kamisu.ibaraki.jp", "kasama.ibaraki.jp", "kashima.ibaraki.jp", "kasumigaura.ibaraki.jp", "koga.ibaraki.jp", "miho.ibaraki.jp", "mito.ibaraki.jp", "moriya.ibaraki.jp", "naka.ibaraki.jp", "namegata.ibaraki.jp", "oarai.ibaraki.jp", "ogawa.ibaraki.jp", "omitama.ibaraki.jp", "ryugasaki.ibaraki.jp", "sakai.ibaraki.jp", "sakuragawa.ibaraki.jp", "shimodate.ibaraki.jp", "shimotsuma.ibaraki.jp", "shirosato.ibaraki.jp", "sowa.ibaraki.jp", "suifu.ibaraki.jp", "takahagi.ibaraki.jp", "tamatsukuri.ibaraki.jp", "tokai.ibaraki.jp", "tomobe.ibaraki.jp", "tone.ibaraki.jp", "toride.ibaraki.jp", "tsuchiura.ibaraki.jp", "tsukuba.ibaraki.jp", "uchihara.ibaraki.jp", "ushiku.ibaraki.jp", "yachiyo.ibaraki.jp", "yamagata.ibaraki.jp", "yawara.ibaraki.jp", "yuki.ibaraki.jp", "anamizu.ishikawa.jp", "hakui.ishikawa.jp", "hakusan.ishikawa.jp", "kaga.ishikawa.jp", "kahoku.ishikawa.jp", "kanazawa.ishikawa.jp", "kawakita.ishikawa.jp", "komatsu.ishikawa.jp", "nakanoto.ishikawa.jp", "nanao.ishikawa.jp", "nomi.ishikawa.jp", "nonoichi.ishikawa.jp", "noto.ishikawa.jp", "shika.ishikawa.jp", "suzu.ishikawa.jp", "tsubata.ishikawa.jp", "tsurugi.ishikawa.jp", "uchinada.ishikawa.jp", "wajima.ishikawa.jp", "fudai.iwate.jp", "fujisawa.iwate.jp", "hanamaki.iwate.jp", "hiraizumi.iwate.jp", "hirono.iwate.jp", "ichinohe.iwate.jp", "ichinoseki.iwate.jp", "iwaizumi.iwate.jp", "iwate.iwate.jp", "joboji.iwate.jp", "kamaishi.iwate.jp", "kanegasaki.iwate.jp", "karumai.iwate.jp", "kawai.iwate.jp", "kitakami.iwate.jp", "kuji.iwate.jp", "kunohe.iwate.jp", "kuzumaki.iwate.jp", "miyako.iwate.jp", "mizusawa.iwate.jp", "morioka.iwate.jp", "ninohe.iwate.jp", "noda.iwate.jp", "ofunato.iwate.jp", "oshu.iwate.jp", "otsuchi.iwate.jp", "rikuzentakata.iwate.jp", "shiwa.iwate.jp", "shizukuishi.iwate.jp", "sumita.iwate.jp", "tanohata.iwate.jp", "tono.iwate.jp", "yahaba.iwate.jp", "yamada.iwate.jp", "ayagawa.kagawa.jp", "higashikagawa.kagawa.jp", "kanonji.kagawa.jp", "kotohira.kagawa.jp", "manno.kagawa.jp", "marugame.kagawa.jp", "mitoyo.kagawa.jp", "naoshima.kagawa.jp", "sanuki.kagawa.jp", "tadotsu.kagawa.jp", "takamatsu.kagawa.jp", "tonosho.kagawa.jp", "uchinomi.kagawa.jp", "utazu.kagawa.jp", "zentsuji.kagawa.jp", "akune.kagoshima.jp", "amami.kagoshima.jp", "hioki.kagoshima.jp", "isa.kagoshima.jp", "isen.kagoshima.jp", "izumi.kagoshima.jp", "kagoshima.kagoshima.jp", "kanoya.kagoshima.jp", "kawanabe.kagoshima.jp", "kinko.kagoshima.jp", "kouyama.kagoshima.jp", "makurazaki.kagoshima.jp", "matsumoto.kagoshima.jp", "minamitane.kagoshima.jp", "nakatane.kagoshima.jp", "nishinoomote.kagoshima.jp", "satsumasendai.kagoshima.jp", "soo.kagoshima.jp", "tarumizu.kagoshima.jp", "yusui.kagoshima.jp", "aikawa.kanagawa.jp", "atsugi.kanagawa.jp", "ayase.kanagawa.jp", "chigasaki.kanagawa.jp", "ebina.kanagawa.jp", "fujisawa.kanagawa.jp", "hadano.kanagawa.jp", "hakone.kanagawa.jp", "hiratsuka.kanagawa.jp", "isehara.kanagawa.jp", "kaisei.kanagawa.jp", "kamakura.kanagawa.jp", "kiyokawa.kanagawa.jp", "matsuda.kanagawa.jp", "minamiashigara.kanagawa.jp", "miura.kanagawa.jp", "nakai.kanagawa.jp", "ninomiya.kanagawa.jp", "odawara.kanagawa.jp", "oi.kanagawa.jp", "oiso.kanagawa.jp", "sagamihara.kanagawa.jp", "samukawa.kanagawa.jp", "tsukui.kanagawa.jp", "yamakita.kanagawa.jp", "yamato.kanagawa.jp", "yokosuka.kanagawa.jp", "yugawara.kanagawa.jp", "zama.kanagawa.jp", "zushi.kanagawa.jp", "aki.kochi.jp", "geisei.kochi.jp", "hidaka.kochi.jp", "higashitsuno.kochi.jp", "ino.kochi.jp", "kagami.kochi.jp", "kami.kochi.jp", "kitagawa.kochi.jp", "kochi.kochi.jp", "mihara.kochi.jp", "motoyama.kochi.jp", "muroto.kochi.jp", "nahari.kochi.jp", "nakamura.kochi.jp", "nankoku.kochi.jp", "nishitosa.kochi.jp", "niyodogawa.kochi.jp", "ochi.kochi.jp", "okawa.kochi.jp", "otoyo.kochi.jp", "otsuki.kochi.jp", "sakawa.kochi.jp", "sukumo.kochi.jp", "susaki.kochi.jp", "tosa.kochi.jp", "tosashimizu.kochi.jp", "toyo.kochi.jp", "tsuno.kochi.jp", "umaji.kochi.jp", "yasuda.kochi.jp", "yusuhara.kochi.jp", "amakusa.kumamoto.jp", "arao.kumamoto.jp", "aso.kumamoto.jp", "choyo.kumamoto.jp", "gyokuto.kumamoto.jp", "kamiamakusa.kumamoto.jp", "kikuchi.kumamoto.jp", "kumamoto.kumamoto.jp", "mashiki.kumamoto.jp", "mifune.kumamoto.jp", "minamata.kumamoto.jp", "minamioguni.kumamoto.jp", "nagasu.kumamoto.jp", "nishihara.kumamoto.jp", "oguni.kumamoto.jp", "ozu.kumamoto.jp", "sumoto.kumamoto.jp", "takamori.kumamoto.jp", "uki.kumamoto.jp", "uto.kumamoto.jp", "yamaga.kumamoto.jp", "yamato.kumamoto.jp", "yatsushiro.kumamoto.jp", "ayabe.kyoto.jp", "fukuchiyama.kyoto.jp", "higashiyama.kyoto.jp", "ide.kyoto.jp", "ine.kyoto.jp", "joyo.kyoto.jp", "kameoka.kyoto.jp", "kamo.kyoto.jp", "kita.kyoto.jp", "kizu.kyoto.jp", "kumiyama.kyoto.jp", "kyotamba.kyoto.jp", "kyotanabe.kyoto.jp", "kyotango.kyoto.jp", "maizuru.kyoto.jp", "minami.kyoto.jp", "minamiyamashiro.kyoto.jp", "miyazu.kyoto.jp", "muko.kyoto.jp", "nagaokakyo.kyoto.jp", "nakagyo.kyoto.jp", "nantan.kyoto.jp", "oyamazaki.kyoto.jp", "sakyo.kyoto.jp", "seika.kyoto.jp", "tanabe.kyoto.jp", "uji.kyoto.jp", "ujitawara.kyoto.jp", "wazuka.kyoto.jp", "yamashina.kyoto.jp", "yawata.kyoto.jp", "asahi.mie.jp", "inabe.mie.jp", "ise.mie.jp", "kameyama.mie.jp", "kawagoe.mie.jp", "kiho.mie.jp", "kisosaki.mie.jp", "kiwa.mie.jp", "komono.mie.jp", "kumano.mie.jp", "kuwana.mie.jp", "matsusaka.mie.jp", "meiwa.mie.jp", "mihama.mie.jp", "minamiise.mie.jp", "misugi.mie.jp", "miyama.mie.jp", "nabari.mie.jp", "shima.mie.jp", "suzuka.mie.jp", "tado.mie.jp", "taiki.mie.jp", "taki.mie.jp", "tamaki.mie.jp", "toba.mie.jp", "tsu.mie.jp", "udono.mie.jp", "ureshino.mie.jp", "watarai.mie.jp", "yokkaichi.mie.jp", "furukawa.miyagi.jp", "higashimatsushima.miyagi.jp", "ishinomaki.miyagi.jp", "iwanuma.miyagi.jp", "kakuda.miyagi.jp", "kami.miyagi.jp", "kawasaki.miyagi.jp", "marumori.miyagi.jp", "matsushima.miyagi.jp", "minamisanriku.miyagi.jp", "misato.miyagi.jp", "murata.miyagi.jp", "natori.miyagi.jp", "ogawara.miyagi.jp", "ohira.miyagi.jp", "onagawa.miyagi.jp", "osaki.miyagi.jp", "rifu.miyagi.jp", "semine.miyagi.jp", "shibata.miyagi.jp", "shichikashuku.miyagi.jp", "shikama.miyagi.jp", "shiogama.miyagi.jp", "shiroishi.miyagi.jp", "tagajo.miyagi.jp", "taiwa.miyagi.jp", "tome.miyagi.jp", "tomiya.miyagi.jp", "wakuya.miyagi.jp", "watari.miyagi.jp", "yamamoto.miyagi.jp", "zao.miyagi.jp", "aya.miyazaki.jp", "ebino.miyazaki.jp", "gokase.miyazaki.jp", "hyuga.miyazaki.jp", "kadogawa.miyazaki.jp", "kawaminami.miyazaki.jp", "kijo.miyazaki.jp", "kitagawa.miyazaki.jp", "kitakata.miyazaki.jp", "kitaura.miyazaki.jp", "kobayashi.miyazaki.jp", "kunitomi.miyazaki.jp", "kushima.miyazaki.jp", "mimata.miyazaki.jp", "miyakonojo.miyazaki.jp", "miyazaki.miyazaki.jp", "morotsuka.miyazaki.jp", "nichinan.miyazaki.jp", "nishimera.miyazaki.jp", "nobeoka.miyazaki.jp", "saito.miyazaki.jp", "shiiba.miyazaki.jp", "shintomi.miyazaki.jp", "takaharu.miyazaki.jp", "takanabe.miyazaki.jp", "takazaki.miyazaki.jp", "tsuno.miyazaki.jp", "achi.nagano.jp", "agematsu.nagano.jp", "anan.nagano.jp", "aoki.nagano.jp", "asahi.nagano.jp", "azumino.nagano.jp", "chikuhoku.nagano.jp", "chikuma.nagano.jp", "chino.nagano.jp", "fujimi.nagano.jp", "hakuba.nagano.jp", "hara.nagano.jp", "hiraya.nagano.jp", "iida.nagano.jp", "iijima.nagano.jp", "iiyama.nagano.jp", "iizuna.nagano.jp", "ikeda.nagano.jp", "ikusaka.nagano.jp", "ina.nagano.jp", "karuizawa.nagano.jp", "kawakami.nagano.jp", "kiso.nagano.jp", "kisofukushima.nagano.jp", "kitaaiki.nagano.jp", "komagane.nagano.jp", "komoro.nagano.jp", "matsukawa.nagano.jp", "matsumoto.nagano.jp", "miasa.nagano.jp", "minamiaiki.nagano.jp", "minamimaki.nagano.jp", "minamiminowa.nagano.jp", "minowa.nagano.jp", "miyada.nagano.jp", "miyota.nagano.jp", "mochizuki.nagano.jp", "nagano.nagano.jp", "nagawa.nagano.jp", "nagiso.nagano.jp", "nakagawa.nagano.jp", "nakano.nagano.jp", "nozawaonsen.nagano.jp", "obuse.nagano.jp", "ogawa.nagano.jp", "okaya.nagano.jp", "omachi.nagano.jp", "omi.nagano.jp", "ookuwa.nagano.jp", "ooshika.nagano.jp", "otaki.nagano.jp", "otari.nagano.jp", "sakae.nagano.jp", "sakaki.nagano.jp", "saku.nagano.jp", "sakuho.nagano.jp", "shimosuwa.nagano.jp", "shinanomachi.nagano.jp", "shiojiri.nagano.jp", "suwa.nagano.jp", "suzaka.nagano.jp", "takagi.nagano.jp", "takamori.nagano.jp", "takayama.nagano.jp", "tateshina.nagano.jp", "tatsuno.nagano.jp", "togakushi.nagano.jp", "togura.nagano.jp", "tomi.nagano.jp", "ueda.nagano.jp", "wada.nagano.jp", "yamagata.nagano.jp", "yamanouchi.nagano.jp", "yasaka.nagano.jp", "yasuoka.nagano.jp", "chijiwa.nagasaki.jp", "futsu.nagasaki.jp", "goto.nagasaki.jp", "hasami.nagasaki.jp", "hirado.nagasaki.jp", "iki.nagasaki.jp", "isahaya.nagasaki.jp", "kawatana.nagasaki.jp", "kuchinotsu.nagasaki.jp", "matsuura.nagasaki.jp", "nagasaki.nagasaki.jp", "obama.nagasaki.jp", "omura.nagasaki.jp", "oseto.nagasaki.jp", "saikai.nagasaki.jp", "sasebo.nagasaki.jp", "seihi.nagasaki.jp", "shimabara.nagasaki.jp", "shinkamigoto.nagasaki.jp", "togitsu.nagasaki.jp", "tsushima.nagasaki.jp", "unzen.nagasaki.jp", "ando.nara.jp", "gose.nara.jp", "heguri.nara.jp", "higashiyoshino.nara.jp", "ikaruga.nara.jp", "ikoma.nara.jp", "kamikitayama.nara.jp", "kanmaki.nara.jp", "kashiba.nara.jp", "kashihara.nara.jp", "katsuragi.nara.jp", "kawai.nara.jp", "kawakami.nara.jp", "kawanishi.nara.jp", "koryo.nara.jp", "kurotaki.nara.jp", "mitsue.nara.jp", "miyake.nara.jp", "nara.nara.jp", "nosegawa.nara.jp", "oji.nara.jp", "ouda.nara.jp", "oyodo.nara.jp", "sakurai.nara.jp", "sango.nara.jp", "shimoichi.nara.jp", "shimokitayama.nara.jp", "shinjo.nara.jp", "soni.nara.jp", "takatori.nara.jp", "tawaramoto.nara.jp", "tenkawa.nara.jp", "tenri.nara.jp", "uda.nara.jp", "yamatokoriyama.nara.jp", "yamatotakada.nara.jp", "yamazoe.nara.jp", "yoshino.nara.jp", "aga.niigata.jp", "agano.niigata.jp", "gosen.niigata.jp", "itoigawa.niigata.jp", "izumozaki.niigata.jp", "joetsu.niigata.jp", "kamo.niigata.jp", "kariwa.niigata.jp", "kashiwazaki.niigata.jp", "minamiuonuma.niigata.jp", "mitsuke.niigata.jp", "muika.niigata.jp", "murakami.niigata.jp", "myoko.niigata.jp", "nagaoka.niigata.jp", "niigata.niigata.jp", "ojiya.niigata.jp", "omi.niigata.jp", "sado.niigata.jp", "sanjo.niigata.jp", "seiro.niigata.jp", "seirou.niigata.jp", "sekikawa.niigata.jp", "shibata.niigata.jp", "tagami.niigata.jp", "tainai.niigata.jp", "tochio.niigata.jp", "tokamachi.niigata.jp", "tsubame.niigata.jp", "tsunan.niigata.jp", "uonuma.niigata.jp", "yahiko.niigata.jp", "yoita.niigata.jp", "yuzawa.niigata.jp", "beppu.oita.jp", "bungoono.oita.jp", "bungotakada.oita.jp", "hasama.oita.jp", "hiji.oita.jp", "himeshima.oita.jp", "hita.oita.jp", "kamitsue.oita.jp", "kokonoe.oita.jp", "kuju.oita.jp", "kunisaki.oita.jp", "kusu.oita.jp", "oita.oita.jp", "saiki.oita.jp", "taketa.oita.jp", "tsukumi.oita.jp", "usa.oita.jp", "usuki.oita.jp", "yufu.oita.jp", "akaiwa.okayama.jp", "asakuchi.okayama.jp", "bizen.okayama.jp", "hayashima.okayama.jp", "ibara.okayama.jp", "kagamino.okayama.jp", "kasaoka.okayama.jp", "kibichuo.okayama.jp", "kumenan.okayama.jp", "kurashiki.okayama.jp", "maniwa.okayama.jp", "misaki.okayama.jp", "nagi.okayama.jp", "niimi.okayama.jp", "nishiawakura.okayama.jp", "okayama.okayama.jp", "satosho.okayama.jp", "setouchi.okayama.jp", "shinjo.okayama.jp", "shoo.okayama.jp", "soja.okayama.jp", "takahashi.okayama.jp", "tamano.okayama.jp", "tsuyama.okayama.jp", "wake.okayama.jp", "yakage.okayama.jp", "aguni.okinawa.jp", "ginowan.okinawa.jp", "ginoza.okinawa.jp", "gushikami.okinawa.jp", "haebaru.okinawa.jp", "higashi.okinawa.jp", "hirara.okinawa.jp", "iheya.okinawa.jp", "ishigaki.okinawa.jp", "ishikawa.okinawa.jp", "itoman.okinawa.jp", "izena.okinawa.jp", "kadena.okinawa.jp", "kin.okinawa.jp", "kitadaito.okinawa.jp", "kitanakagusuku.okinawa.jp", "kumejima.okinawa.jp", "kunigami.okinawa.jp", "minamidaito.okinawa.jp", "motobu.okinawa.jp", "nago.okinawa.jp", "naha.okinawa.jp", "nakagusuku.okinawa.jp", "nakijin.okinawa.jp", "nanjo.okinawa.jp", "nishihara.okinawa.jp", "ogimi.okinawa.jp", "okinawa.okinawa.jp", "onna.okinawa.jp", "shimoji.okinawa.jp", "taketomi.okinawa.jp", "tarama.okinawa.jp", "tokashiki.okinawa.jp", "tomigusuku.okinawa.jp", "tonaki.okinawa.jp", "urasoe.okinawa.jp", "uruma.okinawa.jp", "yaese.okinawa.jp", "yomitan.okinawa.jp", "yonabaru.okinawa.jp", "yonaguni.okinawa.jp", "zamami.okinawa.jp", "abeno.osaka.jp", "chihayaakasaka.osaka.jp", "chuo.osaka.jp", "daito.osaka.jp", "fujiidera.osaka.jp", "habikino.osaka.jp", "hannan.osaka.jp", "higashiosaka.osaka.jp", "higashisumiyoshi.osaka.jp", "higashiyodogawa.osaka.jp", "hirakata.osaka.jp", "ibaraki.osaka.jp", "ikeda.osaka.jp", "izumi.osaka.jp", "izumiotsu.osaka.jp", "izumisano.osaka.jp", "kadoma.osaka.jp", "kaizuka.osaka.jp", "kanan.osaka.jp", "kashiwara.osaka.jp", "katano.osaka.jp", "kawachinagano.osaka.jp", "kishiwada.osaka.jp", "kita.osaka.jp", "kumatori.osaka.jp", "matsubara.osaka.jp", "minato.osaka.jp", "minoh.osaka.jp", "misaki.osaka.jp", "moriguchi.osaka.jp", "neyagawa.osaka.jp", "nishi.osaka.jp", "nose.osaka.jp", "osakasayama.osaka.jp", "sakai.osaka.jp", "sayama.osaka.jp", "sennan.osaka.jp", "settsu.osaka.jp", "shijonawate.osaka.jp", "shimamoto.osaka.jp", "suita.osaka.jp", "tadaoka.osaka.jp", "taishi.osaka.jp", "tajiri.osaka.jp", "takaishi.osaka.jp", "takatsuki.osaka.jp", "tondabayashi.osaka.jp", "toyonaka.osaka.jp", "toyono.osaka.jp", "yao.osaka.jp", "ariake.saga.jp", "arita.saga.jp", "fukudomi.saga.jp", "genkai.saga.jp", "hamatama.saga.jp", "hizen.saga.jp", "imari.saga.jp", "kamimine.saga.jp", "kanzaki.saga.jp", "karatsu.saga.jp", "kashima.saga.jp", "kitagata.saga.jp", "kitahata.saga.jp", "kiyama.saga.jp", "kouhoku.saga.jp", "kyuragi.saga.jp", "nishiarita.saga.jp", "ogi.saga.jp", "omachi.saga.jp", "ouchi.saga.jp", "saga.saga.jp", "shiroishi.saga.jp", "taku.saga.jp", "tara.saga.jp", "tosu.saga.jp", "yoshinogari.saga.jp", "arakawa.saitama.jp", "asaka.saitama.jp", "chichibu.saitama.jp", "fujimi.saitama.jp", "fujimino.saitama.jp", "fukaya.saitama.jp", "hanno.saitama.jp", "hanyu.saitama.jp", "hasuda.saitama.jp", "hatogaya.saitama.jp", "hatoyama.saitama.jp", "hidaka.saitama.jp", "higashichichibu.saitama.jp", "higashimatsuyama.saitama.jp", "honjo.saitama.jp", "ina.saitama.jp", "iruma.saitama.jp", "iwatsuki.saitama.jp", "kamiizumi.saitama.jp", "kamikawa.saitama.jp", "kamisato.saitama.jp", "kasukabe.saitama.jp", "kawagoe.saitama.jp", "kawaguchi.saitama.jp", "kawajima.saitama.jp", "kazo.saitama.jp", "kitamoto.saitama.jp", "koshigaya.saitama.jp", "kounosu.saitama.jp", "kuki.saitama.jp", "kumagaya.saitama.jp", "matsubushi.saitama.jp", "minano.saitama.jp", "misato.saitama.jp", "miyashiro.saitama.jp", "miyoshi.saitama.jp", "moroyama.saitama.jp", "nagatoro.saitama.jp", "namegawa.saitama.jp", "niiza.saitama.jp", "ogano.saitama.jp", "ogawa.saitama.jp", "ogose.saitama.jp", "okegawa.saitama.jp", "omiya.saitama.jp", "otaki.saitama.jp", "ranzan.saitama.jp", "ryokami.saitama.jp", "saitama.saitama.jp", "sakado.saitama.jp", "satte.saitama.jp", "sayama.saitama.jp", "shiki.saitama.jp", "shiraoka.saitama.jp", "soka.saitama.jp", "sugito.saitama.jp", "toda.saitama.jp", "tokigawa.saitama.jp", "tokorozawa.saitama.jp", "tsurugashima.saitama.jp", "urawa.saitama.jp", "warabi.saitama.jp", "yashio.saitama.jp", "yokoze.saitama.jp", "yono.saitama.jp", "yorii.saitama.jp", "yoshida.saitama.jp", "yoshikawa.saitama.jp", "yoshimi.saitama.jp", "aisho.shiga.jp", "gamo.shiga.jp", "higashiomi.shiga.jp", "hikone.shiga.jp", "koka.shiga.jp", "konan.shiga.jp", "kosei.shiga.jp", "koto.shiga.jp", "kusatsu.shiga.jp", "maibara.shiga.jp", "moriyama.shiga.jp", "nagahama.shiga.jp", "nishiazai.shiga.jp", "notogawa.shiga.jp", "omihachiman.shiga.jp", "otsu.shiga.jp", "ritto.shiga.jp", "ryuoh.shiga.jp", "takashima.shiga.jp", "takatsuki.shiga.jp", "torahime.shiga.jp", "toyosato.shiga.jp", "yasu.shiga.jp", "akagi.shimane.jp", "ama.shimane.jp", "gotsu.shimane.jp", "hamada.shimane.jp", "higashiizumo.shimane.jp", "hikawa.shimane.jp", "hikimi.shimane.jp", "izumo.shimane.jp", "kakinoki.shimane.jp", "masuda.shimane.jp", "matsue.shimane.jp", "misato.shimane.jp", "nishinoshima.shimane.jp", "ohda.shimane.jp", "okinoshima.shimane.jp", "okuizumo.shimane.jp", "shimane.shimane.jp", "tamayu.shimane.jp", "tsuwano.shimane.jp", "unnan.shimane.jp", "yakumo.shimane.jp", "yasugi.shimane.jp", "yatsuka.shimane.jp", "arai.shizuoka.jp", "atami.shizuoka.jp", "fuji.shizuoka.jp", "fujieda.shizuoka.jp", "fujikawa.shizuoka.jp", "fujinomiya.shizuoka.jp", "fukuroi.shizuoka.jp", "gotemba.shizuoka.jp", "haibara.shizuoka.jp", "hamamatsu.shizuoka.jp", "higashiizu.shizuoka.jp", "ito.shizuoka.jp", "iwata.shizuoka.jp", "izu.shizuoka.jp", "izunokuni.shizuoka.jp", "kakegawa.shizuoka.jp", "kannami.shizuoka.jp", "kawanehon.shizuoka.jp", "kawazu.shizuoka.jp", "kikugawa.shizuoka.jp", "kosai.shizuoka.jp", "makinohara.shizuoka.jp", "matsuzaki.shizuoka.jp", "minamiizu.shizuoka.jp", "mishima.shizuoka.jp", "morimachi.shizuoka.jp", "nishiizu.shizuoka.jp", "numazu.shizuoka.jp", "omaezaki.shizuoka.jp", "shimada.shizuoka.jp", "shimizu.shizuoka.jp", "shimoda.shizuoka.jp", "shizuoka.shizuoka.jp", "susono.shizuoka.jp", "yaizu.shizuoka.jp", "yoshida.shizuoka.jp", "ashikaga.tochigi.jp", "bato.tochigi.jp", "haga.tochigi.jp", "ichikai.tochigi.jp", "iwafune.tochigi.jp", "kaminokawa.tochigi.jp", "kanuma.tochigi.jp", "karasuyama.tochigi.jp", "kuroiso.tochigi.jp", "mashiko.tochigi.jp", "mibu.tochigi.jp", "moka.tochigi.jp", "motegi.tochigi.jp", "nasu.tochigi.jp", "nasushiobara.tochigi.jp", "nikko.tochigi.jp", "nishikata.tochigi.jp", "nogi.tochigi.jp", "ohira.tochigi.jp", "ohtawara.tochigi.jp", "oyama.tochigi.jp", "sakura.tochigi.jp", "sano.tochigi.jp", "shimotsuke.tochigi.jp", "shioya.tochigi.jp", "takanezawa.tochigi.jp", "tochigi.tochigi.jp", "tsuga.tochigi.jp", "ujiie.tochigi.jp", "utsunomiya.tochigi.jp", "yaita.tochigi.jp", "aizumi.tokushima.jp", "anan.tokushima.jp", "ichiba.tokushima.jp", "itano.tokushima.jp", "kainan.tokushima.jp", "komatsushima.tokushima.jp", "matsushige.tokushima.jp", "mima.tokushima.jp", "minami.tokushima.jp", "miyoshi.tokushima.jp", "mugi.tokushima.jp", "nakagawa.tokushima.jp", "naruto.tokushima.jp", "sanagochi.tokushima.jp", "shishikui.tokushima.jp", "tokushima.tokushima.jp", "wajiki.tokushima.jp", "adachi.tokyo.jp", "akiruno.tokyo.jp", "akishima.tokyo.jp", "aogashima.tokyo.jp", "arakawa.tokyo.jp", "bunkyo.tokyo.jp", "chiyoda.tokyo.jp", "chofu.tokyo.jp", "chuo.tokyo.jp", "edogawa.tokyo.jp", "fuchu.tokyo.jp", "fussa.tokyo.jp", "hachijo.tokyo.jp", "hachioji.tokyo.jp", "hamura.tokyo.jp", "higashikurume.tokyo.jp", "higashimurayama.tokyo.jp", "higashiyamato.tokyo.jp", "hino.tokyo.jp", "hinode.tokyo.jp", "hinohara.tokyo.jp", "inagi.tokyo.jp", "itabashi.tokyo.jp", "katsushika.tokyo.jp", "kita.tokyo.jp", "kiyose.tokyo.jp", "kodaira.tokyo.jp", "koganei.tokyo.jp", "kokubunji.tokyo.jp", "komae.tokyo.jp", "koto.tokyo.jp", "kouzushima.tokyo.jp", "kunitachi.tokyo.jp", "machida.tokyo.jp", "meguro.tokyo.jp", "minato.tokyo.jp", "mitaka.tokyo.jp", "mizuho.tokyo.jp", "musashimurayama.tokyo.jp", "musashino.tokyo.jp", "nakano.tokyo.jp", "nerima.tokyo.jp", "ogasawara.tokyo.jp", "okutama.tokyo.jp", "ome.tokyo.jp", "oshima.tokyo.jp", "ota.tokyo.jp", "setagaya.tokyo.jp", "shibuya.tokyo.jp", "shinagawa.tokyo.jp", "shinjuku.tokyo.jp", "suginami.tokyo.jp", "sumida.tokyo.jp", "tachikawa.tokyo.jp", "taito.tokyo.jp", "tama.tokyo.jp", "toshima.tokyo.jp", "chizu.tottori.jp", "hino.tottori.jp", "kawahara.tottori.jp", "koge.tottori.jp", "kotoura.tottori.jp", "misasa.tottori.jp", "nanbu.tottori.jp", "nichinan.tottori.jp", "sakaiminato.tottori.jp", "tottori.tottori.jp", "wakasa.tottori.jp", "yazu.tottori.jp", "yonago.tottori.jp", "asahi.toyama.jp", "fuchu.toyama.jp", "fukumitsu.toyama.jp", "funahashi.toyama.jp", "himi.toyama.jp", "imizu.toyama.jp", "inami.toyama.jp", "johana.toyama.jp", "kamiichi.toyama.jp", "kurobe.toyama.jp", "nakaniikawa.toyama.jp", "namerikawa.toyama.jp", "nanto.toyama.jp", "nyuzen.toyama.jp", "oyabe.toyama.jp", "taira.toyama.jp", "takaoka.toyama.jp", "tateyama.toyama.jp", "toga.toyama.jp", "tonami.toyama.jp", "toyama.toyama.jp", "unazuki.toyama.jp", "uozu.toyama.jp", "yamada.toyama.jp", "arida.wakayama.jp", "aridagawa.wakayama.jp", "gobo.wakayama.jp", "hashimoto.wakayama.jp", "hidaka.wakayama.jp", "hirogawa.wakayama.jp", "inami.wakayama.jp", "iwade.wakayama.jp", "kainan.wakayama.jp", "kamitonda.wakayama.jp", "katsuragi.wakayama.jp", "kimino.wakayama.jp", "kinokawa.wakayama.jp", "kitayama.wakayama.jp", "koya.wakayama.jp", "koza.wakayama.jp", "kozagawa.wakayama.jp", "kudoyama.wakayama.jp", "kushimoto.wakayama.jp", "mihama.wakayama.jp", "misato.wakayama.jp", "nachikatsuura.wakayama.jp", "shingu.wakayama.jp", "shirahama.wakayama.jp", "taiji.wakayama.jp", "tanabe.wakayama.jp", "wakayama.wakayama.jp", "yuasa.wakayama.jp", "yura.wakayama.jp", "asahi.yamagata.jp", "funagata.yamagata.jp", "higashine.yamagata.jp", "iide.yamagata.jp", "kahoku.yamagata.jp", "kaminoyama.yamagata.jp", "kaneyama.yamagata.jp", "kawanishi.yamagata.jp", "mamurogawa.yamagata.jp", "mikawa.yamagata.jp", "murayama.yamagata.jp", "nagai.yamagata.jp", "nakayama.yamagata.jp", "nanyo.yamagata.jp", "nishikawa.yamagata.jp", "obanazawa.yamagata.jp", "oe.yamagata.jp", "oguni.yamagata.jp", "ohkura.yamagata.jp", "oishida.yamagata.jp", "sagae.yamagata.jp", "sakata.yamagata.jp", "sakegawa.yamagata.jp", "shinjo.yamagata.jp", "shirataka.yamagata.jp", "shonai.yamagata.jp", "takahata.yamagata.jp", "tendo.yamagata.jp", "tozawa.yamagata.jp", "tsuruoka.yamagata.jp", "yamagata.yamagata.jp", "yamanobe.yamagata.jp", "yonezawa.yamagata.jp", "yuza.yamagata.jp", "abu.yamaguchi.jp", "hagi.yamaguchi.jp", "hikari.yamaguchi.jp", "hofu.yamaguchi.jp", "iwakuni.yamaguchi.jp", "kudamatsu.yamaguchi.jp", "mitou.yamaguchi.jp", "nagato.yamaguchi.jp", "oshima.yamaguchi.jp", "shimonoseki.yamaguchi.jp", "shunan.yamaguchi.jp", "tabuse.yamaguchi.jp", "tokuyama.yamaguchi.jp", "toyota.yamaguchi.jp", "ube.yamaguchi.jp", "yuu.yamaguchi.jp", "chuo.yamanashi.jp", "doshi.yamanashi.jp", "fuefuki.yamanashi.jp", "fujikawa.yamanashi.jp", "fujikawaguchiko.yamanashi.jp", "fujiyoshida.yamanashi.jp", "hayakawa.yamanashi.jp", "hokuto.yamanashi.jp", "ichikawamisato.yamanashi.jp", "kai.yamanashi.jp", "kofu.yamanashi.jp", "koshu.yamanashi.jp", "kosuge.yamanashi.jp", "minami-alps.yamanashi.jp", "minobu.yamanashi.jp", "nakamichi.yamanashi.jp", "nanbu.yamanashi.jp", "narusawa.yamanashi.jp", "nirasaki.yamanashi.jp", "nishikatsura.yamanashi.jp", "oshino.yamanashi.jp", "otsuki.yamanashi.jp", "showa.yamanashi.jp", "tabayama.yamanashi.jp", "tsuru.yamanashi.jp", "uenohara.yamanashi.jp", "yamanakako.yamanashi.jp", "yamanashi.yamanashi.jp", "ke", "ac.ke", "co.ke", "go.ke", "info.ke", "me.ke", "mobi.ke", "ne.ke", "or.ke", "sc.ke", "kg", "com.kg", "edu.kg", "gov.kg", "mil.kg", "net.kg", "org.kg", "*.kh", "ki", "biz.ki", "com.ki", "edu.ki", "gov.ki", "info.ki", "net.ki", "org.ki", "km", "ass.km", "com.km", "edu.km", "gov.km", "mil.km", "nom.km", "org.km", "prd.km", "tm.km", "asso.km", "coop.km", "gouv.km", "medecin.km", "notaires.km", "pharmaciens.km", "presse.km", "veterinaire.km", "kn", "edu.kn", "gov.kn", "net.kn", "org.kn", "kp", "com.kp", "edu.kp", "gov.kp", "org.kp", "rep.kp", "tra.kp", "kr", "ac.kr", "co.kr", "es.kr", "go.kr", "hs.kr", "kg.kr", "mil.kr", "ms.kr", "ne.kr", "or.kr", "pe.kr", "re.kr", "sc.kr", "busan.kr", "chungbuk.kr", "chungnam.kr", "daegu.kr", "daejeon.kr", "gangwon.kr", "gwangju.kr", "gyeongbuk.kr", "gyeonggi.kr", "gyeongnam.kr", "incheon.kr", "jeju.kr", "jeonbuk.kr", "jeonnam.kr", "seoul.kr", "ulsan.kr", "kw", "com.kw", "edu.kw", "emb.kw", "gov.kw", "ind.kw", "net.kw", "org.kw", "ky", "com.ky", "edu.ky", "net.ky", "org.ky", "kz", "com.kz", "edu.kz", "gov.kz", "mil.kz", "net.kz", "org.kz", "la", "com.la", "edu.la", "gov.la", "info.la", "int.la", "net.la", "org.la", "per.la", "lb", "com.lb", "edu.lb", "gov.lb", "net.lb", "org.lb", "lc", "co.lc", "com.lc", "edu.lc", "gov.lc", "net.lc", "org.lc", "li", "lk", "ac.lk", "assn.lk", "com.lk", "edu.lk", "gov.lk", "grp.lk", "hotel.lk", "int.lk", "ltd.lk", "net.lk", "ngo.lk", "org.lk", "sch.lk", "soc.lk", "web.lk", "lr", "com.lr", "edu.lr", "gov.lr", "net.lr", "org.lr", "ls", "ac.ls", "biz.ls", "co.ls", "edu.ls", "gov.ls", "info.ls", "net.ls", "org.ls", "sc.ls", "lt", "gov.lt", "lu", "lv", "asn.lv", "com.lv", "conf.lv", "edu.lv", "gov.lv", "id.lv", "mil.lv", "net.lv", "org.lv", "ly", "com.ly", "edu.ly", "gov.ly", "id.ly", "med.ly", "net.ly", "org.ly", "plc.ly", "sch.ly", "ma", "ac.ma", "co.ma", "gov.ma", "net.ma", "org.ma", "press.ma", "mc", "asso.mc", "tm.mc", "md", "me", "ac.me", "co.me", "edu.me", "gov.me", "its.me", "net.me", "org.me", "priv.me", "mg", "co.mg", "com.mg", "edu.mg", "gov.mg", "mil.mg", "nom.mg", "org.mg", "prd.mg", "mh", "mil", "mk", "com.mk", "edu.mk", "gov.mk", "inf.mk", "name.mk", "net.mk", "org.mk", "ml", "com.ml", "edu.ml", "gouv.ml", "gov.ml", "net.ml", "org.ml", "presse.ml", "*.mm", "mn", "edu.mn", "gov.mn", "org.mn", "mo", "com.mo", "edu.mo", "gov.mo", "net.mo", "org.mo", "mobi", "mp", "mq", "mr", "gov.mr", "ms", "com.ms", "edu.ms", "gov.ms", "net.ms", "org.ms", "mt", "com.mt", "edu.mt", "net.mt", "org.mt", "mu", "ac.mu", "co.mu", "com.mu", "gov.mu", "net.mu", "or.mu", "org.mu", "museum", "mv", "aero.mv", "biz.mv", "com.mv", "coop.mv", "edu.mv", "gov.mv", "info.mv", "int.mv", "mil.mv", "museum.mv", "name.mv", "net.mv", "org.mv", "pro.mv", "mw", "ac.mw", "biz.mw", "co.mw", "com.mw", "coop.mw", "edu.mw", "gov.mw", "int.mw", "net.mw", "org.mw", "mx", "com.mx", "edu.mx", "gob.mx", "net.mx", "org.mx", "my", "biz.my", "com.my", "edu.my", "gov.my", "mil.my", "name.my", "net.my", "org.my", "mz", "ac.mz", "adv.mz", "co.mz", "edu.mz", "gov.mz", "mil.mz", "net.mz", "org.mz", "na", "alt.na", "co.na", "com.na", "gov.na", "net.na", "org.na", "name", "nc", "asso.nc", "nom.nc", "ne", "net", "nf", "arts.nf", "com.nf", "firm.nf", "info.nf", "net.nf", "other.nf", "per.nf", "rec.nf", "store.nf", "web.nf", "ng", "com.ng", "edu.ng", "gov.ng", "i.ng", "mil.ng", "mobi.ng", "name.ng", "net.ng", "org.ng", "sch.ng", "ni", "ac.ni", "biz.ni", "co.ni", "com.ni", "edu.ni", "gob.ni", "in.ni", "info.ni", "int.ni", "mil.ni", "net.ni", "nom.ni", "org.ni", "web.ni", "nl", "no", "fhs.no", "folkebibl.no", "fylkesbibl.no", "idrett.no", "museum.no", "priv.no", "vgs.no", "dep.no", "herad.no", "kommune.no", "mil.no", "stat.no", "aa.no", "ah.no", "bu.no", "fm.no", "hl.no", "hm.no", "jan-mayen.no", "mr.no", "nl.no", "nt.no", "of.no", "ol.no", "oslo.no", "rl.no", "sf.no", "st.no", "svalbard.no", "tm.no", "tr.no", "va.no", "vf.no", "gs.aa.no", "gs.ah.no", "gs.bu.no", "gs.fm.no", "gs.hl.no", "gs.hm.no", "gs.jan-mayen.no", "gs.mr.no", "gs.nl.no", "gs.nt.no", "gs.of.no", "gs.ol.no", "gs.oslo.no", "gs.rl.no", "gs.sf.no", "gs.st.no", "gs.svalbard.no", "gs.tm.no", "gs.tr.no", "gs.va.no", "gs.vf.no", "akrehamn.no", "krehamn.no", "algard.no", "lgrd.no", "arna.no", "bronnoysund.no", "brnnysund.no", "brumunddal.no", "bryne.no", "drobak.no", "drbak.no", "egersund.no", "fetsund.no", "floro.no", "flor.no", "fredrikstad.no", "hokksund.no", "honefoss.no", "hnefoss.no", "jessheim.no", "jorpeland.no", "jrpeland.no", "kirkenes.no", "kopervik.no", "krokstadelva.no", "langevag.no", "langevg.no", "leirvik.no", "mjondalen.no", "mjndalen.no", "mo-i-rana.no", "mosjoen.no", "mosjen.no", "nesoddtangen.no", "orkanger.no", "osoyro.no", "osyro.no", "raholt.no", "rholt.no", "sandnessjoen.no", "sandnessjen.no", "skedsmokorset.no", "slattum.no", "spjelkavik.no", "stathelle.no", "stavern.no", "stjordalshalsen.no", "stjrdalshalsen.no", "tananger.no", "tranby.no", "vossevangen.no", "aarborte.no", "aejrie.no", "afjord.no", "fjord.no", "agdenes.no", "nes.akershus.no", "aknoluokta.no", "koluokta.no", "al.no", "l.no", "alaheadju.no", "laheadju.no", "alesund.no", "lesund.no", "alstahaug.no", "alta.no", "lt.no", "alvdal.no", "amli.no", "mli.no", "amot.no", "mot.no", "andasuolo.no", "andebu.no", "andoy.no", "andy.no", "ardal.no", "rdal.no", "aremark.no", "arendal.no", "s.no", "aseral.no", "seral.no", "asker.no", "askim.no", "askoy.no", "asky.no", "askvoll.no", "asnes.no", "snes.no", "audnedaln.no", "aukra.no", "aure.no", "aurland.no", "aurskog-holand.no", "aurskog-hland.no", "austevoll.no", "austrheim.no", "averoy.no", "avery.no", "badaddja.no", "bdddj.no", "brum.no", "bahcavuotna.no", "bhcavuotna.no", "bahccavuotna.no", "bhccavuotna.no", "baidar.no", "bidr.no", "bajddar.no", "bjddar.no", "balat.no", "blt.no", "balestrand.no", "ballangen.no", "balsfjord.no", "bamble.no", "bardu.no", "barum.no", "batsfjord.no", "btsfjord.no", "bearalvahki.no", "bearalvhki.no", "beardu.no", "beiarn.no", "berg.no", "bergen.no", "berlevag.no", "berlevg.no", "bievat.no", "bievt.no", "bindal.no", "birkenes.no", "bjarkoy.no", "bjarky.no", "bjerkreim.no", "bjugn.no", "bodo.no", "bod.no", "bokn.no", "bomlo.no", "bmlo.no", "bremanger.no", "bronnoy.no", "brnny.no", "budejju.no", "nes.buskerud.no", "bygland.no", "bykle.no", "cahcesuolo.no", "hcesuolo.no", "davvenjarga.no", "davvenjrga.no", "davvesiida.no", "deatnu.no", "dielddanuorri.no", "divtasvuodna.no", "divttasvuotna.no", "donna.no", "dnna.no", "dovre.no", "drammen.no", "drangedal.no", "dyroy.no", "dyry.no", "eid.no", "eidfjord.no", "eidsberg.no", "eidskog.no", "eidsvoll.no", "eigersund.no", "elverum.no", "enebakk.no", "engerdal.no", "etne.no", "etnedal.no", "evenassi.no", "eveni.no", "evenes.no", "evje-og-hornnes.no", "farsund.no", "fauske.no", "fedje.no", "fet.no", "finnoy.no", "finny.no", "fitjar.no", "fjaler.no", "fjell.no", "fla.no", "fl.no", "flakstad.no", "flatanger.no", "flekkefjord.no", "flesberg.no", "flora.no", "folldal.no", "forde.no", "frde.no", "forsand.no", "fosnes.no", "frna.no", "frana.no", "frei.no", "frogn.no", "froland.no", "frosta.no", "froya.no", "frya.no", "fuoisku.no", "fuossko.no", "fusa.no", "fyresdal.no", "gaivuotna.no", "givuotna.no", "galsa.no", "gls.no", "gamvik.no", "gangaviika.no", "ggaviika.no", "gaular.no", "gausdal.no", "giehtavuoatna.no", "gildeskal.no", "gildeskl.no", "giske.no", "gjemnes.no", "gjerdrum.no", "gjerstad.no", "gjesdal.no", "gjovik.no", "gjvik.no", "gloppen.no", "gol.no", "gran.no", "grane.no", "granvin.no", "gratangen.no", "grimstad.no", "grong.no", "grue.no", "gulen.no", "guovdageaidnu.no", "ha.no", "h.no", "habmer.no", "hbmer.no", "hadsel.no", "hgebostad.no", "hagebostad.no", "halden.no", "halsa.no", "hamar.no", "hamaroy.no", "hammarfeasta.no", "hmmrfeasta.no", "hammerfest.no", "hapmir.no", "hpmir.no", "haram.no", "hareid.no", "harstad.no", "hasvik.no", "hattfjelldal.no", "haugesund.no", "os.hedmark.no", "valer.hedmark.no", "vler.hedmark.no", "hemne.no", "hemnes.no", "hemsedal.no", "hitra.no", "hjartdal.no", "hjelmeland.no", "hobol.no", "hobl.no", "hof.no", "hol.no", "hole.no", "holmestrand.no", "holtalen.no", "holtlen.no", "os.hordaland.no", "hornindal.no", "horten.no", "hoyanger.no", "hyanger.no", "hoylandet.no", "hylandet.no", "hurdal.no", "hurum.no", "hvaler.no", "hyllestad.no", "ibestad.no", "inderoy.no", "indery.no", "iveland.no", "ivgu.no", "jevnaker.no", "jolster.no", "jlster.no", "jondal.no", "kafjord.no", "kfjord.no", "karasjohka.no", "krjohka.no", "karasjok.no", "karlsoy.no", "karmoy.no", "karmy.no", "kautokeino.no", "klabu.no", "klbu.no", "klepp.no", "kongsberg.no", "kongsvinger.no", "kraanghke.no", "kranghke.no", "kragero.no", "krager.no", "kristiansand.no", "kristiansund.no", "krodsherad.no", "krdsherad.no", "kvfjord.no", "kvnangen.no", "kvafjord.no", "kvalsund.no", "kvam.no", "kvanangen.no", "kvinesdal.no", "kvinnherad.no", "kviteseid.no", "kvitsoy.no", "kvitsy.no", "laakesvuemie.no", "lrdal.no", "lahppi.no", "lhppi.no", "lardal.no", "larvik.no", "lavagis.no", "lavangen.no", "leangaviika.no", "leagaviika.no", "lebesby.no", "leikanger.no", "leirfjord.no", "leka.no", "leksvik.no", "lenvik.no", "lerdal.no", "lesja.no", "levanger.no", "lier.no", "lierne.no", "lillehammer.no", "lillesand.no", "lindas.no", "linds.no", "lindesnes.no", "loabat.no", "loabt.no", "lodingen.no", "ldingen.no", "lom.no", "loppa.no", "lorenskog.no", "lrenskog.no", "loten.no", "lten.no", "lund.no", "lunner.no", "luroy.no", "lury.no", "luster.no", "lyngdal.no", "lyngen.no", "malatvuopmi.no", "mlatvuopmi.no", "malselv.no", "mlselv.no", "malvik.no", "mandal.no", "marker.no", "marnardal.no", "masfjorden.no", "masoy.no", "msy.no", "matta-varjjat.no", "mtta-vrjjat.no", "meland.no", "meldal.no", "melhus.no", "meloy.no", "mely.no", "meraker.no", "merker.no", "midsund.no", "midtre-gauldal.no", "moareke.no", "moreke.no", "modalen.no", "modum.no", "molde.no", "heroy.more-og-romsdal.no", "sande.more-og-romsdal.no", "hery.mre-og-romsdal.no", "sande.mre-og-romsdal.no", "moskenes.no", "moss.no", "mosvik.no", "muosat.no", "muost.no", "naamesjevuemie.no", "nmesjevuemie.no", "nry.no", "namdalseid.no", "namsos.no", "namsskogan.no", "nannestad.no", "naroy.no", "narviika.no", "narvik.no", "naustdal.no", "navuotna.no", "nvuotna.no", "nedre-eiker.no", "nesna.no", "nesodden.no", "nesseby.no", "nesset.no", "nissedal.no", "nittedal.no", "nord-aurdal.no", "nord-fron.no", "nord-odal.no", "norddal.no", "nordkapp.no", "bo.nordland.no", "b.nordland.no", "heroy.nordland.no", "hery.nordland.no", "nordre-land.no", "nordreisa.no", "nore-og-uvdal.no", "notodden.no", "notteroy.no", "nttery.no", "odda.no", "oksnes.no", "ksnes.no", "omasvuotna.no", "oppdal.no", "oppegard.no", "oppegrd.no", "orkdal.no", "orland.no", "rland.no", "orskog.no", "rskog.no", "orsta.no", "rsta.no", "osen.no", "osteroy.no", "ostery.no", "valer.ostfold.no", "vler.stfold.no", "ostre-toten.no", "stre-toten.no", "overhalla.no", "ovre-eiker.no", "vre-eiker.no", "oyer.no", "yer.no", "oygarden.no", "ygarden.no", "oystre-slidre.no", "ystre-slidre.no", "porsanger.no", "porsangu.no", "porsgu.no", "porsgrunn.no", "rade.no", "rde.no", "radoy.no", "rady.no", "rlingen.no", "rahkkeravju.no", "rhkkervju.no", "raisa.no", "risa.no", "rakkestad.no", "ralingen.no", "rana.no", "randaberg.no", "rauma.no", "rendalen.no", "rennebu.no", "rennesoy.no", "rennesy.no", "rindal.no", "ringebu.no", "ringerike.no", "ringsaker.no", "risor.no", "risr.no", "rissa.no", "roan.no", "rodoy.no", "rdy.no", "rollag.no", "romsa.no", "romskog.no", "rmskog.no", "roros.no", "rros.no", "rost.no", "rst.no", "royken.no", "ryken.no", "royrvik.no", "ryrvik.no", "ruovat.no", "rygge.no", "salangen.no", "salat.no", "slat.no", "slt.no", "saltdal.no", "samnanger.no", "sandefjord.no", "sandnes.no", "sandoy.no", "sandy.no", "sarpsborg.no", "sauda.no", "sauherad.no", "sel.no", "selbu.no", "selje.no", "seljord.no", "siellak.no", "sigdal.no", "siljan.no", "sirdal.no", "skanit.no", "sknit.no", "skanland.no", "sknland.no", "skaun.no", "skedsmo.no", "ski.no", "skien.no", "skierva.no", "skierv.no", "skiptvet.no", "skjak.no", "skjk.no", "skjervoy.no", "skjervy.no", "skodje.no", "smola.no", "smla.no", "snaase.no", "snase.no", "snasa.no", "snsa.no", "snillfjord.no", "snoasa.no", "sogndal.no", "sogne.no", "sgne.no", "sokndal.no", "sola.no", "solund.no", "somna.no", "smna.no", "sondre-land.no", "sndre-land.no", "songdalen.no", "sor-aurdal.no", "sr-aurdal.no", "sor-fron.no", "sr-fron.no", "sor-odal.no", "sr-odal.no", "sor-varanger.no", "sr-varanger.no", "sorfold.no", "srfold.no", "sorreisa.no", "srreisa.no", "sortland.no", "sorum.no", "srum.no", "spydeberg.no", "stange.no", "stavanger.no", "steigen.no", "steinkjer.no", "stjordal.no", "stjrdal.no", "stokke.no", "stor-elvdal.no", "stord.no", "stordal.no", "storfjord.no", "strand.no", "stranda.no", "stryn.no", "sula.no", "suldal.no", "sund.no", "sunndal.no", "surnadal.no", "sveio.no", "svelvik.no", "sykkylven.no", "tana.no", "bo.telemark.no", "b.telemark.no", "time.no", "tingvoll.no", "tinn.no", "tjeldsund.no", "tjome.no", "tjme.no", "tokke.no", "tolga.no", "tonsberg.no", "tnsberg.no", "torsken.no", "trna.no", "trana.no", "tranoy.no", "trany.no", "troandin.no", "trogstad.no", "trgstad.no", "tromsa.no", "tromso.no", "troms.no", "trondheim.no", "trysil.no", "tvedestrand.no", "tydal.no", "tynset.no", "tysfjord.no", "tysnes.no", "tysvr.no", "tysvar.no", "ullensaker.no", "ullensvang.no", "ulvik.no", "unjarga.no", "unjrga.no", "utsira.no", "vaapste.no", "vadso.no", "vads.no", "vry.no", "vaga.no", "vg.no", "vagan.no", "vgan.no", "vagsoy.no", "vgsy.no", "vaksdal.no", "valle.no", "vang.no", "vanylven.no", "vardo.no", "vard.no", "varggat.no", "vrggt.no", "varoy.no", "vefsn.no", "vega.no", "vegarshei.no", "vegrshei.no", "vennesla.no", "verdal.no", "verran.no", "vestby.no", "sande.vestfold.no", "vestnes.no", "vestre-slidre.no", "vestre-toten.no", "vestvagoy.no", "vestvgy.no", "vevelstad.no", "vik.no", "vikna.no", "vindafjord.no", "voagat.no", "volda.no", "voss.no", "*.np", "nr", "biz.nr", "com.nr", "edu.nr", "gov.nr", "info.nr", "net.nr", "org.nr", "nu", "nz", "ac.nz", "co.nz", "cri.nz", "geek.nz", "gen.nz", "govt.nz", "health.nz", "iwi.nz", "kiwi.nz", "maori.nz", "mori.nz", "mil.nz", "net.nz", "org.nz", "parliament.nz", "school.nz", "om", "co.om", "com.om", "edu.om", "gov.om", "med.om", "museum.om", "net.om", "org.om", "pro.om", "onion", "org", "pa", "abo.pa", "ac.pa", "com.pa", "edu.pa", "gob.pa", "ing.pa", "med.pa", "net.pa", "nom.pa", "org.pa", "sld.pa", "pe", "com.pe", "edu.pe", "gob.pe", "mil.pe", "net.pe", "nom.pe", "org.pe", "pf", "com.pf", "edu.pf", "org.pf", "*.pg", "ph", "com.ph", "edu.ph", "gov.ph", "i.ph", "mil.ph", "net.ph", "ngo.ph", "org.ph", "pk", "ac.pk", "biz.pk", "com.pk", "edu.pk", "fam.pk", "gkp.pk", "gob.pk", "gog.pk", "gok.pk", "gon.pk", "gop.pk", "gos.pk", "gov.pk", "net.pk", "org.pk", "web.pk", "pl", "com.pl", "net.pl", "org.pl", "agro.pl", "aid.pl", "atm.pl", "auto.pl", "biz.pl", "edu.pl", "gmina.pl", "gsm.pl", "info.pl", "mail.pl", "media.pl", "miasta.pl", "mil.pl", "nieruchomosci.pl", "nom.pl", "pc.pl", "powiat.pl", "priv.pl", "realestate.pl", "rel.pl", "sex.pl", "shop.pl", "sklep.pl", "sos.pl", "szkola.pl", "targi.pl", "tm.pl", "tourism.pl", "travel.pl", "turystyka.pl", "gov.pl", "ap.gov.pl", "griw.gov.pl", "ic.gov.pl", "is.gov.pl", "kmpsp.gov.pl", "konsulat.gov.pl", "kppsp.gov.pl", "kwp.gov.pl", "kwpsp.gov.pl", "mup.gov.pl", "mw.gov.pl", "oia.gov.pl", "oirm.gov.pl", "oke.gov.pl", "oow.gov.pl", "oschr.gov.pl", "oum.gov.pl", "pa.gov.pl", "pinb.gov.pl", "piw.gov.pl", "po.gov.pl", "pr.gov.pl", "psp.gov.pl", "psse.gov.pl", "pup.gov.pl", "rzgw.gov.pl", "sa.gov.pl", "sdn.gov.pl", "sko.gov.pl", "so.gov.pl", "sr.gov.pl", "starostwo.gov.pl", "ug.gov.pl", "ugim.gov.pl", "um.gov.pl", "umig.gov.pl", "upow.gov.pl", "uppo.gov.pl", "us.gov.pl", "uw.gov.pl", "uzs.gov.pl", "wif.gov.pl", "wiih.gov.pl", "winb.gov.pl", "wios.gov.pl", "witd.gov.pl", "wiw.gov.pl", "wkz.gov.pl", "wsa.gov.pl", "wskr.gov.pl", "wsse.gov.pl", "wuoz.gov.pl", "wzmiuw.gov.pl", "zp.gov.pl", "zpisdn.gov.pl", "augustow.pl", "babia-gora.pl", "bedzin.pl", "beskidy.pl", "bialowieza.pl", "bialystok.pl", "bielawa.pl", "bieszczady.pl", "boleslawiec.pl", "bydgoszcz.pl", "bytom.pl", "cieszyn.pl", "czeladz.pl", "czest.pl", "dlugoleka.pl", "elblag.pl", "elk.pl", "glogow.pl", "gniezno.pl", "gorlice.pl", "grajewo.pl", "ilawa.pl", "jaworzno.pl", "jelenia-gora.pl", "jgora.pl", "kalisz.pl", "karpacz.pl", "kartuzy.pl", "kaszuby.pl", "katowice.pl", "kazimierz-dolny.pl", "kepno.pl", "ketrzyn.pl", "klodzko.pl", "kobierzyce.pl", "kolobrzeg.pl", "konin.pl", "konskowola.pl", "kutno.pl", "lapy.pl", "lebork.pl", "legnica.pl", "lezajsk.pl", "limanowa.pl", "lomza.pl", "lowicz.pl", "lubin.pl", "lukow.pl", "malbork.pl", "malopolska.pl", "mazowsze.pl", "mazury.pl", "mielec.pl", "mielno.pl", "mragowo.pl", "naklo.pl", "nowaruda.pl", "nysa.pl", "olawa.pl", "olecko.pl", "olkusz.pl", "olsztyn.pl", "opoczno.pl", "opole.pl", "ostroda.pl", "ostroleka.pl", "ostrowiec.pl", "ostrowwlkp.pl", "pila.pl", "pisz.pl", "podhale.pl", "podlasie.pl", "polkowice.pl", "pomorskie.pl", "pomorze.pl", "prochowice.pl", "pruszkow.pl", "przeworsk.pl", "pulawy.pl", "radom.pl", "rawa-maz.pl", "rybnik.pl", "rzeszow.pl", "sanok.pl", "sejny.pl", "skoczow.pl", "slask.pl", "slupsk.pl", "sosnowiec.pl", "stalowa-wola.pl", "starachowice.pl", "stargard.pl", "suwalki.pl", "swidnica.pl", "swiebodzin.pl", "swinoujscie.pl", "szczecin.pl", "szczytno.pl", "tarnobrzeg.pl", "tgory.pl", "turek.pl", "tychy.pl", "ustka.pl", "walbrzych.pl", "warmia.pl", "warszawa.pl", "waw.pl", "wegrow.pl", "wielun.pl", "wlocl.pl", "wloclawek.pl", "wodzislaw.pl", "wolomin.pl", "wroclaw.pl", "zachpomor.pl", "zagan.pl", "zarow.pl", "zgora.pl", "zgorzelec.pl", "pm", "pn", "co.pn", "edu.pn", "gov.pn", "net.pn", "org.pn", "post", "pr", "biz.pr", "com.pr", "edu.pr", "gov.pr", "info.pr", "isla.pr", "name.pr", "net.pr", "org.pr", "pro.pr", "ac.pr", "est.pr", "prof.pr", "pro", "aaa.pro", "aca.pro", "acct.pro", "avocat.pro", "bar.pro", "cpa.pro", "eng.pro", "jur.pro", "law.pro", "med.pro", "recht.pro", "ps", "com.ps", "edu.ps", "gov.ps", "net.ps", "org.ps", "plo.ps", "sec.ps", "pt", "com.pt", "edu.pt", "gov.pt", "int.pt", "net.pt", "nome.pt", "org.pt", "publ.pt", "pw", "belau.pw", "co.pw", "ed.pw", "go.pw", "or.pw", "py", "com.py", "coop.py", "edu.py", "gov.py", "mil.py", "net.py", "org.py", "qa", "com.qa", "edu.qa", "gov.qa", "mil.qa", "name.qa", "net.qa", "org.qa", "sch.qa", "re", "asso.re", "com.re", "ro", "arts.ro", "com.ro", "firm.ro", "info.ro", "nom.ro", "nt.ro", "org.ro", "rec.ro", "store.ro", "tm.ro", "www.ro", "rs", "ac.rs", "co.rs", "edu.rs", "gov.rs", "in.rs", "org.rs", "ru", "rw", "ac.rw", "co.rw", "coop.rw", "gov.rw", "mil.rw", "net.rw", "org.rw", "sa", "com.sa", "edu.sa", "gov.sa", "med.sa", "net.sa", "org.sa", "pub.sa", "sch.sa", "sb", "com.sb", "edu.sb", "gov.sb", "net.sb", "org.sb", "sc", "com.sc", "edu.sc", "gov.sc", "net.sc", "org.sc", "sd", "com.sd", "edu.sd", "gov.sd", "info.sd", "med.sd", "net.sd", "org.sd", "tv.sd", "se", "a.se", "ac.se", "b.se", "bd.se", "brand.se", "c.se", "d.se", "e.se", "f.se", "fh.se", "fhsk.se", "fhv.se", "g.se", "h.se", "i.se", "k.se", "komforb.se", "kommunalforbund.se", "komvux.se", "l.se", "lanbib.se", "m.se", "n.se", "naturbruksgymn.se", "o.se", "org.se", "p.se", "parti.se", "pp.se", "press.se", "r.se", "s.se", "t.se", "tm.se", "u.se", "w.se", "x.se", "y.se", "z.se", "sg", "com.sg", "edu.sg", "gov.sg", "net.sg", "org.sg", "sh", "com.sh", "gov.sh", "mil.sh", "net.sh", "org.sh", "si", "sj", "sk", "sl", "com.sl", "edu.sl", "gov.sl", "net.sl", "org.sl", "sm", "sn", "art.sn", "com.sn", "edu.sn", "gouv.sn", "org.sn", "perso.sn", "univ.sn", "so", "com.so", "edu.so", "gov.so", "me.so", "net.so", "org.so", "sr", "ss", "biz.ss", "co.ss", "com.ss", "edu.ss", "gov.ss", "me.ss", "net.ss", "org.ss", "sch.ss", "st", "co.st", "com.st", "consulado.st", "edu.st", "embaixada.st", "mil.st", "net.st", "org.st", "principe.st", "saotome.st", "store.st", "su", "sv", "com.sv", "edu.sv", "gob.sv", "org.sv", "red.sv", "sx", "gov.sx", "sy", "com.sy", "edu.sy", "gov.sy", "mil.sy", "net.sy", "org.sy", "sz", "ac.sz", "co.sz", "org.sz", "tc", "td", "tel", "tf", "tg", "th", "ac.th", "co.th", "go.th", "in.th", "mi.th", "net.th", "or.th", "tj", "ac.tj", "biz.tj", "co.tj", "com.tj", "edu.tj", "go.tj", "gov.tj", "int.tj", "mil.tj", "name.tj", "net.tj", "nic.tj", "org.tj", "test.tj", "web.tj", "tk", "tl", "gov.tl", "tm", "co.tm", "com.tm", "edu.tm", "gov.tm", "mil.tm", "net.tm", "nom.tm", "org.tm", "tn", "com.tn", "ens.tn", "fin.tn", "gov.tn", "ind.tn", "info.tn", "intl.tn", "mincom.tn", "nat.tn", "net.tn", "org.tn", "perso.tn", "tourism.tn", "to", "com.to", "edu.to", "gov.to", "mil.to", "net.to", "org.to", "tr", "av.tr", "bbs.tr", "bel.tr", "biz.tr", "com.tr", "dr.tr", "edu.tr", "gen.tr", "gov.tr", "info.tr", "k12.tr", "kep.tr", "mil.tr", "name.tr", "net.tr", "org.tr", "pol.tr", "tel.tr", "tsk.tr", "tv.tr", "web.tr", "nc.tr", "gov.nc.tr", "tt", "biz.tt", "co.tt", "com.tt", "edu.tt", "gov.tt", "info.tt", "mil.tt", "name.tt", "net.tt", "org.tt", "pro.tt", "tv", "tw", "club.tw", "com.tw", "ebiz.tw", "edu.tw", "game.tw", "gov.tw", "idv.tw", "mil.tw", "net.tw", "org.tw", "tz", "ac.tz", "co.tz", "go.tz", "hotel.tz", "info.tz", "me.tz", "mil.tz", "mobi.tz", "ne.tz", "or.tz", "sc.tz", "tv.tz", "ua", "com.ua", "edu.ua", "gov.ua", "in.ua", "net.ua", "org.ua", "cherkassy.ua", "cherkasy.ua", "chernigov.ua", "chernihiv.ua", "chernivtsi.ua", "chernovtsy.ua", "ck.ua", "cn.ua", "cr.ua", "crimea.ua", "cv.ua", "dn.ua", "dnepropetrovsk.ua", "dnipropetrovsk.ua", "donetsk.ua", "dp.ua", "if.ua", "ivano-frankivsk.ua", "kh.ua", "kharkiv.ua", "kharkov.ua", "kherson.ua", "khmelnitskiy.ua", "khmelnytskyi.ua", "kiev.ua", "kirovograd.ua", "km.ua", "kr.ua", "kropyvnytskyi.ua", "krym.ua", "ks.ua", "kv.ua", "kyiv.ua", "lg.ua", "lt.ua", "lugansk.ua", "luhansk.ua", "lutsk.ua", "lv.ua", "lviv.ua", "mk.ua", "mykolaiv.ua", "nikolaev.ua", "od.ua", "odesa.ua", "odessa.ua", "pl.ua", "poltava.ua", "rivne.ua", "rovno.ua", "rv.ua", "sb.ua", "sebastopol.ua", "sevastopol.ua", "sm.ua", "sumy.ua", "te.ua", "ternopil.ua", "uz.ua", "uzhgorod.ua", "uzhhorod.ua", "vinnica.ua", "vinnytsia.ua", "vn.ua", "volyn.ua", "yalta.ua", "zakarpattia.ua", "zaporizhzhe.ua", "zaporizhzhia.ua", "zhitomir.ua", "zhytomyr.ua", "zp.ua", "zt.ua", "ug", "ac.ug", "co.ug", "com.ug", "go.ug", "ne.ug", "or.ug", "org.ug", "sc.ug", "uk", "ac.uk", "co.uk", "gov.uk", "ltd.uk", "me.uk", "net.uk", "nhs.uk", "org.uk", "plc.uk", "police.uk", "*.sch.uk", "us", "dni.us", "fed.us", "isa.us", "kids.us", "nsn.us", "ak.us", "al.us", "ar.us", "as.us", "az.us", "ca.us", "co.us", "ct.us", "dc.us", "de.us", "fl.us", "ga.us", "gu.us", "hi.us", "ia.us", "id.us", "il.us", "in.us", "ks.us", "ky.us", "la.us", "ma.us", "md.us", "me.us", "mi.us", "mn.us", "mo.us", "ms.us", "mt.us", "nc.us", "nd.us", "ne.us", "nh.us", "nj.us", "nm.us", "nv.us", "ny.us", "oh.us", "ok.us", "or.us", "pa.us", "pr.us", "ri.us", "sc.us", "sd.us", "tn.us", "tx.us", "ut.us", "va.us", "vi.us", "vt.us", "wa.us", "wi.us", "wv.us", "wy.us", "k12.ak.us", "k12.al.us", "k12.ar.us", "k12.as.us", "k12.az.us", "k12.ca.us", "k12.co.us", "k12.ct.us", "k12.dc.us", "k12.fl.us", "k12.ga.us", "k12.gu.us", "k12.ia.us", "k12.id.us", "k12.il.us", "k12.in.us", "k12.ks.us", "k12.ky.us", "k12.la.us", "k12.ma.us", "k12.md.us", "k12.me.us", "k12.mi.us", "k12.mn.us", "k12.mo.us", "k12.ms.us", "k12.mt.us", "k12.nc.us", "k12.ne.us", "k12.nh.us", "k12.nj.us", "k12.nm.us", "k12.nv.us", "k12.ny.us", "k12.oh.us", "k12.ok.us", "k12.or.us", "k12.pa.us", "k12.pr.us", "k12.sc.us", "k12.tn.us", "k12.tx.us", "k12.ut.us", "k12.va.us", "k12.vi.us", "k12.vt.us", "k12.wa.us", "k12.wi.us", "cc.ak.us", "lib.ak.us", "cc.al.us", "lib.al.us", "cc.ar.us", "lib.ar.us", "cc.as.us", "lib.as.us", "cc.az.us", "lib.az.us", "cc.ca.us", "lib.ca.us", "cc.co.us", "lib.co.us", "cc.ct.us", "lib.ct.us", "cc.dc.us", "lib.dc.us", "cc.de.us", "cc.fl.us", "cc.ga.us", "cc.gu.us", "cc.hi.us", "cc.ia.us", "cc.id.us", "cc.il.us", "cc.in.us", "cc.ks.us", "cc.ky.us", "cc.la.us", "cc.ma.us", "cc.md.us", "cc.me.us", "cc.mi.us", "cc.mn.us", "cc.mo.us", "cc.ms.us", "cc.mt.us", "cc.nc.us", "cc.nd.us", "cc.ne.us", "cc.nh.us", "cc.nj.us", "cc.nm.us", "cc.nv.us", "cc.ny.us", "cc.oh.us", "cc.ok.us", "cc.or.us", "cc.pa.us", "cc.pr.us", "cc.ri.us", "cc.sc.us", "cc.sd.us", "cc.tn.us", "cc.tx.us", "cc.ut.us", "cc.va.us", "cc.vi.us", "cc.vt.us", "cc.wa.us", "cc.wi.us", "cc.wv.us", "cc.wy.us", "k12.wy.us", "lib.fl.us", "lib.ga.us", "lib.gu.us", "lib.hi.us", "lib.ia.us", "lib.id.us", "lib.il.us", "lib.in.us", "lib.ks.us", "lib.ky.us", "lib.la.us", "lib.ma.us", "lib.md.us", "lib.me.us", "lib.mi.us", "lib.mn.us", "lib.mo.us", "lib.ms.us", "lib.mt.us", "lib.nc.us", "lib.nd.us", "lib.ne.us", "lib.nh.us", "lib.nj.us", "lib.nm.us", "lib.nv.us", "lib.ny.us", "lib.oh.us", "lib.ok.us", "lib.or.us", "lib.pa.us", "lib.pr.us", "lib.ri.us", "lib.sc.us", "lib.sd.us", "lib.tn.us", "lib.tx.us", "lib.ut.us", "lib.va.us", "lib.vi.us", "lib.vt.us", "lib.wa.us", "lib.wi.us", "lib.wy.us", "chtr.k12.ma.us", "paroch.k12.ma.us", "pvt.k12.ma.us", "ann-arbor.mi.us", "cog.mi.us", "dst.mi.us", "eaton.mi.us", "gen.mi.us", "mus.mi.us", "tec.mi.us", "washtenaw.mi.us", "uy", "com.uy", "edu.uy", "gub.uy", "mil.uy", "net.uy", "org.uy", "uz", "co.uz", "com.uz", "net.uz", "org.uz", "va", "vc", "com.vc", "edu.vc", "gov.vc", "mil.vc", "net.vc", "org.vc", "ve", "arts.ve", "bib.ve", "co.ve", "com.ve", "e12.ve", "edu.ve", "firm.ve", "gob.ve", "gov.ve", "info.ve", "int.ve", "mil.ve", "net.ve", "nom.ve", "org.ve", "rar.ve", "rec.ve", "store.ve", "tec.ve", "web.ve", "vg", "vi", "co.vi", "com.vi", "k12.vi", "net.vi", "org.vi", "vn", "ac.vn", "ai.vn", "biz.vn", "com.vn", "edu.vn", "gov.vn", "health.vn", "id.vn", "info.vn", "int.vn", "io.vn", "name.vn", "net.vn", "org.vn", "pro.vn", "angiang.vn", "bacgiang.vn", "backan.vn", "baclieu.vn", "bacninh.vn", "baria-vungtau.vn", "bentre.vn", "binhdinh.vn", "binhduong.vn", "binhphuoc.vn", "binhthuan.vn", "camau.vn", "cantho.vn", "caobang.vn", "daklak.vn", "daknong.vn", "danang.vn", "dienbien.vn", "dongnai.vn", "dongthap.vn", "gialai.vn", "hagiang.vn", "haiduong.vn", "haiphong.vn", "hanam.vn", "hanoi.vn", "hatinh.vn", "haugiang.vn", "hoabinh.vn", "hungyen.vn", "khanhhoa.vn", "kiengiang.vn", "kontum.vn", "laichau.vn", "lamdong.vn", "langson.vn", "laocai.vn", "longan.vn", "namdinh.vn", "nghean.vn", "ninhbinh.vn", "ninhthuan.vn", "phutho.vn", "phuyen.vn", "quangbinh.vn", "quangnam.vn", "quangngai.vn", "quangninh.vn", "quangtri.vn", "soctrang.vn", "sonla.vn", "tayninh.vn", "thaibinh.vn", "thainguyen.vn", "thanhhoa.vn", "thanhphohochiminh.vn", "thuathienhue.vn", "tiengiang.vn", "travinh.vn", "tuyenquang.vn", "vinhlong.vn", "vinhphuc.vn", "yenbai.vn", "vu", "com.vu", "edu.vu", "net.vu", "org.vu", "wf", "ws", "com.ws", "edu.ws", "gov.ws", "net.ws", "org.ws", "yt", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ".", ".", ".", ".", ".", ".", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ".", ".", ".", ".", ".", ".", "", "", "", "", "", "", "", "", "", "", "", "", ".", ".", ".", ".", ".", ".", "", "", "", "", "", "", "xxx", "ye", "com.ye", "edu.ye", "gov.ye", "mil.ye", "net.ye", "org.ye", "ac.za", "agric.za", "alt.za", "co.za", "edu.za", "gov.za", "grondar.za", "law.za", "mil.za", "net.za", "ngo.za", "nic.za", "nis.za", "nom.za", "org.za", "school.za", "tm.za", "web.za", "zm", "ac.zm", "biz.zm", "co.zm", "com.zm", "edu.zm", "gov.zm", "info.zm", "mil.zm", "net.zm", "org.zm", "sch.zm", "zw", "ac.zw", "co.zw", "gov.zw", "mil.zw", "org.zw", "aaa", "aarp", "abb", "abbott", "abbvie", "abc", "able", "abogado", "abudhabi", "academy", "accenture", "accountant", "accountants", "aco", "actor", "ads", "adult", "aeg", "aetna", "afl", "africa", "agakhan", "agency", "aig", "airbus", "airforce", "airtel", "akdn", "alibaba", "alipay", "allfinanz", "allstate", "ally", "alsace", "alstom", "amazon", "americanexpress", "americanfamily", "amex", "amfam", "amica", "amsterdam", "analytics", "android", "anquan", "anz", "aol", "apartments", "app", "apple", "aquarelle", "arab", "aramco", "archi", "army", "art", "arte", "asda", "associates", "athleta", "attorney", "auction", "audi", "audible", "audio", "auspost", "author", "auto", "autos", "aws", "axa", "azure", "baby", "baidu", "banamex", "band", "bank", "bar", "barcelona", "barclaycard", "barclays", "barefoot", "bargains", "baseball", "basketball", "bauhaus", "bayern", "bbc", "bbt", "bbva", "bcg", "bcn", "beats", "beauty", "beer", "bentley", "berlin", "best", "bestbuy", "bet", "bharti", "bible", "bid", "bike", "bing", "bingo", "bio", "black", "blackfriday", "blockbuster", "blog", "bloomberg", "blue", "bms", "bmw", "bnpparibas", "boats", "boehringer", "bofa", "bom", "bond", "boo", "book", "booking", "bosch", "bostik", "boston", "bot", "boutique", "box", "bradesco", "bridgestone", "broadway", "broker", "brother", "brussels", "build", "builders", "business", "buy", "buzz", "bzh", "cab", "cafe", "cal", "call", "calvinklein", "cam", "camera", "camp", "canon", "capetown", "capital", "capitalone", "car", "caravan", "cards", "care", "career", "careers", "cars", "casa", "case", "cash", "casino", "catering", "catholic", "cba", "cbn", "cbre", "center", "ceo", "cern", "cfa", "cfd", "chanel", "channel", "charity", "chase", "chat", "cheap", "chintai", "christmas", "chrome", "church", "cipriani", "circle", "cisco", "citadel", "citi", "citic", "city", "claims", "cleaning", "click", "clinic", "clinique", "clothing", "cloud", "club", "clubmed", "coach", "codes", "coffee", "college", "cologne", "commbank", "community", "company", "compare", "computer", "comsec", "condos", "construction", "consulting", "contact", "contractors", "cooking", "cool", "corsica", "country", "coupon", "coupons", "courses", "cpa", "credit", "creditcard", "creditunion", "cricket", "crown", "crs", "cruise", "cruises", "cuisinella", "cymru", "cyou", "dad", "dance", "data", "date", "dating", "datsun", "day", "dclk", "dds", "deal", "dealer", "deals", "degree", "delivery", "dell", "deloitte", "delta", "democrat", "dental", "dentist", "desi", "design", "dev", "dhl", "diamonds", "diet", "digital", "direct", "directory", "discount", "discover", "dish", "diy", "dnp", "docs", "doctor", "dog", "domains", "dot", "download", "drive", "dtv", "dubai", "dunlop", "dupont", "durban", "dvag", "dvr", "earth", "eat", "eco", "edeka", "education", "email", "emerck", "energy", "engineer", "engineering", "enterprises", "epson", "equipment", "ericsson", "erni", "esq", "estate", "eurovision", "eus", "events", "exchange", "expert", "exposed", "express", "extraspace", "fage", "fail", "fairwinds", "faith", "family", "fan", "fans", "farm", "farmers", "fashion", "fast", "fedex", "feedback", "ferrari", "ferrero", "fidelity", "fido", "film", "final", "finance", "financial", "fire", "firestone", "firmdale", "fish", "fishing", "fit", "fitness", "flickr", "flights", "flir", "florist", "flowers", "fly", "foo", "food", "football", "ford", "forex", "forsale", "forum", "foundation", "fox", "free", "fresenius", "frl", "frogans", "frontier", "ftr", "fujitsu", "fun", "fund", "furniture", "futbol", "fyi", "gal", "gallery", "gallo", "gallup", "game", "games", "gap", "garden", "gay", "gbiz", "gdn", "gea", "gent", "genting", "george", "ggee", "gift", "gifts", "gives", "giving", "glass", "gle", "global", "globo", "gmail", "gmbh", "gmo", "gmx", "godaddy", "gold", "goldpoint", "golf", "goo", "goodyear", "goog", "google", "gop", "got", "grainger", "graphics", "gratis", "green", "gripe", "grocery", "group", "gucci", "guge", "guide", "guitars", "guru", "hair", "hamburg", "hangout", "haus", "hbo", "hdfc", "hdfcbank", "health", "healthcare", "help", "helsinki", "here", "hermes", "hiphop", "hisamitsu", "hitachi", "hiv", "hkt", "hockey", "holdings", "holiday", "homedepot", "homegoods", "homes", "homesense", "honda", "horse", "hospital", "host", "hosting", "hot", "hotels", "hotmail", "house", "how", "hsbc", "hughes", "hyatt", "hyundai", "ibm", "icbc", "ice", "icu", "ieee", "ifm", "ikano", "imamat", "imdb", "immo", "immobilien", "inc", "industries", "infiniti", "ing", "ink", "institute", "insurance", "insure", "international", "intuit", "investments", "ipiranga", "irish", "ismaili", "ist", "istanbul", "itau", "itv", "jaguar", "java", "jcb", "jeep", "jetzt", "jewelry", "jio", "jll", "jmp", "jnj", "joburg", "jot", "joy", "jpmorgan", "jprs", "juegos", "juniper", "kaufen", "kddi", "kerryhotels", "kerrylogistics", "kerryproperties", "kfh", "kia", "kids", "kim", "kindle", "kitchen", "kiwi", "koeln", "komatsu", "kosher", "kpmg", "kpn", "krd", "kred", "kuokgroup", "kyoto", "lacaixa", "lamborghini", "lamer", "lancaster", "land", "landrover", "lanxess", "lasalle", "lat", "latino", "latrobe", "law", "lawyer", "lds", "lease", "leclerc", "lefrak", "legal", "lego", "lexus", "lgbt", "lidl", "life", "lifeinsurance", "lifestyle", "lighting", "like", "lilly", "limited", "limo", "lincoln", "link", "lipsy", "live", "living", "llc", "llp", "loan", "loans", "locker", "locus", "lol", "london", "lotte", "lotto", "love", "lpl", "lplfinancial", "ltd", "ltda", "lundbeck", "luxe", "luxury", "madrid", "maif", "maison", "makeup", "man", "management", "mango", "map", "market", "marketing", "markets", "marriott", "marshalls", "mattel", "mba", "mckinsey", "med", "media", "meet", "melbourne", "meme", "memorial", "men", "menu", "merck", "merckmsd", "miami", "microsoft", "mini", "mint", "mit", "mitsubishi", "mlb", "mls", "mma", "mobile", "moda", "moe", "moi", "mom", "monash", "money", "monster", "mormon", "mortgage", "moscow", "moto", "motorcycles", "mov", "movie", "msd", "mtn", "mtr", "music", "nab", "nagoya", "navy", "nba", "nec", "netbank", "netflix", "network", "neustar", "new", "news", "next", "nextdirect", "nexus", "nfl", "ngo", "nhk", "nico", "nike", "nikon", "ninja", "nissan", "nissay", "nokia", "norton", "now", "nowruz", "nowtv", "nra", "nrw", "ntt", "nyc", "obi", "observer", "office", "okinawa", "olayan", "olayangroup", "ollo", "omega", "one", "ong", "onl", "online", "ooo", "open", "oracle", "orange", "organic", "origins", "osaka", "otsuka", "ott", "ovh", "page", "panasonic", "paris", "pars", "partners", "parts", "party", "pay", "pccw", "pet", "pfizer", "pharmacy", "phd", "philips", "phone", "photo", "photography", "photos", "physio", "pics", "pictet", "pictures", "pid", "pin", "ping", "pink", "pioneer", "pizza", "place", "play", "playstation", "plumbing", "plus", "pnc", "pohl", "poker", "politie", "porn", "pramerica", "praxi", "press", "prime", "prod", "productions", "prof", "progressive", "promo", "properties", "property", "protection", "pru", "prudential", "pub", "pwc", "qpon", "quebec", "quest", "racing", "radio", "read", "realestate", "realtor", "realty", "recipes", "red", "redstone", "redumbrella", "rehab", "reise", "reisen", "reit", "reliance", "ren", "rent", "rentals", "repair", "report", "republican", "rest", "restaurant", "review", "reviews", "rexroth", "rich", "richardli", "ricoh", "ril", "rio", "rip", "rocks", "rodeo", "rogers", "room", "rsvp", "rugby", "ruhr", "run", "rwe", "ryukyu", "saarland", "safe", "safety", "sakura", "sale", "salon", "samsclub", "samsung", "sandvik", "sandvikcoromant", "sanofi", "sap", "sarl", "sas", "save", "saxo", "sbi", "sbs", "scb", "schaeffler", "schmidt", "scholarships", "school", "schule", "schwarz", "science", "scot", "search", "seat", "secure", "security", "seek", "select", "sener", "services", "seven", "sew", "sex", "sexy", "sfr", "shangrila", "sharp", "shell", "shia", "shiksha", "shoes", "shop", "shopping", "shouji", "show", "silk", "sina", "singles", "site", "ski", "skin", "sky", "skype", "sling", "smart", "smile", "sncf", "soccer", "social", "softbank", "software", "sohu", "solar", "solutions", "song", "sony", "soy", "spa", "space", "sport", "spot", "srl", "stada", "staples", "star", "statebank", "statefarm", "stc", "stcgroup", "stockholm", "storage", "store", "stream", "studio", "study", "style", "sucks", "supplies", "supply", "support", "surf", "surgery", "suzuki", "swatch", "swiss", "sydney", "systems", "tab", "taipei", "talk", "taobao", "target", "tatamotors", "tatar", "tattoo", "tax", "taxi", "tci", "tdk", "team", "tech", "technology", "temasek", "tennis", "teva", "thd", "theater", "theatre", "tiaa", "tickets", "tienda", "tips", "tires", "tirol", "tjmaxx", "tjx", "tkmaxx", "tmall", "today", "tokyo", "tools", "top", "toray", "toshiba", "total", "tours", "town", "toyota", "toys", "trade", "trading", "training", "travel", "travelers", "travelersinsurance", "trust", "trv", "tube", "tui", "tunes", "tushu", "tvs", "ubank", "ubs", "unicom", "university", "uno", "uol", "ups", "vacations", "vana", "vanguard", "vegas", "ventures", "verisign", "versicherung", "vet", "viajes", "video", "vig", "viking", "villas", "vin", "vip", "virgin", "visa", "vision", "viva", "vivo", "vlaanderen", "vodka", "volvo", "vote", "voting", "voto", "voyage", "wales", "walmart", "walter", "wang", "wanggou", "watch", "watches", "weather", "weatherchannel", "webcam", "weber", "website", "wed", "wedding", "weibo", "weir", "whoswho", "wien", "wiki", "williamhill", "win", "windows", "wine", "winners", "wme", "wolterskluwer", "woodside", "work", "works", "world", "wow", "wtc", "wtf", "xbox", "xerox", "xihuan", "xin", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "vermgensberater", "vermgensberatung", "", "", "", "", "", "", "xyz", "yachts", "yahoo", "yamaxun", "yandex", "yodobashi", "yoga", "yokohama", "you", "youtube", "yun", "zappos", "zara", "zero", "zip", "zone", "zuerich", "co.krd", "edu.krd", "art.pl", "gliwice.pl", "krakow.pl", "poznan.pl", "wroc.pl", "zakopane.pl", "lib.de.us", "12chars.dev", "12chars.it", "12chars.pro", "cc.ua", "inf.ua", "ltd.ua", "611.to", "a2hosted.com", "cpserver.com", "aaa.vodka", "*.on-acorn.io", "activetrail.biz", "adaptable.app", "adobeaemcloud.com", "*.dev.adobeaemcloud.com", "aem.live", "hlx.live", "adobeaemcloud.net", "aem.page", "hlx.page", "hlx3.page", "adobeio-static.net", "adobeioruntime.net", "africa.com", "beep.pl", "airkitapps.com", "airkitapps-au.com", "airkitapps.eu", "aivencloud.com", "akadns.net", "akamai.net", "akamai-staging.net", "akamaiedge.net", "akamaiedge-staging.net", "akamaihd.net", "akamaihd-staging.net", "akamaiorigin.net", "akamaiorigin-staging.net", "akamaized.net", "akamaized-staging.net", "edgekey.net", "edgekey-staging.net", "edgesuite.net", "edgesuite-staging.net", "barsy.ca", "*.compute.estate", "*.alces.network", "kasserver.com", "altervista.org", "alwaysdata.net", "myamaze.net", "execute-api.cn-north-1.amazonaws.com.cn", "execute-api.cn-northwest-1.amazonaws.com.cn", "execute-api.af-south-1.amazonaws.com", "execute-api.ap-east-1.amazonaws.com", "execute-api.ap-northeast-1.amazonaws.com", "execute-api.ap-northeast-2.amazonaws.com", "execute-api.ap-northeast-3.amazonaws.com", "execute-api.ap-south-1.amazonaws.com", "execute-api.ap-south-2.amazonaws.com", "execute-api.ap-southeast-1.amazonaws.com", "execute-api.ap-southeast-2.amazonaws.com", "execute-api.ap-southeast-3.amazonaws.com", "execute-api.ap-southeast-4.amazonaws.com", "execute-api.ap-southeast-5.amazonaws.com", "execute-api.ca-central-1.amazonaws.com", "execute-api.ca-west-1.amazonaws.com", "execute-api.eu-central-1.amazonaws.com", "execute-api.eu-central-2.amazonaws.com", "execute-api.eu-north-1.amazonaws.com", "execute-api.eu-south-1.amazonaws.com", "execute-api.eu-south-2.amazonaws.com", "execute-api.eu-west-1.amazonaws.com", "execute-api.eu-west-2.amazonaws.com", "execute-api.eu-west-3.amazonaws.com", "execute-api.il-central-1.amazonaws.com", "execute-api.me-central-1.amazonaws.com", "execute-api.me-south-1.amazonaws.com", "execute-api.sa-east-1.amazonaws.com", "execute-api.us-east-1.amazonaws.com", "execute-api.us-east-2.amazonaws.com", "execute-api.us-gov-east-1.amazonaws.com", "execute-api.us-gov-west-1.amazonaws.com", "execute-api.us-west-1.amazonaws.com", "execute-api.us-west-2.amazonaws.com", "cloudfront.net", "auth.af-south-1.amazoncognito.com", "auth.ap-east-1.amazoncognito.com", "auth.ap-northeast-1.amazoncognito.com", "auth.ap-northeast-2.amazoncognito.com", "auth.ap-northeast-3.amazoncognito.com", "auth.ap-south-1.amazoncognito.com", "auth.ap-south-2.amazoncognito.com", "auth.ap-southeast-1.amazoncognito.com", "auth.ap-southeast-2.amazoncognito.com", "auth.ap-southeast-3.amazoncognito.com", "auth.ap-southeast-4.amazoncognito.com", "auth.ca-central-1.amazoncognito.com", "auth.ca-west-1.amazoncognito.com", "auth.eu-central-1.amazoncognito.com", "auth.eu-central-2.amazoncognito.com", "auth.eu-north-1.amazoncognito.com", "auth.eu-south-1.amazoncognito.com", "auth.eu-south-2.amazoncognito.com", "auth.eu-west-1.amazoncognito.com", "auth.eu-west-2.amazoncognito.com", "auth.eu-west-3.amazoncognito.com", "auth.il-central-1.amazoncognito.com", "auth.me-central-1.amazoncognito.com", "auth.me-south-1.amazoncognito.com", "auth.sa-east-1.amazoncognito.com", "auth.us-east-1.amazoncognito.com", "auth-fips.us-east-1.amazoncognito.com", "auth.us-east-2.amazoncognito.com", "auth-fips.us-east-2.amazoncognito.com", "auth-fips.us-gov-west-1.amazoncognito.com", "auth.us-west-1.amazoncognito.com", "auth-fips.us-west-1.amazoncognito.com", "auth.us-west-2.amazoncognito.com", "auth-fips.us-west-2.amazoncognito.com", "*.compute.amazonaws.com.cn", "*.compute.amazonaws.com", "*.compute-1.amazonaws.com", "us-east-1.amazonaws.com", "emrappui-prod.cn-north-1.amazonaws.com.cn", "emrnotebooks-prod.cn-north-1.amazonaws.com.cn", "emrstudio-prod.cn-north-1.amazonaws.com.cn", "emrappui-prod.cn-northwest-1.amazonaws.com.cn", "emrnotebooks-prod.cn-northwest-1.amazonaws.com.cn", "emrstudio-prod.cn-northwest-1.amazonaws.com.cn", "emrappui-prod.af-south-1.amazonaws.com", "emrnotebooks-prod.af-south-1.amazonaws.com", "emrstudio-prod.af-south-1.amazonaws.com", "emrappui-prod.ap-east-1.amazonaws.com", "emrnotebooks-prod.ap-east-1.amazonaws.com", "emrstudio-prod.ap-east-1.amazonaws.com", "emrappui-prod.ap-northeast-1.amazonaws.com", "emrnotebooks-prod.ap-northeast-1.amazonaws.com", "emrstudio-prod.ap-northeast-1.amazonaws.com", "emrappui-prod.ap-northeast-2.amazonaws.com", "emrnotebooks-prod.ap-northeast-2.amazonaws.com", "emrstudio-prod.ap-northeast-2.amazonaws.com", "emrappui-prod.ap-northeast-3.amazonaws.com", "emrnotebooks-prod.ap-northeast-3.amazonaws.com", "emrstudio-prod.ap-northeast-3.amazonaws.com", "emrappui-prod.ap-south-1.amazonaws.com", "emrnotebooks-prod.ap-south-1.amazonaws.com", "emrstudio-prod.ap-south-1.amazonaws.com", "emrappui-prod.ap-south-2.amazonaws.com", "emrnotebooks-prod.ap-south-2.amazonaws.com", "emrstudio-prod.ap-south-2.amazonaws.com", "emrappui-prod.ap-southeast-1.amazonaws.com", "emrnotebooks-prod.ap-southeast-1.amazonaws.com", "emrstudio-prod.ap-southeast-1.amazonaws.com", "emrappui-prod.ap-southeast-2.amazonaws.com", "emrnotebooks-prod.ap-southeast-2.amazonaws.com", "emrstudio-prod.ap-southeast-2.amazonaws.com", "emrappui-prod.ap-southeast-3.amazonaws.com", "emrnotebooks-prod.ap-southeast-3.amazonaws.com", "emrstudio-prod.ap-southeast-3.amazonaws.com", "emrappui-prod.ap-southeast-4.amazonaws.com", "emrnotebooks-prod.ap-southeast-4.amazonaws.com", "emrstudio-prod.ap-southeast-4.amazonaws.com", "emrappui-prod.ca-central-1.amazonaws.com", "emrnotebooks-prod.ca-central-1.amazonaws.com", "emrstudio-prod.ca-central-1.amazonaws.com", "emrappui-prod.ca-west-1.amazonaws.com", "emrnotebooks-prod.ca-west-1.amazonaws.com", "emrstudio-prod.ca-west-1.amazonaws.com", "emrappui-prod.eu-central-1.amazonaws.com", "emrnotebooks-prod.eu-central-1.amazonaws.com", "emrstudio-prod.eu-central-1.amazonaws.com", "emrappui-prod.eu-central-2.amazonaws.com", "emrnotebooks-prod.eu-central-2.amazonaws.com", "emrstudio-prod.eu-central-2.amazonaws.com", "emrappui-prod.eu-north-1.amazonaws.com", "emrnotebooks-prod.eu-north-1.amazonaws.com", "emrstudio-prod.eu-north-1.amazonaws.com", "emrappui-prod.eu-south-1.amazonaws.com", "emrnotebooks-prod.eu-south-1.amazonaws.com", "emrstudio-prod.eu-south-1.amazonaws.com", "emrappui-prod.eu-south-2.amazonaws.com", "emrnotebooks-prod.eu-south-2.amazonaws.com", "emrstudio-prod.eu-south-2.amazonaws.com", "emrappui-prod.eu-west-1.amazonaws.com", "emrnotebooks-prod.eu-west-1.amazonaws.com", "emrstudio-prod.eu-west-1.amazonaws.com", "emrappui-prod.eu-west-2.amazonaws.com", "emrnotebooks-prod.eu-west-2.amazonaws.com", "emrstudio-prod.eu-west-2.amazonaws.com", "emrappui-prod.eu-west-3.amazonaws.com", "emrnotebooks-prod.eu-west-3.amazonaws.com", "emrstudio-prod.eu-west-3.amazonaws.com", "emrappui-prod.il-central-1.amazonaws.com", "emrnotebooks-prod.il-central-1.amazonaws.com", "emrstudio-prod.il-central-1.amazonaws.com", "emrappui-prod.me-central-1.amazonaws.com", "emrnotebooks-prod.me-central-1.amazonaws.com", "emrstudio-prod.me-central-1.amazonaws.com", "emrappui-prod.me-south-1.amazonaws.com", "emrnotebooks-prod.me-south-1.amazonaws.com", "emrstudio-prod.me-south-1.amazonaws.com", "emrappui-prod.sa-east-1.amazonaws.com", "emrnotebooks-prod.sa-east-1.amazonaws.com", "emrstudio-prod.sa-east-1.amazonaws.com", "emrappui-prod.us-east-1.amazonaws.com", "emrnotebooks-prod.us-east-1.amazonaws.com", "emrstudio-prod.us-east-1.amazonaws.com", "emrappui-prod.us-east-2.amazonaws.com", "emrnotebooks-prod.us-east-2.amazonaws.com", "emrstudio-prod.us-east-2.amazonaws.com", "emrappui-prod.us-gov-east-1.amazonaws.com", "emrnotebooks-prod.us-gov-east-1.amazonaws.com", "emrstudio-prod.us-gov-east-1.amazonaws.com", "emrappui-prod.us-gov-west-1.amazonaws.com", "emrnotebooks-prod.us-gov-west-1.amazonaws.com", "emrstudio-prod.us-gov-west-1.amazonaws.com", "emrappui-prod.us-west-1.amazonaws.com", "emrnotebooks-prod.us-west-1.amazonaws.com", "emrstudio-prod.us-west-1.amazonaws.com", "emrappui-prod.us-west-2.amazonaws.com", "emrnotebooks-prod.us-west-2.amazonaws.com", "emrstudio-prod.us-west-2.amazonaws.com", "*.cn-north-1.airflow.amazonaws.com.cn", "*.cn-northwest-1.airflow.amazonaws.com.cn", "*.af-south-1.airflow.amazonaws.com", "*.ap-east-1.airflow.amazonaws.com", "*.ap-northeast-1.airflow.amazonaws.com", "*.ap-northeast-2.airflow.amazonaws.com", "*.ap-northeast-3.airflow.amazonaws.com", "*.ap-south-1.airflow.amazonaws.com", "*.ap-south-2.airflow.amazonaws.com", "*.ap-southeast-1.airflow.amazonaws.com", "*.ap-southeast-2.airflow.amazonaws.com", "*.ap-southeast-3.airflow.amazonaws.com", "*.ap-southeast-4.airflow.amazonaws.com", "*.ca-central-1.airflow.amazonaws.com", "*.ca-west-1.airflow.amazonaws.com", "*.eu-central-1.airflow.amazonaws.com", "*.eu-central-2.airflow.amazonaws.com", "*.eu-north-1.airflow.amazonaws.com", "*.eu-south-1.airflow.amazonaws.com", "*.eu-south-2.airflow.amazonaws.com", "*.eu-west-1.airflow.amazonaws.com", "*.eu-west-2.airflow.amazonaws.com", "*.eu-west-3.airflow.amazonaws.com", "*.il-central-1.airflow.amazonaws.com", "*.me-central-1.airflow.amazonaws.com", "*.me-south-1.airflow.amazonaws.com", "*.sa-east-1.airflow.amazonaws.com", "*.us-east-1.airflow.amazonaws.com", "*.us-east-2.airflow.amazonaws.com", "*.us-west-1.airflow.amazonaws.com", "*.us-west-2.airflow.amazonaws.com", "s3.dualstack.cn-north-1.amazonaws.com.cn", "s3-accesspoint.dualstack.cn-north-1.amazonaws.com.cn", "s3-website.dualstack.cn-north-1.amazonaws.com.cn", "s3.cn-north-1.amazonaws.com.cn", "s3-accesspoint.cn-north-1.amazonaws.com.cn", "s3-deprecated.cn-north-1.amazonaws.com.cn", "s3-object-lambda.cn-north-1.amazonaws.com.cn", "s3-website.cn-north-1.amazonaws.com.cn", "s3.dualstack.cn-northwest-1.amazonaws.com.cn", "s3-accesspoint.dualstack.cn-northwest-1.amazonaws.com.cn", "s3.cn-northwest-1.amazonaws.com.cn", "s3-accesspoint.cn-northwest-1.amazonaws.com.cn", "s3-object-lambda.cn-northwest-1.amazonaws.com.cn", "s3-website.cn-northwest-1.amazonaws.com.cn", "s3.dualstack.af-south-1.amazonaws.com", "s3-accesspoint.dualstack.af-south-1.amazonaws.com", "s3-website.dualstack.af-south-1.amazonaws.com", "s3.af-south-1.amazonaws.com", "s3-accesspoint.af-south-1.amazonaws.com", "s3-object-lambda.af-south-1.amazonaws.com", "s3-website.af-south-1.amazonaws.com", "s3.dualstack.ap-east-1.amazonaws.com", "s3-accesspoint.dualstack.ap-east-1.amazonaws.com", "s3.ap-east-1.amazonaws.com", "s3-accesspoint.ap-east-1.amazonaws.com", "s3-object-lambda.ap-east-1.amazonaws.com", "s3-website.ap-east-1.amazonaws.com", "s3.dualstack.ap-northeast-1.amazonaws.com", "s3-accesspoint.dualstack.ap-northeast-1.amazonaws.com", "s3-website.dualstack.ap-northeast-1.amazonaws.com", "s3.ap-northeast-1.amazonaws.com", "s3-accesspoint.ap-northeast-1.amazonaws.com", "s3-object-lambda.ap-northeast-1.amazonaws.com", "s3-website.ap-northeast-1.amazonaws.com", "s3.dualstack.ap-northeast-2.amazonaws.com", "s3-accesspoint.dualstack.ap-northeast-2.amazonaws.com", "s3-website.dualstack.ap-northeast-2.amazonaws.com", "s3.ap-northeast-2.amazonaws.com", "s3-accesspoint.ap-northeast-2.amazonaws.com", "s3-object-lambda.ap-northeast-2.amazonaws.com", "s3-website.ap-northeast-2.amazonaws.com", "s3.dualstack.ap-northeast-3.amazonaws.com", "s3-accesspoint.dualstack.ap-northeast-3.amazonaws.com", "s3-website.dualstack.ap-northeast-3.amazonaws.com", "s3.ap-northeast-3.amazonaws.com", "s3-accesspoint.ap-northeast-3.amazonaws.com", "s3-object-lambda.ap-northeast-3.amazonaws.com", "s3-website.ap-northeast-3.amazonaws.com", "s3.dualstack.ap-south-1.amazonaws.com", "s3-accesspoint.dualstack.ap-south-1.amazonaws.com", "s3-website.dualstack.ap-south-1.amazonaws.com", "s3.ap-south-1.amazonaws.com", "s3-accesspoint.ap-south-1.amazonaws.com", "s3-object-lambda.ap-south-1.amazonaws.com", "s3-website.ap-south-1.amazonaws.com", "s3.dualstack.ap-south-2.amazonaws.com", "s3-accesspoint.dualstack.ap-south-2.amazonaws.com", "s3-website.dualstack.ap-south-2.amazonaws.com", "s3.ap-south-2.amazonaws.com", "s3-accesspoint.ap-south-2.amazonaws.com", "s3-object-lambda.ap-south-2.amazonaws.com", "s3-website.ap-south-2.amazonaws.com", "s3.dualstack.ap-southeast-1.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-1.amazonaws.com", "s3-website.dualstack.ap-southeast-1.amazonaws.com", "s3.ap-southeast-1.amazonaws.com", "s3-accesspoint.ap-southeast-1.amazonaws.com", "s3-object-lambda.ap-southeast-1.amazonaws.com", "s3-website.ap-southeast-1.amazonaws.com", "s3.dualstack.ap-southeast-2.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-2.amazonaws.com", "s3-website.dualstack.ap-southeast-2.amazonaws.com", "s3.ap-southeast-2.amazonaws.com", "s3-accesspoint.ap-southeast-2.amazonaws.com", "s3-object-lambda.ap-southeast-2.amazonaws.com", "s3-website.ap-southeast-2.amazonaws.com", "s3.dualstack.ap-southeast-3.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-3.amazonaws.com", "s3-website.dualstack.ap-southeast-3.amazonaws.com", "s3.ap-southeast-3.amazonaws.com", "s3-accesspoint.ap-southeast-3.amazonaws.com", "s3-object-lambda.ap-southeast-3.amazonaws.com", "s3-website.ap-southeast-3.amazonaws.com", "s3.dualstack.ap-southeast-4.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-4.amazonaws.com", "s3-website.dualstack.ap-southeast-4.amazonaws.com", "s3.ap-southeast-4.amazonaws.com", "s3-accesspoint.ap-southeast-4.amazonaws.com", "s3-object-lambda.ap-southeast-4.amazonaws.com", "s3-website.ap-southeast-4.amazonaws.com", "s3.dualstack.ap-southeast-5.amazonaws.com", "s3-accesspoint.dualstack.ap-southeast-5.amazonaws.com", "s3-website.dualstack.ap-southeast-5.amazonaws.com", "s3.ap-southeast-5.amazonaws.com", "s3-accesspoint.ap-southeast-5.amazonaws.com", "s3-deprecated.ap-southeast-5.amazonaws.com", "s3-object-lambda.ap-southeast-5.amazonaws.com", "s3-website.ap-southeast-5.amazonaws.com", "s3.dualstack.ca-central-1.amazonaws.com", "s3-accesspoint.dualstack.ca-central-1.amazonaws.com", "s3-accesspoint-fips.dualstack.ca-central-1.amazonaws.com", "s3-fips.dualstack.ca-central-1.amazonaws.com", "s3-website.dualstack.ca-central-1.amazonaws.com", "s3.ca-central-1.amazonaws.com", "s3-accesspoint.ca-central-1.amazonaws.com", "s3-accesspoint-fips.ca-central-1.amazonaws.com", "s3-fips.ca-central-1.amazonaws.com", "s3-object-lambda.ca-central-1.amazonaws.com", "s3-website.ca-central-1.amazonaws.com", "s3.dualstack.ca-west-1.amazonaws.com", "s3-accesspoint.dualstack.ca-west-1.amazonaws.com", "s3-accesspoint-fips.dualstack.ca-west-1.amazonaws.com", "s3-fips.dualstack.ca-west-1.amazonaws.com", "s3-website.dualstack.ca-west-1.amazonaws.com", "s3.ca-west-1.amazonaws.com", "s3-accesspoint.ca-west-1.amazonaws.com", "s3-accesspoint-fips.ca-west-1.amazonaws.com", "s3-fips.ca-west-1.amazonaws.com", "s3-object-lambda.ca-west-1.amazonaws.com", "s3-website.ca-west-1.amazonaws.com", "s3.dualstack.eu-central-1.amazonaws.com", "s3-accesspoint.dualstack.eu-central-1.amazonaws.com", "s3-website.dualstack.eu-central-1.amazonaws.com", "s3.eu-central-1.amazonaws.com", "s3-accesspoint.eu-central-1.amazonaws.com", "s3-object-lambda.eu-central-1.amazonaws.com", "s3-website.eu-central-1.amazonaws.com", "s3.dualstack.eu-central-2.amazonaws.com", "s3-accesspoint.dualstack.eu-central-2.amazonaws.com", "s3-website.dualstack.eu-central-2.amazonaws.com", "s3.eu-central-2.amazonaws.com", "s3-accesspoint.eu-central-2.amazonaws.com", "s3-object-lambda.eu-central-2.amazonaws.com", "s3-website.eu-central-2.amazonaws.com", "s3.dualstack.eu-north-1.amazonaws.com", "s3-accesspoint.dualstack.eu-north-1.amazonaws.com", "s3.eu-north-1.amazonaws.com", "s3-accesspoint.eu-north-1.amazonaws.com", "s3-object-lambda.eu-north-1.amazonaws.com", "s3-website.eu-north-1.amazonaws.com", "s3.dualstack.eu-south-1.amazonaws.com", "s3-accesspoint.dualstack.eu-south-1.amazonaws.com", "s3-website.dualstack.eu-south-1.amazonaws.com", "s3.eu-south-1.amazonaws.com", "s3-accesspoint.eu-south-1.amazonaws.com", "s3-object-lambda.eu-south-1.amazonaws.com", "s3-website.eu-south-1.amazonaws.com", "s3.dualstack.eu-south-2.amazonaws.com", "s3-accesspoint.dualstack.eu-south-2.amazonaws.com", "s3-website.dualstack.eu-south-2.amazonaws.com", "s3.eu-south-2.amazonaws.com", "s3-accesspoint.eu-south-2.amazonaws.com", "s3-object-lambda.eu-south-2.amazonaws.com", "s3-website.eu-south-2.amazonaws.com", "s3.dualstack.eu-west-1.amazonaws.com", "s3-accesspoint.dualstack.eu-west-1.amazonaws.com", "s3-website.dualstack.eu-west-1.amazonaws.com", "s3.eu-west-1.amazonaws.com", "s3-accesspoint.eu-west-1.amazonaws.com", "s3-deprecated.eu-west-1.amazonaws.com", "s3-object-lambda.eu-west-1.amazonaws.com", "s3-website.eu-west-1.amazonaws.com", "s3.dualstack.eu-west-2.amazonaws.com", "s3-accesspoint.dualstack.eu-west-2.amazonaws.com", "s3.eu-west-2.amazonaws.com", "s3-accesspoint.eu-west-2.amazonaws.com", "s3-object-lambda.eu-west-2.amazonaws.com", "s3-website.eu-west-2.amazonaws.com", "s3.dualstack.eu-west-3.amazonaws.com", "s3-accesspoint.dualstack.eu-west-3.amazonaws.com", "s3-website.dualstack.eu-west-3.amazonaws.com", "s3.eu-west-3.amazonaws.com", "s3-accesspoint.eu-west-3.amazonaws.com", "s3-object-lambda.eu-west-3.amazonaws.com", "s3-website.eu-west-3.amazonaws.com", "s3.dualstack.il-central-1.amazonaws.com", "s3-accesspoint.dualstack.il-central-1.amazonaws.com", "s3-website.dualstack.il-central-1.amazonaws.com", "s3.il-central-1.amazonaws.com", "s3-accesspoint.il-central-1.amazonaws.com", "s3-object-lambda.il-central-1.amazonaws.com", "s3-website.il-central-1.amazonaws.com", "s3.dualstack.me-central-1.amazonaws.com", "s3-accesspoint.dualstack.me-central-1.amazonaws.com", "s3-website.dualstack.me-central-1.amazonaws.com", "s3.me-central-1.amazonaws.com", "s3-accesspoint.me-central-1.amazonaws.com", "s3-object-lambda.me-central-1.amazonaws.com", "s3-website.me-central-1.amazonaws.com", "s3.dualstack.me-south-1.amazonaws.com", "s3-accesspoint.dualstack.me-south-1.amazonaws.com", "s3.me-south-1.amazonaws.com", "s3-accesspoint.me-south-1.amazonaws.com", "s3-object-lambda.me-south-1.amazonaws.com", "s3-website.me-south-1.amazonaws.com", "s3.amazonaws.com", "s3-1.amazonaws.com", "s3-ap-east-1.amazonaws.com", "s3-ap-northeast-1.amazonaws.com", "s3-ap-northeast-2.amazonaws.com", "s3-ap-northeast-3.amazonaws.com", "s3-ap-south-1.amazonaws.com", "s3-ap-southeast-1.amazonaws.com", "s3-ap-southeast-2.amazonaws.com", "s3-ca-central-1.amazonaws.com", "s3-eu-central-1.amazonaws.com", "s3-eu-north-1.amazonaws.com", "s3-eu-west-1.amazonaws.com", "s3-eu-west-2.amazonaws.com", "s3-eu-west-3.amazonaws.com", "s3-external-1.amazonaws.com", "s3-fips-us-gov-east-1.amazonaws.com", "s3-fips-us-gov-west-1.amazonaws.com", "mrap.accesspoint.s3-global.amazonaws.com", "s3-me-south-1.amazonaws.com", "s3-sa-east-1.amazonaws.com", "s3-us-east-2.amazonaws.com", "s3-us-gov-east-1.amazonaws.com", "s3-us-gov-west-1.amazonaws.com", "s3-us-west-1.amazonaws.com", "s3-us-west-2.amazonaws.com", "s3-website-ap-northeast-1.amazonaws.com", "s3-website-ap-southeast-1.amazonaws.com", "s3-website-ap-southeast-2.amazonaws.com", "s3-website-eu-west-1.amazonaws.com", "s3-website-sa-east-1.amazonaws.com", "s3-website-us-east-1.amazonaws.com", "s3-website-us-gov-west-1.amazonaws.com", "s3-website-us-west-1.amazonaws.com", "s3-website-us-west-2.amazonaws.com", "s3.dualstack.sa-east-1.amazonaws.com", "s3-accesspoint.dualstack.sa-east-1.amazonaws.com", "s3-website.dualstack.sa-east-1.amazonaws.com", "s3.sa-east-1.amazonaws.com", "s3-accesspoint.sa-east-1.amazonaws.com", "s3-object-lambda.sa-east-1.amazonaws.com", "s3-website.sa-east-1.amazonaws.com", "s3.dualstack.us-east-1.amazonaws.com", "s3-accesspoint.dualstack.us-east-1.amazonaws.com", "s3-accesspoint-fips.dualstack.us-east-1.amazonaws.com", "s3-fips.dualstack.us-east-1.amazonaws.com", "s3-website.dualstack.us-east-1.amazonaws.com", "s3.us-east-1.amazonaws.com", "s3-accesspoint.us-east-1.amazonaws.com", "s3-accesspoint-fips.us-east-1.amazonaws.com", "s3-deprecated.us-east-1.amazonaws.com", "s3-fips.us-east-1.amazonaws.com", "s3-object-lambda.us-east-1.amazonaws.com", "s3-website.us-east-1.amazonaws.com", "s3.dualstack.us-east-2.amazonaws.com", "s3-accesspoint.dualstack.us-east-2.amazonaws.com", "s3-accesspoint-fips.dualstack.us-east-2.amazonaws.com", "s3-fips.dualstack.us-east-2.amazonaws.com", "s3-website.dualstack.us-east-2.amazonaws.com", "s3.us-east-2.amazonaws.com", "s3-accesspoint.us-east-2.amazonaws.com", "s3-accesspoint-fips.us-east-2.amazonaws.com", "s3-deprecated.us-east-2.amazonaws.com", "s3-fips.us-east-2.amazonaws.com", "s3-object-lambda.us-east-2.amazonaws.com", "s3-website.us-east-2.amazonaws.com", "s3.dualstack.us-gov-east-1.amazonaws.com", "s3-accesspoint.dualstack.us-gov-east-1.amazonaws.com", "s3-accesspoint-fips.dualstack.us-gov-east-1.amazonaws.com", "s3-fips.dualstack.us-gov-east-1.amazonaws.com", "s3.us-gov-east-1.amazonaws.com", "s3-accesspoint.us-gov-east-1.amazonaws.com", "s3-accesspoint-fips.us-gov-east-1.amazonaws.com", "s3-fips.us-gov-east-1.amazonaws.com", "s3-object-lambda.us-gov-east-1.amazonaws.com", "s3-website.us-gov-east-1.amazonaws.com", "s3.dualstack.us-gov-west-1.amazonaws.com", "s3-accesspoint.dualstack.us-gov-west-1.amazonaws.com", "s3-accesspoint-fips.dualstack.us-gov-west-1.amazonaws.com", "s3-fips.dualstack.us-gov-west-1.amazonaws.com", "s3.us-gov-west-1.amazonaws.com", "s3-accesspoint.us-gov-west-1.amazonaws.com", "s3-accesspoint-fips.us-gov-west-1.amazonaws.com", "s3-fips.us-gov-west-1.amazonaws.com", "s3-object-lambda.us-gov-west-1.amazonaws.com", "s3-website.us-gov-west-1.amazonaws.com", "s3.dualstack.us-west-1.amazonaws.com", "s3-accesspoint.dualstack.us-west-1.amazonaws.com", "s3-accesspoint-fips.dualstack.us-west-1.amazonaws.com", "s3-fips.dualstack.us-west-1.amazonaws.com", "s3-website.dualstack.us-west-1.amazonaws.com", "s3.us-west-1.amazonaws.com", "s3-accesspoint.us-west-1.amazonaws.com", "s3-accesspoint-fips.us-west-1.amazonaws.com", "s3-fips.us-west-1.amazonaws.com", "s3-object-lambda.us-west-1.amazonaws.com", "s3-website.us-west-1.amazonaws.com", "s3.dualstack.us-west-2.amazonaws.com", "s3-accesspoint.dualstack.us-west-2.amazonaws.com", "s3-accesspoint-fips.dualstack.us-west-2.amazonaws.com", "s3-fips.dualstack.us-west-2.amazonaws.com", "s3-website.dualstack.us-west-2.amazonaws.com", "s3.us-west-2.amazonaws.com", "s3-accesspoint.us-west-2.amazonaws.com", "s3-accesspoint-fips.us-west-2.amazonaws.com", "s3-deprecated.us-west-2.amazonaws.com", "s3-fips.us-west-2.amazonaws.com", "s3-object-lambda.us-west-2.amazonaws.com", "s3-website.us-west-2.amazonaws.com", "labeling.ap-northeast-1.sagemaker.aws", "labeling.ap-northeast-2.sagemaker.aws", "labeling.ap-south-1.sagemaker.aws", "labeling.ap-southeast-1.sagemaker.aws", "labeling.ap-southeast-2.sagemaker.aws", "labeling.ca-central-1.sagemaker.aws", "labeling.eu-central-1.sagemaker.aws", "labeling.eu-west-1.sagemaker.aws", "labeling.eu-west-2.sagemaker.aws", "labeling.us-east-1.sagemaker.aws", "labeling.us-east-2.sagemaker.aws", "labeling.us-west-2.sagemaker.aws", "notebook.af-south-1.sagemaker.aws", "notebook.ap-east-1.sagemaker.aws", "notebook.ap-northeast-1.sagemaker.aws", "notebook.ap-northeast-2.sagemaker.aws", "notebook.ap-northeast-3.sagemaker.aws", "notebook.ap-south-1.sagemaker.aws", "notebook.ap-south-2.sagemaker.aws", "notebook.ap-southeast-1.sagemaker.aws", "notebook.ap-southeast-2.sagemaker.aws", "notebook.ap-southeast-3.sagemaker.aws", "notebook.ap-southeast-4.sagemaker.aws", "notebook.ca-central-1.sagemaker.aws", "notebook-fips.ca-central-1.sagemaker.aws", "notebook.ca-west-1.sagemaker.aws", "notebook-fips.ca-west-1.sagemaker.aws", "notebook.eu-central-1.sagemaker.aws", "notebook.eu-central-2.sagemaker.aws", "notebook.eu-north-1.sagemaker.aws", "notebook.eu-south-1.sagemaker.aws", "notebook.eu-south-2.sagemaker.aws", "notebook.eu-west-1.sagemaker.aws", "notebook.eu-west-2.sagemaker.aws", "notebook.eu-west-3.sagemaker.aws", "notebook.il-central-1.sagemaker.aws", "notebook.me-central-1.sagemaker.aws", "notebook.me-south-1.sagemaker.aws", "notebook.sa-east-1.sagemaker.aws", "notebook.us-east-1.sagemaker.aws", "notebook-fips.us-east-1.sagemaker.aws", "notebook.us-east-2.sagemaker.aws", "notebook-fips.us-east-2.sagemaker.aws", "notebook.us-gov-east-1.sagemaker.aws", "notebook-fips.us-gov-east-1.sagemaker.aws", "notebook.us-gov-west-1.sagemaker.aws", "notebook-fips.us-gov-west-1.sagemaker.aws", "notebook.us-west-1.sagemaker.aws", "notebook-fips.us-west-1.sagemaker.aws", "notebook.us-west-2.sagemaker.aws", "notebook-fips.us-west-2.sagemaker.aws", "notebook.cn-north-1.sagemaker.com.cn", "notebook.cn-northwest-1.sagemaker.com.cn", "studio.af-south-1.sagemaker.aws", "studio.ap-east-1.sagemaker.aws", "studio.ap-northeast-1.sagemaker.aws", "studio.ap-northeast-2.sagemaker.aws", "studio.ap-northeast-3.sagemaker.aws", "studio.ap-south-1.sagemaker.aws", "studio.ap-southeast-1.sagemaker.aws", "studio.ap-southeast-2.sagemaker.aws", "studio.ap-southeast-3.sagemaker.aws", "studio.ca-central-1.sagemaker.aws", "studio.eu-central-1.sagemaker.aws", "studio.eu-north-1.sagemaker.aws", "studio.eu-south-1.sagemaker.aws", "studio.eu-south-2.sagemaker.aws", "studio.eu-west-1.sagemaker.aws", "studio.eu-west-2.sagemaker.aws", "studio.eu-west-3.sagemaker.aws", "studio.il-central-1.sagemaker.aws", "studio.me-central-1.sagemaker.aws", "studio.me-south-1.sagemaker.aws", "studio.sa-east-1.sagemaker.aws", "studio.us-east-1.sagemaker.aws", "studio.us-east-2.sagemaker.aws", "studio.us-gov-east-1.sagemaker.aws", "studio-fips.us-gov-east-1.sagemaker.aws", "studio.us-gov-west-1.sagemaker.aws", "studio-fips.us-gov-west-1.sagemaker.aws", "studio.us-west-1.sagemaker.aws", "studio.us-west-2.sagemaker.aws", "studio.cn-north-1.sagemaker.com.cn", "studio.cn-northwest-1.sagemaker.com.cn", "*.experiments.sagemaker.aws", "analytics-gateway.ap-northeast-1.amazonaws.com", "analytics-gateway.ap-northeast-2.amazonaws.com", "analytics-gateway.ap-south-1.amazonaws.com", "analytics-gateway.ap-southeast-1.amazonaws.com", "analytics-gateway.ap-southeast-2.amazonaws.com", "analytics-gateway.eu-central-1.amazonaws.com", "analytics-gateway.eu-west-1.amazonaws.com", "analytics-gateway.us-east-1.amazonaws.com", "analytics-gateway.us-east-2.amazonaws.com", "analytics-gateway.us-west-2.amazonaws.com", "amplifyapp.com", "*.awsapprunner.com", "webview-assets.aws-cloud9.af-south-1.amazonaws.com", "vfs.cloud9.af-south-1.amazonaws.com", "webview-assets.cloud9.af-south-1.amazonaws.com", "webview-assets.aws-cloud9.ap-east-1.amazonaws.com", "vfs.cloud9.ap-east-1.amazonaws.com", "webview-assets.cloud9.ap-east-1.amazonaws.com", "webview-assets.aws-cloud9.ap-northeast-1.amazonaws.com", "vfs.cloud9.ap-northeast-1.amazonaws.com", "webview-assets.cloud9.ap-northeast-1.amazonaws.com", "webview-assets.aws-cloud9.ap-northeast-2.amazonaws.com", "vfs.cloud9.ap-northeast-2.amazonaws.com", "webview-assets.cloud9.ap-northeast-2.amazonaws.com", "webview-assets.aws-cloud9.ap-northeast-3.amazonaws.com", "vfs.cloud9.ap-northeast-3.amazonaws.com", "webview-assets.cloud9.ap-northeast-3.amazonaws.com", "webview-assets.aws-cloud9.ap-south-1.amazonaws.com", "vfs.cloud9.ap-south-1.amazonaws.com", "webview-assets.cloud9.ap-south-1.amazonaws.com", "webview-assets.aws-cloud9.ap-southeast-1.amazonaws.com", "vfs.cloud9.ap-southeast-1.amazonaws.com", "webview-assets.cloud9.ap-southeast-1.amazonaws.com", "webview-assets.aws-cloud9.ap-southeast-2.amazonaws.com", "vfs.cloud9.ap-southeast-2.amazonaws.com", "webview-assets.cloud9.ap-southeast-2.amazonaws.com", "webview-assets.aws-cloud9.ca-central-1.amazonaws.com", "vfs.cloud9.ca-central-1.amazonaws.com", "webview-assets.cloud9.ca-central-1.amazonaws.com", "webview-assets.aws-cloud9.eu-central-1.amazonaws.com", "vfs.cloud9.eu-central-1.amazonaws.com", "webview-assets.cloud9.eu-central-1.amazonaws.com", "webview-assets.aws-cloud9.eu-north-1.amazonaws.com", "vfs.cloud9.eu-north-1.amazonaws.com", "webview-assets.cloud9.eu-north-1.amazonaws.com", "webview-assets.aws-cloud9.eu-south-1.amazonaws.com", "vfs.cloud9.eu-south-1.amazonaws.com", "webview-assets.cloud9.eu-south-1.amazonaws.com", "webview-assets.aws-cloud9.eu-west-1.amazonaws.com", "vfs.cloud9.eu-west-1.amazonaws.com", "webview-assets.cloud9.eu-west-1.amazonaws.com", "webview-assets.aws-cloud9.eu-west-2.amazonaws.com", "vfs.cloud9.eu-west-2.amazonaws.com", "webview-assets.cloud9.eu-west-2.amazonaws.com", "webview-assets.aws-cloud9.eu-west-3.amazonaws.com", "vfs.cloud9.eu-west-3.amazonaws.com", "webview-assets.cloud9.eu-west-3.amazonaws.com", "webview-assets.aws-cloud9.il-central-1.amazonaws.com", "vfs.cloud9.il-central-1.amazonaws.com", "webview-assets.aws-cloud9.me-south-1.amazonaws.com", "vfs.cloud9.me-south-1.amazonaws.com", "webview-assets.cloud9.me-south-1.amazonaws.com", "webview-assets.aws-cloud9.sa-east-1.amazonaws.com", "vfs.cloud9.sa-east-1.amazonaws.com", "webview-assets.cloud9.sa-east-1.amazonaws.com", "webview-assets.aws-cloud9.us-east-1.amazonaws.com", "vfs.cloud9.us-east-1.amazonaws.com", "webview-assets.cloud9.us-east-1.amazonaws.com", "webview-assets.aws-cloud9.us-east-2.amazonaws.com", "vfs.cloud9.us-east-2.amazonaws.com", "webview-assets.cloud9.us-east-2.amazonaws.com", "webview-assets.aws-cloud9.us-west-1.amazonaws.com", "vfs.cloud9.us-west-1.amazonaws.com", "webview-assets.cloud9.us-west-1.amazonaws.com", "webview-assets.aws-cloud9.us-west-2.amazonaws.com", "vfs.cloud9.us-west-2.amazonaws.com", "webview-assets.cloud9.us-west-2.amazonaws.com", "awsapps.com", "cn-north-1.eb.amazonaws.com.cn", "cn-northwest-1.eb.amazonaws.com.cn", "elasticbeanstalk.com", "af-south-1.elasticbeanstalk.com", "ap-east-1.elasticbeanstalk.com", "ap-northeast-1.elasticbeanstalk.com", "ap-northeast-2.elasticbeanstalk.com", "ap-northeast-3.elasticbeanstalk.com", "ap-south-1.elasticbeanstalk.com", "ap-southeast-1.elasticbeanstalk.com", "ap-southeast-2.elasticbeanstalk.com", "ap-southeast-3.elasticbeanstalk.com", "ca-central-1.elasticbeanstalk.com", "eu-central-1.elasticbeanstalk.com", "eu-north-1.elasticbeanstalk.com", "eu-south-1.elasticbeanstalk.com", "eu-west-1.elasticbeanstalk.com", "eu-west-2.elasticbeanstalk.com", "eu-west-3.elasticbeanstalk.com", "il-central-1.elasticbeanstalk.com", "me-south-1.elasticbeanstalk.com", "sa-east-1.elasticbeanstalk.com", "us-east-1.elasticbeanstalk.com", "us-east-2.elasticbeanstalk.com", "us-gov-east-1.elasticbeanstalk.com", "us-gov-west-1.elasticbeanstalk.com", "us-west-1.elasticbeanstalk.com", "us-west-2.elasticbeanstalk.com", "*.elb.amazonaws.com.cn", "*.elb.amazonaws.com", "awsglobalaccelerator.com", "*.private.repost.aws", "eero.online", "eero-stage.online", "apigee.io", "panel.dev", "siiites.com", "appspacehosted.com", "appspaceusercontent.com", "appudo.net", "on-aptible.com", "f5.si", "arvanedge.ir", "user.aseinet.ne.jp", "gv.vc", "d.gv.vc", "user.party.eus", "pimienta.org", "poivron.org", "potager.org", "sweetpepper.org", "myasustor.com", "cdn.prod.atlassian-dev.net", "translated.page", "myfritz.link", "myfritz.net", "onavstack.net", "*.awdev.ca", "*.advisor.ws", "ecommerce-shop.pl", "b-data.io", "balena-devices.com", "base.ec", "official.ec", "buyshop.jp", "fashionstore.jp", "handcrafted.jp", "kawaiishop.jp", "supersale.jp", "theshop.jp", "shopselect.net", "base.shop", "beagleboard.io", "*.beget.app", "pages.gay", "bnr.la", "bitbucket.io", "blackbaudcdn.net", "of.je", "bluebite.io", "boomla.net", "boutir.com", "boxfuse.io", "square7.ch", "bplaced.com", "bplaced.de", "square7.de", "bplaced.net", "square7.net", "*.s.brave.io", "shop.brendly.hr", "shop.brendly.rs", "browsersafetymark.io", "radio.am", "radio.fm", "uk0.bigv.io", "dh.bytemark.co.uk", "vm.bytemark.co.uk", "cafjs.com", "canva-apps.cn", "*.my.canvasite.cn", "canva-apps.com", "*.my.canva.site", "drr.ac", "uwu.ai", "carrd.co", "crd.co", "ju.mp", "api.gov.uk", "cdn77-storage.com", "rsc.contentproxy9.cz", "r.cdn77.net", "cdn77-ssl.net", "c.cdn77.org", "rsc.cdn77.org", "ssl.origin.cdn77-secure.org", "za.bz", "br.com", "cn.com", "de.com", "eu.com", "jpn.com", "mex.com", "ru.com", "sa.com", "uk.com", "us.com", "za.com", "com.de", "gb.net", "hu.net", "jp.net", "se.net", "uk.net", "ae.org", "com.se", "cx.ua", "discourse.group", "discourse.team", "clerk.app", "clerkstage.app", "*.lcl.dev", "*.lclstage.dev", "*.stg.dev", "*.stgstage.dev", "cleverapps.cc", "*.services.clever-cloud.com", "cleverapps.io", "cleverapps.tech", "clickrising.net", "cloudns.asia", "cloudns.be", "cloud-ip.biz", "cloudns.biz", "cloudns.cc", "cloudns.ch", "cloudns.cl", "cloudns.club", "dnsabr.com", "ip-ddns.com", "cloudns.cx", "cloudns.eu", "cloudns.in", "cloudns.info", "ddns-ip.net", "dns-cloud.net", "dns-dynamic.net", "cloudns.nz", "cloudns.org", "ip-dynamic.org", "cloudns.ph", "cloudns.pro", "cloudns.pw", "cloudns.us", "c66.me", "cloud66.ws", "cloud66.zone", "jdevcloud.com", "wpdevcloud.com", "cloudaccess.host", "freesite.host", "cloudaccess.net", "*.cloudera.site", "cf-ipfs.com", "cloudflare-ipfs.com", "trycloudflare.com", "pages.dev", "r2.dev", "workers.dev", "cloudflare.net", "cdn.cloudflare.net", "cdn.cloudflareanycast.net", "cdn.cloudflarecn.net", "cdn.cloudflareglobal.net", "cust.cloudscale.ch", "objects.lpg.cloudscale.ch", "objects.rma.cloudscale.ch", "wnext.app", "cnpy.gdn", "*.otap.co", "co.ca", "co.com", "codeberg.page", "csb.app", "preview.csb.app", "co.nl", "co.no", "webhosting.be", "hosting-cluster.nl", "ctfcloud.net", "convex.site", "ac.ru", "edu.ru", "gov.ru", "int.ru", "mil.ru", "test.ru", "dyn.cosidns.de", "dnsupdater.de", "dynamisches-dns.de", "internet-dns.de", "l-o-g-i-n.de", "dynamic-dns.info", "feste-ip.net", "knx-server.net", "static-access.net", "craft.me", "realm.cz", "on.crisp.email", "*.cryptonomic.net", "curv.dev", "cfolks.pl", "cyon.link", "cyon.site", "platform0.app", "fnwk.site", "folionetwork.site", "biz.dk", "co.dk", "firm.dk", "reg.dk", "store.dk", "dyndns.dappnode.io", "builtwithdark.com", "darklang.io", "demo.datadetect.com", "instance.datadetect.com", "edgestack.me", "dattolocal.com", "dattorelay.com", "dattoweb.com", "mydatto.com", "dattolocal.net", "mydatto.net", "ddnss.de", "dyn.ddnss.de", "dyndns.ddnss.de", "dyn-ip24.de", "dyndns1.de", "home-webserver.de", "dyn.home-webserver.de", "myhome-server.de", "ddnss.org", "debian.net", "definima.io", "definima.net", "deno.dev", "deno-staging.dev", "dedyn.io", "deta.app", "deta.dev", "dfirma.pl", "dkonto.pl", "you2.pl", "ondigitalocean.app", "*.digitaloceanspaces.com", "us.kg", "rss.my.id", "diher.solutions", "discordsays.com", "discordsez.com", "jozi.biz", "dnshome.de", "online.th", "shop.th", "drayddns.com", "shoparena.pl", "dreamhosters.com", "durumis.com", "mydrobo.com", "drud.io", "drud.us", "duckdns.org", "dy.fi", "tunk.org", "dyndns.biz", "for-better.biz", "for-more.biz", "for-some.biz", "for-the.biz", "selfip.biz", "webhop.biz", "ftpaccess.cc", "game-server.cc", "myphotos.cc", "scrapping.cc", "blogdns.com", "cechire.com", "dnsalias.com", "dnsdojo.com", "doesntexist.com", "dontexist.com", "doomdns.com", "dyn-o-saur.com", "dynalias.com", "dyndns-at-home.com", "dyndns-at-work.com", "dyndns-blog.com", "dyndns-free.com", "dyndns-home.com", "dyndns-ip.com", "dyndns-mail.com", "dyndns-office.com", "dyndns-pics.com", "dyndns-remote.com", "dyndns-server.com", "dyndns-web.com", "dyndns-wiki.com", "dyndns-work.com", "est-a-la-maison.com", "est-a-la-masion.com", "est-le-patron.com", "est-mon-blogueur.com", "from-ak.com", "from-al.com", "from-ar.com", "from-ca.com", "from-ct.com", "from-dc.com", "from-de.com", "from-fl.com", "from-ga.com", "from-hi.com", "from-ia.com", "from-id.com", "from-il.com", "from-in.com", "from-ks.com", "from-ky.com", "from-ma.com", "from-md.com", "from-mi.com", "from-mn.com", "from-mo.com", "from-ms.com", "from-mt.com", "from-nc.com", "from-nd.com", "from-ne.com", "from-nh.com", "from-nj.com", "from-nm.com", "from-nv.com", "from-oh.com", "from-ok.com", "from-or.com", "from-pa.com", "from-pr.com", "from-ri.com", "from-sc.com", "from-sd.com", "from-tn.com", "from-tx.com", "from-ut.com", "from-va.com", "from-vt.com", "from-wa.com", "from-wi.com", "from-wv.com", "from-wy.com", "getmyip.com", "gotdns.com", "hobby-site.com", "homelinux.com", "homeunix.com", "iamallama.com", "is-a-anarchist.com", "is-a-blogger.com", "is-a-bookkeeper.com", "is-a-bulls-fan.com", "is-a-caterer.com", "is-a-chef.com", "is-a-conservative.com", "is-a-cpa.com", "is-a-cubicle-slave.com", "is-a-democrat.com", "is-a-designer.com", "is-a-doctor.com", "is-a-financialadvisor.com", "is-a-geek.com", "is-a-green.com", "is-a-guru.com", "is-a-hard-worker.com", "is-a-hunter.com", "is-a-landscaper.com", "is-a-lawyer.com", "is-a-liberal.com", "is-a-libertarian.com", "is-a-llama.com", "is-a-musician.com", "is-a-nascarfan.com", "is-a-nurse.com", "is-a-painter.com", "is-a-personaltrainer.com", "is-a-photographer.com", "is-a-player.com", "is-a-republican.com", "is-a-rockstar.com", "is-a-socialist.com", "is-a-student.com", "is-a-teacher.com", "is-a-techie.com", "is-a-therapist.com", "is-an-accountant.com", "is-an-actor.com", "is-an-actress.com", "is-an-anarchist.com", "is-an-artist.com", "is-an-engineer.com", "is-an-entertainer.com", "is-certified.com", "is-gone.com", "is-into-anime.com", "is-into-cars.com", "is-into-cartoons.com", "is-into-games.com", "is-leet.com", "is-not-certified.com", "is-slick.com", "is-uberleet.com", "is-with-theband.com", "isa-geek.com", "isa-hockeynut.com", "issmarterthanyou.com", "likes-pie.com", "likescandy.com", "neat-url.com", "saves-the-whales.com", "selfip.com", "sells-for-less.com", "sells-for-u.com", "servebbs.com", "simple-url.com", "space-to-rent.com", "teaches-yoga.com", "writesthisblog.com", "ath.cx", "fuettertdasnetz.de", "isteingeek.de", "istmein.de", "lebtimnetz.de", "leitungsen.de", "traeumtgerade.de", "barrel-of-knowledge.info", "barrell-of-knowledge.info", "dyndns.info", "for-our.info", "groks-the.info", "groks-this.info", "here-for-more.info", "knowsitall.info", "selfip.info", "webhop.info", "forgot.her.name", "forgot.his.name", "at-band-camp.net", "blogdns.net", "broke-it.net", "buyshouses.net", "dnsalias.net", "dnsdojo.net", "does-it.net", "dontexist.net", "dynalias.net", "dynathome.net", "endofinternet.net", "from-az.net", "from-co.net", "from-la.net", "from-ny.net", "gets-it.net", "ham-radio-op.net", "homeftp.net", "homeip.net", "homelinux.net", "homeunix.net", "in-the-band.net", "is-a-chef.net", "is-a-geek.net", "isa-geek.net", "kicks-ass.net", "office-on-the.net", "podzone.net", "scrapper-site.net", "selfip.net", "sells-it.net", "servebbs.net", "serveftp.net", "thruhere.net", "webhop.net", "merseine.nu", "mine.nu", "shacknet.nu", "blogdns.org", "blogsite.org", "boldlygoingnowhere.org", "dnsalias.org", "dnsdojo.org", "doesntexist.org", "dontexist.org", "doomdns.org", "dvrdns.org", "dynalias.org", "dyndns.org", "go.dyndns.org", "home.dyndns.org", "endofinternet.org", "endoftheinternet.org", "from-me.org", "game-host.org", "gotdns.org", "hobby-site.org", "homedns.org", "homeftp.org", "homelinux.org", "homeunix.org", "is-a-bruinsfan.org", "is-a-candidate.org", "is-a-celticsfan.org", "is-a-chef.org", "is-a-geek.org", "is-a-knight.org", "is-a-linux-user.org", "is-a-patsfan.org", "is-a-soxfan.org", "is-found.org", "is-lost.org", "is-saved.org", "is-very-bad.org", "is-very-evil.org", "is-very-good.org", "is-very-nice.org", "is-very-sweet.org", "isa-geek.org", "kicks-ass.org", "misconfused.org", "podzone.org", "readmyblog.org", "selfip.org", "sellsyourhome.org", "servebbs.org", "serveftp.org", "servegame.org", "stuff-4-sale.org", "webhop.org", "better-than.tv", "dyndns.tv", "on-the-web.tv", "worse-than.tv", "is-by.us", "land-4-sale.us", "stuff-4-sale.us", "dyndns.ws", "mypets.ws", "ddnsfree.com", "ddnsgeek.com", "giize.com", "gleeze.com", "kozow.com", "loseyourip.com", "ooguy.com", "theworkpc.com", "casacam.net", "dynu.net", "accesscam.org", "camdvr.org", "freeddns.org", "mywire.org", "webredirect.org", "myddns.rocks", "dynv6.net", "e4.cz", "easypanel.app", "easypanel.host", "*.ewp.live", "twmail.cc", "twmail.net", "twmail.org", "mymailer.com.tw", "url.tw", "at.emf.camp", "rt.ht", "elementor.cloud", "elementor.cool", "en-root.fr", "mytuleap.com", "tuleap-partners.com", "encr.app", "encoreapi.com", "eu.encoway.cloud", "eu.org", "al.eu.org", "asso.eu.org", "at.eu.org", "au.eu.org", "be.eu.org", "bg.eu.org", "ca.eu.org", "cd.eu.org", "ch.eu.org", "cn.eu.org", "cy.eu.org", "cz.eu.org", "de.eu.org", "dk.eu.org", "edu.eu.org", "ee.eu.org", "es.eu.org", "fi.eu.org", "fr.eu.org", "gr.eu.org", "hr.eu.org", "hu.eu.org", "ie.eu.org", "il.eu.org", "in.eu.org", "int.eu.org", "is.eu.org", "it.eu.org", "jp.eu.org", "kr.eu.org", "lt.eu.org", "lu.eu.org", "lv.eu.org", "me.eu.org", "mk.eu.org", "mt.eu.org", "my.eu.org", "net.eu.org", "ng.eu.org", "nl.eu.org", "no.eu.org", "nz.eu.org", "pl.eu.org", "pt.eu.org", "ro.eu.org", "ru.eu.org", "se.eu.org", "si.eu.org", "sk.eu.org", "tr.eu.org", "uk.eu.org", "us.eu.org", "eurodir.ru", "eu-1.evennode.com", "eu-2.evennode.com", "eu-3.evennode.com", "eu-4.evennode.com", "us-1.evennode.com", "us-2.evennode.com", "us-3.evennode.com", "us-4.evennode.com", "relay.evervault.app", "relay.evervault.dev", "expo.app", "staging.expo.app", "onfabrica.com", "ru.net", "adygeya.ru", "bashkiria.ru", "bir.ru", "cbg.ru", "com.ru", "dagestan.ru", "grozny.ru", "kalmykia.ru", "kustanai.ru", "marine.ru", "mordovia.ru", "msk.ru", "mytis.ru", "nalchik.ru", "nov.ru", "pyatigorsk.ru", "spb.ru", "vladikavkaz.ru", "vladimir.ru", "abkhazia.su", "adygeya.su", "aktyubinsk.su", "arkhangelsk.su", "armenia.su", "ashgabad.su", "azerbaijan.su", "balashov.su", "bashkiria.su", "bryansk.su", "bukhara.su", "chimkent.su", "dagestan.su", "east-kazakhstan.su", "exnet.su", "georgia.su", "grozny.su", "ivanovo.su", "jambyl.su", "kalmykia.su", "kaluga.su", "karacol.su", "karaganda.su", "karelia.su", "khakassia.su", "krasnodar.su", "kurgan.su", "kustanai.su", "lenug.su", "mangyshlak.su", "mordovia.su", "msk.su", "murmansk.su", "nalchik.su", "navoi.su", "north-kazakhstan.su", "nov.su", "obninsk.su", "penza.su", "pokrovsk.su", "sochi.su", "spb.su", "tashkent.su", "termez.su", "togliatti.su", "troitsk.su", "tselinograd.su", "tula.su", "tuva.su", "vladikavkaz.su", "vladimir.su", "vologda.su", "channelsdvr.net", "u.channelsdvr.net", "edgecompute.app", "fastly-edge.com", "fastly-terrarium.com", "freetls.fastly.net", "map.fastly.net", "a.prod.fastly.net", "global.prod.fastly.net", "a.ssl.fastly.net", "b.ssl.fastly.net", "global.ssl.fastly.net", "fastlylb.net", "map.fastlylb.net", "*.user.fm", "fastvps-server.com", "fastvps.host", "myfast.host", "fastvps.site", "myfast.space", "conn.uk", "copro.uk", "hosp.uk", "fedorainfracloud.org", "fedorapeople.org", "cloud.fedoraproject.org", "app.os.fedoraproject.org", "app.os.stg.fedoraproject.org", "mydobiss.com", "fh-muenster.io", "filegear.me", "firebaseapp.com", "fldrv.com", "flutterflow.app", "fly.dev", "shw.io", "edgeapp.net", "forgeblocks.com", "id.forgerock.io", "framer.ai", "framer.app", "framercanvas.com", "framer.media", "framer.photos", "framer.website", "framer.wiki", "0e.vc", "freebox-os.com", "freeboxos.com", "fbx-os.fr", "fbxos.fr", "freebox-os.fr", "freeboxos.fr", "freedesktop.org", "freemyip.com", "*.frusky.de", "wien.funkfeuer.at", "daemon.asia", "dix.asia", "mydns.bz", "0am.jp", "0g0.jp", "0j0.jp", "0t0.jp", "mydns.jp", "pgw.jp", "wjg.jp", "keyword-on.net", "live-on.net", "server-on.net", "mydns.tw", "mydns.vc", "*.futurecms.at", "*.ex.futurecms.at", "*.in.futurecms.at", "futurehosting.at", "futuremailing.at", "*.ex.ortsinfo.at", "*.kunden.ortsinfo.at", "*.statics.cloud", "aliases121.com", "campaign.gov.uk", "service.gov.uk", "independent-commission.uk", "independent-inquest.uk", "independent-inquiry.uk", "independent-panel.uk", "independent-review.uk", "public-inquiry.uk", "royal-commission.uk", "gehirn.ne.jp", "usercontent.jp", "gentapps.com", "gentlentapis.com", "lab.ms", "cdn-edges.net", "localcert.net", "localhostcert.net", "gsj.bz", "githubusercontent.com", "githubpreview.dev", "github.io", "gitlab.io", "gitapp.si", "gitpage.si", "glitch.me", "nog.community", "co.ro", "shop.ro", "lolipop.io", "angry.jp", "babyblue.jp", "babymilk.jp", "backdrop.jp", "bambina.jp", "bitter.jp", "blush.jp", "boo.jp", "boy.jp", "boyfriend.jp", "but.jp", "candypop.jp", "capoo.jp", "catfood.jp", "cheap.jp", "chicappa.jp", "chillout.jp", "chips.jp", "chowder.jp", "chu.jp", "ciao.jp", "cocotte.jp", "coolblog.jp", "cranky.jp", "cutegirl.jp", "daa.jp", "deca.jp", "deci.jp", "digick.jp", "egoism.jp", "fakefur.jp", "fem.jp", "flier.jp", "floppy.jp", "fool.jp", "frenchkiss.jp", "girlfriend.jp", "girly.jp", "gloomy.jp", "gonna.jp", "greater.jp", "hacca.jp", "heavy.jp", "her.jp", "hiho.jp", "hippy.jp", "holy.jp", "hungry.jp", "icurus.jp", "itigo.jp", "jellybean.jp", "kikirara.jp", "kill.jp", "kilo.jp", "kuron.jp", "littlestar.jp", "lolipopmc.jp", "lolitapunk.jp", "lomo.jp", "lovepop.jp", "lovesick.jp", "main.jp", "mods.jp", "mond.jp", "mongolian.jp", "moo.jp", "namaste.jp", "nikita.jp", "nobushi.jp", "noor.jp", "oops.jp", "parallel.jp", "parasite.jp", "pecori.jp", "peewee.jp", "penne.jp", "pepper.jp", "perma.jp", "pigboat.jp", "pinoko.jp", "punyu.jp", "pupu.jp", "pussycat.jp", "pya.jp", "raindrop.jp", "readymade.jp", "sadist.jp", "schoolbus.jp", "secret.jp", "staba.jp", "stripper.jp", "sub.jp", "sunnyday.jp", "thick.jp", "tonkotsu.jp", "under.jp", "upper.jp", "velvet.jp", "verse.jp", "versus.jp", "vivian.jp", "watson.jp", "weblike.jp", "whitesnow.jp", "zombie.jp", "heteml.net", "graphic.design", "goip.de", "blogspot.ae", "blogspot.al", "blogspot.am", "*.hosted.app", "*.run.app", "web.app", "blogspot.com.ar", "blogspot.co.at", "blogspot.com.au", "blogspot.ba", "blogspot.be", "blogspot.bg", "blogspot.bj", "blogspot.com.br", "blogspot.com.by", "blogspot.ca", "blogspot.cf", "blogspot.ch", "blogspot.cl", "blogspot.com.co", "*.0emm.com", "appspot.com", "*.r.appspot.com", "blogspot.com", "codespot.com", "googleapis.com", "googlecode.com", "pagespeedmobilizer.com", "withgoogle.com", "withyoutube.com", "blogspot.cv", "blogspot.com.cy", "blogspot.cz", "blogspot.de", "*.gateway.dev", "blogspot.dk", "blogspot.com.ee", "blogspot.com.eg", "blogspot.com.es", "blogspot.fi", "blogspot.fr", "cloud.goog", "translate.goog", "*.usercontent.goog", "blogspot.gr", "blogspot.hk", "blogspot.hr", "blogspot.hu", "blogspot.co.id", "blogspot.ie", "blogspot.co.il", "blogspot.in", "blogspot.is", "blogspot.it", "blogspot.jp", "blogspot.co.ke", "blogspot.kr", "blogspot.li", "blogspot.lt", "blogspot.lu", "blogspot.md", "blogspot.mk", "blogspot.com.mt", "blogspot.mx", "blogspot.my", "cloudfunctions.net", "blogspot.com.ng", "blogspot.nl", "blogspot.no", "blogspot.co.nz", "blogspot.pe", "blogspot.pt", "blogspot.qa", "blogspot.re", "blogspot.ro", "blogspot.rs", "blogspot.ru", "blogspot.se", "blogspot.sg", "blogspot.si", "blogspot.sk", "blogspot.sn", "blogspot.td", "blogspot.com.tr", "blogspot.tw", "blogspot.ug", "blogspot.co.uk", "blogspot.com.uy", "blogspot.vn", "blogspot.co.za", "goupile.fr", "pymnt.uk", "cloudapps.digital", "london.cloudapps.digital", "gov.nl", "grafana-dev.net", "grayjayleagues.com", "gnstigbestellen.de", "gnstigliefern.de", "fin.ci", "free.hr", "caa.li", "ua.rs", "conf.se", "hkkinen.fi", "hrsn.dev", "hashbang.sh", "hasura.app", "hasura-app.io", "hatenablog.com", "hatenadiary.com", "hateblo.jp", "hatenablog.jp", "hatenadiary.jp", "hatenadiary.org", "pages.it.hs-heilbronn.de", "pages-research.it.hs-heilbronn.de", "heiyu.space", "helioho.st", "heliohost.us", "hepforge.org", "herokuapp.com", "herokussl.com", "heyflow.page", "heyflow.site", "ravendb.cloud", "ravendb.community", "development.run", "ravendb.run", "homesklep.pl", "*.kin.one", "*.id.pub", "*.kin.pub", "secaas.hk", "hoplix.shop", "orx.biz", "biz.gl", "biz.ng", "co.biz.ng", "dl.biz.ng", "go.biz.ng", "lg.biz.ng", "on.biz.ng", "col.ng", "firm.ng", "gen.ng", "ltd.ng", "ngo.ng", "plc.ng", "ie.ua", "hostyhosting.io", "hf.space", "static.hf.space", "hypernode.io", "iobb.net", "co.cz", "*.moonscale.io", "moonscale.net", "gr.com", "iki.fi", "ibxos.it", "iliadboxos.it", "smushcdn.com", "wphostedmail.com", "wpmucdn.com", "tempurl.host", "wpmudev.host", "dyn-berlin.de", "in-berlin.de", "in-brb.de", "in-butter.de", "in-dsl.de", "in-vpn.de", "in-dsl.net", "in-vpn.net", "in-dsl.org", "in-vpn.org", "biz.at", "info.at", "info.cx", "ac.leg.br", "al.leg.br", "am.leg.br", "ap.leg.br", "ba.leg.br", "ce.leg.br", "df.leg.br", "es.leg.br", "go.leg.br", "ma.leg.br", "mg.leg.br", "ms.leg.br", "mt.leg.br", "pa.leg.br", "pb.leg.br", "pe.leg.br", "pi.leg.br", "pr.leg.br", "rj.leg.br", "rn.leg.br", "ro.leg.br", "rr.leg.br", "rs.leg.br", "sc.leg.br", "se.leg.br", "sp.leg.br", "to.leg.br", "pixolino.com", "na4u.ru", "apps-1and1.com", "live-website.com", "apps-1and1.net", "websitebuilder.online", "app-ionos.space", "iopsys.se", "*.dweb.link", "ipifony.net", "ir.md", "is-a-good.dev", "is-a.dev", "iservschule.de", "mein-iserv.de", "schulplattform.de", "schulserver.de", "test-iserv.de", "iserv.dev", "mel.cloudlets.com.au", "cloud.interhostsolutions.be", "alp1.ae.flow.ch", "appengine.flow.ch", "es-1.axarnet.cloud", "diadem.cloud", "vip.jelastic.cloud", "jele.cloud", "it1.eur.aruba.jenv-aruba.cloud", "it1.jenv-aruba.cloud", "keliweb.cloud", "cs.keliweb.cloud", "oxa.cloud", "tn.oxa.cloud", "uk.oxa.cloud", "primetel.cloud", "uk.primetel.cloud", "ca.reclaim.cloud", "uk.reclaim.cloud", "us.reclaim.cloud", "ch.trendhosting.cloud", "de.trendhosting.cloud", "jele.club", "dopaas.com", "paas.hosted-by-previder.com", "rag-cloud.hosteur.com", "rag-cloud-ch.hosteur.com", "jcloud.ik-server.com", "jcloud-ver-jpc.ik-server.com", "demo.jelastic.com", "paas.massivegrid.com", "jed.wafaicloud.com", "ryd.wafaicloud.com", "j.scaleforce.com.cy", "jelastic.dogado.eu", "fi.cloudplatform.fi", "demo.datacenter.fi", "paas.datacenter.fi", "jele.host", "mircloud.host", "paas.beebyte.io", "sekd1.beebyteapp.io", "jele.io", "jc.neen.it", "jcloud.kz", "cloudjiffy.net", "fra1-de.cloudjiffy.net", "west1-us.cloudjiffy.net", "jls-sto1.elastx.net", "jls-sto2.elastx.net", "jls-sto3.elastx.net", "fr-1.paas.massivegrid.net", "lon-1.paas.massivegrid.net", "lon-2.paas.massivegrid.net", "ny-1.paas.massivegrid.net", "ny-2.paas.massivegrid.net", "sg-1.paas.massivegrid.net", "jelastic.saveincloud.net", "nordeste-idc.saveincloud.net", "j.scaleforce.net", "sdscloud.pl", "unicloud.pl", "mircloud.ru", "enscaled.sg", "jele.site", "jelastic.team", "orangecloud.tn", "j.layershift.co.uk", "phx.enscaled.us", "mircloud.us", "myjino.ru", "*.hosting.myjino.ru", "*.landing.myjino.ru", "*.spectrum.myjino.ru", "*.vps.myjino.ru", "jotelulu.cloud", "webadorsite.com", "jouwweb.site", "*.cns.joyent.com", "*.triton.zone", "js.org", "kaas.gg", "khplay.nl", "kapsi.fi", "ezproxy.kuleuven.be", "kuleuven.cloud", "keymachine.de", "kinghost.net", "uni5.net", "knightpoint.systems", "koobin.events", "webthings.io", "krellian.net", "oya.to", "git-repos.de", "lcube-server.de", "svn-repos.de", "leadpages.co", "lpages.co", "lpusercontent.com", "lelux.site", "libp2p.direct", "runcontainers.dev", "co.business", "co.education", "co.events", "co.financial", "co.network", "co.place", "co.technology", "linkyard-cloud.ch", "linkyard.cloud", "members.linode.com", "*.nodebalancer.linode.com", "*.linodeobjects.com", "ip.linodeusercontent.com", "we.bs", "filegear-sg.me", "ggff.net", "*.user.localcert.dev", "lodz.pl", "pabianice.pl", "plock.pl", "sieradz.pl", "skierniewice.pl", "zgierz.pl", "loginline.app", "loginline.dev", "loginline.io", "loginline.services", "loginline.site", "lohmus.me", "servers.run", "krasnik.pl", "leczna.pl", "lubartow.pl", "lublin.pl", "poniatowa.pl", "swidnik.pl", "glug.org.uk", "lug.org.uk", "lugs.org.uk", "barsy.bg", "barsy.club", "barsycenter.com", "barsyonline.com", "barsy.de", "barsy.dev", "barsy.eu", "barsy.gr", "barsy.in", "barsy.info", "barsy.io", "barsy.me", "barsy.menu", "barsyonline.menu", "barsy.mobi", "barsy.net", "barsy.online", "barsy.org", "barsy.pro", "barsy.pub", "barsy.ro", "barsy.rs", "barsy.shop", "barsyonline.shop", "barsy.site", "barsy.store", "barsy.support", "barsy.uk", "barsy.co.uk", "barsyonline.co.uk", "*.magentosite.cloud", "hb.cldmail.ru", "matlab.cloud", "modelscape.com", "mwcloudnonprod.com", "polyspace.com", "mayfirst.info", "mayfirst.org", "mazeplay.com", "mcdir.me", "mcdir.ru", "vps.mcdir.ru", "mcpre.ru", "mediatech.by", "mediatech.dev", "hra.health", "medusajs.app", "miniserver.com", "memset.net", "messerli.app", "atmeta.com", "apps.fbsbx.com", "*.cloud.metacentrum.cz", "custom.metacentrum.cz", "flt.cloud.muni.cz", "usr.cloud.muni.cz", "meteorapp.com", "eu.meteorapp.com", "co.pl", "*.azurecontainer.io", "azure-api.net", "azure-mobile.net", "azureedge.net", "azurefd.net", "azurestaticapps.net", "1.azurestaticapps.net", "2.azurestaticapps.net", "3.azurestaticapps.net", "4.azurestaticapps.net", "5.azurestaticapps.net", "6.azurestaticapps.net", "7.azurestaticapps.net", "centralus.azurestaticapps.net", "eastasia.azurestaticapps.net", "eastus2.azurestaticapps.net", "westeurope.azurestaticapps.net", "westus2.azurestaticapps.net", "azurewebsites.net", "cloudapp.net", "trafficmanager.net", "blob.core.windows.net", "servicebus.windows.net", "routingthecloud.com", "sn.mynetname.net", "routingthecloud.net", "routingthecloud.org", "csx.cc", "mydbserver.com", "webspaceconfig.de", "mittwald.info", "mittwaldserver.info", "typo3server.info", "project.space", "modx.dev", "bmoattachments.org", "net.ru", "org.ru", "pp.ru", "hostedpi.com", "caracal.mythic-beasts.com", "customer.mythic-beasts.com", "fentiger.mythic-beasts.com", "lynx.mythic-beasts.com", "ocelot.mythic-beasts.com", "oncilla.mythic-beasts.com", "onza.mythic-beasts.com", "sphinx.mythic-beasts.com", "vs.mythic-beasts.com", "x.mythic-beasts.com", "yali.mythic-beasts.com", "cust.retrosnub.co.uk", "ui.nabu.casa", "cloud.nospamproxy.com", "netfy.app", "netlify.app", "4u.com", "nfshost.com", "ipfs.nftstorage.link", "ngo.us", "ngrok.app", "ngrok-free.app", "ngrok.dev", "ngrok-free.dev", "ngrok.io", "ap.ngrok.io", "au.ngrok.io", "eu.ngrok.io", "in.ngrok.io", "jp.ngrok.io", "sa.ngrok.io", "us.ngrok.io", "ngrok.pizza", "ngrok.pro", "torun.pl", "nh-serv.co.uk", "nimsite.uk", "mmafan.biz", "myftp.biz", "no-ip.biz", "no-ip.ca", "fantasyleague.cc", "gotdns.ch", "3utilities.com", "blogsyte.com", "ciscofreak.com", "damnserver.com", "ddnsking.com", "ditchyourip.com", "dnsiskinky.com", "dynns.com", "geekgalaxy.com", "health-carereform.com", "homesecuritymac.com", "homesecuritypc.com", "myactivedirectory.com", "mysecuritycamera.com", "myvnc.com", "net-freaks.com", "onthewifi.com", "point2this.com", "quicksytes.com", "securitytactics.com", "servebeer.com", "servecounterstrike.com", "serveexchange.com", "serveftp.com", "servegame.com", "servehalflife.com", "servehttp.com", "servehumour.com", "serveirc.com", "servemp3.com", "servep2p.com", "servepics.com", "servequake.com", "servesarcasm.com", "stufftoread.com", "unusualperson.com", "workisboring.com", "dvrcam.info", "ilovecollege.info", "no-ip.info", "brasilia.me", "ddns.me", "dnsfor.me", "hopto.me", "loginto.me", "noip.me", "webhop.me", "bounceme.net", "ddns.net", "eating-organic.net", "mydissent.net", "myeffect.net", "mymediapc.net", "mypsx.net", "mysecuritycamera.net", "nhlfan.net", "no-ip.net", "pgafan.net", "privatizehealthinsurance.net", "redirectme.net", "serveblog.net", "serveminecraft.net", "sytes.net", "cable-modem.org", "collegefan.org", "couchpotatofries.org", "hopto.org", "mlbfan.org", "myftp.org", "mysecuritycamera.org", "nflfan.org", "no-ip.org", "read-books.org", "ufcfan.org", "zapto.org", "no-ip.co.uk", "golffan.us", "noip.us", "pointto.us", "stage.nodeart.io", "*.developer.app", "noop.app", "*.northflank.app", "*.build.run", "*.code.run", "*.database.run", "*.migration.run", "noticeable.news", "notion.site", "dnsking.ch", "mypi.co", "n4t.co", "001www.com", "myiphost.com", "forumz.info", "soundcast.me", "tcp4.me", "dnsup.net", "hicam.net", "now-dns.net", "ownip.net", "vpndns.net", "dynserv.org", "now-dns.org", "x443.pw", "now-dns.top", "ntdll.top", "freeddns.us", "nsupdate.info", "nerdpol.ovh", "nyc.mn", "prvcy.page", "obl.ong", "observablehq.cloud", "static.observableusercontent.com", "omg.lol", "cloudycluster.net", "omniwe.site", "123webseite.at", "123website.be", "simplesite.com.br", "123website.ch", "simplesite.com", "123webseite.de", "123hjemmeside.dk", "123miweb.es", "123kotisivu.fi", "123siteweb.fr", "simplesite.gr", "123homepage.it", "123website.lu", "123website.nl", "123hjemmeside.no", "service.one", "simplesite.pl", "123paginaweb.pt", "123minsida.se", "is-a-fullstack.dev", "is-cool.dev", "is-not-a.dev", "localplayer.dev", "is-local.org", "opensocial.site", "opencraft.hosting", "16-b.it", "32-b.it", "64-b.it", "orsites.com", "operaunite.com", "*.customer-oci.com", "*.oci.customer-oci.com", "*.ocp.customer-oci.com", "*.ocs.customer-oci.com", "*.oraclecloudapps.com", "*.oraclegovcloudapps.com", "*.oraclegovcloudapps.uk", "tech.orange", "can.re", "authgear-staging.com", "authgearapps.com", "skygearapp.com", "outsystemscloud.com", "*.hosting.ovh.net", "*.webpaas.ovh.net", "ownprovider.com", "own.pm", "*.owo.codes", "ox.rs", "oy.lc", "pgfog.com", "pagexl.com", "gotpantheon.com", "pantheonsite.io", "*.paywhirl.com", "*.xmit.co", "xmit.dev", "madethis.site", "srv.us", "gh.srv.us", "gl.srv.us", "lk3.ru", "mypep.link", "perspecta.cloud", "on-web.fr", "*.upsun.app", "upsunapp.com", "ent.platform.sh", "eu.platform.sh", "us.platform.sh", "*.platformsh.site", "*.tst.site", "platter-app.com", "platter-app.dev", "platterp.us", "pley.games", "onporter.run", "co.bn", "postman-echo.com", "pstmn.io", "mock.pstmn.io", "httpbin.org", "prequalifyme.today", "xen.prgmr.com", "priv.at", "protonet.io", "chirurgiens-dentistes-en-france.fr", "byen.site", "pubtls.org", "pythonanywhere.com", "eu.pythonanywhere.com", "qa2.com", "qcx.io", "*.sys.qcx.io", "myqnapcloud.cn", "alpha-myqnapcloud.com", "dev-myqnapcloud.com", "mycloudnas.com", "mynascloud.com", "myqnapcloud.com", "qoto.io", "qualifioapp.com", "ladesk.com", "qbuser.com", "*.quipelements.com", "vapor.cloud", "vaporcloud.io", "rackmaze.com", "rackmaze.net", "cloudsite.builders", "myradweb.net", "servername.us", "web.in", "in.net", "myrdbx.io", "site.rb-hosting.io", "*.on-rancher.cloud", "*.on-k3s.io", "*.on-rio.io", "ravpage.co.il", "readthedocs-hosted.com", "readthedocs.io", "rhcloud.com", "instances.spawn.cc", "onrender.com", "app.render.com", "replit.app", "id.replit.app", "firewalledreplit.co", "id.firewalledreplit.co", "repl.co", "id.repl.co", "replit.dev", "archer.replit.dev", "bones.replit.dev", "canary.replit.dev", "global.replit.dev", "hacker.replit.dev", "id.replit.dev", "janeway.replit.dev", "kim.replit.dev", "kira.replit.dev", "kirk.replit.dev", "odo.replit.dev", "paris.replit.dev", "picard.replit.dev", "pike.replit.dev", "prerelease.replit.dev", "reed.replit.dev", "riker.replit.dev", "sisko.replit.dev", "spock.replit.dev", "staging.replit.dev", "sulu.replit.dev", "tarpit.replit.dev", "teams.replit.dev", "tucker.replit.dev", "wesley.replit.dev", "worf.replit.dev", "repl.run", "resindevice.io", "devices.resinstaging.io", "hzc.io", "adimo.co.uk", "itcouldbewor.se", "aus.basketball", "nz.basketball", "git-pages.rit.edu", "rocky.page", "rub.de", "ruhr-uni-bochum.de", "io.noc.ruhr-uni-bochum.de", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "ras.ru", "nyat.app", "180r.com", "dojin.com", "sakuratan.com", "sakuraweb.com", "x0.com", "2-d.jp", "bona.jp", "crap.jp", "daynight.jp", "eek.jp", "flop.jp", "halfmoon.jp", "jeez.jp", "matrix.jp", "mimoza.jp", "ivory.ne.jp", "mail-box.ne.jp", "mints.ne.jp", "mokuren.ne.jp", "opal.ne.jp", "sakura.ne.jp", "sumomo.ne.jp", "topaz.ne.jp", "netgamers.jp", "nyanta.jp", "o0o0.jp", "rdy.jp", "rgr.jp", "rulez.jp", "s3.isk01.sakurastorage.jp", "s3.isk02.sakurastorage.jp", "saloon.jp", "sblo.jp", "skr.jp", "tank.jp", "uh-oh.jp", "undo.jp", "rs.webaccel.jp", "user.webaccel.jp", "websozai.jp", "xii.jp", "squares.net", "jpn.org", "kirara.st", "x0.to", "from.tv", "sakura.tv", "*.builder.code.com", "*.dev-builder.code.com", "*.stg-builder.code.com", "*.001.test.code-builder-stg.platform.salesforce.com", "*.d.crm.dev", "*.w.crm.dev", "*.wa.crm.dev", "*.wb.crm.dev", "*.wc.crm.dev", "*.wd.crm.dev", "*.we.crm.dev", "*.wf.crm.dev", "sandcats.io", "logoip.com", "logoip.de", "fr-par-1.baremetal.scw.cloud", "fr-par-2.baremetal.scw.cloud", "nl-ams-1.baremetal.scw.cloud", "cockpit.fr-par.scw.cloud", "fnc.fr-par.scw.cloud", "functions.fnc.fr-par.scw.cloud", "k8s.fr-par.scw.cloud", "nodes.k8s.fr-par.scw.cloud", "s3.fr-par.scw.cloud", "s3-website.fr-par.scw.cloud", "whm.fr-par.scw.cloud", "priv.instances.scw.cloud", "pub.instances.scw.cloud", "k8s.scw.cloud", "cockpit.nl-ams.scw.cloud", "k8s.nl-ams.scw.cloud", "nodes.k8s.nl-ams.scw.cloud", "s3.nl-ams.scw.cloud", "s3-website.nl-ams.scw.cloud", "whm.nl-ams.scw.cloud", "cockpit.pl-waw.scw.cloud", "k8s.pl-waw.scw.cloud", "nodes.k8s.pl-waw.scw.cloud", "s3.pl-waw.scw.cloud", "s3-website.pl-waw.scw.cloud", "scalebook.scw.cloud", "smartlabeling.scw.cloud", "dedibox.fr", "schokokeks.net", "gov.scot", "service.gov.scot", "scrysec.com", "client.scrypted.io", "firewall-gateway.com", "firewall-gateway.de", "my-gateway.de", "my-router.de", "spdns.de", "spdns.eu", "firewall-gateway.net", "my-firewall.org", "myfirewall.org", "spdns.org", "seidat.net", "sellfy.store", "minisite.ms", "senseering.net", "servebolt.cloud", "biz.ua", "co.ua", "pp.ua", "as.sh.cn", "sheezy.games", "shiftedit.io", "myshopblocks.com", "myshopify.com", "shopitsite.com", "shopware.shop", "shopware.store", "mo-siemens.io", "1kapp.com", "appchizi.com", "applinzi.com", "sinaapp.com", "vipsinaapp.com", "siteleaf.net", "small-web.org", "aeroport.fr", "avocat.fr", "chambagri.fr", "chirurgiens-dentistes.fr", "experts-comptables.fr", "medecin.fr", "notaires.fr", "pharmacien.fr", "port.fr", "veterinaire.fr", "vp4.me", "*.snowflake.app", "*.privatelink.snowflake.app", "streamlit.app", "streamlitapp.com", "try-snowplow.com", "mafelo.net", "playstation-cloud.com", "srht.site", "apps.lair.io", "*.stolos.io", "spacekit.io", "ind.mom", "customer.speedpartner.de", "myspreadshop.at", "myspreadshop.com.au", "myspreadshop.be", "myspreadshop.ca", "myspreadshop.ch", "myspreadshop.com", "myspreadshop.de", "myspreadshop.dk", "myspreadshop.es", "myspreadshop.fi", "myspreadshop.fr", "myspreadshop.ie", "myspreadshop.it", "myspreadshop.net", "myspreadshop.nl", "myspreadshop.no", "myspreadshop.pl", "myspreadshop.se", "myspreadshop.co.uk", "w-corp-staticblitz.com", "w-credentialless-staticblitz.com", "w-staticblitz.com", "stackhero-network.com", "runs.onstackit.cloud", "stackit.gg", "stackit.rocks", "stackit.run", "stackit.zone", "musician.io", "novecore.site", "api.stdlib.com", "feedback.ac", "forms.ac", "assessments.cx", "calculators.cx", "funnels.cx", "paynow.cx", "quizzes.cx", "researched.cx", "tests.cx", "surveys.so", "storebase.store", "storipress.app", "storj.farm", "strapiapp.com", "media.strapiapp.com", "vps-host.net", "atl.jelastic.vps-host.net", "njs.jelastic.vps-host.net", "ric.jelastic.vps-host.net", "streak-link.com", "streaklinks.com", "streakusercontent.com", "soc.srcf.net", "user.srcf.net", "utwente.io", "temp-dns.com", "supabase.co", "supabase.in", "supabase.net", "syncloud.it", "dscloud.biz", "direct.quickconnect.cn", "dsmynas.com", "familyds.com", "diskstation.me", "dscloud.me", "i234.me", "myds.me", "synology.me", "dscloud.mobi", "dsmynas.net", "familyds.net", "dsmynas.org", "familyds.org", "direct.quickconnect.to", "vpnplus.to", "mytabit.com", "mytabit.co.il", "tabitorder.co.il", "taifun-dns.de", "ts.net", "*.c.ts.net", "gda.pl", "gdansk.pl", "gdynia.pl", "med.pl", "sopot.pl", "taveusercontent.com", "p.tawk.email", "p.tawkto.email", "site.tb-hosting.com", "edugit.io", "s3.teckids.org", "telebit.app", "telebit.io", "*.telebit.xyz", "*.firenet.ch", "*.svc.firenet.ch", "reservd.com", "thingdustdata.com", "cust.dev.thingdust.io", "reservd.dev.thingdust.io", "cust.disrec.thingdust.io", "reservd.disrec.thingdust.io", "cust.prod.thingdust.io", "cust.testing.thingdust.io", "reservd.testing.thingdust.io", "tickets.io", "arvo.network", "azimuth.network", "tlon.network", "torproject.net", "pages.torproject.net", "townnews-staging.com", "12hp.at", "2ix.at", "4lima.at", "lima-city.at", "12hp.ch", "2ix.ch", "4lima.ch", "lima-city.ch", "trafficplex.cloud", "de.cool", "12hp.de", "2ix.de", "4lima.de", "lima-city.de", "1337.pictures", "clan.rip", "lima-city.rocks", "webspace.rocks", "lima.zone", "*.transurl.be", "*.transurl.eu", "site.transip.me", "*.transurl.nl", "tuxfamily.org", "dd-dns.de", "dray-dns.de", "draydns.de", "dyn-vpn.de", "dynvpn.de", "mein-vigor.de", "my-vigor.de", "my-wan.de", "syno-ds.de", "synology-diskstation.de", "synology-ds.de", "diskstation.eu", "diskstation.org", "typedream.app", "pro.typeform.com", "*.uberspace.de", "uber.space", "hk.com", "inc.hk", "ltd.hk", "hk.org", "it.com", "unison-services.cloud", "virtual-user.de", "virtualuser.de", "name.pm", "sch.tf", "biz.wf", "sch.wf", "org.yt", "rs.ba", "bielsko.pl", "upli.io", "urown.cloud", "dnsupdate.info", "us.org", "v.ua", "express.val.run", "web.val.run", "vercel.app", "v0.build", "vercel.dev", "vusercontent.net", "now.sh", "2038.io", "router.management", "v-info.info", "voorloper.cloud", "*.vultrobjects.com", "wafflecell.com", "webflow.io", "webflowtest.io", "*.webhare.dev", "bookonline.app", "hotelwithflight.com", "reserve-online.com", "reserve-online.net", "cprapid.com", "pleskns.com", "wp2.host", "pdns.page", "plesk.page", "wpsquared.site", "*.wadl.top", "remotewd.com", "box.ca", "pages.wiardweb.com", "toolforge.org", "wmcloud.org", "wmflabs.org", "wdh.app", "panel.gg", "daemon.panel.gg", "wixsite.com", "wixstudio.com", "editorx.io", "wixstudio.io", "wix.run", "messwithdns.com", "woltlab-demo.com", "myforum.community", "community-pro.de", "diskussionsbereich.de", "community-pro.net", "meinforum.net", "affinitylottery.org.uk", "raffleentry.org.uk", "weeklylottery.org.uk", "wpenginepowered.com", "js.wpenginepowered.com", "half.host", "xnbay.com", "u2.xnbay.com", "u2-local.xnbay.com", "cistron.nl", "demon.nl", "xs4all.space", "yandexcloud.net", "storage.yandexcloud.net", "website.yandexcloud.net", "official.academy", "yolasite.com", "yombo.me", "ynh.fr", "nohost.me", "noho.st", "za.net", "za.org", "zap.cloud", "zeabur.app", "bss.design", "basicserver.io", "virtualserver.io", "enterprisecloud.nu"];
  var Z = Y.reduce((e, s) => {
    const c = s.replace(/^(\*\.|\!)/, ""), o = A.toASCII(c), t = s.charAt(0);
    if (e.has(o))
      throw new Error(`Multiple rules found for ${s} (${o})`);
    return e.set(o, { rule: s, suffix: c, punySuffix: o, wildcard: t === "*", exception: t === "!" }), e;
  }, new Map);
  var aa = (e) => {
    const c = A.toASCII(e).split(".");
    for (let o = 0;o < c.length; o++) {
      const t = c.slice(o).join("."), d = Z.get(t);
      if (d)
        return d;
    }
    return null;
  };
  var H = { DOMAIN_TOO_SHORT: "Domain name too short.", DOMAIN_TOO_LONG: "Domain name too long. It should be no more than 255 chars.", LABEL_STARTS_WITH_DASH: "Domain name label can not start with a dash.", LABEL_ENDS_WITH_DASH: "Domain name label can not end with a dash.", LABEL_TOO_LONG: "Domain name label should be at most 63 chars long.", LABEL_TOO_SHORT: "Domain name label should be at least 1 character long.", LABEL_INVALID_CHARS: "Domain name label can only contain alphanumeric characters or dashes." };
  var oa = (e) => {
    const s = A.toASCII(e);
    if (s.length < 1)
      return "DOMAIN_TOO_SHORT";
    if (s.length > 255)
      return "DOMAIN_TOO_LONG";
    const c = s.split(".");
    let o;
    for (let t = 0;t < c.length; ++t) {
      if (o = c[t], !o.length)
        return "LABEL_TOO_SHORT";
      if (o.length > 63)
        return "LABEL_TOO_LONG";
      if (o.charAt(0) === "-")
        return "LABEL_STARTS_WITH_DASH";
      if (o.charAt(o.length - 1) === "-")
        return "LABEL_ENDS_WITH_DASH";
      if (!/^[a-z0-9\-_]+$/.test(o))
        return "LABEL_INVALID_CHARS";
    }
  };
  var _ = (e) => {
    if (typeof e != "string")
      throw new TypeError("Domain name must be a string.");
    let s = e.slice(0).toLowerCase();
    s.charAt(s.length - 1) === "." && (s = s.slice(0, s.length - 1));
    const c = oa(s);
    if (c)
      return { input: e, error: { message: H[c], code: c } };
    const o = { input: e, tld: null, sld: null, domain: null, subdomain: null, listed: false }, t = s.split(".");
    if (t[t.length - 1] === "local")
      return o;
    const d = () => (/xn--/.test(s) && (o.domain && (o.domain = A.toASCII(o.domain)), o.subdomain && (o.subdomain = A.toASCII(o.subdomain))), o), z = aa(s);
    if (!z)
      return t.length < 2 ? o : (o.tld = t.pop(), o.sld = t.pop(), o.domain = [o.sld, o.tld].join("."), t.length && (o.subdomain = t.pop()), d());
    o.listed = true;
    const y = z.suffix.split("."), g = t.slice(0, t.length - y.length);
    return z.exception && g.push(y.shift()), o.tld = y.join("."), !g.length || (z.wildcard && (y.unshift(g.pop()), o.tld = y.join(".")), !g.length) || (o.sld = g.pop(), o.domain = [o.sld, o.tld].join("."), g.length && (o.subdomain = g.join("."))), d();
  };
  var N = (e) => e && _(e).domain || null;
  var R = (e) => {
    const s = _(e);
    return !!(s.domain && s.listed);
  };
  var sa = { parse: _, get: N, isValid: R };
  exports2.default = sa;
  exports2.errorCodes = H;
  exports2.get = N;
  exports2.isValid = R;
  exports2.parse = _;
});

// backend/node_modules/@cypress/request-promise/node_modules/tough-cookie/lib/pubsuffix-psl.js
var require_pubsuffix_psl = __commonJS((exports2) => {
  /*!
   * Copyright (c) 2018, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  var psl = require_psl();
  var SPECIAL_USE_DOMAINS = [
    "local",
    "example",
    "invalid",
    "localhost",
    "test"
  ];
  var SPECIAL_TREATMENT_DOMAINS = ["localhost", "invalid"];
  function getPublicSuffix(domain, options = {}) {
    const domainParts = domain.split(".");
    const topLevelDomain = domainParts[domainParts.length - 1];
    const allowSpecialUseDomain = !!options.allowSpecialUseDomain;
    const ignoreError = !!options.ignoreError;
    if (allowSpecialUseDomain && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {
      if (domainParts.length > 1) {
        const secondLevelDomain = domainParts[domainParts.length - 2];
        return `${secondLevelDomain}.${topLevelDomain}`;
      } else if (SPECIAL_TREATMENT_DOMAINS.includes(topLevelDomain)) {
        return `${topLevelDomain}`;
      }
    }
    if (!ignoreError && SPECIAL_USE_DOMAINS.includes(topLevelDomain)) {
      throw new Error(`Cookie has domain set to the public suffix "${topLevelDomain}" which is a special use domain. To allow this, configure your CookieJar with {allowSpecialUseDomain:true, rejectPublicSuffixes: false}.`);
    }
    return psl.get(domain);
  }
  exports2.getPublicSuffix = getPublicSuffix;
});

// backend/node_modules/@cypress/request-promise/node_modules/tough-cookie/lib/store.js
var require_store2 = __commonJS((exports2) => {
  /*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */

  class Store {
    constructor() {
      this.synchronous = false;
    }
    findCookie(domain, path2, key, cb) {
      throw new Error("findCookie is not implemented");
    }
    findCookies(domain, path2, allowSpecialUseDomain, cb) {
      throw new Error("findCookies is not implemented");
    }
    putCookie(cookie, cb) {
      throw new Error("putCookie is not implemented");
    }
    updateCookie(oldCookie, newCookie, cb) {
      throw new Error("updateCookie is not implemented");
    }
    removeCookie(domain, path2, key, cb) {
      throw new Error("removeCookie is not implemented");
    }
    removeCookies(domain, path2, cb) {
      throw new Error("removeCookies is not implemented");
    }
    removeAllCookies(cb) {
      throw new Error("removeAllCookies is not implemented");
    }
    getAllCookies(cb) {
      throw new Error("getAllCookies is not implemented (therefore jar cannot be serialized)");
    }
  }
  exports2.Store = Store;
});

// backend/node_modules/universalify/index.js
var require_universalify = __commonJS((exports2) => {
  exports2.fromCallback = function(fn) {
    return Object.defineProperty(function() {
      if (typeof arguments[arguments.length - 1] === "function")
        fn.apply(this, arguments);
      else {
        return new Promise((resolve, reject) => {
          arguments[arguments.length] = (err, res) => {
            if (err)
              return reject(err);
            resolve(res);
          };
          arguments.length++;
          fn.apply(this, arguments);
        });
      }
    }, "name", { value: fn.name });
  };
  exports2.fromPromise = function(fn) {
    return Object.defineProperty(function() {
      const cb = arguments[arguments.length - 1];
      if (typeof cb !== "function")
        return fn.apply(this, arguments);
      else {
        delete arguments[arguments.length - 1];
        arguments.length--;
        fn.apply(this, arguments).then((r) => cb(null, r), cb);
      }
    }, "name", { value: fn.name });
  };
});

// backend/node_modules/@cypress/request-promise/node_modules/tough-cookie/lib/permuteDomain.js
var require_permuteDomain2 = __commonJS((exports2) => {
  /*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  var pubsuffix = require_pubsuffix_psl();
  function permuteDomain(domain, allowSpecialUseDomain) {
    const pubSuf = pubsuffix.getPublicSuffix(domain, {
      allowSpecialUseDomain
    });
    if (!pubSuf) {
      return null;
    }
    if (pubSuf == domain) {
      return [domain];
    }
    if (domain.slice(-1) == ".") {
      domain = domain.slice(0, -1);
    }
    const prefix = domain.slice(0, -(pubSuf.length + 1));
    const parts = prefix.split(".").reverse();
    let cur = pubSuf;
    const permutations = [cur];
    while (parts.length) {
      cur = `${parts.shift()}.${cur}`;
      permutations.push(cur);
    }
    return permutations;
  }
  exports2.permuteDomain = permuteDomain;
});

// backend/node_modules/@cypress/request-promise/node_modules/tough-cookie/lib/pathMatch.js
var require_pathMatch2 = __commonJS((exports2) => {
  /*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  function pathMatch(reqPath, cookiePath) {
    if (cookiePath === reqPath) {
      return true;
    }
    const idx = reqPath.indexOf(cookiePath);
    if (idx === 0) {
      if (cookiePath.substr(-1) === "/") {
        return true;
      }
      if (reqPath.substr(cookiePath.length, 1) === "/") {
        return true;
      }
    }
    return false;
  }
  exports2.pathMatch = pathMatch;
});

// backend/node_modules/@cypress/request-promise/node_modules/tough-cookie/lib/utilHelper.js
var require_utilHelper = __commonJS((exports2) => {
  function requireUtil() {
    try {
      return require("util");
    } catch (e) {
      return null;
    }
  }
  function lookupCustomInspectSymbol() {
    return Symbol.for("nodejs.util.inspect.custom");
  }
  function tryReadingCustomSymbolFromUtilInspect(options) {
    const _requireUtil = options.requireUtil || requireUtil;
    const util3 = _requireUtil();
    return util3 ? util3.inspect.custom : null;
  }
  exports2.getUtilInspect = function getUtilInspect(fallback, options = {}) {
    const _requireUtil = options.requireUtil || requireUtil;
    const util3 = _requireUtil();
    return function inspect(value, showHidden, depth) {
      return util3 ? util3.inspect(value, showHidden, depth) : fallback(value);
    };
  };
  exports2.getCustomInspectSymbol = function getCustomInspectSymbol(options = {}) {
    const _lookupCustomInspectSymbol = options.lookupCustomInspectSymbol || lookupCustomInspectSymbol;
    return _lookupCustomInspectSymbol() || tryReadingCustomSymbolFromUtilInspect(options);
  };
});

// backend/node_modules/@cypress/request-promise/node_modules/tough-cookie/lib/memstore.js
var require_memstore2 = __commonJS((exports2) => {
  /*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  var { fromCallback } = require_universalify();
  var Store = require_store2().Store;
  var permuteDomain = require_permuteDomain2().permuteDomain;
  var pathMatch = require_pathMatch2().pathMatch;
  var { getCustomInspectSymbol, getUtilInspect } = require_utilHelper();

  class MemoryCookieStore extends Store {
    constructor() {
      super();
      this.synchronous = true;
      this.idx = Object.create(null);
      const customInspectSymbol = getCustomInspectSymbol();
      if (customInspectSymbol) {
        this[customInspectSymbol] = this.inspect;
      }
    }
    inspect() {
      const util3 = { inspect: getUtilInspect(inspectFallback) };
      return `{ idx: ${util3.inspect(this.idx, false, 2)} }`;
    }
    findCookie(domain, path2, key, cb) {
      if (!this.idx[domain]) {
        return cb(null, undefined);
      }
      if (!this.idx[domain][path2]) {
        return cb(null, undefined);
      }
      return cb(null, this.idx[domain][path2][key] || null);
    }
    findCookies(domain, path2, allowSpecialUseDomain, cb) {
      const results = [];
      if (typeof allowSpecialUseDomain === "function") {
        cb = allowSpecialUseDomain;
        allowSpecialUseDomain = true;
      }
      if (!domain) {
        return cb(null, []);
      }
      let pathMatcher;
      if (!path2) {
        pathMatcher = function matchAll(domainIndex) {
          for (const curPath in domainIndex) {
            const pathIndex = domainIndex[curPath];
            for (const key in pathIndex) {
              results.push(pathIndex[key]);
            }
          }
        };
      } else {
        pathMatcher = function matchRFC(domainIndex) {
          Object.keys(domainIndex).forEach((cookiePath) => {
            if (pathMatch(path2, cookiePath)) {
              const pathIndex = domainIndex[cookiePath];
              for (const key in pathIndex) {
                results.push(pathIndex[key]);
              }
            }
          });
        };
      }
      const domains = permuteDomain(domain, allowSpecialUseDomain) || [domain];
      const idx = this.idx;
      domains.forEach((curDomain) => {
        const domainIndex = idx[curDomain];
        if (!domainIndex) {
          return;
        }
        pathMatcher(domainIndex);
      });
      cb(null, results);
    }
    putCookie(cookie, cb) {
      if (!this.idx[cookie.domain]) {
        this.idx[cookie.domain] = Object.create(null);
      }
      if (!this.idx[cookie.domain][cookie.path]) {
        this.idx[cookie.domain][cookie.path] = Object.create(null);
      }
      this.idx[cookie.domain][cookie.path][cookie.key] = cookie;
      cb(null);
    }
    updateCookie(oldCookie, newCookie, cb) {
      this.putCookie(newCookie, cb);
    }
    removeCookie(domain, path2, key, cb) {
      if (this.idx[domain] && this.idx[domain][path2] && this.idx[domain][path2][key]) {
        delete this.idx[domain][path2][key];
      }
      cb(null);
    }
    removeCookies(domain, path2, cb) {
      if (this.idx[domain]) {
        if (path2) {
          delete this.idx[domain][path2];
        } else {
          delete this.idx[domain];
        }
      }
      return cb(null);
    }
    removeAllCookies(cb) {
      this.idx = Object.create(null);
      return cb(null);
    }
    getAllCookies(cb) {
      const cookies = [];
      const idx = this.idx;
      const domains = Object.keys(idx);
      domains.forEach((domain) => {
        const paths = Object.keys(idx[domain]);
        paths.forEach((path2) => {
          const keys = Object.keys(idx[domain][path2]);
          keys.forEach((key) => {
            if (key !== null) {
              cookies.push(idx[domain][path2][key]);
            }
          });
        });
      });
      cookies.sort((a, b) => {
        return (a.creationIndex || 0) - (b.creationIndex || 0);
      });
      cb(null, cookies);
    }
  }
  [
    "findCookie",
    "findCookies",
    "putCookie",
    "updateCookie",
    "removeCookie",
    "removeCookies",
    "removeAllCookies",
    "getAllCookies"
  ].forEach((name) => {
    MemoryCookieStore.prototype[name] = fromCallback(MemoryCookieStore.prototype[name]);
  });
  exports2.MemoryCookieStore = MemoryCookieStore;
  function inspectFallback(val) {
    const domains = Object.keys(val);
    if (domains.length === 0) {
      return "[Object: null prototype] {}";
    }
    let result = `[Object: null prototype] {
`;
    Object.keys(val).forEach((domain, i) => {
      result += formatDomain(domain, val[domain]);
      if (i < domains.length - 1) {
        result += ",";
      }
      result += `
`;
    });
    result += "}";
    return result;
  }
  function formatDomain(domainName, domainValue) {
    const indent = "  ";
    let result = `${indent}'${domainName}': [Object: null prototype] {
`;
    Object.keys(domainValue).forEach((path2, i, paths) => {
      result += formatPath(path2, domainValue[path2]);
      if (i < paths.length - 1) {
        result += ",";
      }
      result += `
`;
    });
    result += `${indent}}`;
    return result;
  }
  function formatPath(pathName, pathValue) {
    const indent = "    ";
    let result = `${indent}'${pathName}': [Object: null prototype] {
`;
    Object.keys(pathValue).forEach((cookieName, i, cookieNames) => {
      const cookie = pathValue[cookieName];
      result += `      ${cookieName}: ${cookie.inspect()}`;
      if (i < cookieNames.length - 1) {
        result += ",";
      }
      result += `
`;
    });
    result += `${indent}}`;
    return result;
  }
  exports2.inspectFallback = inspectFallback;
});

// backend/node_modules/@cypress/request-promise/node_modules/tough-cookie/lib/validators.js
var require_validators2 = __commonJS((exports2) => {
  var toString3 = Object.prototype.toString;
  function isFunction3(data) {
    return typeof data === "function";
  }
  function isNonEmptyString(data) {
    return isString2(data) && data !== "";
  }
  function isDate2(data) {
    return isInstanceStrict(data, Date) && isInteger(data.getTime());
  }
  function isEmptyString(data) {
    return data === "" || data instanceof String && data.toString() === "";
  }
  function isString2(data) {
    return typeof data === "string" || data instanceof String;
  }
  function isObject2(data) {
    return toString3.call(data) === "[object Object]";
  }
  function isInstanceStrict(data, prototype3) {
    try {
      return data instanceof prototype3;
    } catch (error2) {
      return false;
    }
  }
  function isUrlStringOrObject(data) {
    return isNonEmptyString(data) || isObject2(data) && "hostname" in data && "pathname" in data && "protocol" in data || isInstanceStrict(data, URL);
  }
  function isInteger(data) {
    return typeof data === "number" && data % 1 === 0;
  }
  function validate(bool, cb, options) {
    if (!isFunction3(cb)) {
      options = cb;
      cb = null;
    }
    if (!isObject2(options))
      options = { Error: "Failed Check" };
    if (!bool) {
      if (cb) {
        cb(new ParameterError(options));
      } else {
        throw new ParameterError(options);
      }
    }
  }

  class ParameterError extends Error {
    constructor(...params) {
      super(...params);
    }
  }
  exports2.ParameterError = ParameterError;
  exports2.isFunction = isFunction3;
  exports2.isNonEmptyString = isNonEmptyString;
  exports2.isDate = isDate2;
  exports2.isEmptyString = isEmptyString;
  exports2.isString = isString2;
  exports2.isObject = isObject2;
  exports2.isUrlStringOrObject = isUrlStringOrObject;
  exports2.validate = validate;
});

// backend/node_modules/@cypress/request-promise/node_modules/tough-cookie/lib/version.js
var require_version7 = __commonJS((exports2, module2) => {
  module2.exports = "4.1.4";
});

// backend/node_modules/@cypress/request-promise/node_modules/tough-cookie/lib/cookie.js
var require_cookie3 = __commonJS((exports2) => {
  /*!
   * Copyright (c) 2015-2020, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  var punycode = require_punycode();
  var urlParse = require_url_parse();
  var pubsuffix = require_pubsuffix_psl();
  var Store = require_store2().Store;
  var MemoryCookieStore = require_memstore2().MemoryCookieStore;
  var pathMatch = require_pathMatch2().pathMatch;
  var validators3 = require_validators2();
  var VERSION3 = require_version7();
  var { fromCallback } = require_universalify();
  var { getCustomInspectSymbol } = require_utilHelper();
  var COOKIE_OCTETS = /^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/;
  var CONTROL_CHARS = /[\x00-\x1F]/;
  var TERMINATORS = [`
`, "\r", "\x00"];
  var PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;
  var DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;
  var MONTH_TO_NUM = {
    jan: 0,
    feb: 1,
    mar: 2,
    apr: 3,
    may: 4,
    jun: 5,
    jul: 6,
    aug: 7,
    sep: 8,
    oct: 9,
    nov: 10,
    dec: 11
  };
  var MAX_TIME = 2147483647000;
  var MIN_TIME = 0;
  var SAME_SITE_CONTEXT_VAL_ERR = 'Invalid sameSiteContext option for getCookies(); expected one of "strict", "lax", or "none"';
  function checkSameSiteContext(value) {
    validators3.validate(validators3.isNonEmptyString(value), value);
    const context = String(value).toLowerCase();
    if (context === "none" || context === "lax" || context === "strict") {
      return context;
    } else {
      return null;
    }
  }
  var PrefixSecurityEnum = Object.freeze({
    SILENT: "silent",
    STRICT: "strict",
    DISABLED: "unsafe-disabled"
  });
  var IP_REGEX_LOWERCASE = /(?:^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}$)|(?:^(?:(?:[a-f\d]{1,4}:){7}(?:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|:[a-f\d]{1,4}|:)|(?:[a-f\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,2}|:)|(?:[a-f\d]{1,4}:){4}(?:(?::[a-f\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,3}|:)|(?:[a-f\d]{1,4}:){3}(?:(?::[a-f\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,4}|:)|(?:[a-f\d]{1,4}:){2}(?:(?::[a-f\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,5}|:)|(?:[a-f\d]{1,4}:){1}(?:(?::[a-f\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,6}|:)|(?::(?:(?::[a-f\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-f\d]{1,4}){1,7}|:)))$)/;
  var IP_V6_REGEX = `
\\[?(?:
(?:[a-fA-F\\d]{1,4}:){7}(?:[a-fA-F\\d]{1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|:[a-fA-F\\d]{1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,2}|:)|
(?:[a-fA-F\\d]{1,4}:){4}(?:(?::[a-fA-F\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,3}|:)|
(?:[a-fA-F\\d]{1,4}:){3}(?:(?::[a-fA-F\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,4}|:)|
(?:[a-fA-F\\d]{1,4}:){2}(?:(?::[a-fA-F\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,5}|:)|
(?:[a-fA-F\\d]{1,4}:){1}(?:(?::[a-fA-F\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,6}|:)|
(?::(?:(?::[a-fA-F\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,7}|:))
)(?:%[0-9a-zA-Z]{1,})?\\]?
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
  var IP_V6_REGEX_OBJECT = new RegExp(`^${IP_V6_REGEX}$`);
  function parseDigits(token, minDigits, maxDigits, trailingOK) {
    let count = 0;
    while (count < token.length) {
      const c = token.charCodeAt(count);
      if (c <= 47 || c >= 58) {
        break;
      }
      count++;
    }
    if (count < minDigits || count > maxDigits) {
      return null;
    }
    if (!trailingOK && count != token.length) {
      return null;
    }
    return parseInt(token.substr(0, count), 10);
  }
  function parseTime(token) {
    const parts = token.split(":");
    const result = [0, 0, 0];
    if (parts.length !== 3) {
      return null;
    }
    for (let i = 0;i < 3; i++) {
      const trailingOK = i == 2;
      const num = parseDigits(parts[i], 1, 2, trailingOK);
      if (num === null) {
        return null;
      }
      result[i] = num;
    }
    return result;
  }
  function parseMonth(token) {
    token = String(token).substr(0, 3).toLowerCase();
    const num = MONTH_TO_NUM[token];
    return num >= 0 ? num : null;
  }
  function parseDate(str2) {
    if (!str2) {
      return;
    }
    const tokens = str2.split(DATE_DELIM);
    if (!tokens) {
      return;
    }
    let hour = null;
    let minute = null;
    let second = null;
    let dayOfMonth = null;
    let month = null;
    let year = null;
    for (let i = 0;i < tokens.length; i++) {
      const token = tokens[i].trim();
      if (!token.length) {
        continue;
      }
      let result;
      if (second === null) {
        result = parseTime(token);
        if (result) {
          hour = result[0];
          minute = result[1];
          second = result[2];
          continue;
        }
      }
      if (dayOfMonth === null) {
        result = parseDigits(token, 1, 2, true);
        if (result !== null) {
          dayOfMonth = result;
          continue;
        }
      }
      if (month === null) {
        result = parseMonth(token);
        if (result !== null) {
          month = result;
          continue;
        }
      }
      if (year === null) {
        result = parseDigits(token, 2, 4, true);
        if (result !== null) {
          year = result;
          if (year >= 70 && year <= 99) {
            year += 1900;
          } else if (year >= 0 && year <= 69) {
            year += 2000;
          }
        }
      }
    }
    if (dayOfMonth === null || month === null || year === null || second === null || dayOfMonth < 1 || dayOfMonth > 31 || year < 1601 || hour > 23 || minute > 59 || second > 59) {
      return;
    }
    return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));
  }
  function formatDate(date) {
    validators3.validate(validators3.isDate(date), date);
    return date.toUTCString();
  }
  function canonicalDomain(str2) {
    if (str2 == null) {
      return null;
    }
    str2 = str2.trim().replace(/^\./, "");
    if (IP_V6_REGEX_OBJECT.test(str2)) {
      str2 = str2.replace("[", "").replace("]", "");
    }
    if (punycode && /[^\u0001-\u007f]/.test(str2)) {
      str2 = punycode.toASCII(str2);
    }
    return str2.toLowerCase();
  }
  function domainMatch(str2, domStr, canonicalize) {
    if (str2 == null || domStr == null) {
      return null;
    }
    if (canonicalize !== false) {
      str2 = canonicalDomain(str2);
      domStr = canonicalDomain(domStr);
    }
    if (str2 == domStr) {
      return true;
    }
    const idx = str2.lastIndexOf(domStr);
    if (idx <= 0) {
      return false;
    }
    if (str2.length !== domStr.length + idx) {
      return false;
    }
    if (str2.substr(idx - 1, 1) !== ".") {
      return false;
    }
    if (IP_REGEX_LOWERCASE.test(str2)) {
      return false;
    }
    return true;
  }
  function defaultPath(path2) {
    if (!path2 || path2.substr(0, 1) !== "/") {
      return "/";
    }
    if (path2 === "/") {
      return path2;
    }
    const rightSlash = path2.lastIndexOf("/");
    if (rightSlash === 0) {
      return "/";
    }
    return path2.slice(0, rightSlash);
  }
  function trimTerminator(str2) {
    if (validators3.isEmptyString(str2))
      return str2;
    for (let t = 0;t < TERMINATORS.length; t++) {
      const terminatorIdx = str2.indexOf(TERMINATORS[t]);
      if (terminatorIdx !== -1) {
        str2 = str2.substr(0, terminatorIdx);
      }
    }
    return str2;
  }
  function parseCookiePair(cookiePair, looseMode) {
    cookiePair = trimTerminator(cookiePair);
    validators3.validate(validators3.isString(cookiePair), cookiePair);
    let firstEq = cookiePair.indexOf("=");
    if (looseMode) {
      if (firstEq === 0) {
        cookiePair = cookiePair.substr(1);
        firstEq = cookiePair.indexOf("=");
      }
    } else {
      if (firstEq <= 0) {
        return;
      }
    }
    let cookieName, cookieValue;
    if (firstEq <= 0) {
      cookieName = "";
      cookieValue = cookiePair.trim();
    } else {
      cookieName = cookiePair.substr(0, firstEq).trim();
      cookieValue = cookiePair.substr(firstEq + 1).trim();
    }
    if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {
      return;
    }
    const c = new Cookie;
    c.key = cookieName;
    c.value = cookieValue;
    return c;
  }
  function parse(str2, options) {
    if (!options || typeof options !== "object") {
      options = {};
    }
    if (validators3.isEmptyString(str2) || !validators3.isString(str2)) {
      return null;
    }
    str2 = str2.trim();
    const firstSemi = str2.indexOf(";");
    const cookiePair = firstSemi === -1 ? str2 : str2.substr(0, firstSemi);
    const c = parseCookiePair(cookiePair, !!options.loose);
    if (!c) {
      return;
    }
    if (firstSemi === -1) {
      return c;
    }
    const unparsed = str2.slice(firstSemi + 1).trim();
    if (unparsed.length === 0) {
      return c;
    }
    const cookie_avs = unparsed.split(";");
    while (cookie_avs.length) {
      const av = cookie_avs.shift().trim();
      if (av.length === 0) {
        continue;
      }
      const av_sep = av.indexOf("=");
      let av_key, av_value;
      if (av_sep === -1) {
        av_key = av;
        av_value = null;
      } else {
        av_key = av.substr(0, av_sep);
        av_value = av.substr(av_sep + 1);
      }
      av_key = av_key.trim().toLowerCase();
      if (av_value) {
        av_value = av_value.trim();
      }
      switch (av_key) {
        case "expires":
          if (av_value) {
            const exp = parseDate(av_value);
            if (exp) {
              c.expires = exp;
            }
          }
          break;
        case "max-age":
          if (av_value) {
            if (/^-?[0-9]+$/.test(av_value)) {
              const delta = parseInt(av_value, 10);
              c.setMaxAge(delta);
            }
          }
          break;
        case "domain":
          if (av_value) {
            const domain = av_value.trim().replace(/^\./, "");
            if (domain) {
              c.domain = domain.toLowerCase();
            }
          }
          break;
        case "path":
          c.path = av_value && av_value[0] === "/" ? av_value : null;
          break;
        case "secure":
          c.secure = true;
          break;
        case "httponly":
          c.httpOnly = true;
          break;
        case "samesite":
          const enforcement = av_value ? av_value.toLowerCase() : "";
          switch (enforcement) {
            case "strict":
              c.sameSite = "strict";
              break;
            case "lax":
              c.sameSite = "lax";
              break;
            case "none":
              c.sameSite = "none";
              break;
            default:
              c.sameSite = undefined;
              break;
          }
          break;
        default:
          c.extensions = c.extensions || [];
          c.extensions.push(av);
          break;
      }
    }
    return c;
  }
  function isSecurePrefixConditionMet(cookie) {
    validators3.validate(validators3.isObject(cookie), cookie);
    return !cookie.key.startsWith("__Secure-") || cookie.secure;
  }
  function isHostPrefixConditionMet(cookie) {
    validators3.validate(validators3.isObject(cookie));
    return !cookie.key.startsWith("__Host-") || cookie.secure && cookie.hostOnly && cookie.path != null && cookie.path === "/";
  }
  function jsonParse(str2) {
    let obj2;
    try {
      obj2 = JSON.parse(str2);
    } catch (e) {
      return e;
    }
    return obj2;
  }
  function fromJSON(str2) {
    if (!str2 || validators3.isEmptyString(str2)) {
      return null;
    }
    let obj2;
    if (typeof str2 === "string") {
      obj2 = jsonParse(str2);
      if (obj2 instanceof Error) {
        return null;
      }
    } else {
      obj2 = str2;
    }
    const c = new Cookie;
    for (let i = 0;i < Cookie.serializableProperties.length; i++) {
      const prop = Cookie.serializableProperties[i];
      if (obj2[prop] === undefined || obj2[prop] === cookieDefaults[prop]) {
        continue;
      }
      if (prop === "expires" || prop === "creation" || prop === "lastAccessed") {
        if (obj2[prop] === null) {
          c[prop] = null;
        } else {
          c[prop] = obj2[prop] == "Infinity" ? "Infinity" : new Date(obj2[prop]);
        }
      } else {
        c[prop] = obj2[prop];
      }
    }
    return c;
  }
  function cookieCompare(a, b) {
    validators3.validate(validators3.isObject(a), a);
    validators3.validate(validators3.isObject(b), b);
    let cmp = 0;
    const aPathLen = a.path ? a.path.length : 0;
    const bPathLen = b.path ? b.path.length : 0;
    cmp = bPathLen - aPathLen;
    if (cmp !== 0) {
      return cmp;
    }
    const aTime = a.creation ? a.creation.getTime() : MAX_TIME;
    const bTime = b.creation ? b.creation.getTime() : MAX_TIME;
    cmp = aTime - bTime;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = a.creationIndex - b.creationIndex;
    return cmp;
  }
  function permutePath(path2) {
    validators3.validate(validators3.isString(path2));
    if (path2 === "/") {
      return ["/"];
    }
    const permutations = [path2];
    while (path2.length > 1) {
      const lindex = path2.lastIndexOf("/");
      if (lindex === 0) {
        break;
      }
      path2 = path2.substr(0, lindex);
      permutations.push(path2);
    }
    permutations.push("/");
    return permutations;
  }
  function getCookieContext(url2) {
    if (url2 instanceof Object) {
      return url2;
    }
    try {
      url2 = decodeURI(url2);
    } catch (err) {}
    return urlParse(url2);
  }
  var cookieDefaults = {
    key: "",
    value: "",
    expires: "Infinity",
    maxAge: null,
    domain: null,
    path: null,
    secure: false,
    httpOnly: false,
    extensions: null,
    hostOnly: null,
    pathIsDefault: null,
    creation: null,
    lastAccessed: null,
    sameSite: undefined
  };

  class Cookie {
    constructor(options = {}) {
      const customInspectSymbol = getCustomInspectSymbol();
      if (customInspectSymbol) {
        this[customInspectSymbol] = this.inspect;
      }
      Object.assign(this, cookieDefaults, options);
      this.creation = this.creation || new Date;
      Object.defineProperty(this, "creationIndex", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: ++Cookie.cookiesCreated
      });
    }
    inspect() {
      const now = Date.now();
      const hostOnly = this.hostOnly != null ? this.hostOnly : "?";
      const createAge = this.creation ? `${now - this.creation.getTime()}ms` : "?";
      const accessAge = this.lastAccessed ? `${now - this.lastAccessed.getTime()}ms` : "?";
      return `Cookie="${this.toString()}; hostOnly=${hostOnly}; aAge=${accessAge}; cAge=${createAge}"`;
    }
    toJSON() {
      const obj2 = {};
      for (const prop of Cookie.serializableProperties) {
        if (this[prop] === cookieDefaults[prop]) {
          continue;
        }
        if (prop === "expires" || prop === "creation" || prop === "lastAccessed") {
          if (this[prop] === null) {
            obj2[prop] = null;
          } else {
            obj2[prop] = this[prop] == "Infinity" ? "Infinity" : this[prop].toISOString();
          }
        } else if (prop === "maxAge") {
          if (this[prop] !== null) {
            obj2[prop] = this[prop] == Infinity || this[prop] == -Infinity ? this[prop].toString() : this[prop];
          }
        } else {
          if (this[prop] !== cookieDefaults[prop]) {
            obj2[prop] = this[prop];
          }
        }
      }
      return obj2;
    }
    clone() {
      return fromJSON(this.toJSON());
    }
    validate() {
      if (!COOKIE_OCTETS.test(this.value)) {
        return false;
      }
      if (this.expires != Infinity && !(this.expires instanceof Date) && !parseDate(this.expires)) {
        return false;
      }
      if (this.maxAge != null && this.maxAge <= 0) {
        return false;
      }
      if (this.path != null && !PATH_VALUE.test(this.path)) {
        return false;
      }
      const cdomain = this.cdomain();
      if (cdomain) {
        if (cdomain.match(/\.$/)) {
          return false;
        }
        const suffix = pubsuffix.getPublicSuffix(cdomain);
        if (suffix == null) {
          return false;
        }
      }
      return true;
    }
    setExpires(exp) {
      if (exp instanceof Date) {
        this.expires = exp;
      } else {
        this.expires = parseDate(exp) || "Infinity";
      }
    }
    setMaxAge(age) {
      if (age === Infinity || age === -Infinity) {
        this.maxAge = age.toString();
      } else {
        this.maxAge = age;
      }
    }
    cookieString() {
      let val = this.value;
      if (val == null) {
        val = "";
      }
      if (this.key === "") {
        return val;
      }
      return `${this.key}=${val}`;
    }
    toString() {
      let str2 = this.cookieString();
      if (this.expires != Infinity) {
        if (this.expires instanceof Date) {
          str2 += `; Expires=${formatDate(this.expires)}`;
        } else {
          str2 += `; Expires=${this.expires}`;
        }
      }
      if (this.maxAge != null && this.maxAge != Infinity) {
        str2 += `; Max-Age=${this.maxAge}`;
      }
      if (this.domain && !this.hostOnly) {
        str2 += `; Domain=${this.domain}`;
      }
      if (this.path) {
        str2 += `; Path=${this.path}`;
      }
      if (this.secure) {
        str2 += "; Secure";
      }
      if (this.httpOnly) {
        str2 += "; HttpOnly";
      }
      if (this.sameSite && this.sameSite !== "none") {
        const ssCanon = Cookie.sameSiteCanonical[this.sameSite.toLowerCase()];
        str2 += `; SameSite=${ssCanon ? ssCanon : this.sameSite}`;
      }
      if (this.extensions) {
        this.extensions.forEach((ext) => {
          str2 += `; ${ext}`;
        });
      }
      return str2;
    }
    TTL(now) {
      if (this.maxAge != null) {
        return this.maxAge <= 0 ? 0 : this.maxAge * 1000;
      }
      let expires = this.expires;
      if (expires != Infinity) {
        if (!(expires instanceof Date)) {
          expires = parseDate(expires) || Infinity;
        }
        if (expires == Infinity) {
          return Infinity;
        }
        return expires.getTime() - (now || Date.now());
      }
      return Infinity;
    }
    expiryTime(now) {
      if (this.maxAge != null) {
        const relativeTo = now || this.creation || new Date;
        const age = this.maxAge <= 0 ? -Infinity : this.maxAge * 1000;
        return relativeTo.getTime() + age;
      }
      if (this.expires == Infinity) {
        return Infinity;
      }
      return this.expires.getTime();
    }
    expiryDate(now) {
      const millisec = this.expiryTime(now);
      if (millisec == Infinity) {
        return new Date(MAX_TIME);
      } else if (millisec == -Infinity) {
        return new Date(MIN_TIME);
      } else {
        return new Date(millisec);
      }
    }
    isPersistent() {
      return this.maxAge != null || this.expires != Infinity;
    }
    canonicalizedDomain() {
      if (this.domain == null) {
        return null;
      }
      return canonicalDomain(this.domain);
    }
    cdomain() {
      return this.canonicalizedDomain();
    }
  }
  Cookie.cookiesCreated = 0;
  Cookie.parse = parse;
  Cookie.fromJSON = fromJSON;
  Cookie.serializableProperties = Object.keys(cookieDefaults);
  Cookie.sameSiteLevel = {
    strict: 3,
    lax: 2,
    none: 1
  };
  Cookie.sameSiteCanonical = {
    strict: "Strict",
    lax: "Lax"
  };
  function getNormalizedPrefixSecurity(prefixSecurity) {
    if (prefixSecurity != null) {
      const normalizedPrefixSecurity = prefixSecurity.toLowerCase();
      switch (normalizedPrefixSecurity) {
        case PrefixSecurityEnum.STRICT:
        case PrefixSecurityEnum.SILENT:
        case PrefixSecurityEnum.DISABLED:
          return normalizedPrefixSecurity;
      }
    }
    return PrefixSecurityEnum.SILENT;
  }

  class CookieJar {
    constructor(store, options = { rejectPublicSuffixes: true }) {
      if (typeof options === "boolean") {
        options = { rejectPublicSuffixes: options };
      }
      validators3.validate(validators3.isObject(options), options);
      this.rejectPublicSuffixes = options.rejectPublicSuffixes;
      this.enableLooseMode = !!options.looseMode;
      this.allowSpecialUseDomain = typeof options.allowSpecialUseDomain === "boolean" ? options.allowSpecialUseDomain : true;
      this.store = store || new MemoryCookieStore;
      this.prefixSecurity = getNormalizedPrefixSecurity(options.prefixSecurity);
      this._cloneSync = syncWrap("clone");
      this._importCookiesSync = syncWrap("_importCookies");
      this.getCookiesSync = syncWrap("getCookies");
      this.getCookieStringSync = syncWrap("getCookieString");
      this.getSetCookieStringsSync = syncWrap("getSetCookieStrings");
      this.removeAllCookiesSync = syncWrap("removeAllCookies");
      this.setCookieSync = syncWrap("setCookie");
      this.serializeSync = syncWrap("serialize");
    }
    setCookie(cookie, url2, options, cb) {
      validators3.validate(validators3.isUrlStringOrObject(url2), cb, options);
      let err;
      if (validators3.isFunction(url2)) {
        cb = url2;
        return cb(new Error("No URL was specified"));
      }
      const context = getCookieContext(url2);
      if (validators3.isFunction(options)) {
        cb = options;
        options = {};
      }
      validators3.validate(validators3.isFunction(cb), cb);
      if (!validators3.isNonEmptyString(cookie) && !validators3.isObject(cookie) && cookie instanceof String && cookie.length == 0) {
        return cb(null);
      }
      const host = canonicalDomain(context.hostname);
      const loose = options.loose || this.enableLooseMode;
      let sameSiteContext = null;
      if (options.sameSiteContext) {
        sameSiteContext = checkSameSiteContext(options.sameSiteContext);
        if (!sameSiteContext) {
          return cb(new Error(SAME_SITE_CONTEXT_VAL_ERR));
        }
      }
      if (typeof cookie === "string" || cookie instanceof String) {
        cookie = Cookie.parse(cookie, { loose });
        if (!cookie) {
          err = new Error("Cookie failed to parse");
          return cb(options.ignoreError ? null : err);
        }
      } else if (!(cookie instanceof Cookie)) {
        err = new Error("First argument to setCookie must be a Cookie object or string");
        return cb(options.ignoreError ? null : err);
      }
      const now = options.now || new Date;
      if (this.rejectPublicSuffixes && cookie.domain) {
        const suffix = pubsuffix.getPublicSuffix(cookie.cdomain(), {
          allowSpecialUseDomain: this.allowSpecialUseDomain,
          ignoreError: options.ignoreError
        });
        if (suffix == null && !IP_V6_REGEX_OBJECT.test(cookie.domain)) {
          err = new Error("Cookie has domain set to a public suffix");
          return cb(options.ignoreError ? null : err);
        }
      }
      if (cookie.domain) {
        if (!domainMatch(host, cookie.cdomain(), false)) {
          err = new Error(`Cookie not in this host's domain. Cookie:${cookie.cdomain()} Request:${host}`);
          return cb(options.ignoreError ? null : err);
        }
        if (cookie.hostOnly == null) {
          cookie.hostOnly = false;
        }
      } else {
        cookie.hostOnly = true;
        cookie.domain = host;
      }
      if (!cookie.path || cookie.path[0] !== "/") {
        cookie.path = defaultPath(context.pathname);
        cookie.pathIsDefault = true;
      }
      if (options.http === false && cookie.httpOnly) {
        err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
        return cb(options.ignoreError ? null : err);
      }
      if (cookie.sameSite !== "none" && cookie.sameSite !== undefined && sameSiteContext) {
        if (sameSiteContext === "none") {
          err = new Error("Cookie is SameSite but this is a cross-origin request");
          return cb(options.ignoreError ? null : err);
        }
      }
      const ignoreErrorForPrefixSecurity = this.prefixSecurity === PrefixSecurityEnum.SILENT;
      const prefixSecurityDisabled = this.prefixSecurity === PrefixSecurityEnum.DISABLED;
      if (!prefixSecurityDisabled) {
        let errorFound = false;
        let errorMsg;
        if (!isSecurePrefixConditionMet(cookie)) {
          errorFound = true;
          errorMsg = "Cookie has __Secure prefix but Secure attribute is not set";
        } else if (!isHostPrefixConditionMet(cookie)) {
          errorFound = true;
          errorMsg = "Cookie has __Host prefix but either Secure or HostOnly attribute is not set or Path is not '/'";
        }
        if (errorFound) {
          return cb(options.ignoreError || ignoreErrorForPrefixSecurity ? null : new Error(errorMsg));
        }
      }
      const store = this.store;
      if (!store.updateCookie) {
        store.updateCookie = function(oldCookie, newCookie, cb2) {
          this.putCookie(newCookie, cb2);
        };
      }
      function withCookie(err2, oldCookie) {
        if (err2) {
          return cb(err2);
        }
        const next = function(err3) {
          if (err3) {
            return cb(err3);
          } else {
            cb(null, cookie);
          }
        };
        if (oldCookie) {
          if (options.http === false && oldCookie.httpOnly) {
            err2 = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
            return cb(options.ignoreError ? null : err2);
          }
          cookie.creation = oldCookie.creation;
          cookie.creationIndex = oldCookie.creationIndex;
          cookie.lastAccessed = now;
          store.updateCookie(oldCookie, cookie, next);
        } else {
          cookie.creation = cookie.lastAccessed = now;
          store.putCookie(cookie, next);
        }
      }
      store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
    }
    getCookies(url2, options, cb) {
      validators3.validate(validators3.isUrlStringOrObject(url2), cb, url2);
      const context = getCookieContext(url2);
      if (validators3.isFunction(options)) {
        cb = options;
        options = {};
      }
      validators3.validate(validators3.isObject(options), cb, options);
      validators3.validate(validators3.isFunction(cb), cb);
      const host = canonicalDomain(context.hostname);
      const path2 = context.pathname || "/";
      let secure = options.secure;
      if (secure == null && context.protocol && (context.protocol == "https:" || context.protocol == "wss:")) {
        secure = true;
      }
      let sameSiteLevel = 0;
      if (options.sameSiteContext) {
        const sameSiteContext = checkSameSiteContext(options.sameSiteContext);
        sameSiteLevel = Cookie.sameSiteLevel[sameSiteContext];
        if (!sameSiteLevel) {
          return cb(new Error(SAME_SITE_CONTEXT_VAL_ERR));
        }
      }
      let http3 = options.http;
      if (http3 == null) {
        http3 = true;
      }
      const now = options.now || Date.now();
      const expireCheck = options.expire !== false;
      const allPaths = !!options.allPaths;
      const store = this.store;
      function matchingCookie(c) {
        if (c.hostOnly) {
          if (c.domain != host) {
            return false;
          }
        } else {
          if (!domainMatch(host, c.domain, false)) {
            return false;
          }
        }
        if (!allPaths && !pathMatch(path2, c.path)) {
          return false;
        }
        if (c.secure && !secure) {
          return false;
        }
        if (c.httpOnly && !http3) {
          return false;
        }
        if (sameSiteLevel) {
          const cookieLevel = Cookie.sameSiteLevel[c.sameSite || "none"];
          if (cookieLevel > sameSiteLevel) {
            return false;
          }
        }
        if (expireCheck && c.expiryTime() <= now) {
          store.removeCookie(c.domain, c.path, c.key, () => {});
          return false;
        }
        return true;
      }
      store.findCookies(host, allPaths ? null : path2, this.allowSpecialUseDomain, (err, cookies) => {
        if (err) {
          return cb(err);
        }
        cookies = cookies.filter(matchingCookie);
        if (options.sort !== false) {
          cookies = cookies.sort(cookieCompare);
        }
        const now2 = new Date;
        for (const cookie of cookies) {
          cookie.lastAccessed = now2;
        }
        cb(null, cookies);
      });
    }
    getCookieString(...args) {
      const cb = args.pop();
      validators3.validate(validators3.isFunction(cb), cb);
      const next = function(err, cookies) {
        if (err) {
          cb(err);
        } else {
          cb(null, cookies.sort(cookieCompare).map((c) => c.cookieString()).join("; "));
        }
      };
      args.push(next);
      this.getCookies.apply(this, args);
    }
    getSetCookieStrings(...args) {
      const cb = args.pop();
      validators3.validate(validators3.isFunction(cb), cb);
      const next = function(err, cookies) {
        if (err) {
          cb(err);
        } else {
          cb(null, cookies.map((c) => {
            return c.toString();
          }));
        }
      };
      args.push(next);
      this.getCookies.apply(this, args);
    }
    serialize(cb) {
      validators3.validate(validators3.isFunction(cb), cb);
      let type = this.store.constructor.name;
      if (validators3.isObject(type)) {
        type = null;
      }
      const serialized = {
        version: `tough-cookie@${VERSION3}`,
        storeType: type,
        rejectPublicSuffixes: !!this.rejectPublicSuffixes,
        enableLooseMode: !!this.enableLooseMode,
        allowSpecialUseDomain: !!this.allowSpecialUseDomain,
        prefixSecurity: getNormalizedPrefixSecurity(this.prefixSecurity),
        cookies: []
      };
      if (!(this.store.getAllCookies && typeof this.store.getAllCookies === "function")) {
        return cb(new Error("store does not support getAllCookies and cannot be serialized"));
      }
      this.store.getAllCookies((err, cookies) => {
        if (err) {
          return cb(err);
        }
        serialized.cookies = cookies.map((cookie) => {
          cookie = cookie instanceof Cookie ? cookie.toJSON() : cookie;
          delete cookie.creationIndex;
          return cookie;
        });
        return cb(null, serialized);
      });
    }
    toJSON() {
      return this.serializeSync();
    }
    _importCookies(serialized, cb) {
      let cookies = serialized.cookies;
      if (!cookies || !Array.isArray(cookies)) {
        return cb(new Error("serialized jar has no cookies array"));
      }
      cookies = cookies.slice();
      const putNext = (err) => {
        if (err) {
          return cb(err);
        }
        if (!cookies.length) {
          return cb(err, this);
        }
        let cookie;
        try {
          cookie = fromJSON(cookies.shift());
        } catch (e) {
          return cb(e);
        }
        if (cookie === null) {
          return putNext(null);
        }
        this.store.putCookie(cookie, putNext);
      };
      putNext();
    }
    clone(newStore, cb) {
      if (arguments.length === 1) {
        cb = newStore;
        newStore = null;
      }
      this.serialize((err, serialized) => {
        if (err) {
          return cb(err);
        }
        CookieJar.deserialize(serialized, newStore, cb);
      });
    }
    cloneSync(newStore) {
      if (arguments.length === 0) {
        return this._cloneSync();
      }
      if (!newStore.synchronous) {
        throw new Error("CookieJar clone destination store is not synchronous; use async API instead.");
      }
      return this._cloneSync(newStore);
    }
    removeAllCookies(cb) {
      validators3.validate(validators3.isFunction(cb), cb);
      const store = this.store;
      if (typeof store.removeAllCookies === "function" && store.removeAllCookies !== Store.prototype.removeAllCookies) {
        return store.removeAllCookies(cb);
      }
      store.getAllCookies((err, cookies) => {
        if (err) {
          return cb(err);
        }
        if (cookies.length === 0) {
          return cb(null);
        }
        let completedCount = 0;
        const removeErrors = [];
        function removeCookieCb(removeErr) {
          if (removeErr) {
            removeErrors.push(removeErr);
          }
          completedCount++;
          if (completedCount === cookies.length) {
            return cb(removeErrors.length ? removeErrors[0] : null);
          }
        }
        cookies.forEach((cookie) => {
          store.removeCookie(cookie.domain, cookie.path, cookie.key, removeCookieCb);
        });
      });
    }
    static deserialize(strOrObj, store, cb) {
      if (arguments.length !== 3) {
        cb = store;
        store = null;
      }
      validators3.validate(validators3.isFunction(cb), cb);
      let serialized;
      if (typeof strOrObj === "string") {
        serialized = jsonParse(strOrObj);
        if (serialized instanceof Error) {
          return cb(serialized);
        }
      } else {
        serialized = strOrObj;
      }
      const jar = new CookieJar(store, {
        rejectPublicSuffixes: serialized.rejectPublicSuffixes,
        looseMode: serialized.enableLooseMode,
        allowSpecialUseDomain: serialized.allowSpecialUseDomain,
        prefixSecurity: serialized.prefixSecurity
      });
      jar._importCookies(serialized, (err) => {
        if (err) {
          return cb(err);
        }
        cb(null, jar);
      });
    }
    static deserializeSync(strOrObj, store) {
      const serialized = typeof strOrObj === "string" ? JSON.parse(strOrObj) : strOrObj;
      const jar = new CookieJar(store, {
        rejectPublicSuffixes: serialized.rejectPublicSuffixes,
        looseMode: serialized.enableLooseMode
      });
      if (!jar.store.synchronous) {
        throw new Error("CookieJar store is not synchronous; use async API instead.");
      }
      jar._importCookiesSync(serialized);
      return jar;
    }
  }
  CookieJar.fromJSON = CookieJar.deserializeSync;
  [
    "_importCookies",
    "clone",
    "getCookies",
    "getCookieString",
    "getSetCookieStrings",
    "removeAllCookies",
    "serialize",
    "setCookie"
  ].forEach((name) => {
    CookieJar.prototype[name] = fromCallback(CookieJar.prototype[name]);
  });
  CookieJar.deserialize = fromCallback(CookieJar.deserialize);
  function syncWrap(method) {
    return function(...args) {
      if (!this.store.synchronous) {
        throw new Error("CookieJar store is not synchronous; use async API instead.");
      }
      let syncErr, syncResult;
      this[method](...args, (err, result) => {
        syncErr = err;
        syncResult = result;
      });
      if (syncErr) {
        throw syncErr;
      }
      return syncResult;
    };
  }
  exports2.version = VERSION3;
  exports2.CookieJar = CookieJar;
  exports2.Cookie = Cookie;
  exports2.Store = Store;
  exports2.MemoryCookieStore = MemoryCookieStore;
  exports2.parseDate = parseDate;
  exports2.formatDate = formatDate;
  exports2.parse = parse;
  exports2.fromJSON = fromJSON;
  exports2.domainMatch = domainMatch;
  exports2.defaultPath = defaultPath;
  exports2.pathMatch = pathMatch;
  exports2.getPublicSuffix = pubsuffix.getPublicSuffix;
  exports2.cookieCompare = cookieCompare;
  exports2.permuteDomain = require_permuteDomain2().permuteDomain;
  exports2.permutePath = permutePath;
  exports2.canonicalDomain = canonicalDomain;
  exports2.PrefixSecurityEnum = PrefixSecurityEnum;
  exports2.ParameterError = validators3.ParameterError;
});

// backend/node_modules/@cypress/request-promise/lib/rp.js
var require_rp = __commonJS((exports2, module2) => {
  var Bluebird = require_bluebird().getNewLibraryCopy();
  var configure = require_request2();
  var stealthyRequire = require_lib2();
  try {
    request = stealthyRequire(require.cache, function() {
      return require_request3();
    }, function() {
      require_cookie3();
    }, module2);
  } catch (err) {
    EOL = require("os").EOL;
    console.error(EOL + "###" + EOL + '### The "request" library is not installed automatically anymore.' + EOL + '### But is a dependency of "request-promise".' + EOL + "### Please install it with:" + EOL + "### npm install request --save" + EOL + "###" + EOL);
    throw err;
  }
  var request;
  var EOL;
  Bluebird.config({ cancellation: true });
  configure({
    request,
    PromiseImpl: Bluebird,
    expose: [
      "then",
      "catch",
      "finally",
      "cancel",
      "promise"
    ],
    constructorMixin: function(resolve, reject, onCancel) {
      var self2 = this;
      onCancel(function() {
        self2.abort();
      });
    }
  });
  request.bindCLS = function RP$bindCLS() {
    throw new Error("CLS support was dropped. To get it back read: https://github.com/request/request-promise/wiki/Getting-Back-Support-for-Continuation-Local-Storage");
  };
  module2.exports = request;
});

// backend/node_modules/mime/types.json
var require_types5 = __commonJS((exports2, module2) => {
  module2.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomsvc+xml": ["atomsvc"], "application/bdoc": ["bdoc"], "application/ccxml+xml": ["ccxml"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["ecma"], "application/emma+xml": ["emma"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/font-tdpfr": ["pfr"], "application/font-woff": [], "application/font-woff2": [], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/prs.cww": ["cww"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": [], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": [], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": [], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": [], "application/x-msdownload": ["com", "bat"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["wmf", "emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": [], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "application/xaml+xml": ["xaml"], "application/xcap-diff+xml": ["xdf"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": [], "audio/adpcm": ["adp"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mp3": [], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/wav": ["wav"], "audio/wave": [], "audio/webm": ["weba"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": [], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": [], "audio/x-wav": [], "audio/xm": ["xm"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/apng": ["apng"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/ief": ["ief"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/ktx": ["ktx"], "image/png": ["png"], "image/prs.btif": ["btif"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/tiff": ["tiff", "tif"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": [], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/webp": ["webp"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": [], "image/x-pcx": ["pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/rfc822": ["eml", "mime"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.vtu": ["vtu"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["x3db", "x3dbz"], "model/x3d+vrml": ["x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/hjson": ["hjson"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/prs.lines.tag": ["dsc"], "text/richtext": ["rtx"], "text/rtf": [], "text/sgml": ["sgml", "sgm"], "text/slim": ["slim", "slm"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/vtt": ["vtt"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": [], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "text/xml": [], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/jpeg": ["jpgv"], "video/jpm": ["jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/webm": ["webm"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
});

// backend/node_modules/mime/mime.js
var require_mime = __commonJS((exports2, module2) => {
  var path2 = require("path");
  var fs = require("fs");
  function Mime() {
    this.types = Object.create(null);
    this.extensions = Object.create(null);
  }
  Mime.prototype.define = function(map) {
    for (var type in map) {
      var exts = map[type];
      for (var i = 0;i < exts.length; i++) {
        if (process.env.DEBUG_MIME && this.types[exts[i]]) {
          console.warn((this._loading || "define()").replace(/.*\//, ""), 'changes "' + exts[i] + '" extension type from ' + this.types[exts[i]] + " to " + type);
        }
        this.types[exts[i]] = type;
      }
      if (!this.extensions[type]) {
        this.extensions[type] = exts[0];
      }
    }
  };
  Mime.prototype.load = function(file) {
    this._loading = file;
    var map = {}, content = fs.readFileSync(file, "ascii"), lines = content.split(/[\r\n]+/);
    lines.forEach(function(line) {
      var fields = line.replace(/\s*#.*|^\s*|\s*$/g, "").split(/\s+/);
      map[fields.shift()] = fields;
    });
    this.define(map);
    this._loading = null;
  };
  Mime.prototype.lookup = function(path3, fallback) {
    var ext = path3.replace(/^.*[\.\/\\]/, "").toLowerCase();
    return this.types[ext] || fallback || this.default_type;
  };
  Mime.prototype.extension = function(mimeType) {
    var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
    return this.extensions[type];
  };
  var mime = new Mime;
  mime.define(require_types5());
  mime.default_type = mime.lookup("bin");
  mime.Mime = Mime;
  mime.charsets = {
    lookup: function(mimeType, fallback) {
      return /^text\/|^application\/(javascript|json)/.test(mimeType) ? "UTF-8" : fallback;
    }
  };
  module2.exports = mime;
});

// backend/node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS((exports2, module2) => {
  module2.exports = wrappy;
  function wrappy(fn, cb) {
    if (fn && cb)
      return wrappy(fn)(cb);
    if (typeof fn !== "function")
      throw new TypeError("need wrapper function");
    Object.keys(fn).forEach(function(k) {
      wrapper[k] = fn[k];
    });
    return wrapper;
    function wrapper() {
      var args = new Array(arguments.length);
      for (var i = 0;i < args.length; i++) {
        args[i] = arguments[i];
      }
      var ret = fn.apply(this, args);
      var cb2 = args[args.length - 1];
      if (typeof ret === "function" && ret !== cb2) {
        Object.keys(cb2).forEach(function(k) {
          ret[k] = cb2[k];
        });
      }
      return ret;
    }
  }
});

// backend/node_modules/once/once.js
var require_once = __commonJS((exports2, module2) => {
  var wrappy = require_wrappy();
  module2.exports = wrappy(once);
  module2.exports.strict = wrappy(onceStrict);
  once.proto = once(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: function() {
        return once(this);
      },
      configurable: true
    });
    Object.defineProperty(Function.prototype, "onceStrict", {
      value: function() {
        return onceStrict(this);
      },
      configurable: true
    });
  });
  function once(fn) {
    var f = function() {
      if (f.called)
        return f.value;
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    f.called = false;
    return f;
  }
  function onceStrict(fn) {
    var f = function() {
      if (f.called)
        throw new Error(f.onceError);
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    var name = fn.name || "Function wrapped with `once`";
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f;
  }
});

// backend/node_modules/end-of-stream/index.js
var require_end_of_stream = __commonJS((exports2, module2) => {
  var once = require_once();
  var noop3 = function() {};
  var qnt = global.Bare ? queueMicrotask : process.nextTick.bind(process);
  var isRequest2 = function(stream4) {
    return stream4.setHeader && typeof stream4.abort === "function";
  };
  var isChildProcess = function(stream4) {
    return stream4.stdio && Array.isArray(stream4.stdio) && stream4.stdio.length === 3;
  };
  var eos = function(stream4, opts, callback) {
    if (typeof opts === "function")
      return eos(stream4, null, opts);
    if (!opts)
      opts = {};
    callback = once(callback || noop3);
    var ws = stream4._writableState;
    var rs = stream4._readableState;
    var readable = opts.readable || opts.readable !== false && stream4.readable;
    var writable = opts.writable || opts.writable !== false && stream4.writable;
    var cancelled = false;
    var onlegacyfinish = function() {
      if (!stream4.writable)
        onfinish();
    };
    var onfinish = function() {
      writable = false;
      if (!readable)
        callback.call(stream4);
    };
    var onend = function() {
      readable = false;
      if (!writable)
        callback.call(stream4);
    };
    var onexit = function(exitCode) {
      callback.call(stream4, exitCode ? new Error("exited with error code: " + exitCode) : null);
    };
    var onerror = function(err) {
      callback.call(stream4, err);
    };
    var onclose = function() {
      qnt(onclosenexttick);
    };
    var onclosenexttick = function() {
      if (cancelled)
        return;
      if (readable && !(rs && (rs.ended && !rs.destroyed)))
        return callback.call(stream4, new Error("premature close"));
      if (writable && !(ws && (ws.ended && !ws.destroyed)))
        return callback.call(stream4, new Error("premature close"));
    };
    var onrequest = function() {
      stream4.req.on("finish", onfinish);
    };
    if (isRequest2(stream4)) {
      stream4.on("complete", onfinish);
      stream4.on("abort", onclose);
      if (stream4.req)
        onrequest();
      else
        stream4.on("request", onrequest);
    } else if (writable && !ws) {
      stream4.on("end", onlegacyfinish);
      stream4.on("close", onlegacyfinish);
    }
    if (isChildProcess(stream4))
      stream4.on("exit", onexit);
    stream4.on("end", onend);
    stream4.on("finish", onfinish);
    if (opts.error !== false)
      stream4.on("error", onerror);
    stream4.on("close", onclose);
    return function() {
      cancelled = true;
      stream4.removeListener("complete", onfinish);
      stream4.removeListener("abort", onclose);
      stream4.removeListener("request", onrequest);
      if (stream4.req)
        stream4.req.removeListener("finish", onfinish);
      stream4.removeListener("end", onlegacyfinish);
      stream4.removeListener("close", onlegacyfinish);
      stream4.removeListener("finish", onfinish);
      stream4.removeListener("exit", onexit);
      stream4.removeListener("end", onend);
      stream4.removeListener("error", onerror);
      stream4.removeListener("close", onclose);
    };
  };
  module2.exports = eos;
});

// backend/node_modules/pump/index.js
var require_pump = __commonJS((exports2, module2) => {
  var once = require_once();
  var eos = require_end_of_stream();
  var fs = require("fs");
  var noop3 = function() {};
  var ancient = /^v?\.0/.test(process.version);
  var isFn = function(fn) {
    return typeof fn === "function";
  };
  var isFS = function(stream4) {
    if (!ancient)
      return false;
    if (!fs)
      return false;
    return (stream4 instanceof (fs.ReadStream || noop3) || stream4 instanceof (fs.WriteStream || noop3)) && isFn(stream4.close);
  };
  var isRequest2 = function(stream4) {
    return stream4.setHeader && isFn(stream4.abort);
  };
  var destroyer = function(stream4, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream4.on("close", function() {
      closed = true;
    });
    eos(stream4, { readable: reading, writable: writing }, function(err) {
      if (err)
        return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed)
        return;
      if (destroyed)
        return;
      destroyed = true;
      if (isFS(stream4))
        return stream4.close(noop3);
      if (isRequest2(stream4))
        return stream4.abort();
      if (isFn(stream4.destroy))
        return stream4.destroy();
      callback(err || new Error("stream was destroyed"));
    };
  };
  var call = function(fn) {
    fn();
  };
  var pipe = function(from, to) {
    return from.pipe(to);
  };
  var pump = function() {
    var streams = Array.prototype.slice.call(arguments);
    var callback = isFn(streams[streams.length - 1] || noop3) && streams.pop() || noop3;
    if (Array.isArray(streams[0]))
      streams = streams[0];
    if (streams.length < 2)
      throw new Error("pump requires two streams per minimum");
    var error2;
    var destroys = streams.map(function(stream4, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream4, reading, writing, function(err) {
        if (!error2)
          error2 = err;
        if (err)
          destroys.forEach(call);
        if (reading)
          return;
        destroys.forEach(call);
        callback(error2);
      });
    });
    streams.reduce(pipe);
  };
  module2.exports = pump;
});

// backend/node_modules/node-telegram-bot-api/lib/telegram.js
var require_telegram = __commonJS((exports2, module2) => {
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  };
  var _slicedToArray = function() {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = arr[Symbol.iterator](), _s;!(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"])
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    return function(arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();
  var _createClass = function() {
    function defineProperties(target, props) {
      for (var i = 0;i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _get = function get(object, property, receiver2) {
    if (object === null)
      object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);
    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);
      if (parent === null) {
        return;
      } else {
        return get(parent, property, receiver2);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;
      if (getter === undefined) {
        return;
      }
      return getter.call(receiver2);
    }
  };
  function _defineProperty(obj2, key, value) {
    if (key in obj2) {
      Object.defineProperty(obj2, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj2[key] = value;
    }
    return obj2;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _possibleConstructorReturn(self2, call) {
    if (!self2) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && (typeof call === "object" || typeof call === "function") ? call : self2;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
    if (superClass)
      Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  require_array_prototype().shim();
  var errors = require_errors4();
  var TelegramBotWebHook = require_telegramWebHook();
  var TelegramBotPolling = require_telegramPolling();
  var debug = require_src()("node-telegram-bot-api");
  var EventEmitter2 = require_eventemitter3();
  var fileType = require_file_type();
  var request = require_rp();
  var streamedRequest = require_request3();
  var qs = require("querystring");
  var stream4 = require("stream");
  var mime = require_mime();
  var path2 = require("path");
  var URL2 = require("url");
  var fs = require("fs");
  var pump = require_pump();
  var deprecate = require_utils2().deprecate;
  var _messageTypes = ["text", "animation", "audio", "channel_chat_created", "contact", "delete_chat_photo", "dice", "document", "game", "group_chat_created", "invoice", "left_chat_member", "location", "migrate_from_chat_id", "migrate_to_chat_id", "new_chat_members", "new_chat_photo", "new_chat_title", "passport_data", "photo", "pinned_message", "poll", "sticker", "successful_payment", "supergroup_chat_created", "video", "video_note", "voice", "video_chat_started", "video_chat_ended", "video_chat_participants_invited", "video_chat_scheduled", "message_auto_delete_timer_changed", "chat_invite_link", "chat_member_updated", "web_app_data", "message_reaction"];
  var _deprecatedMessageTypes = ["new_chat_participant", "left_chat_participant"];
  function stringify2(data) {
    if (typeof data === "string") {
      return data;
    }
    return JSON.stringify(data);
  }
  var TelegramBot = function(_EventEmitter) {
    _inherits(TelegramBot2, _EventEmitter);
    _createClass(TelegramBot2, [{
      key: "on",
      value: function on(event, listener) {
        if (_deprecatedMessageTypes.indexOf(event) !== -1) {
          var url2 = "https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#events";
          deprecate("Events " + _deprecatedMessageTypes.join(",") + " are deprecated. See the updated list of events: " + url2);
        }
        _get(TelegramBot2.prototype.__proto__ || Object.getPrototypeOf(TelegramBot2.prototype), "on", this).call(this, event, listener);
      }
    }], [{
      key: "errors",
      get: function get() {
        return errors;
      }
    }, {
      key: "messageTypes",
      get: function get() {
        return _messageTypes;
      }
    }]);
    function TelegramBot2(token) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      _classCallCheck(this, TelegramBot2);
      var _this = _possibleConstructorReturn(this, (TelegramBot2.__proto__ || Object.getPrototypeOf(TelegramBot2)).call(this));
      _this.token = token;
      _this.options = options;
      _this.options.polling = typeof options.polling === "undefined" ? false : options.polling;
      _this.options.webHook = typeof options.webHook === "undefined" ? false : options.webHook;
      _this.options.baseApiUrl = options.baseApiUrl || "https://api.telegram.org";
      _this.options.filepath = typeof options.filepath === "undefined" ? true : options.filepath;
      _this.options.badRejection = typeof options.badRejection === "undefined" ? false : options.badRejection;
      _this._textRegexpCallbacks = [];
      _this._replyListenerId = 0;
      _this._replyListeners = [];
      _this._polling = null;
      _this._webHook = null;
      if (options.polling) {
        var autoStart = options.polling.autoStart;
        if (typeof autoStart === "undefined" || autoStart === true) {
          _this.startPolling();
        }
      }
      if (options.webHook) {
        var autoOpen = options.webHook.autoOpen;
        if (typeof autoOpen === "undefined" || autoOpen === true) {
          _this.openWebHook();
        }
      }
      return _this;
    }
    _createClass(TelegramBot2, [{
      key: "_buildURL",
      value: function _buildURL(_path) {
        return this.options.baseApiUrl + "/bot" + this.token + (this.options.testEnvironment ? "/test" : "") + "/" + _path;
      }
    }, {
      key: "_fixReplyMarkup",
      value: function _fixReplyMarkup(obj2) {
        var replyMarkup = obj2.reply_markup;
        if (replyMarkup && typeof replyMarkup !== "string") {
          obj2.reply_markup = stringify2(replyMarkup);
        }
      }
    }, {
      key: "_fixEntitiesField",
      value: function _fixEntitiesField(obj2) {
        var entities = obj2.entities;
        var captionEntities = obj2.caption_entities;
        var explanationEntities = obj2.explanation_entities;
        if (entities && typeof entities !== "string") {
          obj2.entities = stringify2(entities);
        }
        if (captionEntities && typeof captionEntities !== "string") {
          obj2.caption_entities = stringify2(captionEntities);
        }
        if (explanationEntities && typeof explanationEntities !== "string") {
          obj2.explanation_entities = stringify2(explanationEntities);
        }
      }
    }, {
      key: "_fixAddFileThumbnail",
      value: function _fixAddFileThumbnail(options, opts) {
        if (options.thumb) {
          if (opts.formData === null) {
            opts.formData = {};
          }
          var attachName = "photo";
          var _formatSendData2 = this._formatSendData(attachName, options.thumb.replace("attach://", "")), _formatSendData3 = _slicedToArray(_formatSendData2, 1), formData = _formatSendData3[0];
          if (formData) {
            opts.formData[attachName] = formData[attachName];
            opts.qs.thumbnail = "attach://" + attachName;
          }
        }
      }
    }, {
      key: "_fixReplyParameters",
      value: function _fixReplyParameters(obj2) {
        if (obj2.hasOwnProperty("reply_parameters") && typeof obj2.reply_parameters !== "string") {
          obj2.reply_parameters = stringify2(obj2.reply_parameters);
        }
      }
    }, {
      key: "_request",
      value: function _request(_path) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        if (!this.token) {
          return Promise.reject(new errors.FatalError("Telegram Bot Token not provided!"));
        }
        if (this.options.request) {
          Object.assign(options, this.options.request);
        }
        if (options.form) {
          this._fixReplyMarkup(options.form);
          this._fixEntitiesField(options.form);
          this._fixReplyParameters(options.form);
        }
        if (options.qs) {
          this._fixReplyMarkup(options.qs);
          this._fixReplyParameters(options.qs);
        }
        options.method = "POST";
        options.url = this._buildURL(_path);
        options.simple = false;
        options.resolveWithFullResponse = true;
        options.forever = true;
        debug("HTTP request: %j", options);
        return request(options).then(function(resp) {
          var data = undefined;
          try {
            data = resp.body = JSON.parse(resp.body);
          } catch (err) {
            throw new errors.ParseError("Error parsing response: " + resp.body, resp);
          }
          if (data.ok) {
            return data.result;
          }
          throw new errors.TelegramError(data.error_code + " " + data.description, resp);
        }).catch(function(error2) {
          if (error2.response)
            throw error2;
          throw new errors.FatalError(error2);
        });
      }
    }, {
      key: "_formatSendData",
      value: function _formatSendData(type, data) {
        var fileOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var deprecationMessage = "See https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files" + " for more information on how sending files has been improved and" + " on how to disable this deprecation message altogether.";
        var filedata = data;
        var filename = fileOptions.filename;
        var contentType = fileOptions.contentType;
        if (data instanceof stream4.Stream) {
          if (!filename && data.path) {
            var url2 = URL2.parse(path2.basename(data.path.toString()));
            if (url2.pathname) {
              filename = qs.unescape(url2.pathname);
            }
          }
        } else if (Buffer.isBuffer(data)) {
          if (!filename && !process.env.NTBA_FIX_350) {
            deprecate('Buffers will have their filenames default to "filename" instead of "data". ' + deprecationMessage);
            filename = "data";
          }
          if (!contentType) {
            var filetype = fileType(data);
            if (filetype) {
              contentType = filetype.mime;
              var ext = filetype.ext;
              if (ext && !process.env.NTBA_FIX_350) {
                filename = filename + "." + ext;
              }
            } else if (!process.env.NTBA_FIX_350) {
              deprecate("An error will no longer be thrown if file-type of buffer could not be detected. " + deprecationMessage);
              throw new errors.FatalError("Unsupported Buffer file-type");
            }
          }
        } else if (data) {
          if (this.options.filepath && fs.existsSync(data)) {
            filedata = fs.createReadStream(data);
            if (!filename) {
              filename = path2.basename(data);
            }
          } else {
            return [null, data];
          }
        } else {
          return [null, data];
        }
        filename = filename || "filename";
        contentType = contentType || mime.lookup(filename);
        if (process.env.NTBA_FIX_350) {
          contentType = contentType || "application/octet-stream";
        } else {
          deprecate('In the future, content-type of files you send will default to "application/octet-stream". ' + deprecationMessage);
        }
        return [_defineProperty({}, type, {
          value: filedata,
          options: {
            filename,
            contentType
          }
        }), null];
      }
    }, {
      key: "startPolling",
      value: function startPolling() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (this.hasOpenWebHook()) {
          return Promise.reject(new errors.FatalError("Polling and WebHook are mutually exclusive"));
        }
        options.restart = typeof options.restart === "undefined" ? true : options.restart;
        if (!this._polling) {
          this._polling = new TelegramBotPolling(this);
        }
        return this._polling.start(options);
      }
    }, {
      key: "initPolling",
      value: function initPolling() {
        deprecate("TelegramBot#initPolling() is deprecated. Use TelegramBot#startPolling() instead.");
        return this.startPolling();
      }
    }, {
      key: "stopPolling",
      value: function stopPolling(options) {
        if (!this._polling) {
          return Promise.resolve();
        }
        return this._polling.stop(options);
      }
    }, {
      key: "getFileLink",
      value: function getFileLink(fileId) {
        var _this2 = this;
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return this.getFile(fileId, form).then(function(resp) {
          return _this2.options.baseApiUrl + "/file/bot" + _this2.token + "/" + resp.file_path;
        });
      }
    }, {
      key: "getFileStream",
      value: function getFileStream(fileId) {
        var _this3 = this;
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var fileStream = new stream4.PassThrough;
        fileStream.path = fileId;
        this.getFileLink(fileId, form).then(function(fileURI) {
          fileStream.emit("info", {
            uri: fileURI
          });
          pump(streamedRequest(Object.assign({ uri: fileURI }, _this3.options.request)), fileStream);
        }).catch(function(error2) {
          fileStream.emit("error", error2);
        });
        return fileStream;
      }
    }, {
      key: "downloadFile",
      value: function downloadFile(fileId, downloadDir) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var resolve = undefined;
        var reject = undefined;
        var promise = new Promise(function(a, b) {
          resolve = a;
          reject = b;
        });
        var fileStream = this.getFileStream(fileId, form);
        fileStream.on("info", function(info) {
          var fileName = info.uri.slice(info.uri.lastIndexOf("/") + 1);
          var filePath = path2.join(downloadDir, fileName);
          pump(fileStream, fs.createWriteStream(filePath), function(error2) {
            if (error2) {
              return reject(error2);
            }
            return resolve(filePath);
          });
        });
        fileStream.on("error", function(err) {
          reject(err);
        });
        return promise;
      }
    }, {
      key: "onText",
      value: function onText(regexp, callback) {
        this._textRegexpCallbacks.push({ regexp, callback });
      }
    }, {
      key: "removeTextListener",
      value: function removeTextListener(regexp) {
        var index = this._textRegexpCallbacks.findIndex(function(textListener) {
          return String(textListener.regexp) === String(regexp);
        });
        if (index === -1) {
          return null;
        }
        return this._textRegexpCallbacks.splice(index, 1)[0];
      }
    }, {
      key: "clearTextListeners",
      value: function clearTextListeners() {
        this._textRegexpCallbacks = [];
      }
    }, {
      key: "onReplyToMessage",
      value: function onReplyToMessage(chatId, messageId, callback) {
        var id = ++this._replyListenerId;
        this._replyListeners.push({
          id,
          chatId,
          messageId,
          callback
        });
        return id;
      }
    }, {
      key: "removeReplyListener",
      value: function removeReplyListener(replyListenerId) {
        var index = this._replyListeners.findIndex(function(replyListener) {
          return replyListener.id === replyListenerId;
        });
        if (index === -1) {
          return null;
        }
        return this._replyListeners.splice(index, 1)[0];
      }
    }, {
      key: "clearReplyListeners",
      value: function clearReplyListeners() {
        this._replyListeners = [];
      }
    }, {
      key: "isPolling",
      value: function isPolling() {
        return this._polling ? this._polling.isPolling() : false;
      }
    }, {
      key: "openWebHook",
      value: function openWebHook() {
        if (this.isPolling()) {
          return Promise.reject(new errors.FatalError("WebHook and Polling are mutually exclusive"));
        }
        if (!this._webHook) {
          this._webHook = new TelegramBotWebHook(this);
        }
        return this._webHook.open();
      }
    }, {
      key: "closeWebHook",
      value: function closeWebHook() {
        if (!this._webHook) {
          return Promise.resolve();
        }
        return this._webHook.close();
      }
    }, {
      key: "hasOpenWebHook",
      value: function hasOpenWebHook() {
        return this._webHook ? this._webHook.isOpen() : false;
      }
    }, {
      key: "processUpdate",
      value: function processUpdate(update) {
        var _this4 = this;
        debug("Process Update %j", update);
        var message = update.message;
        var editedMessage = update.edited_message;
        var channelPost = update.channel_post;
        var editedChannelPost = update.edited_channel_post;
        var businessConnection = update.business_connection;
        var businesssMessage = update.business_message;
        var editedBusinessMessage = update.edited_business_message;
        var deletedBusinessMessage = update.deleted_business_messages;
        var messageReaction = update.message_reaction;
        var messageReactionCount = update.message_reaction_count;
        var inlineQuery = update.inline_query;
        var chosenInlineResult = update.chosen_inline_result;
        var callbackQuery = update.callback_query;
        var shippingQuery = update.shipping_query;
        var preCheckoutQuery = update.pre_checkout_query;
        var poll = update.poll;
        var pollAnswer = update.poll_answer;
        var myChatMember = update.my_chat_member;
        var chatMember = update.chat_member;
        var chatJoinRequest = update.chat_join_request;
        var chatBoost = update.chat_boost;
        var removedChatBoost = update.removed_chat_boost;
        if (message) {
          debug("Process Update message %j", message);
          var metadata = {};
          metadata.type = TelegramBot2.messageTypes.find(function(messageType) {
            return message[messageType];
          });
          this.emit("message", message, metadata);
          if (metadata.type) {
            debug("Emitting %s: %j", metadata.type, message);
            this.emit(metadata.type, message, metadata);
          }
          if (message.text) {
            debug("Text message");
            this._textRegexpCallbacks.some(function(reg) {
              debug("Matching %s with %s", message.text, reg.regexp);
              if (!(reg.regexp instanceof RegExp)) {
                reg.regexp = new RegExp(reg.regexp);
              }
              var result = reg.regexp.exec(message.text);
              if (!result) {
                return false;
              }
              reg.regexp.lastIndex = 0;
              debug("Matches %s", reg.regexp);
              reg.callback(message, result);
              return _this4.options.onlyFirstMatch;
            });
          }
          if (message.reply_to_message) {
            this._replyListeners.forEach(function(reply) {
              if (reply.chatId === message.chat.id) {
                if (reply.messageId === message.reply_to_message.message_id) {
                  reply.callback(message);
                }
              }
            });
          }
        } else if (editedMessage) {
          debug("Process Update edited_message %j", editedMessage);
          this.emit("edited_message", editedMessage);
          if (editedMessage.text) {
            this.emit("edited_message_text", editedMessage);
          }
          if (editedMessage.caption) {
            this.emit("edited_message_caption", editedMessage);
          }
        } else if (channelPost) {
          debug("Process Update channel_post %j", channelPost);
          this.emit("channel_post", channelPost);
        } else if (editedChannelPost) {
          debug("Process Update edited_channel_post %j", editedChannelPost);
          this.emit("edited_channel_post", editedChannelPost);
          if (editedChannelPost.text) {
            this.emit("edited_channel_post_text", editedChannelPost);
          }
          if (editedChannelPost.caption) {
            this.emit("edited_channel_post_caption", editedChannelPost);
          }
        } else if (businessConnection) {
          debug("Process Update business_connection %j", businessConnection);
          this.emit("business_connection", businessConnection);
        } else if (businesssMessage) {
          debug("Process Update business_message %j", businesssMessage);
          this.emit("business_message", businesssMessage);
        } else if (editedBusinessMessage) {
          debug("Process Update edited_business_message %j", editedBusinessMessage);
          this.emit("edited_business_message", editedBusinessMessage);
        } else if (deletedBusinessMessage) {
          debug("Process Update deleted_business_messages %j", deletedBusinessMessage);
          this.emit("deleted_business_messages", deletedBusinessMessage);
        } else if (messageReaction) {
          debug("Process Update message_reaction %j", messageReaction);
          this.emit("message_reaction", messageReaction);
        } else if (messageReactionCount) {
          debug("Process Update message_reaction_count %j", messageReactionCount);
          this.emit("message_reaction_count", messageReactionCount);
        } else if (inlineQuery) {
          debug("Process Update inline_query %j", inlineQuery);
          this.emit("inline_query", inlineQuery);
        } else if (chosenInlineResult) {
          debug("Process Update chosen_inline_result %j", chosenInlineResult);
          this.emit("chosen_inline_result", chosenInlineResult);
        } else if (callbackQuery) {
          debug("Process Update callback_query %j", callbackQuery);
          this.emit("callback_query", callbackQuery);
        } else if (shippingQuery) {
          debug("Process Update shipping_query %j", shippingQuery);
          this.emit("shipping_query", shippingQuery);
        } else if (preCheckoutQuery) {
          debug("Process Update pre_checkout_query %j", preCheckoutQuery);
          this.emit("pre_checkout_query", preCheckoutQuery);
        } else if (poll) {
          debug("Process Update poll %j", poll);
          this.emit("poll", poll);
        } else if (pollAnswer) {
          debug("Process Update poll_answer %j", pollAnswer);
          this.emit("poll_answer", pollAnswer);
        } else if (chatMember) {
          debug("Process Update chat_member %j", chatMember);
          this.emit("chat_member", chatMember);
        } else if (myChatMember) {
          debug("Process Update my_chat_member %j", myChatMember);
          this.emit("my_chat_member", myChatMember);
        } else if (chatJoinRequest) {
          debug("Process Update my_chat_member %j", chatJoinRequest);
          this.emit("chat_join_request", chatJoinRequest);
        } else if (chatBoost) {
          debug("Process Update chat_boost %j", chatBoost);
          this.emit("chat_boost", chatBoost);
        } else if (removedChatBoost) {
          debug("Process Update removed_chat_boost %j", removedChatBoost);
          this.emit("removed_chat_boost", removedChatBoost);
        }
      }
    }, {
      key: "getUpdates",
      value: function getUpdates() {
        var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if ((typeof form === "undefined" ? "undefined" : _typeof(form)) !== "object") {
          deprecate("The method signature getUpdates(timeout, limit, offset) has been deprecated since v0.25.0");
          form = {
            timeout: arguments[0],
            limit: arguments[1],
            offset: arguments[2]
          };
        }
        return this._request("getUpdates", { form });
      }
    }, {
      key: "setWebHook",
      value: function setWebHook(url2) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var fileOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var cert = undefined;
        if ((typeof options === "undefined" ? "undefined" : _typeof(options)) !== "object" || options instanceof stream4.Stream) {
          deprecate("The method signature setWebHook(url, cert) has been deprecated since v0.25.0");
          cert = options;
          options = {};
        } else {
          cert = options.certificate;
        }
        var opts = {
          qs: options
        };
        opts.qs.url = url2;
        if (cert) {
          try {
            var sendData = this._formatSendData("certificate", cert, fileOptions);
            opts.formData = sendData[0];
            opts.qs.certificate = sendData[1];
          } catch (ex) {
            return Promise.reject(ex);
          }
        }
        return this._request("setWebHook", opts);
      }
    }, {
      key: "deleteWebHook",
      value: function deleteWebHook() {
        var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return this._request("deleteWebhook", { form });
      }
    }, {
      key: "getWebHookInfo",
      value: function getWebHookInfo() {
        var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return this._request("getWebhookInfo", { form });
      }
    }, {
      key: "getMe",
      value: function getMe() {
        var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return this._request("getMe", { form });
      }
    }, {
      key: "logOut",
      value: function logOut() {
        var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return this._request("logOut", { form });
      }
    }, {
      key: "close",
      value: function close() {
        var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return this._request("close", { form });
      }
    }, {
      key: "sendMessage",
      value: function sendMessage(chatId, text) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.text = text;
        return this._request("sendMessage", { form });
      }
    }, {
      key: "forwardMessage",
      value: function forwardMessage(chatId, fromChatId, messageId) {
        var form = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        form.chat_id = chatId;
        form.from_chat_id = fromChatId;
        form.message_id = messageId;
        return this._request("forwardMessage", { form });
      }
    }, {
      key: "forwardMessages",
      value: function forwardMessages(chatId, fromChatId, messageIds) {
        var form = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        form.chat_id = chatId;
        form.from_chat_id = fromChatId;
        form.message_ids = messageIds;
        return this._request("forwardMessages", { form });
      }
    }, {
      key: "copyMessage",
      value: function copyMessage(chatId, fromChatId, messageId) {
        var form = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        form.chat_id = chatId;
        form.from_chat_id = fromChatId;
        form.message_id = messageId;
        return this._request("copyMessage", { form });
      }
    }, {
      key: "copyMessages",
      value: function copyMessages(chatId, fromChatId, messageIds) {
        var form = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        form.chat_id = chatId;
        form.from_chat_id = fromChatId;
        form.message_ids = stringify2(messageIds);
        return this._request("copyMessages", { form });
      }
    }, {
      key: "sendPhoto",
      value: function sendPhoto(chatId, photo) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var fileOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        var opts = {
          qs: options
        };
        opts.qs.chat_id = chatId;
        try {
          var sendData = this._formatSendData("photo", photo, fileOptions);
          opts.formData = sendData[0];
          opts.qs.photo = sendData[1];
        } catch (ex) {
          return Promise.reject(ex);
        }
        return this._request("sendPhoto", opts);
      }
    }, {
      key: "sendAudio",
      value: function sendAudio(chatId, audio) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var fileOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        var opts = {
          qs: options
        };
        opts.qs.chat_id = chatId;
        try {
          var sendData = this._formatSendData("audio", audio, fileOptions);
          opts.formData = sendData[0];
          opts.qs.audio = sendData[1];
          this._fixAddFileThumbnail(options, opts);
        } catch (ex) {
          return Promise.reject(ex);
        }
        return this._request("sendAudio", opts);
      }
    }, {
      key: "sendDocument",
      value: function sendDocument(chatId, doc) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var fileOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        var opts = {
          qs: options
        };
        opts.qs.chat_id = chatId;
        try {
          var sendData = this._formatSendData("document", doc, fileOptions);
          opts.formData = sendData[0];
          opts.qs.document = sendData[1];
          this._fixAddFileThumbnail(options, opts);
        } catch (ex) {
          return Promise.reject(ex);
        }
        return this._request("sendDocument", opts);
      }
    }, {
      key: "sendVideo",
      value: function sendVideo(chatId, video) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var fileOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        var opts = {
          qs: options
        };
        opts.qs.chat_id = chatId;
        try {
          var sendData = this._formatSendData("video", video, fileOptions);
          opts.formData = sendData[0];
          opts.qs.video = sendData[1];
          this._fixAddFileThumbnail(options, opts);
        } catch (ex) {
          return Promise.reject(ex);
        }
        return this._request("sendVideo", opts);
      }
    }, {
      key: "sendAnimation",
      value: function sendAnimation(chatId, animation) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var fileOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        var opts = {
          qs: options
        };
        opts.qs.chat_id = chatId;
        try {
          var sendData = this._formatSendData("animation", animation, fileOptions);
          opts.formData = sendData[0];
          opts.qs.animation = sendData[1];
        } catch (ex) {
          return Promise.reject(ex);
        }
        return this._request("sendAnimation", opts);
      }
    }, {
      key: "sendVoice",
      value: function sendVoice(chatId, voice) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var fileOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        var opts = {
          qs: options
        };
        opts.qs.chat_id = chatId;
        try {
          var sendData = this._formatSendData("voice", voice, fileOptions);
          opts.formData = sendData[0];
          opts.qs.voice = sendData[1];
        } catch (ex) {
          return Promise.reject(ex);
        }
        return this._request("sendVoice", opts);
      }
    }, {
      key: "sendVideoNote",
      value: function sendVideoNote(chatId, videoNote) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var fileOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        var opts = {
          qs: options
        };
        opts.qs.chat_id = chatId;
        try {
          var sendData = this._formatSendData("video_note", videoNote, fileOptions);
          opts.formData = sendData[0];
          opts.qs.video_note = sendData[1];
          this._fixAddFileThumbnail(options, opts);
        } catch (ex) {
          return Promise.reject(ex);
        }
        return this._request("sendVideoNote", opts);
      }
    }, {
      key: "sendMediaGroup",
      value: function sendMediaGroup(chatId, media) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var opts = {
          qs: options
        };
        opts.qs.chat_id = chatId;
        opts.formData = {};
        var inputMedia = [];
        var index = 0;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;
        try {
          for (var _iterator = media[Symbol.iterator](), _step;!(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var input = _step.value;
            var payload = Object.assign({}, input);
            delete payload.media;
            delete payload.fileOptions;
            try {
              var attachName = String(index);
              var _formatSendData4 = this._formatSendData(attachName, input.media, input.fileOptions), _formatSendData5 = _slicedToArray(_formatSendData4, 2), formData = _formatSendData5[0], fileId = _formatSendData5[1];
              if (formData) {
                opts.formData[attachName] = formData[attachName];
                payload.media = "attach://" + attachName;
              } else {
                payload.media = fileId;
              }
            } catch (ex) {
              return Promise.reject(ex);
            }
            inputMedia.push(payload);
            index++;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        opts.qs.media = stringify2(inputMedia);
        return this._request("sendMediaGroup", opts);
      }
    }, {
      key: "sendLocation",
      value: function sendLocation(chatId, latitude, longitude) {
        var form = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        form.chat_id = chatId;
        form.latitude = latitude;
        form.longitude = longitude;
        return this._request("sendLocation", { form });
      }
    }, {
      key: "editMessageLiveLocation",
      value: function editMessageLiveLocation(latitude, longitude) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.latitude = latitude;
        form.longitude = longitude;
        return this._request("editMessageLiveLocation", { form });
      }
    }, {
      key: "stopMessageLiveLocation",
      value: function stopMessageLiveLocation() {
        var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return this._request("stopMessageLiveLocation", { form });
      }
    }, {
      key: "sendVenue",
      value: function sendVenue(chatId, latitude, longitude, title, address) {
        var form = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
        form.chat_id = chatId;
        form.latitude = latitude;
        form.longitude = longitude;
        form.title = title;
        form.address = address;
        return this._request("sendVenue", { form });
      }
    }, {
      key: "sendContact",
      value: function sendContact(chatId, phoneNumber, firstName) {
        var form = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        form.chat_id = chatId;
        form.phone_number = phoneNumber;
        form.first_name = firstName;
        return this._request("sendContact", { form });
      }
    }, {
      key: "sendPoll",
      value: function sendPoll(chatId, question, pollOptions) {
        var form = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        form.chat_id = chatId;
        form.question = question;
        form.options = stringify2(pollOptions);
        return this._request("sendPoll", { form });
      }
    }, {
      key: "sendDice",
      value: function sendDice(chatId) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var opts = {
          qs: options
        };
        opts.qs.chat_id = chatId;
        try {
          var sendData = this._formatSendData("dice");
          opts.formData = sendData[0];
        } catch (ex) {
          return Promise.reject(ex);
        }
        return this._request("sendDice", opts);
      }
    }, {
      key: "sendChatAction",
      value: function sendChatAction(chatId, action) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.action = action;
        return this._request("sendChatAction", { form });
      }
    }, {
      key: "setMessageReaction",
      value: function setMessageReaction(chatId, messageId) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.message_id = messageId;
        if (form.reaction) {
          form.reaction = stringify2(form.reaction);
        }
        return this._request("setMessageReaction", { form });
      }
    }, {
      key: "getUserProfilePhotos",
      value: function getUserProfilePhotos(userId) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        if ((typeof form === "undefined" ? "undefined" : _typeof(form)) !== "object") {
          deprecate("The method signature getUserProfilePhotos(userId, offset, limit) has been deprecated since v0.25.0");
          form = {
            offset: arguments[1],
            limit: arguments[2]
          };
        }
        form.user_id = userId;
        return this._request("getUserProfilePhotos", { form });
      }
    }, {
      key: "getFile",
      value: function getFile(fileId) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.file_id = fileId;
        return this._request("getFile", { form });
      }
    }, {
      key: "banChatMember",
      value: function banChatMember(chatId, userId) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.user_id = userId;
        return this._request("banChatMember", { form });
      }
    }, {
      key: "unbanChatMember",
      value: function unbanChatMember(chatId, userId) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.user_id = userId;
        return this._request("unbanChatMember", { form });
      }
    }, {
      key: "restrictChatMember",
      value: function restrictChatMember(chatId, userId) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.user_id = userId;
        return this._request("restrictChatMember", { form });
      }
    }, {
      key: "promoteChatMember",
      value: function promoteChatMember(chatId, userId) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.user_id = userId;
        return this._request("promoteChatMember", { form });
      }
    }, {
      key: "setChatAdministratorCustomTitle",
      value: function setChatAdministratorCustomTitle(chatId, userId, customTitle) {
        var form = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        form.chat_id = chatId;
        form.user_id = userId;
        form.custom_title = customTitle;
        return this._request("setChatAdministratorCustomTitle", { form });
      }
    }, {
      key: "banChatSenderChat",
      value: function banChatSenderChat(chatId, senderChatId) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.sender_chat_id = senderChatId;
        return this._request("banChatSenderChat", { form });
      }
    }, {
      key: "unbanChatSenderChat",
      value: function unbanChatSenderChat(chatId, senderChatId) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.sender_chat_id = senderChatId;
        return this._request("unbanChatSenderChat", { form });
      }
    }, {
      key: "setChatPermissions",
      value: function setChatPermissions(chatId, chatPermissions) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.permissions = stringify2(chatPermissions);
        return this._request("setChatPermissions", { form });
      }
    }, {
      key: "exportChatInviteLink",
      value: function exportChatInviteLink(chatId) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.chat_id = chatId;
        return this._request("exportChatInviteLink", { form });
      }
    }, {
      key: "createChatInviteLink",
      value: function createChatInviteLink(chatId) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.chat_id = chatId;
        return this._request("createChatInviteLink", { form });
      }
    }, {
      key: "editChatInviteLink",
      value: function editChatInviteLink(chatId, inviteLink) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.invite_link = inviteLink;
        return this._request("editChatInviteLink", { form });
      }
    }, {
      key: "revokeChatInviteLink",
      value: function revokeChatInviteLink(chatId, inviteLink) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.invite_link = inviteLink;
        return this._request("revokeChatInviteLink", { form });
      }
    }, {
      key: "approveChatJoinRequest",
      value: function approveChatJoinRequest(chatId, userId) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.user_id = userId;
        return this._request("approveChatJoinRequest", { form });
      }
    }, {
      key: "declineChatJoinRequest",
      value: function declineChatJoinRequest(chatId, userId) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.user_id = userId;
        return this._request("declineChatJoinRequest", { form });
      }
    }, {
      key: "setChatPhoto",
      value: function setChatPhoto(chatId, photo) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var fileOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        var opts = {
          qs: options
        };
        opts.qs.chat_id = chatId;
        try {
          var sendData = this._formatSendData("photo", photo, fileOptions);
          opts.formData = sendData[0];
          opts.qs.photo = sendData[1];
        } catch (ex) {
          return Promise.reject(ex);
        }
        return this._request("setChatPhoto", opts);
      }
    }, {
      key: "deleteChatPhoto",
      value: function deleteChatPhoto(chatId) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.chat_id = chatId;
        return this._request("deleteChatPhoto", { form });
      }
    }, {
      key: "setChatTitle",
      value: function setChatTitle(chatId, title) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.title = title;
        return this._request("setChatTitle", { form });
      }
    }, {
      key: "setChatDescription",
      value: function setChatDescription(chatId, description) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.description = description;
        return this._request("setChatDescription", { form });
      }
    }, {
      key: "pinChatMessage",
      value: function pinChatMessage(chatId, messageId) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.message_id = messageId;
        return this._request("pinChatMessage", { form });
      }
    }, {
      key: "unpinChatMessage",
      value: function unpinChatMessage(chatId) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.chat_id = chatId;
        return this._request("unpinChatMessage", { form });
      }
    }, {
      key: "unpinAllChatMessages",
      value: function unpinAllChatMessages(chatId) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.chat_id = chatId;
        return this._request("unpinAllChatMessages", { form });
      }
    }, {
      key: "leaveChat",
      value: function leaveChat(chatId) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.chat_id = chatId;
        return this._request("leaveChat", { form });
      }
    }, {
      key: "getChat",
      value: function getChat(chatId) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.chat_id = chatId;
        return this._request("getChat", { form });
      }
    }, {
      key: "getChatAdministrators",
      value: function getChatAdministrators(chatId) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.chat_id = chatId;
        return this._request("getChatAdministrators", { form });
      }
    }, {
      key: "getChatMemberCount",
      value: function getChatMemberCount(chatId) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.chat_id = chatId;
        return this._request("getChatMemberCount", { form });
      }
    }, {
      key: "getChatMember",
      value: function getChatMember(chatId, userId) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.user_id = userId;
        return this._request("getChatMember", { form });
      }
    }, {
      key: "setChatStickerSet",
      value: function setChatStickerSet(chatId, stickerSetName) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.sticker_set_name = stickerSetName;
        return this._request("setChatStickerSet", { form });
      }
    }, {
      key: "deleteChatStickerSet",
      value: function deleteChatStickerSet(chatId) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.chat_id = chatId;
        return this._request("deleteChatStickerSet", { form });
      }
    }, {
      key: "getForumTopicIconStickers",
      value: function getForumTopicIconStickers(chatId) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.chat_id = chatId;
        return this._request("getForumTopicIconStickers", { form });
      }
    }, {
      key: "createForumTopic",
      value: function createForumTopic(chatId, name) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.name = name;
        return this._request("createForumTopic", { form });
      }
    }, {
      key: "editForumTopic",
      value: function editForumTopic(chatId, messageThreadId) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.message_thread_id = messageThreadId;
        return this._request("editForumTopic", { form });
      }
    }, {
      key: "closeForumTopic",
      value: function closeForumTopic(chatId, messageThreadId) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.message_thread_id = messageThreadId;
        return this._request("closeForumTopic", { form });
      }
    }, {
      key: "reopenForumTopic",
      value: function reopenForumTopic(chatId, messageThreadId) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.message_thread_id = messageThreadId;
        return this._request("reopenForumTopic", { form });
      }
    }, {
      key: "deleteForumTopic",
      value: function deleteForumTopic(chatId, messageThreadId) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.message_thread_id = messageThreadId;
        return this._request("deleteForumTopic", { form });
      }
    }, {
      key: "unpinAllForumTopicMessages",
      value: function unpinAllForumTopicMessages(chatId, messageThreadId) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.message_thread_id = messageThreadId;
        return this._request("unpinAllForumTopicMessages", { form });
      }
    }, {
      key: "editGeneralForumTopic",
      value: function editGeneralForumTopic(chatId, name) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.name = name;
        return this._request("editGeneralForumTopic", { form });
      }
    }, {
      key: "closeGeneralForumTopic",
      value: function closeGeneralForumTopic(chatId) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.chat_id = chatId;
        return this._request("closeGeneralForumTopic", { form });
      }
    }, {
      key: "reopenGeneralForumTopic",
      value: function reopenGeneralForumTopic(chatId) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.chat_id = chatId;
        return this._request("reopenGeneralForumTopic", { form });
      }
    }, {
      key: "hideGeneralForumTopic",
      value: function hideGeneralForumTopic(chatId) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.chat_id = chatId;
        return this._request("hideGeneralForumTopic", { form });
      }
    }, {
      key: "unhideGeneralForumTopic",
      value: function unhideGeneralForumTopic(chatId) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.chat_id = chatId;
        return this._request("unhideGeneralForumTopic", { form });
      }
    }, {
      key: "unpinAllGeneralForumTopicMessages",
      value: function unpinAllGeneralForumTopicMessages(chatId) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.chat_id = chatId;
        return this._request("unhideGeneralForumTopic", { form });
      }
    }, {
      key: "answerCallbackQuery",
      value: function answerCallbackQuery(callbackQueryId) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        if ((typeof form === "undefined" ? "undefined" : _typeof(form)) !== "object") {
          deprecate("The method signature answerCallbackQuery(callbackQueryId, text, showAlert) has been deprecated since v0.27.1");
          form = {
            callback_query_id: arguments[0],
            text: arguments[1],
            show_alert: arguments[2]
          };
        }
        if ((typeof callbackQueryId === "undefined" ? "undefined" : _typeof(callbackQueryId)) === "object") {
          deprecate("The method signature answerCallbackQuery([options]) has been deprecated since v0.29.0");
          form = callbackQueryId;
        } else {
          form.callback_query_id = callbackQueryId;
        }
        return this._request("answerCallbackQuery", { form });
      }
    }, {
      key: "getUserChatBoosts",
      value: function getUserChatBoosts(chatId, pollId) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.message_id = pollId;
        return this._request("getUserChatBoosts", { form });
      }
    }, {
      key: "getBusinessConnection",
      value: function getBusinessConnection(businessConnectionId) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.business_connection_id = businessConnectionId;
        return this._request("getBusinessConnection", { form });
      }
    }, {
      key: "setMyCommands",
      value: function setMyCommands(commands) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.commands = stringify2(commands);
        if (form.scope) {
          form.scope = stringify2(form.scope);
        }
        return this._request("setMyCommands", { form });
      }
    }, {
      key: "deleteMyCommands",
      value: function deleteMyCommands() {
        var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return this._request("deleteMyCommands", { form });
      }
    }, {
      key: "getMyCommands",
      value: function getMyCommands() {
        var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (form.scope) {
          form.scope = stringify2(form.scope);
        }
        return this._request("getMyCommands", { form });
      }
    }, {
      key: "setMyName",
      value: function setMyName() {
        var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return this._request("setMyName", { form });
      }
    }, {
      key: "getMyName",
      value: function getMyName() {
        var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return this._request("getMyName", { form });
      }
    }, {
      key: "setMyDescription",
      value: function setMyDescription() {
        var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return this._request("setMyDescription", { form });
      }
    }, {
      key: "getMyDescription",
      value: function getMyDescription() {
        var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return this._request("getMyDescription", { form });
      }
    }, {
      key: "setMyShortDescription",
      value: function setMyShortDescription() {
        var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return this._request("setMyShortDescription", { form });
      }
    }, {
      key: "getMyShortDescription",
      value: function getMyShortDescription() {
        var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return this._request("getMyShortDescription", { form });
      }
    }, {
      key: "setChatMenuButton",
      value: function setChatMenuButton() {
        var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return this._request("setChatMenuButton", { form });
      }
    }, {
      key: "getChatMenuButton",
      value: function getChatMenuButton() {
        var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return this._request("getChatMenuButton", { form });
      }
    }, {
      key: "setMyDefaultAdministratorRights",
      value: function setMyDefaultAdministratorRights() {
        var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return this._request("setMyDefaultAdministratorRights", { form });
      }
    }, {
      key: "getMyDefaultAdministratorRights",
      value: function getMyDefaultAdministratorRights() {
        var form = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return this._request("getMyDefaultAdministratorRights", { form });
      }
    }, {
      key: "editMessageText",
      value: function editMessageText(text) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.text = text;
        return this._request("editMessageText", { form });
      }
    }, {
      key: "editMessageCaption",
      value: function editMessageCaption(caption) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.caption = caption;
        return this._request("editMessageCaption", { form });
      }
    }, {
      key: "editMessageMedia",
      value: function editMessageMedia(media) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var regexAttach = /attach:\/\/.+/;
        if (typeof media.media === "string" && regexAttach.test(media.media)) {
          var opts = {
            qs: form
          };
          opts.formData = {};
          var payload = Object.assign({}, media);
          delete payload.media;
          try {
            var attachName = String(0);
            var _formatSendData6 = this._formatSendData(attachName, media.media.replace("attach://", ""), media.fileOptions), _formatSendData7 = _slicedToArray(_formatSendData6, 1), formData = _formatSendData7[0];
            if (formData) {
              opts.formData[attachName] = formData[attachName];
              payload.media = "attach://" + attachName;
            } else {
              throw new errors.FatalError("Failed to process the replacement action for your " + media.type);
            }
          } catch (ex) {
            return Promise.reject(ex);
          }
          opts.qs.media = stringify2(payload);
          return this._request("editMessageMedia", opts);
        }
        form.media = stringify2(media);
        return this._request("editMessageMedia", { form });
      }
    }, {
      key: "editMessageReplyMarkup",
      value: function editMessageReplyMarkup(replyMarkup) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.reply_markup = replyMarkup;
        return this._request("editMessageReplyMarkup", { form });
      }
    }, {
      key: "stopPoll",
      value: function stopPoll(chatId, pollId) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.message_id = pollId;
        return this._request("stopPoll", { form });
      }
    }, {
      key: "sendSticker",
      value: function sendSticker(chatId, sticker) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var fileOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        var opts = {
          qs: options
        };
        opts.qs.chat_id = chatId;
        try {
          var sendData = this._formatSendData("sticker", sticker, fileOptions);
          opts.formData = sendData[0];
          opts.qs.sticker = sendData[1];
        } catch (ex) {
          return Promise.reject(ex);
        }
        return this._request("sendSticker", opts);
      }
    }, {
      key: "getStickerSet",
      value: function getStickerSet(name) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.name = name;
        return this._request("getStickerSet", { form });
      }
    }, {
      key: "getCustomEmojiStickers",
      value: function getCustomEmojiStickers(customEmojiIds) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.custom_emoji_ids = stringify2(customEmojiIds);
        return this._request("getCustomEmojiStickers", { form });
      }
    }, {
      key: "uploadStickerFile",
      value: function uploadStickerFile(userId, sticker) {
        var stickerFormat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "static";
        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        var fileOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
        var opts = {
          qs: options
        };
        opts.qs.user_id = userId;
        opts.qs.sticker_format = stickerFormat;
        try {
          var sendData = this._formatSendData("sticker", sticker, fileOptions);
          opts.formData = sendData[0];
          opts.qs.sticker = sendData[1];
        } catch (ex) {
          return Promise.reject(ex);
        }
        return this._request("uploadStickerFile", opts);
      }
    }, {
      key: "createNewStickerSet",
      value: function createNewStickerSet(userId, name, title, pngSticker, emojis) {
        var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
        var fileOptions = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};
        var opts = {
          qs: options
        };
        opts.qs.user_id = userId;
        opts.qs.name = name;
        opts.qs.title = title;
        opts.qs.emojis = emojis;
        opts.qs.mask_position = stringify2(options.mask_position);
        try {
          var sendData = this._formatSendData("png_sticker", pngSticker, fileOptions);
          opts.formData = sendData[0];
          opts.qs.png_sticker = sendData[1];
        } catch (ex) {
          return Promise.reject(ex);
        }
        return this._request("createNewStickerSet", opts);
      }
    }, {
      key: "addStickerToSet",
      value: function addStickerToSet(userId, name, sticker, emojis) {
        var stickerType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "png_sticker";
        var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
        var fileOptions = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};
        var opts = {
          qs: options
        };
        opts.qs.user_id = userId;
        opts.qs.name = name;
        opts.qs.emojis = emojis;
        opts.qs.mask_position = stringify2(options.mask_position);
        if (typeof stickerType !== "string" || ["png_sticker", "tgs_sticker", "webm_sticker"].indexOf(stickerType) === -1) {
          return Promise.reject(new Error("stickerType must be a string and the allow types is: png_sticker, tgs_sticker, webm_sticker"));
        }
        try {
          var sendData = this._formatSendData(stickerType, sticker, fileOptions);
          opts.formData = sendData[0];
          opts.qs[stickerType] = sendData[1];
        } catch (ex) {
          return Promise.reject(ex);
        }
        return this._request("addStickerToSet", opts);
      }
    }, {
      key: "setStickerPositionInSet",
      value: function setStickerPositionInSet(sticker, position) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.sticker = sticker;
        form.position = position;
        return this._request("setStickerPositionInSet", { form });
      }
    }, {
      key: "deleteStickerFromSet",
      value: function deleteStickerFromSet(sticker) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.sticker = sticker;
        return this._request("deleteStickerFromSet", { form });
      }
    }, {
      key: "replaceStickerInSet",
      value: function replaceStickerInSet(userId, name, oldSticker) {
        var form = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        form.user_id = userId;
        form.name = name;
        form.old_sticker = oldSticker;
        return this._request("deleteStickerFromSet", { form });
      }
    }, {
      key: "setStickerEmojiList",
      value: function setStickerEmojiList(sticker, emojiList) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.sticker = sticker;
        form.emoji_list = stringify2(emojiList);
        return this._request("setStickerEmojiList", { form });
      }
    }, {
      key: "setStickerKeywords",
      value: function setStickerKeywords(sticker) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.sticker = sticker;
        if (form.keywords) {
          form.keywords = stringify2(form.keywords);
        }
        return this._request("setStickerKeywords", { form });
      }
    }, {
      key: "setStickerMaskPosition",
      value: function setStickerMaskPosition(sticker) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.sticker = sticker;
        if (form.mask_position) {
          form.mask_position = stringify2(form.mask_position);
        }
        return this._request("setStickerMaskPosition", { form });
      }
    }, {
      key: "setStickerSetTitle",
      value: function setStickerSetTitle(name, title) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.name = name;
        form.title = title;
        return this._request("setStickerSetTitle", { form });
      }
    }, {
      key: "setStickerSetThumbnail",
      value: function setStickerSetThumbnail(userId, name, thumbnail) {
        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        var fileOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
        var opts = {
          qs: options
        };
        opts.qs.user_id = userId;
        opts.qs.name = name;
        opts.qs.mask_position = stringify2(options.mask_position);
        try {
          var sendData = this._formatSendData("thumbnail", thumbnail, fileOptions);
          opts.formData = sendData[0];
          opts.qs.thumbnail = sendData[1];
        } catch (ex) {
          return Promise.reject(ex);
        }
        return this._request("setStickerSetThumbnail", opts);
      }
    }, {
      key: "setCustomEmojiStickerSetThumbnail",
      value: function setCustomEmojiStickerSetThumbnail(name) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.name = name;
        return this._request("setCustomEmojiStickerSetThumbnail", { form });
      }
    }, {
      key: "deleteStickerSet",
      value: function deleteStickerSet(name) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.name = name;
        return this._request("deleteStickerSet", { form });
      }
    }, {
      key: "answerInlineQuery",
      value: function answerInlineQuery(inlineQueryId, results) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.inline_query_id = inlineQueryId;
        form.results = stringify2(results);
        return this._request("answerInlineQuery", { form });
      }
    }, {
      key: "answerWebAppQuery",
      value: function answerWebAppQuery(webAppQueryId, result) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.web_app_query_id = webAppQueryId;
        form.result = stringify2(result);
        return this._request("answerWebAppQuery", { form });
      }
    }, {
      key: "sendInvoice",
      value: function sendInvoice(chatId, title, description, payload, providerToken, currency, prices) {
        var form = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};
        form.chat_id = chatId;
        form.title = title;
        form.description = description;
        form.payload = payload;
        form.provider_token = providerToken;
        form.currency = currency;
        form.prices = stringify2(prices);
        form.provider_data = stringify2(form.provider_data);
        if (form.suggested_tip_amounts) {
          form.suggested_tip_amounts = stringify2(form.suggested_tip_amounts);
        }
        return this._request("sendInvoice", { form });
      }
    }, {
      key: "createInvoiceLink",
      value: function createInvoiceLink(title, description, payload, providerToken, currency, prices) {
        var form = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};
        form.title = title;
        form.description = description;
        form.payload = payload;
        form.provider_token = providerToken;
        form.currency = currency;
        form.prices = stringify2(prices);
        return this._request("createInvoiceLink", { form });
      }
    }, {
      key: "answerShippingQuery",
      value: function answerShippingQuery(shippingQueryId, ok) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.shipping_query_id = shippingQueryId;
        form.ok = ok;
        form.shipping_options = stringify2(form.shipping_options);
        return this._request("answerShippingQuery", { form });
      }
    }, {
      key: "answerPreCheckoutQuery",
      value: function answerPreCheckoutQuery(preCheckoutQueryId, ok) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.pre_checkout_query_id = preCheckoutQueryId;
        form.ok = ok;
        return this._request("answerPreCheckoutQuery", { form });
      }
    }, {
      key: "sendGame",
      value: function sendGame(chatId, gameShortName) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.game_short_name = gameShortName;
        return this._request("sendGame", { form });
      }
    }, {
      key: "setGameScore",
      value: function setGameScore(userId, score) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.user_id = userId;
        form.score = score;
        return this._request("setGameScore", { form });
      }
    }, {
      key: "getGameHighScores",
      value: function getGameHighScores(userId) {
        var form = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        form.user_id = userId;
        return this._request("getGameHighScores", { form });
      }
    }, {
      key: "deleteMessage",
      value: function deleteMessage(chatId, messageId) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.message_id = messageId;
        return this._request("deleteMessage", { form });
      }
    }, {
      key: "deleteMessages",
      value: function deleteMessages(chatId, messageIds) {
        var form = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        form.chat_id = chatId;
        form.message_ids = stringify2(messageIds);
        return this._request("deleteMessages", { form });
      }
    }]);
    return TelegramBot2;
  }(EventEmitter2);
  module2.exports = TelegramBot;
});

// backend/node_modules/node-telegram-bot-api/src/errors.js
var require_errors9 = __commonJS((exports2) => {
  exports2.BaseError = class BaseError extends Error {
    constructor(code, message) {
      super(`${code}: ${message}`);
      this.code = code;
    }
    toJSON() {
      return {
        code: this.code,
        message: this.message
      };
    }
  };
  exports2.FatalError = class FatalError extends exports2.BaseError {
    constructor(data) {
      const error2 = typeof data === "string" ? null : data;
      const message = error2 ? error2.message : data;
      super("EFATAL", message);
      if (error2)
        this.stack = error2.stack;
    }
  };
  exports2.ParseError = class ParseError extends exports2.BaseError {
    constructor(message, response) {
      super("EPARSE", message);
      this.response = response;
    }
  };
  exports2.TelegramError = class TelegramError extends exports2.BaseError {
    constructor(message, response) {
      super("ETELEGRAM", message);
      this.response = response;
    }
  };
});

// backend/node_modules/node-telegram-bot-api/src/telegramWebHook.js
var require_telegramWebHook2 = __commonJS((exports2, module2) => {
  var errors = require_errors9();
  var debug = require_src()("node-telegram-bot-api");
  var https2 = require("https");
  var http3 = require("http");
  var fs = require("fs");
  var bl = require_bl();

  class TelegramBotWebHook {
    constructor(bot) {
      this.bot = bot;
      this.options = typeof bot.options.webHook === "boolean" ? {} : bot.options.webHook;
      this.options.host = this.options.host || "0.0.0.0";
      this.options.port = this.options.port || 8443;
      this.options.https = this.options.https || {};
      this.options.healthEndpoint = this.options.healthEndpoint || "/healthz";
      this._healthRegex = new RegExp(this.options.healthEndpoint);
      this._webServer = null;
      this._open = false;
      this._requestListener = this._requestListener.bind(this);
      this._parseBody = this._parseBody.bind(this);
      if (this.options.key && this.options.cert) {
        debug("HTTPS WebHook enabled (by key/cert)");
        this.options.https.key = fs.readFileSync(this.options.key);
        this.options.https.cert = fs.readFileSync(this.options.cert);
        this._webServer = https2.createServer(this.options.https, this._requestListener);
      } else if (this.options.pfx) {
        debug("HTTPS WebHook enabled (by pfx)");
        this.options.https.pfx = fs.readFileSync(this.options.pfx);
        this._webServer = https2.createServer(this.options.https, this._requestListener);
      } else if (Object.keys(this.options.https).length) {
        debug("HTTPS WebHook enabled by (https)");
        this._webServer = https2.createServer(this.options.https, this._requestListener);
      } else {
        debug("HTTP WebHook enabled");
        this._webServer = http3.createServer(this._requestListener);
      }
    }
    open() {
      if (this.isOpen()) {
        return Promise.resolve();
      }
      return new Promise((resolve, reject) => {
        this._webServer.listen(this.options.port, this.options.host, () => {
          debug("WebHook listening on port %s", this.options.port);
          this._open = true;
          return resolve();
        });
        this._webServer.once("error", (err) => {
          reject(err);
        });
      });
    }
    close() {
      if (!this.isOpen()) {
        return Promise.resolve();
      }
      return new Promise((resolve, reject) => {
        this._webServer.close((error2) => {
          if (error2)
            return reject(error2);
          this._open = false;
          return resolve();
        });
      });
    }
    isOpen() {
      return this._open;
    }
    _error(error2) {
      if (!this.bot.listeners("webhook_error").length) {
        return console.error("error: [webhook_error] %j", error2);
      }
      return this.bot.emit("webhook_error", error2);
    }
    _parseBody(error2, body) {
      if (error2) {
        return this._error(new errors.FatalError(error2));
      }
      let data;
      try {
        data = JSON.parse(body.toString());
      } catch (parseError) {
        return this._error(new errors.ParseError(parseError.message));
      }
      return this.bot.processUpdate(data);
    }
    _requestListener(req, res) {
      debug("WebHook request URL: %s", req.url);
      debug("WebHook request headers: %j", req.headers);
      if (req.url.indexOf(this.bot.token) !== -1) {
        if (req.method !== "POST") {
          debug("WebHook request isn't a POST");
          res.statusCode = 418;
          res.end();
        } else {
          req.pipe(bl(this._parseBody)).on("finish", () => res.end("OK"));
        }
      } else if (this._healthRegex.test(req.url)) {
        debug("WebHook health check passed");
        res.statusCode = 200;
        res.end("OK");
      } else {
        debug("WebHook request unauthorized");
        res.statusCode = 401;
        res.end();
      }
    }
  }
  module2.exports = TelegramBotWebHook;
});

// backend/node_modules/node-telegram-bot-api/src/telegramPolling.js
var require_telegramPolling2 = __commonJS((exports2, module2) => {
  var errors = require_errors9();
  var debug = require_src()("node-telegram-bot-api");
  var deprecate = require_utils().deprecate;
  var ANOTHER_WEB_HOOK_USED = 409;

  class TelegramBotPolling {
    constructor(bot) {
      this.bot = bot;
      this.options = typeof bot.options.polling === "boolean" ? {} : bot.options.polling;
      this.options.interval = typeof this.options.interval === "number" ? this.options.interval : 300;
      this.options.params = typeof this.options.params === "object" ? this.options.params : {};
      this.options.params.offset = typeof this.options.params.offset === "number" ? this.options.params.offset : 0;
      this.options.params.timeout = typeof this.options.params.timeout === "number" ? this.options.params.timeout : 10;
      if (typeof this.options.timeout === "number") {
        deprecate("`options.polling.timeout` is deprecated. Use `options.polling.params` instead.");
        this.options.params.timeout = this.options.timeout;
      }
      this._lastUpdate = 0;
      this._lastRequest = null;
      this._abort = false;
      this._pollingTimeout = null;
    }
    start(options = {}) {
      if (this._lastRequest) {
        if (!options.restart) {
          return Promise.resolve();
        }
        return this.stop({
          cancel: true,
          reason: "Polling restart"
        }).then(() => {
          return this._polling();
        });
      }
      return this._polling();
    }
    stop(options = {}) {
      if (!this._lastRequest) {
        return Promise.resolve();
      }
      const lastRequest = this._lastRequest;
      this._lastRequest = null;
      clearTimeout(this._pollingTimeout);
      if (options.cancel) {
        const reason = options.reason || "Polling stop";
        lastRequest.cancel(reason);
        return Promise.resolve();
      }
      this._abort = true;
      return lastRequest.finally(() => {
        this._abort = false;
      });
    }
    isPolling() {
      return !!this._lastRequest;
    }
    _error(error2) {
      if (!this.bot.listeners("polling_error").length) {
        return console.error("error: [polling_error] %j", error2);
      }
      return this.bot.emit("polling_error", error2);
    }
    _polling() {
      this._lastRequest = this._getUpdates().then((updates) => {
        this._lastUpdate = Date.now();
        debug("polling data %j", updates);
        updates.forEach((update) => {
          this.options.params.offset = update.update_id + 1;
          debug("updated offset: %s", this.options.params.offset);
          try {
            this.bot.processUpdate(update);
          } catch (err) {
            err._processing = true;
            throw err;
          }
        });
        return null;
      }).catch((err) => {
        debug("polling error: %s", err.message);
        if (!err._processing) {
          return this._error(err);
        }
        delete err._processing;
        if (!this.bot.options.badRejection) {
          return this._error(err);
        }
        const opts = {
          offset: this.options.params.offset,
          limit: 1,
          timeout: 0
        };
        return this.bot.getUpdates(opts).then(() => {
          return this._error(err);
        }).catch((requestErr) => {
          const bugUrl = "https://github.com/yagop/node-telegram-bot-api/issues/36#issuecomment-268532067";
          console.error("error: Internal handling of The Offset Infinite Loop failed");
          console.error(`error: Due to error '${requestErr}'`);
          console.error("error: You may receive already-processed updates on app restart");
          console.error(`error: Please see ${bugUrl} for more information`);
          return this.bot.emit("error", new errors.FatalError(err));
        });
      }).finally(() => {
        if (this._abort) {
          debug("Polling is aborted!");
        } else {
          debug("setTimeout for %s miliseconds", this.options.interval);
          this._pollingTimeout = setTimeout(() => this._polling(), this.options.interval);
        }
      });
      return this._lastRequest;
    }
    _unsetWebHook() {
      debug("unsetting webhook");
      return this.bot._request("setWebHook");
    }
    _getUpdates() {
      debug("polling with options: %j", this.options.params);
      return this.bot.getUpdates(this.options.params).catch((err) => {
        if (err.response && err.response.statusCode === ANOTHER_WEB_HOOK_USED) {
          return this._unsetWebHook().then(() => {
            return this.bot.getUpdates(this.options.params);
          });
        }
        throw err;
      });
    }
  }
  module2.exports = TelegramBotPolling;
});

// backend/node_modules/node-telegram-bot-api/src/telegram.js
var require_telegram2 = __commonJS((exports2, module2) => {
  require_array_prototype().shim();
  var errors = require_errors9();
  var TelegramBotWebHook = require_telegramWebHook2();
  var TelegramBotPolling = require_telegramPolling2();
  var debug = require_src()("node-telegram-bot-api");
  var EventEmitter2 = require_eventemitter3();
  var fileType = require_file_type();
  var request = require_rp();
  var streamedRequest = require_request3();
  var qs = require("querystring");
  var stream4 = require("stream");
  var mime = require_mime();
  var path2 = require("path");
  var URL2 = require("url");
  var fs = require("fs");
  var pump = require_pump();
  var deprecate = require_utils().deprecate;
  var _messageTypes = [
    "text",
    "animation",
    "audio",
    "channel_chat_created",
    "contact",
    "delete_chat_photo",
    "dice",
    "document",
    "game",
    "group_chat_created",
    "invoice",
    "left_chat_member",
    "location",
    "migrate_from_chat_id",
    "migrate_to_chat_id",
    "new_chat_members",
    "new_chat_photo",
    "new_chat_title",
    "passport_data",
    "photo",
    "pinned_message",
    "poll",
    "sticker",
    "successful_payment",
    "supergroup_chat_created",
    "video",
    "video_note",
    "voice",
    "video_chat_started",
    "video_chat_ended",
    "video_chat_participants_invited",
    "video_chat_scheduled",
    "message_auto_delete_timer_changed",
    "chat_invite_link",
    "chat_member_updated",
    "web_app_data",
    "message_reaction"
  ];
  var _deprecatedMessageTypes = [
    "new_chat_participant",
    "left_chat_participant"
  ];
  function stringify2(data) {
    if (typeof data === "string") {
      return data;
    }
    return JSON.stringify(data);
  }

  class TelegramBot extends EventEmitter2 {
    static get errors() {
      return errors;
    }
    static get messageTypes() {
      return _messageTypes;
    }
    on(event, listener) {
      if (_deprecatedMessageTypes.indexOf(event) !== -1) {
        const url2 = "https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#events";
        deprecate(`Events ${_deprecatedMessageTypes.join(",")} are deprecated. See the updated list of events: ${url2}`);
      }
      super.on(event, listener);
    }
    constructor(token, options = {}) {
      super();
      this.token = token;
      this.options = options;
      this.options.polling = typeof options.polling === "undefined" ? false : options.polling;
      this.options.webHook = typeof options.webHook === "undefined" ? false : options.webHook;
      this.options.baseApiUrl = options.baseApiUrl || "https://api.telegram.org";
      this.options.filepath = typeof options.filepath === "undefined" ? true : options.filepath;
      this.options.badRejection = typeof options.badRejection === "undefined" ? false : options.badRejection;
      this._textRegexpCallbacks = [];
      this._replyListenerId = 0;
      this._replyListeners = [];
      this._polling = null;
      this._webHook = null;
      if (options.polling) {
        const autoStart = options.polling.autoStart;
        if (typeof autoStart === "undefined" || autoStart === true) {
          this.startPolling();
        }
      }
      if (options.webHook) {
        const autoOpen = options.webHook.autoOpen;
        if (typeof autoOpen === "undefined" || autoOpen === true) {
          this.openWebHook();
        }
      }
    }
    _buildURL(_path) {
      return `${this.options.baseApiUrl}/bot${this.token}${this.options.testEnvironment ? "/test" : ""}/${_path}`;
    }
    _fixReplyMarkup(obj2) {
      const replyMarkup = obj2.reply_markup;
      if (replyMarkup && typeof replyMarkup !== "string") {
        obj2.reply_markup = stringify2(replyMarkup);
      }
    }
    _fixEntitiesField(obj2) {
      const entities = obj2.entities;
      const captionEntities = obj2.caption_entities;
      const explanationEntities = obj2.explanation_entities;
      if (entities && typeof entities !== "string") {
        obj2.entities = stringify2(entities);
      }
      if (captionEntities && typeof captionEntities !== "string") {
        obj2.caption_entities = stringify2(captionEntities);
      }
      if (explanationEntities && typeof explanationEntities !== "string") {
        obj2.explanation_entities = stringify2(explanationEntities);
      }
    }
    _fixAddFileThumbnail(options, opts) {
      if (options.thumb) {
        if (opts.formData === null) {
          opts.formData = {};
        }
        const attachName = "photo";
        const [formData] = this._formatSendData(attachName, options.thumb.replace("attach://", ""));
        if (formData) {
          opts.formData[attachName] = formData[attachName];
          opts.qs.thumbnail = `attach://${attachName}`;
        }
      }
    }
    _fixReplyParameters(obj2) {
      if (obj2.hasOwnProperty("reply_parameters") && typeof obj2.reply_parameters !== "string") {
        obj2.reply_parameters = stringify2(obj2.reply_parameters);
      }
    }
    _request(_path, options = {}) {
      if (!this.token) {
        return Promise.reject(new errors.FatalError("Telegram Bot Token not provided!"));
      }
      if (this.options.request) {
        Object.assign(options, this.options.request);
      }
      if (options.form) {
        this._fixReplyMarkup(options.form);
        this._fixEntitiesField(options.form);
        this._fixReplyParameters(options.form);
      }
      if (options.qs) {
        this._fixReplyMarkup(options.qs);
        this._fixReplyParameters(options.qs);
      }
      options.method = "POST";
      options.url = this._buildURL(_path);
      options.simple = false;
      options.resolveWithFullResponse = true;
      options.forever = true;
      debug("HTTP request: %j", options);
      return request(options).then((resp) => {
        let data;
        try {
          data = resp.body = JSON.parse(resp.body);
        } catch (err) {
          throw new errors.ParseError(`Error parsing response: ${resp.body}`, resp);
        }
        if (data.ok) {
          return data.result;
        }
        throw new errors.TelegramError(`${data.error_code} ${data.description}`, resp);
      }).catch((error2) => {
        if (error2.response)
          throw error2;
        throw new errors.FatalError(error2);
      });
    }
    _formatSendData(type, data, fileOptions = {}) {
      const deprecationMessage = "See https://github.com/yagop/node-telegram-bot-api/blob/master/doc/usage.md#sending-files" + " for more information on how sending files has been improved and" + " on how to disable this deprecation message altogether.";
      let filedata = data;
      let filename = fileOptions.filename;
      let contentType = fileOptions.contentType;
      if (data instanceof stream4.Stream) {
        if (!filename && data.path) {
          const url2 = URL2.parse(path2.basename(data.path.toString()));
          if (url2.pathname) {
            filename = qs.unescape(url2.pathname);
          }
        }
      } else if (Buffer.isBuffer(data)) {
        if (!filename && !process.env.NTBA_FIX_350) {
          deprecate(`Buffers will have their filenames default to "filename" instead of "data". ${deprecationMessage}`);
          filename = "data";
        }
        if (!contentType) {
          const filetype = fileType(data);
          if (filetype) {
            contentType = filetype.mime;
            const ext = filetype.ext;
            if (ext && !process.env.NTBA_FIX_350) {
              filename = `${filename}.${ext}`;
            }
          } else if (!process.env.NTBA_FIX_350) {
            deprecate(`An error will no longer be thrown if file-type of buffer could not be detected. ${deprecationMessage}`);
            throw new errors.FatalError("Unsupported Buffer file-type");
          }
        }
      } else if (data) {
        if (this.options.filepath && fs.existsSync(data)) {
          filedata = fs.createReadStream(data);
          if (!filename) {
            filename = path2.basename(data);
          }
        } else {
          return [null, data];
        }
      } else {
        return [null, data];
      }
      filename = filename || "filename";
      contentType = contentType || mime.lookup(filename);
      if (process.env.NTBA_FIX_350) {
        contentType = contentType || "application/octet-stream";
      } else {
        deprecate(`In the future, content-type of files you send will default to "application/octet-stream". ${deprecationMessage}`);
      }
      return [{
        [type]: {
          value: filedata,
          options: {
            filename,
            contentType
          }
        }
      }, null];
    }
    startPolling(options = {}) {
      if (this.hasOpenWebHook()) {
        return Promise.reject(new errors.FatalError("Polling and WebHook are mutually exclusive"));
      }
      options.restart = typeof options.restart === "undefined" ? true : options.restart;
      if (!this._polling) {
        this._polling = new TelegramBotPolling(this);
      }
      return this._polling.start(options);
    }
    initPolling() {
      deprecate("TelegramBot#initPolling() is deprecated. Use TelegramBot#startPolling() instead.");
      return this.startPolling();
    }
    stopPolling(options) {
      if (!this._polling) {
        return Promise.resolve();
      }
      return this._polling.stop(options);
    }
    getFileLink(fileId, form = {}) {
      return this.getFile(fileId, form).then((resp) => `${this.options.baseApiUrl}/file/bot${this.token}/${resp.file_path}`);
    }
    getFileStream(fileId, form = {}) {
      const fileStream = new stream4.PassThrough;
      fileStream.path = fileId;
      this.getFileLink(fileId, form).then((fileURI) => {
        fileStream.emit("info", {
          uri: fileURI
        });
        pump(streamedRequest(Object.assign({ uri: fileURI }, this.options.request)), fileStream);
      }).catch((error2) => {
        fileStream.emit("error", error2);
      });
      return fileStream;
    }
    downloadFile(fileId, downloadDir, form = {}) {
      let resolve;
      let reject;
      const promise = new Promise((a, b) => {
        resolve = a;
        reject = b;
      });
      const fileStream = this.getFileStream(fileId, form);
      fileStream.on("info", (info) => {
        const fileName = info.uri.slice(info.uri.lastIndexOf("/") + 1);
        const filePath = path2.join(downloadDir, fileName);
        pump(fileStream, fs.createWriteStream(filePath), (error2) => {
          if (error2) {
            return reject(error2);
          }
          return resolve(filePath);
        });
      });
      fileStream.on("error", (err) => {
        reject(err);
      });
      return promise;
    }
    onText(regexp, callback) {
      this._textRegexpCallbacks.push({ regexp, callback });
    }
    removeTextListener(regexp) {
      const index = this._textRegexpCallbacks.findIndex((textListener) => {
        return String(textListener.regexp) === String(regexp);
      });
      if (index === -1) {
        return null;
      }
      return this._textRegexpCallbacks.splice(index, 1)[0];
    }
    clearTextListeners() {
      this._textRegexpCallbacks = [];
    }
    onReplyToMessage(chatId, messageId, callback) {
      const id = ++this._replyListenerId;
      this._replyListeners.push({
        id,
        chatId,
        messageId,
        callback
      });
      return id;
    }
    removeReplyListener(replyListenerId) {
      const index = this._replyListeners.findIndex((replyListener) => {
        return replyListener.id === replyListenerId;
      });
      if (index === -1) {
        return null;
      }
      return this._replyListeners.splice(index, 1)[0];
    }
    clearReplyListeners() {
      this._replyListeners = [];
    }
    isPolling() {
      return this._polling ? this._polling.isPolling() : false;
    }
    openWebHook() {
      if (this.isPolling()) {
        return Promise.reject(new errors.FatalError("WebHook and Polling are mutually exclusive"));
      }
      if (!this._webHook) {
        this._webHook = new TelegramBotWebHook(this);
      }
      return this._webHook.open();
    }
    closeWebHook() {
      if (!this._webHook) {
        return Promise.resolve();
      }
      return this._webHook.close();
    }
    hasOpenWebHook() {
      return this._webHook ? this._webHook.isOpen() : false;
    }
    processUpdate(update) {
      debug("Process Update %j", update);
      const message = update.message;
      const editedMessage = update.edited_message;
      const channelPost = update.channel_post;
      const editedChannelPost = update.edited_channel_post;
      const businessConnection = update.business_connection;
      const businesssMessage = update.business_message;
      const editedBusinessMessage = update.edited_business_message;
      const deletedBusinessMessage = update.deleted_business_messages;
      const messageReaction = update.message_reaction;
      const messageReactionCount = update.message_reaction_count;
      const inlineQuery = update.inline_query;
      const chosenInlineResult = update.chosen_inline_result;
      const callbackQuery = update.callback_query;
      const shippingQuery = update.shipping_query;
      const preCheckoutQuery = update.pre_checkout_query;
      const poll = update.poll;
      const pollAnswer = update.poll_answer;
      const myChatMember = update.my_chat_member;
      const chatMember = update.chat_member;
      const chatJoinRequest = update.chat_join_request;
      const chatBoost = update.chat_boost;
      const removedChatBoost = update.removed_chat_boost;
      if (message) {
        debug("Process Update message %j", message);
        const metadata = {};
        metadata.type = TelegramBot.messageTypes.find((messageType) => {
          return message[messageType];
        });
        this.emit("message", message, metadata);
        if (metadata.type) {
          debug("Emitting %s: %j", metadata.type, message);
          this.emit(metadata.type, message, metadata);
        }
        if (message.text) {
          debug("Text message");
          this._textRegexpCallbacks.some((reg) => {
            debug("Matching %s with %s", message.text, reg.regexp);
            if (!(reg.regexp instanceof RegExp)) {
              reg.regexp = new RegExp(reg.regexp);
            }
            const result = reg.regexp.exec(message.text);
            if (!result) {
              return false;
            }
            reg.regexp.lastIndex = 0;
            debug("Matches %s", reg.regexp);
            reg.callback(message, result);
            return this.options.onlyFirstMatch;
          });
        }
        if (message.reply_to_message) {
          this._replyListeners.forEach((reply) => {
            if (reply.chatId === message.chat.id) {
              if (reply.messageId === message.reply_to_message.message_id) {
                reply.callback(message);
              }
            }
          });
        }
      } else if (editedMessage) {
        debug("Process Update edited_message %j", editedMessage);
        this.emit("edited_message", editedMessage);
        if (editedMessage.text) {
          this.emit("edited_message_text", editedMessage);
        }
        if (editedMessage.caption) {
          this.emit("edited_message_caption", editedMessage);
        }
      } else if (channelPost) {
        debug("Process Update channel_post %j", channelPost);
        this.emit("channel_post", channelPost);
      } else if (editedChannelPost) {
        debug("Process Update edited_channel_post %j", editedChannelPost);
        this.emit("edited_channel_post", editedChannelPost);
        if (editedChannelPost.text) {
          this.emit("edited_channel_post_text", editedChannelPost);
        }
        if (editedChannelPost.caption) {
          this.emit("edited_channel_post_caption", editedChannelPost);
        }
      } else if (businessConnection) {
        debug("Process Update business_connection %j", businessConnection);
        this.emit("business_connection", businessConnection);
      } else if (businesssMessage) {
        debug("Process Update business_message %j", businesssMessage);
        this.emit("business_message", businesssMessage);
      } else if (editedBusinessMessage) {
        debug("Process Update edited_business_message %j", editedBusinessMessage);
        this.emit("edited_business_message", editedBusinessMessage);
      } else if (deletedBusinessMessage) {
        debug("Process Update deleted_business_messages %j", deletedBusinessMessage);
        this.emit("deleted_business_messages", deletedBusinessMessage);
      } else if (messageReaction) {
        debug("Process Update message_reaction %j", messageReaction);
        this.emit("message_reaction", messageReaction);
      } else if (messageReactionCount) {
        debug("Process Update message_reaction_count %j", messageReactionCount);
        this.emit("message_reaction_count", messageReactionCount);
      } else if (inlineQuery) {
        debug("Process Update inline_query %j", inlineQuery);
        this.emit("inline_query", inlineQuery);
      } else if (chosenInlineResult) {
        debug("Process Update chosen_inline_result %j", chosenInlineResult);
        this.emit("chosen_inline_result", chosenInlineResult);
      } else if (callbackQuery) {
        debug("Process Update callback_query %j", callbackQuery);
        this.emit("callback_query", callbackQuery);
      } else if (shippingQuery) {
        debug("Process Update shipping_query %j", shippingQuery);
        this.emit("shipping_query", shippingQuery);
      } else if (preCheckoutQuery) {
        debug("Process Update pre_checkout_query %j", preCheckoutQuery);
        this.emit("pre_checkout_query", preCheckoutQuery);
      } else if (poll) {
        debug("Process Update poll %j", poll);
        this.emit("poll", poll);
      } else if (pollAnswer) {
        debug("Process Update poll_answer %j", pollAnswer);
        this.emit("poll_answer", pollAnswer);
      } else if (chatMember) {
        debug("Process Update chat_member %j", chatMember);
        this.emit("chat_member", chatMember);
      } else if (myChatMember) {
        debug("Process Update my_chat_member %j", myChatMember);
        this.emit("my_chat_member", myChatMember);
      } else if (chatJoinRequest) {
        debug("Process Update my_chat_member %j", chatJoinRequest);
        this.emit("chat_join_request", chatJoinRequest);
      } else if (chatBoost) {
        debug("Process Update chat_boost %j", chatBoost);
        this.emit("chat_boost", chatBoost);
      } else if (removedChatBoost) {
        debug("Process Update removed_chat_boost %j", removedChatBoost);
        this.emit("removed_chat_boost", removedChatBoost);
      }
    }
    getUpdates(form = {}) {
      if (typeof form !== "object") {
        deprecate("The method signature getUpdates(timeout, limit, offset) has been deprecated since v0.25.0");
        form = {
          timeout: arguments[0],
          limit: arguments[1],
          offset: arguments[2]
        };
      }
      return this._request("getUpdates", { form });
    }
    setWebHook(url2, options = {}, fileOptions = {}) {
      let cert;
      if (typeof options !== "object" || options instanceof stream4.Stream) {
        deprecate("The method signature setWebHook(url, cert) has been deprecated since v0.25.0");
        cert = options;
        options = {};
      } else {
        cert = options.certificate;
      }
      const opts = {
        qs: options
      };
      opts.qs.url = url2;
      if (cert) {
        try {
          const sendData = this._formatSendData("certificate", cert, fileOptions);
          opts.formData = sendData[0];
          opts.qs.certificate = sendData[1];
        } catch (ex) {
          return Promise.reject(ex);
        }
      }
      return this._request("setWebHook", opts);
    }
    deleteWebHook(form = {}) {
      return this._request("deleteWebhook", { form });
    }
    getWebHookInfo(form = {}) {
      return this._request("getWebhookInfo", { form });
    }
    getMe(form = {}) {
      return this._request("getMe", { form });
    }
    logOut(form = {}) {
      return this._request("logOut", { form });
    }
    close(form = {}) {
      return this._request("close", { form });
    }
    sendMessage(chatId, text, form = {}) {
      form.chat_id = chatId;
      form.text = text;
      return this._request("sendMessage", { form });
    }
    forwardMessage(chatId, fromChatId, messageId, form = {}) {
      form.chat_id = chatId;
      form.from_chat_id = fromChatId;
      form.message_id = messageId;
      return this._request("forwardMessage", { form });
    }
    forwardMessages(chatId, fromChatId, messageIds, form = {}) {
      form.chat_id = chatId;
      form.from_chat_id = fromChatId;
      form.message_ids = messageIds;
      return this._request("forwardMessages", { form });
    }
    copyMessage(chatId, fromChatId, messageId, form = {}) {
      form.chat_id = chatId;
      form.from_chat_id = fromChatId;
      form.message_id = messageId;
      return this._request("copyMessage", { form });
    }
    copyMessages(chatId, fromChatId, messageIds, form = {}) {
      form.chat_id = chatId;
      form.from_chat_id = fromChatId;
      form.message_ids = stringify2(messageIds);
      return this._request("copyMessages", { form });
    }
    sendPhoto(chatId, photo, options = {}, fileOptions = {}) {
      const opts = {
        qs: options
      };
      opts.qs.chat_id = chatId;
      try {
        const sendData = this._formatSendData("photo", photo, fileOptions);
        opts.formData = sendData[0];
        opts.qs.photo = sendData[1];
      } catch (ex) {
        return Promise.reject(ex);
      }
      return this._request("sendPhoto", opts);
    }
    sendAudio(chatId, audio, options = {}, fileOptions = {}) {
      const opts = {
        qs: options
      };
      opts.qs.chat_id = chatId;
      try {
        const sendData = this._formatSendData("audio", audio, fileOptions);
        opts.formData = sendData[0];
        opts.qs.audio = sendData[1];
        this._fixAddFileThumbnail(options, opts);
      } catch (ex) {
        return Promise.reject(ex);
      }
      return this._request("sendAudio", opts);
    }
    sendDocument(chatId, doc, options = {}, fileOptions = {}) {
      const opts = {
        qs: options
      };
      opts.qs.chat_id = chatId;
      try {
        const sendData = this._formatSendData("document", doc, fileOptions);
        opts.formData = sendData[0];
        opts.qs.document = sendData[1];
        this._fixAddFileThumbnail(options, opts);
      } catch (ex) {
        return Promise.reject(ex);
      }
      return this._request("sendDocument", opts);
    }
    sendVideo(chatId, video, options = {}, fileOptions = {}) {
      const opts = {
        qs: options
      };
      opts.qs.chat_id = chatId;
      try {
        const sendData = this._formatSendData("video", video, fileOptions);
        opts.formData = sendData[0];
        opts.qs.video = sendData[1];
        this._fixAddFileThumbnail(options, opts);
      } catch (ex) {
        return Promise.reject(ex);
      }
      return this._request("sendVideo", opts);
    }
    sendAnimation(chatId, animation, options = {}, fileOptions = {}) {
      const opts = {
        qs: options
      };
      opts.qs.chat_id = chatId;
      try {
        const sendData = this._formatSendData("animation", animation, fileOptions);
        opts.formData = sendData[0];
        opts.qs.animation = sendData[1];
      } catch (ex) {
        return Promise.reject(ex);
      }
      return this._request("sendAnimation", opts);
    }
    sendVoice(chatId, voice, options = {}, fileOptions = {}) {
      const opts = {
        qs: options
      };
      opts.qs.chat_id = chatId;
      try {
        const sendData = this._formatSendData("voice", voice, fileOptions);
        opts.formData = sendData[0];
        opts.qs.voice = sendData[1];
      } catch (ex) {
        return Promise.reject(ex);
      }
      return this._request("sendVoice", opts);
    }
    sendVideoNote(chatId, videoNote, options = {}, fileOptions = {}) {
      const opts = {
        qs: options
      };
      opts.qs.chat_id = chatId;
      try {
        const sendData = this._formatSendData("video_note", videoNote, fileOptions);
        opts.formData = sendData[0];
        opts.qs.video_note = sendData[1];
        this._fixAddFileThumbnail(options, opts);
      } catch (ex) {
        return Promise.reject(ex);
      }
      return this._request("sendVideoNote", opts);
    }
    sendMediaGroup(chatId, media, options = {}) {
      const opts = {
        qs: options
      };
      opts.qs.chat_id = chatId;
      opts.formData = {};
      const inputMedia = [];
      let index = 0;
      for (const input of media) {
        const payload = Object.assign({}, input);
        delete payload.media;
        delete payload.fileOptions;
        try {
          const attachName = String(index);
          const [formData, fileId] = this._formatSendData(attachName, input.media, input.fileOptions);
          if (formData) {
            opts.formData[attachName] = formData[attachName];
            payload.media = `attach://${attachName}`;
          } else {
            payload.media = fileId;
          }
        } catch (ex) {
          return Promise.reject(ex);
        }
        inputMedia.push(payload);
        index++;
      }
      opts.qs.media = stringify2(inputMedia);
      return this._request("sendMediaGroup", opts);
    }
    sendLocation(chatId, latitude, longitude, form = {}) {
      form.chat_id = chatId;
      form.latitude = latitude;
      form.longitude = longitude;
      return this._request("sendLocation", { form });
    }
    editMessageLiveLocation(latitude, longitude, form = {}) {
      form.latitude = latitude;
      form.longitude = longitude;
      return this._request("editMessageLiveLocation", { form });
    }
    stopMessageLiveLocation(form = {}) {
      return this._request("stopMessageLiveLocation", { form });
    }
    sendVenue(chatId, latitude, longitude, title, address, form = {}) {
      form.chat_id = chatId;
      form.latitude = latitude;
      form.longitude = longitude;
      form.title = title;
      form.address = address;
      return this._request("sendVenue", { form });
    }
    sendContact(chatId, phoneNumber, firstName, form = {}) {
      form.chat_id = chatId;
      form.phone_number = phoneNumber;
      form.first_name = firstName;
      return this._request("sendContact", { form });
    }
    sendPoll(chatId, question, pollOptions, form = {}) {
      form.chat_id = chatId;
      form.question = question;
      form.options = stringify2(pollOptions);
      return this._request("sendPoll", { form });
    }
    sendDice(chatId, options = {}) {
      const opts = {
        qs: options
      };
      opts.qs.chat_id = chatId;
      try {
        const sendData = this._formatSendData("dice");
        opts.formData = sendData[0];
      } catch (ex) {
        return Promise.reject(ex);
      }
      return this._request("sendDice", opts);
    }
    sendChatAction(chatId, action, form = {}) {
      form.chat_id = chatId;
      form.action = action;
      return this._request("sendChatAction", { form });
    }
    setMessageReaction(chatId, messageId, form = {}) {
      form.chat_id = chatId;
      form.message_id = messageId;
      if (form.reaction) {
        form.reaction = stringify2(form.reaction);
      }
      return this._request("setMessageReaction", { form });
    }
    getUserProfilePhotos(userId, form = {}) {
      if (typeof form !== "object") {
        deprecate("The method signature getUserProfilePhotos(userId, offset, limit) has been deprecated since v0.25.0");
        form = {
          offset: arguments[1],
          limit: arguments[2]
        };
      }
      form.user_id = userId;
      return this._request("getUserProfilePhotos", { form });
    }
    getFile(fileId, form = {}) {
      form.file_id = fileId;
      return this._request("getFile", { form });
    }
    banChatMember(chatId, userId, form = {}) {
      form.chat_id = chatId;
      form.user_id = userId;
      return this._request("banChatMember", { form });
    }
    unbanChatMember(chatId, userId, form = {}) {
      form.chat_id = chatId;
      form.user_id = userId;
      return this._request("unbanChatMember", { form });
    }
    restrictChatMember(chatId, userId, form = {}) {
      form.chat_id = chatId;
      form.user_id = userId;
      return this._request("restrictChatMember", { form });
    }
    promoteChatMember(chatId, userId, form = {}) {
      form.chat_id = chatId;
      form.user_id = userId;
      return this._request("promoteChatMember", { form });
    }
    setChatAdministratorCustomTitle(chatId, userId, customTitle, form = {}) {
      form.chat_id = chatId;
      form.user_id = userId;
      form.custom_title = customTitle;
      return this._request("setChatAdministratorCustomTitle", { form });
    }
    banChatSenderChat(chatId, senderChatId, form = {}) {
      form.chat_id = chatId;
      form.sender_chat_id = senderChatId;
      return this._request("banChatSenderChat", { form });
    }
    unbanChatSenderChat(chatId, senderChatId, form = {}) {
      form.chat_id = chatId;
      form.sender_chat_id = senderChatId;
      return this._request("unbanChatSenderChat", { form });
    }
    setChatPermissions(chatId, chatPermissions, form = {}) {
      form.chat_id = chatId;
      form.permissions = stringify2(chatPermissions);
      return this._request("setChatPermissions", { form });
    }
    exportChatInviteLink(chatId, form = {}) {
      form.chat_id = chatId;
      return this._request("exportChatInviteLink", { form });
    }
    createChatInviteLink(chatId, form = {}) {
      form.chat_id = chatId;
      return this._request("createChatInviteLink", { form });
    }
    editChatInviteLink(chatId, inviteLink, form = {}) {
      form.chat_id = chatId;
      form.invite_link = inviteLink;
      return this._request("editChatInviteLink", { form });
    }
    revokeChatInviteLink(chatId, inviteLink, form = {}) {
      form.chat_id = chatId;
      form.invite_link = inviteLink;
      return this._request("revokeChatInviteLink", { form });
    }
    approveChatJoinRequest(chatId, userId, form = {}) {
      form.chat_id = chatId;
      form.user_id = userId;
      return this._request("approveChatJoinRequest", { form });
    }
    declineChatJoinRequest(chatId, userId, form = {}) {
      form.chat_id = chatId;
      form.user_id = userId;
      return this._request("declineChatJoinRequest", { form });
    }
    setChatPhoto(chatId, photo, options = {}, fileOptions = {}) {
      const opts = {
        qs: options
      };
      opts.qs.chat_id = chatId;
      try {
        const sendData = this._formatSendData("photo", photo, fileOptions);
        opts.formData = sendData[0];
        opts.qs.photo = sendData[1];
      } catch (ex) {
        return Promise.reject(ex);
      }
      return this._request("setChatPhoto", opts);
    }
    deleteChatPhoto(chatId, form = {}) {
      form.chat_id = chatId;
      return this._request("deleteChatPhoto", { form });
    }
    setChatTitle(chatId, title, form = {}) {
      form.chat_id = chatId;
      form.title = title;
      return this._request("setChatTitle", { form });
    }
    setChatDescription(chatId, description, form = {}) {
      form.chat_id = chatId;
      form.description = description;
      return this._request("setChatDescription", { form });
    }
    pinChatMessage(chatId, messageId, form = {}) {
      form.chat_id = chatId;
      form.message_id = messageId;
      return this._request("pinChatMessage", { form });
    }
    unpinChatMessage(chatId, form = {}) {
      form.chat_id = chatId;
      return this._request("unpinChatMessage", { form });
    }
    unpinAllChatMessages(chatId, form = {}) {
      form.chat_id = chatId;
      return this._request("unpinAllChatMessages", { form });
    }
    leaveChat(chatId, form = {}) {
      form.chat_id = chatId;
      return this._request("leaveChat", { form });
    }
    getChat(chatId, form = {}) {
      form.chat_id = chatId;
      return this._request("getChat", { form });
    }
    getChatAdministrators(chatId, form = {}) {
      form.chat_id = chatId;
      return this._request("getChatAdministrators", { form });
    }
    getChatMemberCount(chatId, form = {}) {
      form.chat_id = chatId;
      return this._request("getChatMemberCount", { form });
    }
    getChatMember(chatId, userId, form = {}) {
      form.chat_id = chatId;
      form.user_id = userId;
      return this._request("getChatMember", { form });
    }
    setChatStickerSet(chatId, stickerSetName, form = {}) {
      form.chat_id = chatId;
      form.sticker_set_name = stickerSetName;
      return this._request("setChatStickerSet", { form });
    }
    deleteChatStickerSet(chatId, form = {}) {
      form.chat_id = chatId;
      return this._request("deleteChatStickerSet", { form });
    }
    getForumTopicIconStickers(chatId, form = {}) {
      form.chat_id = chatId;
      return this._request("getForumTopicIconStickers", { form });
    }
    createForumTopic(chatId, name, form = {}) {
      form.chat_id = chatId;
      form.name = name;
      return this._request("createForumTopic", { form });
    }
    editForumTopic(chatId, messageThreadId, form = {}) {
      form.chat_id = chatId;
      form.message_thread_id = messageThreadId;
      return this._request("editForumTopic", { form });
    }
    closeForumTopic(chatId, messageThreadId, form = {}) {
      form.chat_id = chatId;
      form.message_thread_id = messageThreadId;
      return this._request("closeForumTopic", { form });
    }
    reopenForumTopic(chatId, messageThreadId, form = {}) {
      form.chat_id = chatId;
      form.message_thread_id = messageThreadId;
      return this._request("reopenForumTopic", { form });
    }
    deleteForumTopic(chatId, messageThreadId, form = {}) {
      form.chat_id = chatId;
      form.message_thread_id = messageThreadId;
      return this._request("deleteForumTopic", { form });
    }
    unpinAllForumTopicMessages(chatId, messageThreadId, form = {}) {
      form.chat_id = chatId;
      form.message_thread_id = messageThreadId;
      return this._request("unpinAllForumTopicMessages", { form });
    }
    editGeneralForumTopic(chatId, name, form = {}) {
      form.chat_id = chatId;
      form.name = name;
      return this._request("editGeneralForumTopic", { form });
    }
    closeGeneralForumTopic(chatId, form = {}) {
      form.chat_id = chatId;
      return this._request("closeGeneralForumTopic", { form });
    }
    reopenGeneralForumTopic(chatId, form = {}) {
      form.chat_id = chatId;
      return this._request("reopenGeneralForumTopic", { form });
    }
    hideGeneralForumTopic(chatId, form = {}) {
      form.chat_id = chatId;
      return this._request("hideGeneralForumTopic", { form });
    }
    unhideGeneralForumTopic(chatId, form = {}) {
      form.chat_id = chatId;
      return this._request("unhideGeneralForumTopic", { form });
    }
    unpinAllGeneralForumTopicMessages(chatId, form = {}) {
      form.chat_id = chatId;
      return this._request("unhideGeneralForumTopic", { form });
    }
    answerCallbackQuery(callbackQueryId, form = {}) {
      if (typeof form !== "object") {
        deprecate("The method signature answerCallbackQuery(callbackQueryId, text, showAlert) has been deprecated since v0.27.1");
        form = {
          callback_query_id: arguments[0],
          text: arguments[1],
          show_alert: arguments[2]
        };
      }
      if (typeof callbackQueryId === "object") {
        deprecate("The method signature answerCallbackQuery([options]) has been deprecated since v0.29.0");
        form = callbackQueryId;
      } else {
        form.callback_query_id = callbackQueryId;
      }
      return this._request("answerCallbackQuery", { form });
    }
    getUserChatBoosts(chatId, pollId, form = {}) {
      form.chat_id = chatId;
      form.message_id = pollId;
      return this._request("getUserChatBoosts", { form });
    }
    getBusinessConnection(businessConnectionId, form = {}) {
      form.business_connection_id = businessConnectionId;
      return this._request("getBusinessConnection", { form });
    }
    setMyCommands(commands, form = {}) {
      form.commands = stringify2(commands);
      if (form.scope) {
        form.scope = stringify2(form.scope);
      }
      return this._request("setMyCommands", { form });
    }
    deleteMyCommands(form = {}) {
      return this._request("deleteMyCommands", { form });
    }
    getMyCommands(form = {}) {
      if (form.scope) {
        form.scope = stringify2(form.scope);
      }
      return this._request("getMyCommands", { form });
    }
    setMyName(form = {}) {
      return this._request("setMyName", { form });
    }
    getMyName(form = {}) {
      return this._request("getMyName", { form });
    }
    setMyDescription(form = {}) {
      return this._request("setMyDescription", { form });
    }
    getMyDescription(form = {}) {
      return this._request("getMyDescription", { form });
    }
    setMyShortDescription(form = {}) {
      return this._request("setMyShortDescription", { form });
    }
    getMyShortDescription(form = {}) {
      return this._request("getMyShortDescription", { form });
    }
    setChatMenuButton(form = {}) {
      return this._request("setChatMenuButton", { form });
    }
    getChatMenuButton(form = {}) {
      return this._request("getChatMenuButton", { form });
    }
    setMyDefaultAdministratorRights(form = {}) {
      return this._request("setMyDefaultAdministratorRights", { form });
    }
    getMyDefaultAdministratorRights(form = {}) {
      return this._request("getMyDefaultAdministratorRights", { form });
    }
    editMessageText(text, form = {}) {
      form.text = text;
      return this._request("editMessageText", { form });
    }
    editMessageCaption(caption, form = {}) {
      form.caption = caption;
      return this._request("editMessageCaption", { form });
    }
    editMessageMedia(media, form = {}) {
      const regexAttach = /attach:\/\/.+/;
      if (typeof media.media === "string" && regexAttach.test(media.media)) {
        const opts = {
          qs: form
        };
        opts.formData = {};
        const payload = Object.assign({}, media);
        delete payload.media;
        try {
          const attachName = String(0);
          const [formData] = this._formatSendData(attachName, media.media.replace("attach://", ""), media.fileOptions);
          if (formData) {
            opts.formData[attachName] = formData[attachName];
            payload.media = `attach://${attachName}`;
          } else {
            throw new errors.FatalError(`Failed to process the replacement action for your ${media.type}`);
          }
        } catch (ex) {
          return Promise.reject(ex);
        }
        opts.qs.media = stringify2(payload);
        return this._request("editMessageMedia", opts);
      }
      form.media = stringify2(media);
      return this._request("editMessageMedia", { form });
    }
    editMessageReplyMarkup(replyMarkup, form = {}) {
      form.reply_markup = replyMarkup;
      return this._request("editMessageReplyMarkup", { form });
    }
    stopPoll(chatId, pollId, form = {}) {
      form.chat_id = chatId;
      form.message_id = pollId;
      return this._request("stopPoll", { form });
    }
    sendSticker(chatId, sticker, options = {}, fileOptions = {}) {
      const opts = {
        qs: options
      };
      opts.qs.chat_id = chatId;
      try {
        const sendData = this._formatSendData("sticker", sticker, fileOptions);
        opts.formData = sendData[0];
        opts.qs.sticker = sendData[1];
      } catch (ex) {
        return Promise.reject(ex);
      }
      return this._request("sendSticker", opts);
    }
    getStickerSet(name, form = {}) {
      form.name = name;
      return this._request("getStickerSet", { form });
    }
    getCustomEmojiStickers(customEmojiIds, form = {}) {
      form.custom_emoji_ids = stringify2(customEmojiIds);
      return this._request("getCustomEmojiStickers", { form });
    }
    uploadStickerFile(userId, sticker, stickerFormat = "static", options = {}, fileOptions = {}) {
      const opts = {
        qs: options
      };
      opts.qs.user_id = userId;
      opts.qs.sticker_format = stickerFormat;
      try {
        const sendData = this._formatSendData("sticker", sticker, fileOptions);
        opts.formData = sendData[0];
        opts.qs.sticker = sendData[1];
      } catch (ex) {
        return Promise.reject(ex);
      }
      return this._request("uploadStickerFile", opts);
    }
    createNewStickerSet(userId, name, title, pngSticker, emojis, options = {}, fileOptions = {}) {
      const opts = {
        qs: options
      };
      opts.qs.user_id = userId;
      opts.qs.name = name;
      opts.qs.title = title;
      opts.qs.emojis = emojis;
      opts.qs.mask_position = stringify2(options.mask_position);
      try {
        const sendData = this._formatSendData("png_sticker", pngSticker, fileOptions);
        opts.formData = sendData[0];
        opts.qs.png_sticker = sendData[1];
      } catch (ex) {
        return Promise.reject(ex);
      }
      return this._request("createNewStickerSet", opts);
    }
    addStickerToSet(userId, name, sticker, emojis, stickerType = "png_sticker", options = {}, fileOptions = {}) {
      const opts = {
        qs: options
      };
      opts.qs.user_id = userId;
      opts.qs.name = name;
      opts.qs.emojis = emojis;
      opts.qs.mask_position = stringify2(options.mask_position);
      if (typeof stickerType !== "string" || ["png_sticker", "tgs_sticker", "webm_sticker"].indexOf(stickerType) === -1) {
        return Promise.reject(new Error("stickerType must be a string and the allow types is: png_sticker, tgs_sticker, webm_sticker"));
      }
      try {
        const sendData = this._formatSendData(stickerType, sticker, fileOptions);
        opts.formData = sendData[0];
        opts.qs[stickerType] = sendData[1];
      } catch (ex) {
        return Promise.reject(ex);
      }
      return this._request("addStickerToSet", opts);
    }
    setStickerPositionInSet(sticker, position, form = {}) {
      form.sticker = sticker;
      form.position = position;
      return this._request("setStickerPositionInSet", { form });
    }
    deleteStickerFromSet(sticker, form = {}) {
      form.sticker = sticker;
      return this._request("deleteStickerFromSet", { form });
    }
    replaceStickerInSet(userId, name, oldSticker, form = {}) {
      form.user_id = userId;
      form.name = name;
      form.old_sticker = oldSticker;
      return this._request("deleteStickerFromSet", { form });
    }
    setStickerEmojiList(sticker, emojiList, form = {}) {
      form.sticker = sticker;
      form.emoji_list = stringify2(emojiList);
      return this._request("setStickerEmojiList", { form });
    }
    setStickerKeywords(sticker, form = {}) {
      form.sticker = sticker;
      if (form.keywords) {
        form.keywords = stringify2(form.keywords);
      }
      return this._request("setStickerKeywords", { form });
    }
    setStickerMaskPosition(sticker, form = {}) {
      form.sticker = sticker;
      if (form.mask_position) {
        form.mask_position = stringify2(form.mask_position);
      }
      return this._request("setStickerMaskPosition", { form });
    }
    setStickerSetTitle(name, title, form = {}) {
      form.name = name;
      form.title = title;
      return this._request("setStickerSetTitle", { form });
    }
    setStickerSetThumbnail(userId, name, thumbnail, options = {}, fileOptions = {}) {
      const opts = {
        qs: options
      };
      opts.qs.user_id = userId;
      opts.qs.name = name;
      opts.qs.mask_position = stringify2(options.mask_position);
      try {
        const sendData = this._formatSendData("thumbnail", thumbnail, fileOptions);
        opts.formData = sendData[0];
        opts.qs.thumbnail = sendData[1];
      } catch (ex) {
        return Promise.reject(ex);
      }
      return this._request("setStickerSetThumbnail", opts);
    }
    setCustomEmojiStickerSetThumbnail(name, form = {}) {
      form.name = name;
      return this._request("setCustomEmojiStickerSetThumbnail", { form });
    }
    deleteStickerSet(name, form = {}) {
      form.name = name;
      return this._request("deleteStickerSet", { form });
    }
    answerInlineQuery(inlineQueryId, results, form = {}) {
      form.inline_query_id = inlineQueryId;
      form.results = stringify2(results);
      return this._request("answerInlineQuery", { form });
    }
    answerWebAppQuery(webAppQueryId, result, form = {}) {
      form.web_app_query_id = webAppQueryId;
      form.result = stringify2(result);
      return this._request("answerWebAppQuery", { form });
    }
    sendInvoice(chatId, title, description, payload, providerToken, currency, prices, form = {}) {
      form.chat_id = chatId;
      form.title = title;
      form.description = description;
      form.payload = payload;
      form.provider_token = providerToken;
      form.currency = currency;
      form.prices = stringify2(prices);
      form.provider_data = stringify2(form.provider_data);
      if (form.suggested_tip_amounts) {
        form.suggested_tip_amounts = stringify2(form.suggested_tip_amounts);
      }
      return this._request("sendInvoice", { form });
    }
    createInvoiceLink(title, description, payload, providerToken, currency, prices, form = {}) {
      form.title = title;
      form.description = description;
      form.payload = payload;
      form.provider_token = providerToken;
      form.currency = currency;
      form.prices = stringify2(prices);
      return this._request("createInvoiceLink", { form });
    }
    answerShippingQuery(shippingQueryId, ok, form = {}) {
      form.shipping_query_id = shippingQueryId;
      form.ok = ok;
      form.shipping_options = stringify2(form.shipping_options);
      return this._request("answerShippingQuery", { form });
    }
    answerPreCheckoutQuery(preCheckoutQueryId, ok, form = {}) {
      form.pre_checkout_query_id = preCheckoutQueryId;
      form.ok = ok;
      return this._request("answerPreCheckoutQuery", { form });
    }
    sendGame(chatId, gameShortName, form = {}) {
      form.chat_id = chatId;
      form.game_short_name = gameShortName;
      return this._request("sendGame", { form });
    }
    setGameScore(userId, score, form = {}) {
      form.user_id = userId;
      form.score = score;
      return this._request("setGameScore", { form });
    }
    getGameHighScores(userId, form = {}) {
      form.user_id = userId;
      return this._request("getGameHighScores", { form });
    }
    deleteMessage(chatId, messageId, form = {}) {
      form.chat_id = chatId;
      form.message_id = messageId;
      return this._request("deleteMessage", { form });
    }
    deleteMessages(chatId, messageIds, form = {}) {
      form.chat_id = chatId;
      form.message_ids = stringify2(messageIds);
      return this._request("deleteMessages", { form });
    }
  }
  module2.exports = TelegramBot;
});

// backend/node_modules/node-telegram-bot-api/index.js
var require_node_telegram_bot_api = __commonJS((exports2, module2) => {
  var majorVersion = parseInt(process.versions.node.split(".")[0], 10);
  if (majorVersion <= 5) {
    const deprecate = require_utils().deprecate;
    deprecate("Node.js v5.x and below will no longer be supported in the future");
    module2.exports = require_telegram();
  } else {
    module2.exports = require_telegram2();
  }
});

// backend/src/index.ts
var exports_src = {};
__export(exports_src, {
  default: () => src_default
});
module.exports = __toCommonJS(exports_src);

// backend/node_modules/hono/dist/compose.js
var compose = (middleware, onError, onNotFound) => {
  return (context, next) => {
    let index = -1;
    return dispatch(0);
    async function dispatch(i) {
      if (i <= index) {
        throw new Error("next() called multiple times");
      }
      index = i;
      let res;
      let isError = false;
      let handler;
      if (middleware[i]) {
        handler = middleware[i][0][0];
        context.req.routeIndex = i;
      } else {
        handler = i === middleware.length && next || undefined;
      }
      if (handler) {
        try {
          res = await handler(context, () => dispatch(i + 1));
        } catch (err) {
          if (err instanceof Error && onError) {
            context.error = err;
            res = await onError(err, context);
            isError = true;
          } else {
            throw err;
          }
        }
      } else {
        if (context.finalized === false && onNotFound) {
          res = await onNotFound(context);
        }
      }
      if (res && (context.finalized === false || isError)) {
        context.res = res;
      }
      return context;
    }
  };
};

// backend/node_modules/hono/dist/request/constants.js
var GET_MATCH_RESULT = Symbol();

// backend/node_modules/hono/dist/utils/body.js
var parseBody = async (request, options = /* @__PURE__ */ Object.create(null)) => {
  const { all = false, dot = false } = options;
  const headers = request instanceof HonoRequest ? request.raw.headers : request.headers;
  const contentType = headers.get("Content-Type");
  if (contentType?.startsWith("multipart/form-data") || contentType?.startsWith("application/x-www-form-urlencoded")) {
    return parseFormData(request, { all, dot });
  }
  return {};
};
async function parseFormData(request, options) {
  const formData = await request.formData();
  if (formData) {
    return convertFormDataToBodyData(formData, options);
  }
  return {};
}
function convertFormDataToBodyData(formData, options) {
  const form = /* @__PURE__ */ Object.create(null);
  formData.forEach((value, key) => {
    const shouldParseAllValues = options.all || key.endsWith("[]");
    if (!shouldParseAllValues) {
      form[key] = value;
    } else {
      handleParsingAllValues(form, key, value);
    }
  });
  if (options.dot) {
    Object.entries(form).forEach(([key, value]) => {
      const shouldParseDotValues = key.includes(".");
      if (shouldParseDotValues) {
        handleParsingNestedValues(form, key, value);
        delete form[key];
      }
    });
  }
  return form;
}
var handleParsingAllValues = (form, key, value) => {
  if (form[key] !== undefined) {
    if (Array.isArray(form[key])) {
      form[key].push(value);
    } else {
      form[key] = [form[key], value];
    }
  } else {
    if (!key.endsWith("[]")) {
      form[key] = value;
    } else {
      form[key] = [value];
    }
  }
};
var handleParsingNestedValues = (form, key, value) => {
  let nestedForm = form;
  const keys = key.split(".");
  keys.forEach((key2, index) => {
    if (index === keys.length - 1) {
      nestedForm[key2] = value;
    } else {
      if (!nestedForm[key2] || typeof nestedForm[key2] !== "object" || Array.isArray(nestedForm[key2]) || nestedForm[key2] instanceof File) {
        nestedForm[key2] = /* @__PURE__ */ Object.create(null);
      }
      nestedForm = nestedForm[key2];
    }
  });
};

// backend/node_modules/hono/dist/utils/url.js
var splitPath = (path) => {
  const paths = path.split("/");
  if (paths[0] === "") {
    paths.shift();
  }
  return paths;
};
var splitRoutingPath = (routePath) => {
  const { groups, path } = extractGroupsFromPath(routePath);
  const paths = splitPath(path);
  return replaceGroupMarks(paths, groups);
};
var extractGroupsFromPath = (path) => {
  const groups = [];
  path = path.replace(/\{[^}]+\}/g, (match, index) => {
    const mark = `@${index}`;
    groups.push([mark, match]);
    return mark;
  });
  return { groups, path };
};
var replaceGroupMarks = (paths, groups) => {
  for (let i = groups.length - 1;i >= 0; i--) {
    const [mark] = groups[i];
    for (let j = paths.length - 1;j >= 0; j--) {
      if (paths[j].includes(mark)) {
        paths[j] = paths[j].replace(mark, groups[i][1]);
        break;
      }
    }
  }
  return paths;
};
var patternCache = {};
var getPattern = (label, next) => {
  if (label === "*") {
    return "*";
  }
  const match = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
  if (match) {
    const cacheKey = `${label}#${next}`;
    if (!patternCache[cacheKey]) {
      if (match[2]) {
        patternCache[cacheKey] = next && next[0] !== ":" && next[0] !== "*" ? [cacheKey, match[1], new RegExp(`^${match[2]}(?=/${next})`)] : [label, match[1], new RegExp(`^${match[2]}$`)];
      } else {
        patternCache[cacheKey] = [label, match[1], true];
      }
    }
    return patternCache[cacheKey];
  }
  return null;
};
var tryDecode = (str, decoder) => {
  try {
    return decoder(str);
  } catch {
    return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match) => {
      try {
        return decoder(match);
      } catch {
        return match;
      }
    });
  }
};
var tryDecodeURI = (str) => tryDecode(str, decodeURI);
var getPath = (request) => {
  const url = request.url;
  const start = url.indexOf("/", url.indexOf(":") + 4);
  let i = start;
  for (;i < url.length; i++) {
    const charCode = url.charCodeAt(i);
    if (charCode === 37) {
      const queryIndex = url.indexOf("?", i);
      const path = url.slice(start, queryIndex === -1 ? undefined : queryIndex);
      return tryDecodeURI(path.includes("%25") ? path.replace(/%25/g, "%2525") : path);
    } else if (charCode === 63) {
      break;
    }
  }
  return url.slice(start, i);
};
var getPathNoStrict = (request) => {
  const result = getPath(request);
  return result.length > 1 && result.at(-1) === "/" ? result.slice(0, -1) : result;
};
var mergePath = (base, sub, ...rest) => {
  if (rest.length) {
    sub = mergePath(sub, ...rest);
  }
  return `${base?.[0] === "/" ? "" : "/"}${base}${sub === "/" ? "" : `${base?.at(-1) === "/" ? "" : "/"}${sub?.[0] === "/" ? sub.slice(1) : sub}`}`;
};
var checkOptionalParameter = (path) => {
  if (path.charCodeAt(path.length - 1) !== 63 || !path.includes(":")) {
    return null;
  }
  const segments = path.split("/");
  const results = [];
  let basePath = "";
  segments.forEach((segment) => {
    if (segment !== "" && !/\:/.test(segment)) {
      basePath += "/" + segment;
    } else if (/\:/.test(segment)) {
      if (/\?/.test(segment)) {
        if (results.length === 0 && basePath === "") {
          results.push("/");
        } else {
          results.push(basePath);
        }
        const optionalSegment = segment.replace("?", "");
        basePath += "/" + optionalSegment;
        results.push(basePath);
      } else {
        basePath += "/" + segment;
      }
    }
  });
  return results.filter((v, i, a) => a.indexOf(v) === i);
};
var _decodeURI = (value) => {
  if (!/[%+]/.test(value)) {
    return value;
  }
  if (value.indexOf("+") !== -1) {
    value = value.replace(/\+/g, " ");
  }
  return value.indexOf("%") !== -1 ? tryDecode(value, decodeURIComponent_) : value;
};
var _getQueryParam = (url, key, multiple) => {
  let encoded;
  if (!multiple && key && !/[%+]/.test(key)) {
    let keyIndex2 = url.indexOf("?", 8);
    if (keyIndex2 === -1) {
      return;
    }
    if (!url.startsWith(key, keyIndex2 + 1)) {
      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
    }
    while (keyIndex2 !== -1) {
      const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);
      if (trailingKeyCode === 61) {
        const valueIndex = keyIndex2 + key.length + 2;
        const endIndex = url.indexOf("&", valueIndex);
        return _decodeURI(url.slice(valueIndex, endIndex === -1 ? undefined : endIndex));
      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
        return "";
      }
      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
    }
    encoded = /[%+]/.test(url);
    if (!encoded) {
      return;
    }
  }
  const results = {};
  encoded ??= /[%+]/.test(url);
  let keyIndex = url.indexOf("?", 8);
  while (keyIndex !== -1) {
    const nextKeyIndex = url.indexOf("&", keyIndex + 1);
    let valueIndex = url.indexOf("=", keyIndex);
    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
      valueIndex = -1;
    }
    let name = url.slice(keyIndex + 1, valueIndex === -1 ? nextKeyIndex === -1 ? undefined : nextKeyIndex : valueIndex);
    if (encoded) {
      name = _decodeURI(name);
    }
    keyIndex = nextKeyIndex;
    if (name === "") {
      continue;
    }
    let value;
    if (valueIndex === -1) {
      value = "";
    } else {
      value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? undefined : nextKeyIndex);
      if (encoded) {
        value = _decodeURI(value);
      }
    }
    if (multiple) {
      if (!(results[name] && Array.isArray(results[name]))) {
        results[name] = [];
      }
      results[name].push(value);
    } else {
      results[name] ??= value;
    }
  }
  return key ? results[key] : results;
};
var getQueryParam = _getQueryParam;
var getQueryParams = (url, key) => {
  return _getQueryParam(url, key, true);
};
var decodeURIComponent_ = decodeURIComponent;

// backend/node_modules/hono/dist/request.js
var tryDecodeURIComponent = (str) => tryDecode(str, decodeURIComponent_);
var HonoRequest = class {
  raw;
  #validatedData;
  #matchResult;
  routeIndex = 0;
  path;
  bodyCache = {};
  constructor(request, path = "/", matchResult = [[]]) {
    this.raw = request;
    this.path = path;
    this.#matchResult = matchResult;
    this.#validatedData = {};
  }
  param(key) {
    return key ? this.#getDecodedParam(key) : this.#getAllDecodedParams();
  }
  #getDecodedParam(key) {
    const paramKey = this.#matchResult[0][this.routeIndex][1][key];
    const param = this.#getParamValue(paramKey);
    return param && /\%/.test(param) ? tryDecodeURIComponent(param) : param;
  }
  #getAllDecodedParams() {
    const decoded = {};
    const keys = Object.keys(this.#matchResult[0][this.routeIndex][1]);
    for (const key of keys) {
      const value = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][key]);
      if (value !== undefined) {
        decoded[key] = /\%/.test(value) ? tryDecodeURIComponent(value) : value;
      }
    }
    return decoded;
  }
  #getParamValue(paramKey) {
    return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;
  }
  query(key) {
    return getQueryParam(this.url, key);
  }
  queries(key) {
    return getQueryParams(this.url, key);
  }
  header(name) {
    if (name) {
      return this.raw.headers.get(name) ?? undefined;
    }
    const headerData = {};
    this.raw.headers.forEach((value, key) => {
      headerData[key] = value;
    });
    return headerData;
  }
  async parseBody(options) {
    return this.bodyCache.parsedBody ??= await parseBody(this, options);
  }
  #cachedBody = (key) => {
    const { bodyCache, raw } = this;
    const cachedBody = bodyCache[key];
    if (cachedBody) {
      return cachedBody;
    }
    const anyCachedKey = Object.keys(bodyCache)[0];
    if (anyCachedKey) {
      return bodyCache[anyCachedKey].then((body) => {
        if (anyCachedKey === "json") {
          body = JSON.stringify(body);
        }
        return new Response(body)[key]();
      });
    }
    return bodyCache[key] = raw[key]();
  };
  json() {
    return this.#cachedBody("text").then((text) => JSON.parse(text));
  }
  text() {
    return this.#cachedBody("text");
  }
  arrayBuffer() {
    return this.#cachedBody("arrayBuffer");
  }
  blob() {
    return this.#cachedBody("blob");
  }
  formData() {
    return this.#cachedBody("formData");
  }
  addValidatedData(target, data) {
    this.#validatedData[target] = data;
  }
  valid(target) {
    return this.#validatedData[target];
  }
  get url() {
    return this.raw.url;
  }
  get method() {
    return this.raw.method;
  }
  get [GET_MATCH_RESULT]() {
    return this.#matchResult;
  }
  get matchedRoutes() {
    return this.#matchResult[0].map(([[, route]]) => route);
  }
  get routePath() {
    return this.#matchResult[0].map(([[, route]]) => route)[this.routeIndex].path;
  }
};

// backend/node_modules/hono/dist/utils/html.js
var HtmlEscapedCallbackPhase = {
  Stringify: 1,
  BeforeStream: 2,
  Stream: 3
};
var raw = (value, callbacks) => {
  const escapedString = new String(value);
  escapedString.isEscaped = true;
  escapedString.callbacks = callbacks;
  return escapedString;
};
var resolveCallback = async (str, phase, preserveCallbacks, context, buffer) => {
  if (typeof str === "object" && !(str instanceof String)) {
    if (!(str instanceof Promise)) {
      str = str.toString();
    }
    if (str instanceof Promise) {
      str = await str;
    }
  }
  const callbacks = str.callbacks;
  if (!callbacks?.length) {
    return Promise.resolve(str);
  }
  if (buffer) {
    buffer[0] += str;
  } else {
    buffer = [str];
  }
  const resStr = Promise.all(callbacks.map((c) => c({ phase, buffer, context }))).then((res) => Promise.all(res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context, buffer))).then(() => buffer[0]));
  if (preserveCallbacks) {
    return raw(await resStr, callbacks);
  } else {
    return resStr;
  }
};

// backend/node_modules/hono/dist/context.js
var TEXT_PLAIN = "text/plain; charset=UTF-8";
var setDefaultContentType = (contentType, headers) => {
  return {
    "Content-Type": contentType,
    ...headers
  };
};
var Context = class {
  #rawRequest;
  #req;
  env = {};
  #var;
  finalized = false;
  error;
  #status;
  #executionCtx;
  #res;
  #layout;
  #renderer;
  #notFoundHandler;
  #preparedHeaders;
  #matchResult;
  #path;
  constructor(req, options) {
    this.#rawRequest = req;
    if (options) {
      this.#executionCtx = options.executionCtx;
      this.env = options.env;
      this.#notFoundHandler = options.notFoundHandler;
      this.#path = options.path;
      this.#matchResult = options.matchResult;
    }
  }
  get req() {
    this.#req ??= new HonoRequest(this.#rawRequest, this.#path, this.#matchResult);
    return this.#req;
  }
  get event() {
    if (this.#executionCtx && "respondWith" in this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no FetchEvent");
    }
  }
  get executionCtx() {
    if (this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no ExecutionContext");
    }
  }
  get res() {
    return this.#res ||= new Response(null, {
      headers: this.#preparedHeaders ??= new Headers
    });
  }
  set res(_res) {
    if (this.#res && _res) {
      _res = new Response(_res.body, _res);
      for (const [k, v] of this.#res.headers.entries()) {
        if (k === "content-type") {
          continue;
        }
        if (k === "set-cookie") {
          const cookies = this.#res.headers.getSetCookie();
          _res.headers.delete("set-cookie");
          for (const cookie of cookies) {
            _res.headers.append("set-cookie", cookie);
          }
        } else {
          _res.headers.set(k, v);
        }
      }
    }
    this.#res = _res;
    this.finalized = true;
  }
  render = (...args) => {
    this.#renderer ??= (content) => this.html(content);
    return this.#renderer(...args);
  };
  setLayout = (layout) => this.#layout = layout;
  getLayout = () => this.#layout;
  setRenderer = (renderer) => {
    this.#renderer = renderer;
  };
  header = (name, value, options) => {
    if (this.finalized) {
      this.#res = new Response(this.#res.body, this.#res);
    }
    const headers = this.#res ? this.#res.headers : this.#preparedHeaders ??= new Headers;
    if (value === undefined) {
      headers.delete(name);
    } else if (options?.append) {
      headers.append(name, value);
    } else {
      headers.set(name, value);
    }
  };
  status = (status) => {
    this.#status = status;
  };
  set = (key, value) => {
    this.#var ??= /* @__PURE__ */ new Map;
    this.#var.set(key, value);
  };
  get = (key) => {
    return this.#var ? this.#var.get(key) : undefined;
  };
  get var() {
    if (!this.#var) {
      return {};
    }
    return Object.fromEntries(this.#var);
  }
  #newResponse(data, arg, headers) {
    const responseHeaders = this.#res ? new Headers(this.#res.headers) : this.#preparedHeaders ?? new Headers;
    if (typeof arg === "object" && "headers" in arg) {
      const argHeaders = arg.headers instanceof Headers ? arg.headers : new Headers(arg.headers);
      for (const [key, value] of argHeaders) {
        if (key.toLowerCase() === "set-cookie") {
          responseHeaders.append(key, value);
        } else {
          responseHeaders.set(key, value);
        }
      }
    }
    if (headers) {
      for (const [k, v] of Object.entries(headers)) {
        if (typeof v === "string") {
          responseHeaders.set(k, v);
        } else {
          responseHeaders.delete(k);
          for (const v2 of v) {
            responseHeaders.append(k, v2);
          }
        }
      }
    }
    const status = typeof arg === "number" ? arg : arg?.status ?? this.#status;
    return new Response(data, { status, headers: responseHeaders });
  }
  newResponse = (...args) => this.#newResponse(...args);
  body = (data, arg, headers) => this.#newResponse(data, arg, headers);
  text = (text, arg, headers) => {
    return !this.#preparedHeaders && !this.#status && !arg && !headers && !this.finalized ? new Response(text) : this.#newResponse(text, arg, setDefaultContentType(TEXT_PLAIN, headers));
  };
  json = (object, arg, headers) => {
    return this.#newResponse(JSON.stringify(object), arg, setDefaultContentType("application/json", headers));
  };
  html = (html, arg, headers) => {
    const res = (html2) => this.#newResponse(html2, arg, setDefaultContentType("text/html; charset=UTF-8", headers));
    return typeof html === "object" ? resolveCallback(html, HtmlEscapedCallbackPhase.Stringify, false, {}).then(res) : res(html);
  };
  redirect = (location, status) => {
    const locationString = String(location);
    this.header("Location", !/[^\x00-\xFF]/.test(locationString) ? locationString : encodeURI(locationString));
    return this.newResponse(null, status ?? 302);
  };
  notFound = () => {
    this.#notFoundHandler ??= () => new Response;
    return this.#notFoundHandler(this);
  };
};

// backend/node_modules/hono/dist/router.js
var METHOD_NAME_ALL = "ALL";
var METHOD_NAME_ALL_LOWERCASE = "all";
var METHODS = ["get", "post", "put", "delete", "options", "patch"];
var MESSAGE_MATCHER_IS_ALREADY_BUILT = "Can not add a route since the matcher is already built.";
var UnsupportedPathError = class extends Error {
};

// backend/node_modules/hono/dist/utils/constants.js
var COMPOSED_HANDLER = "__COMPOSED_HANDLER";

// backend/node_modules/hono/dist/hono-base.js
var notFoundHandler = (c) => {
  return c.text("404 Not Found", 404);
};
var errorHandler = (err, c) => {
  if ("getResponse" in err) {
    const res = err.getResponse();
    return c.newResponse(res.body, res);
  }
  console.error(err);
  return c.text("Internal Server Error", 500);
};
var Hono = class {
  get;
  post;
  put;
  delete;
  options;
  patch;
  all;
  on;
  use;
  router;
  getPath;
  _basePath = "/";
  #path = "/";
  routes = [];
  constructor(options = {}) {
    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];
    allMethods.forEach((method) => {
      this[method] = (args1, ...args) => {
        if (typeof args1 === "string") {
          this.#path = args1;
        } else {
          this.#addRoute(method, this.#path, args1);
        }
        args.forEach((handler) => {
          this.#addRoute(method, this.#path, handler);
        });
        return this;
      };
    });
    this.on = (method, path, ...handlers) => {
      for (const p of [path].flat()) {
        this.#path = p;
        for (const m of [method].flat()) {
          handlers.map((handler) => {
            this.#addRoute(m.toUpperCase(), this.#path, handler);
          });
        }
      }
      return this;
    };
    this.use = (arg1, ...handlers) => {
      if (typeof arg1 === "string") {
        this.#path = arg1;
      } else {
        this.#path = "*";
        handlers.unshift(arg1);
      }
      handlers.forEach((handler) => {
        this.#addRoute(METHOD_NAME_ALL, this.#path, handler);
      });
      return this;
    };
    const { strict, ...optionsWithoutStrict } = options;
    Object.assign(this, optionsWithoutStrict);
    this.getPath = strict ?? true ? options.getPath ?? getPath : getPathNoStrict;
  }
  #clone() {
    const clone = new Hono({
      router: this.router,
      getPath: this.getPath
    });
    clone.errorHandler = this.errorHandler;
    clone.#notFoundHandler = this.#notFoundHandler;
    clone.routes = this.routes;
    return clone;
  }
  #notFoundHandler = notFoundHandler;
  errorHandler = errorHandler;
  route(path, app) {
    const subApp = this.basePath(path);
    app.routes.map((r) => {
      let handler;
      if (app.errorHandler === errorHandler) {
        handler = r.handler;
      } else {
        handler = async (c, next) => (await compose([], app.errorHandler)(c, () => r.handler(c, next))).res;
        handler[COMPOSED_HANDLER] = r.handler;
      }
      subApp.#addRoute(r.method, r.path, handler);
    });
    return this;
  }
  basePath(path) {
    const subApp = this.#clone();
    subApp._basePath = mergePath(this._basePath, path);
    return subApp;
  }
  onError = (handler) => {
    this.errorHandler = handler;
    return this;
  };
  notFound = (handler) => {
    this.#notFoundHandler = handler;
    return this;
  };
  mount(path, applicationHandler, options) {
    let replaceRequest;
    let optionHandler;
    if (options) {
      if (typeof options === "function") {
        optionHandler = options;
      } else {
        optionHandler = options.optionHandler;
        if (options.replaceRequest === false) {
          replaceRequest = (request) => request;
        } else {
          replaceRequest = options.replaceRequest;
        }
      }
    }
    const getOptions = optionHandler ? (c) => {
      const options2 = optionHandler(c);
      return Array.isArray(options2) ? options2 : [options2];
    } : (c) => {
      let executionContext = undefined;
      try {
        executionContext = c.executionCtx;
      } catch {}
      return [c.env, executionContext];
    };
    replaceRequest ||= (() => {
      const mergedPath = mergePath(this._basePath, path);
      const pathPrefixLength = mergedPath === "/" ? 0 : mergedPath.length;
      return (request) => {
        const url = new URL(request.url);
        url.pathname = url.pathname.slice(pathPrefixLength) || "/";
        return new Request(url, request);
      };
    })();
    const handler = async (c, next) => {
      const res = await applicationHandler(replaceRequest(c.req.raw), ...getOptions(c));
      if (res) {
        return res;
      }
      await next();
    };
    this.#addRoute(METHOD_NAME_ALL, mergePath(path, "*"), handler);
    return this;
  }
  #addRoute(method, path, handler) {
    method = method.toUpperCase();
    path = mergePath(this._basePath, path);
    const r = { basePath: this._basePath, path, method, handler };
    this.router.add(method, path, [handler, r]);
    this.routes.push(r);
  }
  #handleError(err, c) {
    if (err instanceof Error) {
      return this.errorHandler(err, c);
    }
    throw err;
  }
  #dispatch(request, executionCtx, env, method) {
    if (method === "HEAD") {
      return (async () => new Response(null, await this.#dispatch(request, executionCtx, env, "GET")))();
    }
    const path = this.getPath(request, { env });
    const matchResult = this.router.match(method, path);
    const c = new Context(request, {
      path,
      matchResult,
      env,
      executionCtx,
      notFoundHandler: this.#notFoundHandler
    });
    if (matchResult[0].length === 1) {
      let res;
      try {
        res = matchResult[0][0][0][0](c, async () => {
          c.res = await this.#notFoundHandler(c);
        });
      } catch (err) {
        return this.#handleError(err, c);
      }
      return res instanceof Promise ? res.then((resolved) => resolved || (c.finalized ? c.res : this.#notFoundHandler(c))).catch((err) => this.#handleError(err, c)) : res ?? this.#notFoundHandler(c);
    }
    const composed = compose(matchResult[0], this.errorHandler, this.#notFoundHandler);
    return (async () => {
      try {
        const context = await composed(c);
        if (!context.finalized) {
          throw new Error("Context is not finalized. Did you forget to return a Response object or `await next()`?");
        }
        return context.res;
      } catch (err) {
        return this.#handleError(err, c);
      }
    })();
  }
  fetch = (request, ...rest) => {
    return this.#dispatch(request, rest[1], rest[0], request.method);
  };
  request = (input, requestInit, Env, executionCtx) => {
    if (input instanceof Request) {
      return this.fetch(requestInit ? new Request(input, requestInit) : input, Env, executionCtx);
    }
    input = input.toString();
    return this.fetch(new Request(/^https?:\/\//.test(input) ? input : `http://localhost${mergePath("/", input)}`, requestInit), Env, executionCtx);
  };
  fire = () => {
    addEventListener("fetch", (event) => {
      event.respondWith(this.#dispatch(event.request, event, undefined, event.request.method));
    });
  };
};

// backend/node_modules/hono/dist/router/reg-exp-router/matcher.js
var emptyParam = [];
function match(method, path) {
  const matchers = this.buildAllMatchers();
  const match2 = (method2, path2) => {
    const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];
    const staticMatch = matcher[2][path2];
    if (staticMatch) {
      return staticMatch;
    }
    const match3 = path2.match(matcher[0]);
    if (!match3) {
      return [[], emptyParam];
    }
    const index = match3.indexOf("", 1);
    return [matcher[1][index], match3];
  };
  this.match = match2;
  return match2(method, path);
}

// backend/node_modules/hono/dist/router/reg-exp-router/node.js
var LABEL_REG_EXP_STR = "[^/]+";
var ONLY_WILDCARD_REG_EXP_STR = ".*";
var TAIL_WILDCARD_REG_EXP_STR = "(?:|/.*)";
var PATH_ERROR = Symbol();
var regExpMetaChars = new Set(".\\+*[^]$()");
function compareKey(a, b) {
  if (a.length === 1) {
    return b.length === 1 ? a < b ? -1 : 1 : -1;
  }
  if (b.length === 1) {
    return 1;
  }
  if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {
    return 1;
  } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {
    return -1;
  }
  if (a === LABEL_REG_EXP_STR) {
    return 1;
  } else if (b === LABEL_REG_EXP_STR) {
    return -1;
  }
  return a.length === b.length ? a < b ? -1 : 1 : b.length - a.length;
}
var Node = class {
  #index;
  #varIndex;
  #children = /* @__PURE__ */ Object.create(null);
  insert(tokens, index, paramMap, context, pathErrorCheckOnly) {
    if (tokens.length === 0) {
      if (this.#index !== undefined) {
        throw PATH_ERROR;
      }
      if (pathErrorCheckOnly) {
        return;
      }
      this.#index = index;
      return;
    }
    const [token, ...restTokens] = tokens;
    const pattern = token === "*" ? restTokens.length === 0 ? ["", "", ONLY_WILDCARD_REG_EXP_STR] : ["", "", LABEL_REG_EXP_STR] : token === "/*" ? ["", "", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
    let node;
    if (pattern) {
      const name = pattern[1];
      let regexpStr = pattern[2] || LABEL_REG_EXP_STR;
      if (name && pattern[2]) {
        if (regexpStr === ".*") {
          throw PATH_ERROR;
        }
        regexpStr = regexpStr.replace(/^\((?!\?:)(?=[^)]+\)$)/, "(?:");
        if (/\((?!\?:)/.test(regexpStr)) {
          throw PATH_ERROR;
        }
      }
      node = this.#children[regexpStr];
      if (!node) {
        if (Object.keys(this.#children).some((k) => k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR)) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[regexpStr] = new Node;
        if (name !== "") {
          node.#varIndex = context.varIndex++;
        }
      }
      if (!pathErrorCheckOnly && name !== "") {
        paramMap.push([name, node.#varIndex]);
      }
    } else {
      node = this.#children[token];
      if (!node) {
        if (Object.keys(this.#children).some((k) => k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR)) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[token] = new Node;
      }
    }
    node.insert(restTokens, index, paramMap, context, pathErrorCheckOnly);
  }
  buildRegExpStr() {
    const childKeys = Object.keys(this.#children).sort(compareKey);
    const strList = childKeys.map((k) => {
      const c = this.#children[k];
      return (typeof c.#varIndex === "number" ? `(${k})@${c.#varIndex}` : regExpMetaChars.has(k) ? `\\${k}` : k) + c.buildRegExpStr();
    });
    if (typeof this.#index === "number") {
      strList.unshift(`#${this.#index}`);
    }
    if (strList.length === 0) {
      return "";
    }
    if (strList.length === 1) {
      return strList[0];
    }
    return "(?:" + strList.join("|") + ")";
  }
};

// backend/node_modules/hono/dist/router/reg-exp-router/trie.js
var Trie = class {
  #context = { varIndex: 0 };
  #root = new Node;
  insert(path, index, pathErrorCheckOnly) {
    const paramAssoc = [];
    const groups = [];
    for (let i = 0;; ) {
      let replaced = false;
      path = path.replace(/\{[^}]+\}/g, (m) => {
        const mark = `@\\${i}`;
        groups[i] = [mark, m];
        i++;
        replaced = true;
        return mark;
      });
      if (!replaced) {
        break;
      }
    }
    const tokens = path.match(/(?::[^\/]+)|(?:\/\*$)|./g) || [];
    for (let i = groups.length - 1;i >= 0; i--) {
      const [mark] = groups[i];
      for (let j = tokens.length - 1;j >= 0; j--) {
        if (tokens[j].indexOf(mark) !== -1) {
          tokens[j] = tokens[j].replace(mark, groups[i][1]);
          break;
        }
      }
    }
    this.#root.insert(tokens, index, paramAssoc, this.#context, pathErrorCheckOnly);
    return paramAssoc;
  }
  buildRegExp() {
    let regexp = this.#root.buildRegExpStr();
    if (regexp === "") {
      return [/^$/, [], []];
    }
    let captureIndex = 0;
    const indexReplacementMap = [];
    const paramReplacementMap = [];
    regexp = regexp.replace(/#(\d+)|@(\d+)|\.\*\$/g, (_, handlerIndex, paramIndex) => {
      if (handlerIndex !== undefined) {
        indexReplacementMap[++captureIndex] = Number(handlerIndex);
        return "$()";
      }
      if (paramIndex !== undefined) {
        paramReplacementMap[Number(paramIndex)] = ++captureIndex;
        return "";
      }
      return "";
    });
    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];
  }
};

// backend/node_modules/hono/dist/router/reg-exp-router/router.js
var nullMatcher = [/^$/, [], /* @__PURE__ */ Object.create(null)];
var wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
function buildWildcardRegExp(path) {
  return wildcardRegExpCache[path] ??= new RegExp(path === "*" ? "" : `^${path.replace(/\/\*$|([.\\+*[^\]$()])/g, (_, metaChar) => metaChar ? `\\${metaChar}` : "(?:|/.*)")}$`);
}
function clearWildcardRegExpCache() {
  wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
}
function buildMatcherFromPreprocessedRoutes(routes) {
  const trie = new Trie;
  const handlerData = [];
  if (routes.length === 0) {
    return nullMatcher;
  }
  const routesWithStaticPathFlag = routes.map((route) => [!/\*|\/:/.test(route[0]), ...route]).sort(([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length);
  const staticMap = /* @__PURE__ */ Object.create(null);
  for (let i = 0, j = -1, len = routesWithStaticPathFlag.length;i < len; i++) {
    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i];
    if (pathErrorCheckOnly) {
      staticMap[path] = [handlers.map(([h]) => [h, /* @__PURE__ */ Object.create(null)]), emptyParam];
    } else {
      j++;
    }
    let paramAssoc;
    try {
      paramAssoc = trie.insert(path, j, pathErrorCheckOnly);
    } catch (e) {
      throw e === PATH_ERROR ? new UnsupportedPathError(path) : e;
    }
    if (pathErrorCheckOnly) {
      continue;
    }
    handlerData[j] = handlers.map(([h, paramCount]) => {
      const paramIndexMap = /* @__PURE__ */ Object.create(null);
      paramCount -= 1;
      for (;paramCount >= 0; paramCount--) {
        const [key, value] = paramAssoc[paramCount];
        paramIndexMap[key] = value;
      }
      return [h, paramIndexMap];
    });
  }
  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();
  for (let i = 0, len = handlerData.length;i < len; i++) {
    for (let j = 0, len2 = handlerData[i].length;j < len2; j++) {
      const map = handlerData[i][j]?.[1];
      if (!map) {
        continue;
      }
      const keys = Object.keys(map);
      for (let k = 0, len3 = keys.length;k < len3; k++) {
        map[keys[k]] = paramReplacementMap[map[keys[k]]];
      }
    }
  }
  const handlerMap = [];
  for (const i in indexReplacementMap) {
    handlerMap[i] = handlerData[indexReplacementMap[i]];
  }
  return [regexp, handlerMap, staticMap];
}
function findMiddleware(middleware, path) {
  if (!middleware) {
    return;
  }
  for (const k of Object.keys(middleware).sort((a, b) => b.length - a.length)) {
    if (buildWildcardRegExp(k).test(path)) {
      return [...middleware[k]];
    }
  }
  return;
}
var RegExpRouter = class {
  name = "RegExpRouter";
  #middleware;
  #routes;
  constructor() {
    this.#middleware = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
    this.#routes = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
  }
  add(method, path, handler) {
    const middleware = this.#middleware;
    const routes = this.#routes;
    if (!middleware || !routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    if (!middleware[method]) {
      [middleware, routes].forEach((handlerMap) => {
        handlerMap[method] = /* @__PURE__ */ Object.create(null);
        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p) => {
          handlerMap[method][p] = [...handlerMap[METHOD_NAME_ALL][p]];
        });
      });
    }
    if (path === "/*") {
      path = "*";
    }
    const paramCount = (path.match(/\/:/g) || []).length;
    if (/\*$/.test(path)) {
      const re = buildWildcardRegExp(path);
      if (method === METHOD_NAME_ALL) {
        Object.keys(middleware).forEach((m) => {
          middleware[m][path] ||= findMiddleware(middleware[m], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
        });
      } else {
        middleware[method][path] ||= findMiddleware(middleware[method], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
      }
      Object.keys(middleware).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(middleware[m]).forEach((p) => {
            re.test(p) && middleware[m][p].push([handler, paramCount]);
          });
        }
      });
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(routes[m]).forEach((p) => re.test(p) && routes[m][p].push([handler, paramCount]));
        }
      });
      return;
    }
    const paths = checkOptionalParameter(path) || [path];
    for (let i = 0, len = paths.length;i < len; i++) {
      const path2 = paths[i];
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          routes[m][path2] ||= [
            ...findMiddleware(middleware[m], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || []
          ];
          routes[m][path2].push([handler, paramCount - len + i + 1]);
        }
      });
    }
  }
  match = match;
  buildAllMatchers() {
    const matchers = /* @__PURE__ */ Object.create(null);
    Object.keys(this.#routes).concat(Object.keys(this.#middleware)).forEach((method) => {
      matchers[method] ||= this.#buildMatcher(method);
    });
    this.#middleware = this.#routes = undefined;
    clearWildcardRegExpCache();
    return matchers;
  }
  #buildMatcher(method) {
    const routes = [];
    let hasOwnRoute = method === METHOD_NAME_ALL;
    [this.#middleware, this.#routes].forEach((r) => {
      const ownRoute = r[method] ? Object.keys(r[method]).map((path) => [path, r[method][path]]) : [];
      if (ownRoute.length !== 0) {
        hasOwnRoute ||= true;
        routes.push(...ownRoute);
      } else if (method !== METHOD_NAME_ALL) {
        routes.push(...Object.keys(r[METHOD_NAME_ALL]).map((path) => [path, r[METHOD_NAME_ALL][path]]));
      }
    });
    if (!hasOwnRoute) {
      return null;
    } else {
      return buildMatcherFromPreprocessedRoutes(routes);
    }
  }
};

// backend/node_modules/hono/dist/router/reg-exp-router/prepared-router.js
var PreparedRegExpRouter = class {
  name = "PreparedRegExpRouter";
  #matchers;
  #relocateMap;
  constructor(matchers, relocateMap) {
    this.#matchers = matchers;
    this.#relocateMap = relocateMap;
  }
  #addWildcard(method, handlerData) {
    const matcher = this.#matchers[method];
    matcher[1].forEach((list) => list && list.push(handlerData));
    Object.values(matcher[2]).forEach((list) => list[0].push(handlerData));
  }
  #addPath(method, path, handler, indexes, map) {
    const matcher = this.#matchers[method];
    if (!map) {
      matcher[2][path][0].push([handler, {}]);
    } else {
      indexes.forEach((index) => {
        if (typeof index === "number") {
          matcher[1][index].push([handler, map]);
        } else {
          matcher[2][index || path][0].push([handler, map]);
        }
      });
    }
  }
  add(method, path, handler) {
    if (!this.#matchers[method]) {
      const all = this.#matchers[METHOD_NAME_ALL];
      const staticMap = {};
      for (const key in all[2]) {
        staticMap[key] = [all[2][key][0].slice(), emptyParam];
      }
      this.#matchers[method] = [
        all[0],
        all[1].map((list) => Array.isArray(list) ? list.slice() : 0),
        staticMap
      ];
    }
    if (path === "/*" || path === "*") {
      const handlerData = [handler, {}];
      if (method === METHOD_NAME_ALL) {
        for (const m in this.#matchers) {
          this.#addWildcard(m, handlerData);
        }
      } else {
        this.#addWildcard(method, handlerData);
      }
      return;
    }
    const data = this.#relocateMap[path];
    if (!data) {
      throw new Error(`Path ${path} is not registered`);
    }
    for (const [indexes, map] of data) {
      if (method === METHOD_NAME_ALL) {
        for (const m in this.#matchers) {
          this.#addPath(m, path, handler, indexes, map);
        }
      } else {
        this.#addPath(method, path, handler, indexes, map);
      }
    }
  }
  buildAllMatchers() {
    return this.#matchers;
  }
  match = match;
};

// backend/node_modules/hono/dist/router/smart-router/router.js
var SmartRouter = class {
  name = "SmartRouter";
  #routers = [];
  #routes = [];
  constructor(init) {
    this.#routers = init.routers;
  }
  add(method, path, handler) {
    if (!this.#routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    this.#routes.push([method, path, handler]);
  }
  match(method, path) {
    if (!this.#routes) {
      throw new Error("Fatal error");
    }
    const routers = this.#routers;
    const routes = this.#routes;
    const len = routers.length;
    let i = 0;
    let res;
    for (;i < len; i++) {
      const router = routers[i];
      try {
        for (let i2 = 0, len2 = routes.length;i2 < len2; i2++) {
          router.add(...routes[i2]);
        }
        res = router.match(method, path);
      } catch (e) {
        if (e instanceof UnsupportedPathError) {
          continue;
        }
        throw e;
      }
      this.match = router.match.bind(router);
      this.#routers = [router];
      this.#routes = undefined;
      break;
    }
    if (i === len) {
      throw new Error("Fatal error");
    }
    this.name = `SmartRouter + ${this.activeRouter.name}`;
    return res;
  }
  get activeRouter() {
    if (this.#routes || this.#routers.length !== 1) {
      throw new Error("No active router has been determined yet.");
    }
    return this.#routers[0];
  }
};

// backend/node_modules/hono/dist/router/trie-router/node.js
var emptyParams = /* @__PURE__ */ Object.create(null);
var Node2 = class {
  #methods;
  #children;
  #patterns;
  #order = 0;
  #params = emptyParams;
  constructor(method, handler, children) {
    this.#children = children || /* @__PURE__ */ Object.create(null);
    this.#methods = [];
    if (method && handler) {
      const m = /* @__PURE__ */ Object.create(null);
      m[method] = { handler, possibleKeys: [], score: 0 };
      this.#methods = [m];
    }
    this.#patterns = [];
  }
  insert(method, path, handler) {
    this.#order = ++this.#order;
    let curNode = this;
    const parts = splitRoutingPath(path);
    const possibleKeys = [];
    for (let i = 0, len = parts.length;i < len; i++) {
      const p = parts[i];
      const nextP = parts[i + 1];
      const pattern = getPattern(p, nextP);
      const key = Array.isArray(pattern) ? pattern[0] : p;
      if (key in curNode.#children) {
        curNode = curNode.#children[key];
        if (pattern) {
          possibleKeys.push(pattern[1]);
        }
        continue;
      }
      curNode.#children[key] = new Node2;
      if (pattern) {
        curNode.#patterns.push(pattern);
        possibleKeys.push(pattern[1]);
      }
      curNode = curNode.#children[key];
    }
    curNode.#methods.push({
      [method]: {
        handler,
        possibleKeys: possibleKeys.filter((v, i, a) => a.indexOf(v) === i),
        score: this.#order
      }
    });
    return curNode;
  }
  #getHandlerSets(node, method, nodeParams, params) {
    const handlerSets = [];
    for (let i = 0, len = node.#methods.length;i < len; i++) {
      const m = node.#methods[i];
      const handlerSet = m[method] || m[METHOD_NAME_ALL];
      const processedSet = {};
      if (handlerSet !== undefined) {
        handlerSet.params = /* @__PURE__ */ Object.create(null);
        handlerSets.push(handlerSet);
        if (nodeParams !== emptyParams || params && params !== emptyParams) {
          for (let i2 = 0, len2 = handlerSet.possibleKeys.length;i2 < len2; i2++) {
            const key = handlerSet.possibleKeys[i2];
            const processed = processedSet[handlerSet.score];
            handlerSet.params[key] = params?.[key] && !processed ? params[key] : nodeParams[key] ?? params?.[key];
            processedSet[handlerSet.score] = true;
          }
        }
      }
    }
    return handlerSets;
  }
  search(method, path) {
    const handlerSets = [];
    this.#params = emptyParams;
    const curNode = this;
    let curNodes = [curNode];
    const parts = splitPath(path);
    const curNodesQueue = [];
    for (let i = 0, len = parts.length;i < len; i++) {
      const part = parts[i];
      const isLast = i === len - 1;
      const tempNodes = [];
      for (let j = 0, len2 = curNodes.length;j < len2; j++) {
        const node = curNodes[j];
        const nextNode = node.#children[part];
        if (nextNode) {
          nextNode.#params = node.#params;
          if (isLast) {
            if (nextNode.#children["*"]) {
              handlerSets.push(...this.#getHandlerSets(nextNode.#children["*"], method, node.#params));
            }
            handlerSets.push(...this.#getHandlerSets(nextNode, method, node.#params));
          } else {
            tempNodes.push(nextNode);
          }
        }
        for (let k = 0, len3 = node.#patterns.length;k < len3; k++) {
          const pattern = node.#patterns[k];
          const params = node.#params === emptyParams ? {} : { ...node.#params };
          if (pattern === "*") {
            const astNode = node.#children["*"];
            if (astNode) {
              handlerSets.push(...this.#getHandlerSets(astNode, method, node.#params));
              astNode.#params = params;
              tempNodes.push(astNode);
            }
            continue;
          }
          const [key, name, matcher] = pattern;
          if (!part && !(matcher instanceof RegExp)) {
            continue;
          }
          const child = node.#children[key];
          const restPathString = parts.slice(i).join("/");
          if (matcher instanceof RegExp) {
            const m = matcher.exec(restPathString);
            if (m) {
              params[name] = m[0];
              handlerSets.push(...this.#getHandlerSets(child, method, node.#params, params));
              if (Object.keys(child.#children).length) {
                child.#params = params;
                const componentCount = m[0].match(/\//)?.length ?? 0;
                const targetCurNodes = curNodesQueue[componentCount] ||= [];
                targetCurNodes.push(child);
              }
              continue;
            }
          }
          if (matcher === true || matcher.test(part)) {
            params[name] = part;
            if (isLast) {
              handlerSets.push(...this.#getHandlerSets(child, method, params, node.#params));
              if (child.#children["*"]) {
                handlerSets.push(...this.#getHandlerSets(child.#children["*"], method, params, node.#params));
              }
            } else {
              child.#params = params;
              tempNodes.push(child);
            }
          }
        }
      }
      curNodes = tempNodes.concat(curNodesQueue.shift() ?? []);
    }
    if (handlerSets.length > 1) {
      handlerSets.sort((a, b) => {
        return a.score - b.score;
      });
    }
    return [handlerSets.map(({ handler, params }) => [handler, params])];
  }
};

// backend/node_modules/hono/dist/router/trie-router/router.js
var TrieRouter = class {
  name = "TrieRouter";
  #node;
  constructor() {
    this.#node = new Node2;
  }
  add(method, path, handler) {
    const results = checkOptionalParameter(path);
    if (results) {
      for (let i = 0, len = results.length;i < len; i++) {
        this.#node.insert(method, results[i], handler);
      }
      return;
    }
    this.#node.insert(method, path, handler);
  }
  match(method, path) {
    return this.#node.search(method, path);
  }
};

// backend/node_modules/hono/dist/hono.js
var Hono2 = class extends Hono {
  constructor(options = {}) {
    super(options);
    this.router = options.router ?? new SmartRouter({
      routers: [new RegExpRouter, new TrieRouter]
    });
  }
};

// backend/node_modules/hono/dist/middleware/cors/index.js
var cors = (options) => {
  const defaults = {
    origin: "*",
    allowMethods: ["GET", "HEAD", "PUT", "POST", "DELETE", "PATCH"],
    allowHeaders: [],
    exposeHeaders: []
  };
  const opts = {
    ...defaults,
    ...options
  };
  const findAllowOrigin = ((optsOrigin) => {
    if (typeof optsOrigin === "string") {
      if (optsOrigin === "*") {
        return () => optsOrigin;
      } else {
        return (origin) => optsOrigin === origin ? origin : null;
      }
    } else if (typeof optsOrigin === "function") {
      return optsOrigin;
    } else {
      return (origin) => optsOrigin.includes(origin) ? origin : null;
    }
  })(opts.origin);
  const findAllowMethods = ((optsAllowMethods) => {
    if (typeof optsAllowMethods === "function") {
      return optsAllowMethods;
    } else if (Array.isArray(optsAllowMethods)) {
      return () => optsAllowMethods;
    } else {
      return () => [];
    }
  })(opts.allowMethods);
  return async function cors2(c, next) {
    function set(key, value) {
      c.res.headers.set(key, value);
    }
    const allowOrigin = await findAllowOrigin(c.req.header("origin") || "", c);
    if (allowOrigin) {
      set("Access-Control-Allow-Origin", allowOrigin);
    }
    if (opts.credentials) {
      set("Access-Control-Allow-Credentials", "true");
    }
    if (opts.exposeHeaders?.length) {
      set("Access-Control-Expose-Headers", opts.exposeHeaders.join(","));
    }
    if (c.req.method === "OPTIONS") {
      if (opts.origin !== "*") {
        set("Vary", "Origin");
      }
      if (opts.maxAge != null) {
        set("Access-Control-Max-Age", opts.maxAge.toString());
      }
      const allowMethods = await findAllowMethods(c.req.header("origin") || "", c);
      if (allowMethods.length) {
        set("Access-Control-Allow-Methods", allowMethods.join(","));
      }
      let headers = opts.allowHeaders;
      if (!headers?.length) {
        const requestHeaders = c.req.header("Access-Control-Request-Headers");
        if (requestHeaders) {
          headers = requestHeaders.split(/\s*,\s*/);
        }
      }
      if (headers?.length) {
        set("Access-Control-Allow-Headers", headers.join(","));
        c.res.headers.append("Vary", "Access-Control-Request-Headers");
      }
      c.res.headers.delete("Content-Length");
      c.res.headers.delete("Content-Type");
      return new Response(null, {
        headers: c.res.headers,
        status: 204,
        statusText: "No Content"
      });
    }
    await next();
    if (opts.origin !== "*") {
      c.header("Vary", "Origin", { append: true });
    }
  };
};

// backend/src/supabase.ts
var import_supabase_js = __toESM(require_main5(), 1);
var supabaseUrl = process.env.SUPABASE_URL;
var supabaseKey = process.env.SUPABASE_KEY;
var supabase = import_supabase_js.createClient(supabaseUrl, supabaseKey);

// backend/node_modules/openai/internal/tslib.mjs
function __classPrivateFieldSet(receiver2, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver2 !== state || !f : !state.has(receiver2))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver2, value) : f ? f.value = value : state.set(receiver2, value), value;
}
function __classPrivateFieldGet(receiver2, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver2 !== state || !f : !state.has(receiver2))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver2) : f ? f.value : state.get(receiver2);
}

// backend/node_modules/openai/internal/utils/uuid.mjs
var uuid4 = function() {
  const { crypto: crypto2 } = globalThis;
  if (crypto2?.randomUUID) {
    uuid4 = crypto2.randomUUID.bind(crypto2);
    return crypto2.randomUUID();
  }
  const u8 = new Uint8Array(1);
  const randomByte = crypto2 ? () => crypto2.getRandomValues(u8)[0] : () => Math.random() * 255 & 255;
  return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (c) => (+c ^ randomByte() & 15 >> +c / 4).toString(16));
};

// backend/node_modules/openai/internal/errors.mjs
function isAbortError(err) {
  return typeof err === "object" && err !== null && (("name" in err) && err.name === "AbortError" || ("message" in err) && String(err.message).includes("FetchRequestCanceledException"));
}
var castToError = (err) => {
  if (err instanceof Error)
    return err;
  if (typeof err === "object" && err !== null) {
    try {
      if (Object.prototype.toString.call(err) === "[object Error]") {
        const error = new Error(err.message, err.cause ? { cause: err.cause } : {});
        if (err.stack)
          error.stack = err.stack;
        if (err.cause && !error.cause)
          error.cause = err.cause;
        if (err.name)
          error.name = err.name;
        return error;
      }
    } catch {}
    try {
      return new Error(JSON.stringify(err));
    } catch {}
  }
  return new Error(err);
};

// backend/node_modules/openai/core/error.mjs
class OpenAIError extends Error {
}

class APIError extends OpenAIError {
  constructor(status, error, message, headers) {
    super(`${APIError.makeMessage(status, error, message)}`);
    this.status = status;
    this.headers = headers;
    this.requestID = headers?.get("x-request-id");
    this.error = error;
    const data = error;
    this.code = data?.["code"];
    this.param = data?.["param"];
    this.type = data?.["type"];
  }
  static makeMessage(status, error, message) {
    const msg = error?.message ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status || !headers) {
      return new APIConnectionError({ message, cause: castToError(errorResponse) });
    }
    const error = errorResponse?.["error"];
    if (status === 400) {
      return new BadRequestError(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error, message, headers);
    }
    return new APIError(status, error, message, headers);
  }
}

class APIUserAbortError extends APIError {
  constructor({ message } = {}) {
    super(undefined, undefined, message || "Request was aborted.", undefined);
  }
}

class APIConnectionError extends APIError {
  constructor({ message, cause }) {
    super(undefined, undefined, message || "Connection error.", undefined);
    if (cause)
      this.cause = cause;
  }
}

class APIConnectionTimeoutError extends APIConnectionError {
  constructor({ message } = {}) {
    super({ message: message ?? "Request timed out." });
  }
}

class BadRequestError extends APIError {
}

class AuthenticationError extends APIError {
}

class PermissionDeniedError extends APIError {
}

class NotFoundError extends APIError {
}

class ConflictError extends APIError {
}

class UnprocessableEntityError extends APIError {
}

class RateLimitError extends APIError {
}

class InternalServerError extends APIError {
}

class LengthFinishReasonError extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the length limit was reached`);
  }
}

class ContentFilterFinishReasonError extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the request was rejected by the content filter`);
  }
}

class InvalidWebhookSignatureError extends Error {
  constructor(message) {
    super(message);
  }
}

// backend/node_modules/openai/internal/utils/values.mjs
var startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
var isAbsoluteURL = (url) => {
  return startsWithSchemeRegexp.test(url);
};
var isArray = (val) => (isArray = Array.isArray, isArray(val));
var isReadonlyArray = isArray;
function maybeObj(x) {
  if (typeof x !== "object") {
    return {};
  }
  return x ?? {};
}
function isEmptyObj(obj2) {
  if (!obj2)
    return true;
  for (const _k in obj2)
    return false;
  return true;
}
function hasOwn(obj2, key) {
  return Object.prototype.hasOwnProperty.call(obj2, key);
}
function isObj(obj2) {
  return obj2 != null && typeof obj2 === "object" && !Array.isArray(obj2);
}
var validatePositiveInteger = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new OpenAIError(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new OpenAIError(`${name} must be a positive integer`);
  }
  return n;
};
var safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return;
  }
};

// backend/node_modules/openai/internal/utils/sleep.mjs
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// backend/node_modules/openai/version.mjs
var VERSION = "6.9.1";

// backend/node_modules/openai/internal/detect-platform.mjs
var isRunningInBrowser = () => {
  return typeof window !== "undefined" && typeof window.document !== "undefined" && typeof navigator !== "undefined";
};
function getDetectedPlatform() {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return "deno";
  }
  if (typeof EdgeRuntime !== "undefined") {
    return "edge";
  }
  if (Object.prototype.toString.call(typeof globalThis.process !== "undefined" ? globalThis.process : 0) === "[object process]") {
    return "node";
  }
  return "unknown";
}
var getPlatformProperties = () => {
  const detectedPlatform = getDetectedPlatform();
  if (detectedPlatform === "deno") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : Deno.version?.deno ?? "unknown"
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": globalThis.process.version
    };
  }
  if (detectedPlatform === "node") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(globalThis.process.platform ?? "unknown"),
      "X-Stainless-Arch": normalizeArch(globalThis.process.arch ?? "unknown"),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": globalThis.process.version ?? "unknown"
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match2 = pattern.exec(navigator.userAgent);
    if (match2) {
      const major = match2[1] || 0;
      const minor = match2[2] || 0;
      const patch = match2[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
var normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders;
var getPlatformHeaders = () => {
  return _platformHeaders ?? (_platformHeaders = getPlatformProperties());
};

// backend/node_modules/openai/internal/shims.mjs
function getDefaultFetch() {
  if (typeof fetch !== "undefined") {
    return fetch;
  }
  throw new Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new OpenAI({ fetch })` or polyfill the global, `globalThis.fetch = fetch`");
}
function makeReadableStream(...args) {
  const ReadableStream2 = globalThis.ReadableStream;
  if (typeof ReadableStream2 === "undefined") {
    throw new Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`");
  }
  return new ReadableStream2(...args);
}
function ReadableStreamFrom(iterable) {
  let iter = Symbol.asyncIterator in iterable ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();
  return makeReadableStream({
    start() {},
    async pull(controller) {
      const { done, value } = await iter.next();
      if (done) {
        controller.close();
      } else {
        controller.enqueue(value);
      }
    },
    async cancel() {
      await iter.return?.();
    }
  });
}
function ReadableStreamToAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result?.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: undefined };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
async function CancelReadableStream(stream) {
  if (stream === null || typeof stream !== "object")
    return;
  if (stream[Symbol.asyncIterator]) {
    await stream[Symbol.asyncIterator]().return?.();
    return;
  }
  const reader = stream.getReader();
  const cancelPromise = reader.cancel();
  reader.releaseLock();
  await cancelPromise;
}

// backend/node_modules/openai/internal/request-options.mjs
var FallbackEncoder = ({ headers, body }) => {
  return {
    bodyHeaders: {
      "content-type": "application/json"
    },
    body: JSON.stringify(body)
  };
};

// backend/node_modules/openai/internal/qs/formats.mjs
var default_format = "RFC3986";
var default_formatter = (v) => String(v);
var formatters = {
  RFC1738: (v) => String(v).replace(/%20/g, "+"),
  RFC3986: default_formatter
};
var RFC1738 = "RFC1738";

// backend/node_modules/openai/internal/qs/utils.mjs
var has = (obj2, key) => (has = Object.hasOwn ?? Function.prototype.call.bind(Object.prototype.hasOwnProperty), has(obj2, key));
var hex_table = /* @__PURE__ */ (() => {
  const array = [];
  for (let i = 0;i < 256; ++i) {
    array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  }
  return array;
})();
var limit = 1024;
var encode = (str, _defaultEncoder, charset, _kind, format) => {
  if (str.length === 0) {
    return str;
  }
  let string = str;
  if (typeof str === "symbol") {
    string = Symbol.prototype.toString.call(str);
  } else if (typeof str !== "string") {
    string = String(str);
  }
  if (charset === "iso-8859-1") {
    return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  let out = "";
  for (let j = 0;j < string.length; j += limit) {
    const segment = string.length >= limit ? string.slice(j, j + limit) : string;
    const arr = [];
    for (let i = 0;i < segment.length; ++i) {
      let c = segment.charCodeAt(i);
      if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === RFC1738 && (c === 40 || c === 41)) {
        arr[arr.length] = segment.charAt(i);
        continue;
      }
      if (c < 128) {
        arr[arr.length] = hex_table[c];
        continue;
      }
      if (c < 2048) {
        arr[arr.length] = hex_table[192 | c >> 6] + hex_table[128 | c & 63];
        continue;
      }
      if (c < 55296 || c >= 57344) {
        arr[arr.length] = hex_table[224 | c >> 12] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
        continue;
      }
      i += 1;
      c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
      arr[arr.length] = hex_table[240 | c >> 18] + hex_table[128 | c >> 12 & 63] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
    }
    out += arr.join("");
  }
  return out;
};
function is_buffer(obj2) {
  if (!obj2 || typeof obj2 !== "object") {
    return false;
  }
  return !!(obj2.constructor && obj2.constructor.isBuffer && obj2.constructor.isBuffer(obj2));
}
function maybe_map(val, fn) {
  if (isArray(val)) {
    const mapped = [];
    for (let i = 0;i < val.length; i += 1) {
      mapped.push(fn(val[i]));
    }
    return mapped;
  }
  return fn(val);
}

// backend/node_modules/openai/internal/qs/stringify.mjs
var array_prefix_generators = {
  brackets(prefix) {
    return String(prefix) + "[]";
  },
  comma: "comma",
  indices(prefix, key) {
    return String(prefix) + "[" + key + "]";
  },
  repeat(prefix) {
    return String(prefix);
  }
};
var push_to_array = function(arr, value_or_array) {
  Array.prototype.push.apply(arr, isArray(value_or_array) ? value_or_array : [value_or_array]);
};
var toISOString;
var defaults = {
  addQueryPrefix: false,
  allowDots: false,
  allowEmptyArrays: false,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encodeDotInKeys: false,
  encoder: encode,
  encodeValuesOnly: false,
  format: default_format,
  formatter: default_formatter,
  indices: false,
  serializeDate(date) {
    return (toISOString ?? (toISOString = Function.prototype.call.bind(Date.prototype.toISOString)))(date);
  },
  skipNulls: false,
  strictNullHandling: false
};
function is_non_nullish_primitive(v) {
  return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
}
var sentinel = {};
function inner_stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
  let obj2 = object;
  let tmp_sc = sideChannel;
  let step = 0;
  let find_flag = false;
  while ((tmp_sc = tmp_sc.get(sentinel)) !== undefined && !find_flag) {
    const pos = tmp_sc.get(object);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        find_flag = true;
      }
    }
    if (typeof tmp_sc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter === "function") {
    obj2 = filter(prefix, obj2);
  } else if (obj2 instanceof Date) {
    obj2 = serializeDate?.(obj2);
  } else if (generateArrayPrefix === "comma" && isArray(obj2)) {
    obj2 = maybe_map(obj2, function(value) {
      if (value instanceof Date) {
        return serializeDate?.(value);
      }
      return value;
    });
  }
  if (obj2 === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
    }
    obj2 = "";
  }
  if (is_non_nullish_primitive(obj2) || is_buffer(obj2)) {
    if (encoder) {
      const key_value = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
      return [
        formatter?.(key_value) + "=" + formatter?.(encoder(obj2, defaults.encoder, charset, "value", format))
      ];
    }
    return [formatter?.(prefix) + "=" + formatter?.(String(obj2))];
  }
  const values = [];
  if (typeof obj2 === "undefined") {
    return values;
  }
  let obj_keys;
  if (generateArrayPrefix === "comma" && isArray(obj2)) {
    if (encodeValuesOnly && encoder) {
      obj2 = maybe_map(obj2, encoder);
    }
    obj_keys = [{ value: obj2.length > 0 ? obj2.join(",") || null : undefined }];
  } else if (isArray(filter)) {
    obj_keys = filter;
  } else {
    const keys = Object.keys(obj2);
    obj_keys = sort ? keys.sort(sort) : keys;
  }
  const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
  const adjusted_prefix = commaRoundTrip && isArray(obj2) && obj2.length === 1 ? encoded_prefix + "[]" : encoded_prefix;
  if (allowEmptyArrays && isArray(obj2) && obj2.length === 0) {
    return adjusted_prefix + "[]";
  }
  for (let j = 0;j < obj_keys.length; ++j) {
    const key = obj_keys[j];
    const value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj2[key];
    if (skipNulls && value === null) {
      continue;
    }
    const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
    const key_prefix = isArray(obj2) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjusted_prefix, encoded_key) : adjusted_prefix : adjusted_prefix + (allowDots ? "." + encoded_key : "[" + encoded_key + "]");
    sideChannel.set(object, step);
    const valueSideChannel = new WeakMap;
    valueSideChannel.set(sentinel, sideChannel);
    push_to_array(values, inner_stringify(value, key_prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj2) ? null : encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));
  }
  return values;
}
function normalize_stringify_options(opts = defaults) {
  if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  }
  if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  const charset = opts.charset || defaults.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  let format = default_format;
  if (typeof opts.format !== "undefined") {
    if (!has(formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format = opts.format;
  }
  const formatter = formatters[format];
  let filter = defaults.filter;
  if (typeof opts.filter === "function" || isArray(opts.filter)) {
    filter = opts.filter;
  }
  let arrayFormat;
  if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) {
    arrayFormat = opts.arrayFormat;
  } else if ("indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = defaults.arrayFormat;
  }
  if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  const allowDots = typeof opts.allowDots === "undefined" ? !!opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
    allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
    arrayFormat,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    commaRoundTrip: !!opts.commaRoundTrip,
    delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
    encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
    filter,
    format,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
  };
}
function stringify(object, opts = {}) {
  let obj2 = object;
  const options = normalize_stringify_options(opts);
  let obj_keys;
  let filter;
  if (typeof options.filter === "function") {
    filter = options.filter;
    obj2 = filter("", obj2);
  } else if (isArray(options.filter)) {
    filter = options.filter;
    obj_keys = filter;
  }
  const keys = [];
  if (typeof obj2 !== "object" || obj2 === null) {
    return "";
  }
  const generateArrayPrefix = array_prefix_generators[options.arrayFormat];
  const commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
  if (!obj_keys) {
    obj_keys = Object.keys(obj2);
  }
  if (options.sort) {
    obj_keys.sort(options.sort);
  }
  const sideChannel = new WeakMap;
  for (let i = 0;i < obj_keys.length; ++i) {
    const key = obj_keys[i];
    if (options.skipNulls && obj2[key] === null) {
      continue;
    }
    push_to_array(keys, inner_stringify(obj2[key], key, generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
  }
  const joined = keys.join(options.delimiter);
  let prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
}
// backend/node_modules/openai/internal/utils/bytes.mjs
function concatBytes(buffers) {
  let length = 0;
  for (const buffer of buffers) {
    length += buffer.length;
  }
  const output = new Uint8Array(length);
  let index = 0;
  for (const buffer of buffers) {
    output.set(buffer, index);
    index += buffer.length;
  }
  return output;
}
var encodeUTF8_;
function encodeUTF8(str) {
  let encoder;
  return (encodeUTF8_ ?? (encoder = new globalThis.TextEncoder, encodeUTF8_ = encoder.encode.bind(encoder)))(str);
}
var decodeUTF8_;
function decodeUTF8(bytes) {
  let decoder;
  return (decodeUTF8_ ?? (decoder = new globalThis.TextDecoder, decodeUTF8_ = decoder.decode.bind(decoder)))(bytes);
}

// backend/node_modules/openai/internal/decoders/line.mjs
var _LineDecoder_buffer;
var _LineDecoder_carriageReturnIndex;

class LineDecoder {
  constructor() {
    _LineDecoder_buffer.set(this, undefined);
    _LineDecoder_carriageReturnIndex.set(this, undefined);
    __classPrivateFieldSet(this, _LineDecoder_buffer, new Uint8Array, "f");
    __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
  }
  decode(chunk) {
    if (chunk == null) {
      return [];
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF8(chunk) : chunk;
    __classPrivateFieldSet(this, _LineDecoder_buffer, concatBytes([__classPrivateFieldGet(this, _LineDecoder_buffer, "f"), binaryChunk]), "f");
    const lines = [];
    let patternIndex;
    while ((patternIndex = findNewlineIndex(__classPrivateFieldGet(this, _LineDecoder_buffer, "f"), __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f"))) != null) {
      if (patternIndex.carriage && __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") == null) {
        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, patternIndex.index, "f");
        continue;
      }
      if (__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") != null && (patternIndex.index !== __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") + 1 || patternIndex.carriage)) {
        lines.push(decodeUTF8(__classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(0, __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") - 1)));
        __classPrivateFieldSet(this, _LineDecoder_buffer, __classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f")), "f");
        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
        continue;
      }
      const endIndex = __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;
      const line = decodeUTF8(__classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(0, endIndex));
      lines.push(line);
      __classPrivateFieldSet(this, _LineDecoder_buffer, __classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(patternIndex.index), "f");
      __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
    }
    return lines;
  }
  flush() {
    if (!__classPrivateFieldGet(this, _LineDecoder_buffer, "f").length) {
      return [];
    }
    return this.decode(`
`);
  }
}
_LineDecoder_buffer = new WeakMap, _LineDecoder_carriageReturnIndex = new WeakMap;
LineDecoder.NEWLINE_CHARS = new Set([`
`, "\r"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function findNewlineIndex(buffer, startIndex) {
  const newline = 10;
  const carriage = 13;
  for (let i = startIndex ?? 0;i < buffer.length; i++) {
    if (buffer[i] === newline) {
      return { preceding: i, index: i + 1, carriage: false };
    }
    if (buffer[i] === carriage) {
      return { preceding: i, index: i + 1, carriage: true };
    }
  }
  return null;
}
function findDoubleNewlineIndex(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i = 0;i < buffer.length - 1; i++) {
    if (buffer[i] === newline && buffer[i + 1] === newline) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === carriage) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {
      return i + 4;
    }
  }
  return -1;
}

// backend/node_modules/openai/internal/utils/log.mjs
var levelNumbers = {
  off: 0,
  error: 200,
  warn: 300,
  info: 400,
  debug: 500
};
var parseLogLevel = (maybeLevel, sourceName, client) => {
  if (!maybeLevel) {
    return;
  }
  if (hasOwn(levelNumbers, maybeLevel)) {
    return maybeLevel;
  }
  loggerFor(client).warn(`${sourceName} was set to ${JSON.stringify(maybeLevel)}, expected one of ${JSON.stringify(Object.keys(levelNumbers))}`);
  return;
};
function noop() {}
function makeLogFn(fnLevel, logger, logLevel) {
  if (!logger || levelNumbers[fnLevel] > levelNumbers[logLevel]) {
    return noop;
  } else {
    return logger[fnLevel].bind(logger);
  }
}
var noopLogger = {
  error: noop,
  warn: noop,
  info: noop,
  debug: noop
};
var cachedLoggers = /* @__PURE__ */ new WeakMap;
function loggerFor(client) {
  const logger = client.logger;
  const logLevel = client.logLevel ?? "off";
  if (!logger) {
    return noopLogger;
  }
  const cachedLogger = cachedLoggers.get(logger);
  if (cachedLogger && cachedLogger[0] === logLevel) {
    return cachedLogger[1];
  }
  const levelLogger = {
    error: makeLogFn("error", logger, logLevel),
    warn: makeLogFn("warn", logger, logLevel),
    info: makeLogFn("info", logger, logLevel),
    debug: makeLogFn("debug", logger, logLevel)
  };
  cachedLoggers.set(logger, [logLevel, levelLogger]);
  return levelLogger;
}
var formatRequestDetails = (details) => {
  if (details.options) {
    details.options = { ...details.options };
    delete details.options["headers"];
  }
  if (details.headers) {
    details.headers = Object.fromEntries((details.headers instanceof Headers ? [...details.headers] : Object.entries(details.headers)).map(([name, value]) => [
      name,
      name.toLowerCase() === "authorization" || name.toLowerCase() === "cookie" || name.toLowerCase() === "set-cookie" ? "***" : value
    ]));
  }
  if ("retryOfRequestLogID" in details) {
    if (details.retryOfRequestLogID) {
      details.retryOf = details.retryOfRequestLogID;
    }
    delete details.retryOfRequestLogID;
  }
  return details;
};

// backend/node_modules/openai/core/streaming.mjs
var _Stream_client;

class Stream {
  constructor(iterator, controller, client) {
    this.iterator = iterator;
    _Stream_client.set(this, undefined);
    this.controller = controller;
    __classPrivateFieldSet(this, _Stream_client, client, "f");
  }
  static fromSSEResponse(response, controller, client) {
    let consumed = false;
    const logger = client ? loggerFor(client) : console;
    async function* iterator() {
      if (consumed) {
        throw new OpenAIError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of _iterSSEMessages(response, controller)) {
          if (done)
            continue;
          if (sse.data.startsWith("[DONE]")) {
            done = true;
            continue;
          }
          if (sse.event === null || !sse.event.startsWith("thread.")) {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              logger.error(`Could not parse message into JSON:`, sse.data);
              logger.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (data && data.error) {
              throw new APIError(undefined, data.error, undefined, response.headers);
            }
            yield data;
          } else {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (sse.event == "error") {
              throw new APIError(undefined, data.error, data.message, undefined);
            }
            yield { event: sse.event, data };
          }
        }
        done = true;
      } catch (e) {
        if (isAbortError(e))
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator, controller, client);
  }
  static fromReadableStream(readableStream, controller, client) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder;
      const iter = ReadableStreamToAsyncIterable(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new OpenAIError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e) {
        if (isAbortError(e))
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator, controller, client);
  }
  [(_Stream_client = new WeakMap, Symbol.asyncIterator)]() {
    return this.iterator();
  }
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue) => {
      return {
        next: () => {
          if (queue.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue.shift();
        }
      };
    };
    return [
      new Stream(() => teeIterator(left), this.controller, __classPrivateFieldGet(this, _Stream_client, "f")),
      new Stream(() => teeIterator(right), this.controller, __classPrivateFieldGet(this, _Stream_client, "f"))
    ];
  }
  toReadableStream() {
    const self2 = this;
    let iter;
    return makeReadableStream({
      async start() {
        iter = self2[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encodeUTF8(JSON.stringify(value) + `
`);
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        await iter.return?.();
      }
    });
  }
}
async function* _iterSSEMessages(response, controller) {
  if (!response.body) {
    controller.abort();
    if (typeof globalThis.navigator !== "undefined" && globalThis.navigator.product === "ReactNative") {
      throw new OpenAIError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);
    }
    throw new OpenAIError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder;
  const lineDecoder = new LineDecoder;
  const iter = ReadableStreamToAsyncIterable(response.body);
  for await (const sseChunk of iterSSEChunks(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse)
      yield sse;
  }
}
async function* iterSSEChunks(iterator) {
  let data = new Uint8Array;
  for await (const chunk of iterator) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF8(chunk) : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}

class SSEDecoder {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join(`
`),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
}
function partition(str, delimiter) {
  const index = str.indexOf(delimiter);
  if (index !== -1) {
    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];
  }
  return [str, "", ""];
}

// backend/node_modules/openai/internal/parse.mjs
async function defaultParseResponse(client, props) {
  const { response, requestLogID, retryOfRequestLogID, startTime } = props;
  const body = await (async () => {
    if (props.options.stream) {
      loggerFor(client).debug("response", response.status, response.url, response.headers, response.body);
      if (props.options.__streamClass) {
        return props.options.__streamClass.fromSSEResponse(response, props.controller, client);
      }
      return Stream.fromSSEResponse(response, props.controller, client);
    }
    if (response.status === 204) {
      return null;
    }
    if (props.options.__binaryResponse) {
      return response;
    }
    const contentType = response.headers.get("content-type");
    const mediaType = contentType?.split(";")[0]?.trim();
    const isJSON = mediaType?.includes("application/json") || mediaType?.endsWith("+json");
    if (isJSON) {
      const json = await response.json();
      return addRequestID(json, response);
    }
    const text = await response.text();
    return text;
  })();
  loggerFor(client).debug(`[${requestLogID}] response parsed`, formatRequestDetails({
    retryOfRequestLogID,
    url: response.url,
    status: response.status,
    body,
    durationMs: Date.now() - startTime
  }));
  return body;
}
function addRequestID(value, response) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return value;
  }
  return Object.defineProperty(value, "_request_id", {
    value: response.headers.get("x-request-id"),
    enumerable: false
  });
}

// backend/node_modules/openai/core/api-promise.mjs
var _APIPromise_client;

class APIPromise extends Promise {
  constructor(client, responsePromise, parseResponse = defaultParseResponse) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse;
    _APIPromise_client.set(this, undefined);
    __classPrivateFieldSet(this, _APIPromise_client, client, "f");
  }
  _thenUnwrap(transform) {
    return new APIPromise(__classPrivateFieldGet(this, _APIPromise_client, "f"), this.responsePromise, async (client, props) => addRequestID(transform(await this.parseResponse(client, props), props), props.response));
  }
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response, request_id: response.headers.get("x-request-id") };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then((data) => this.parseResponse(__classPrivateFieldGet(this, _APIPromise_client, "f"), data));
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
}
_APIPromise_client = new WeakMap;

// backend/node_modules/openai/core/pagination.mjs
var _AbstractPage_client;

class AbstractPage {
  constructor(client, response, body, options) {
    _AbstractPage_client.set(this, undefined);
    __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageRequestOptions() != null;
  }
  async getNextPage() {
    const nextOptions = this.nextPageRequestOptions();
    if (!nextOptions) {
      throw new OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
  }
  async* iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async* [(_AbstractPage_client = new WeakMap, Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
}

class PagePromise extends APIPromise {
  constructor(client, request, Page) {
    super(client, request, async (client2, props) => new Page(client2, props.response, await defaultParseResponse(client2, props), props.options));
  }
  async* [Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
}

class Page extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.object = body.object;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  nextPageRequestOptions() {
    return null;
  }
}

class CursorPage extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.has_more = body.has_more || false;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    if (this.has_more === false) {
      return false;
    }
    return super.hasNextPage();
  }
  nextPageRequestOptions() {
    const data = this.getPaginatedItems();
    const id = data[data.length - 1]?.id;
    if (!id) {
      return null;
    }
    return {
      ...this.options,
      query: {
        ...maybeObj(this.options.query),
        after: id
      }
    };
  }
}

class ConversationCursorPage extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.has_more = body.has_more || false;
    this.last_id = body.last_id || "";
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    if (this.has_more === false) {
      return false;
    }
    return super.hasNextPage();
  }
  nextPageRequestOptions() {
    const cursor = this.last_id;
    if (!cursor) {
      return null;
    }
    return {
      ...this.options,
      query: {
        ...maybeObj(this.options.query),
        after: cursor
      }
    };
  }
}

// backend/node_modules/openai/internal/uploads.mjs
var checkFileSupport = () => {
  if (typeof File === "undefined") {
    const { process: process2 } = globalThis;
    const isOldNode = typeof process2?.versions?.node === "string" && parseInt(process2.versions.node.split(".")) < 20;
    throw new Error("`File` is not defined as a global, which is required for file uploads." + (isOldNode ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`." : ""));
  }
};
function makeFile(fileBits, fileName, options) {
  checkFileSupport();
  return new File(fileBits, fileName ?? "unknown_file", options);
}
function getName(value) {
  return (typeof value === "object" && value !== null && (("name" in value) && value.name && String(value.name) || ("url" in value) && value.url && String(value.url) || ("filename" in value) && value.filename && String(value.filename) || ("path" in value) && value.path && String(value.path)) || "").split(/[\\/]/).pop() || undefined;
}
var isAsyncIterable = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var maybeMultipartFormRequestOptions = async (opts, fetch2) => {
  if (!hasUploadableValue(opts.body))
    return opts;
  return { ...opts, body: await createForm(opts.body, fetch2) };
};
var multipartFormRequestOptions = async (opts, fetch2) => {
  return { ...opts, body: await createForm(opts.body, fetch2) };
};
var supportsFormDataMap = /* @__PURE__ */ new WeakMap;
function supportsFormData(fetchObject) {
  const fetch2 = typeof fetchObject === "function" ? fetchObject : fetchObject.fetch;
  const cached = supportsFormDataMap.get(fetch2);
  if (cached)
    return cached;
  const promise = (async () => {
    try {
      const FetchResponse = "Response" in fetch2 ? fetch2.Response : (await fetch2("data:,")).constructor;
      const data = new FormData;
      if (data.toString() === await new FetchResponse(data).text()) {
        return false;
      }
      return true;
    } catch {
      return true;
    }
  })();
  supportsFormDataMap.set(fetch2, promise);
  return promise;
}
var createForm = async (body, fetch2) => {
  if (!await supportsFormData(fetch2)) {
    throw new TypeError("The provided fetch function does not support file uploads with the current global FormData class.");
  }
  const form = new FormData;
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
  return form;
};
var isNamedBlob = (value) => value instanceof Blob && ("name" in value);
var isUploadable = (value) => typeof value === "object" && value !== null && (value instanceof Response || isAsyncIterable(value) || isNamedBlob(value));
var hasUploadableValue = (value) => {
  if (isUploadable(value))
    return true;
  if (Array.isArray(value))
    return value.some(hasUploadableValue);
  if (value && typeof value === "object") {
    for (const k in value) {
      if (hasUploadableValue(value[k]))
        return true;
    }
  }
  return false;
};
var addFormValue = async (form, key, value) => {
  if (value === undefined)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (value instanceof Response) {
    form.append(key, makeFile([await value.blob()], getName(value)));
  } else if (isAsyncIterable(value)) {
    form.append(key, makeFile([await new Response(ReadableStreamFrom(value)).blob()], getName(value)));
  } else if (isNamedBlob(value)) {
    form.append(key, value, getName(value));
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
};

// backend/node_modules/openai/internal/to-file.mjs
var isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
var isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
var isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
async function toFile(value, name, options) {
  checkFileSupport();
  value = await value;
  if (isFileLike(value)) {
    if (value instanceof File) {
      return value;
    }
    return makeFile([await value.arrayBuffer()], value.name);
  }
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = new URL(value.url).pathname.split(/[\\/]/).pop());
    return makeFile(await getBytes(blob), name, options);
  }
  const parts = await getBytes(value);
  name || (name = getName(value));
  if (!options?.type) {
    const type = parts.find((part) => typeof part === "object" && ("type" in part) && part.type);
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return makeFile(parts, name, options);
}
async function getBytes(value) {
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(value instanceof Blob ? value : await value.arrayBuffer());
  } else if (isAsyncIterable(value)) {
    for await (const chunk of value) {
      parts.push(...await getBytes(chunk));
    }
  } else {
    const constructor = value?.constructor?.name;
    throw new Error(`Unexpected data type: ${typeof value}${constructor ? `; constructor: ${constructor}` : ""}${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  if (typeof value !== "object" || value === null)
    return "";
  const props = Object.getOwnPropertyNames(value);
  return `; props: [${props.map((p) => `"${p}"`).join(", ")}]`;
}
// backend/node_modules/openai/core/resource.mjs
class APIResource {
  constructor(client) {
    this._client = client;
  }
}

// backend/node_modules/openai/internal/utils/path.mjs
function encodeURIPath(str) {
  return str.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);
}
var EMPTY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.create(null));
var createPathTagFunction = (pathEncoder = encodeURIPath) => function path(statics, ...params) {
  if (statics.length === 1)
    return statics[0];
  let postPath = false;
  const invalidSegments = [];
  const path = statics.reduce((previousValue, currentValue, index) => {
    if (/[?#]/.test(currentValue)) {
      postPath = true;
    }
    const value = params[index];
    let encoded = (postPath ? encodeURIComponent : pathEncoder)("" + value);
    if (index !== params.length && (value == null || typeof value === "object" && value.toString === Object.getPrototypeOf(Object.getPrototypeOf(value.hasOwnProperty ?? EMPTY) ?? EMPTY)?.toString)) {
      encoded = value + "";
      invalidSegments.push({
        start: previousValue.length + currentValue.length,
        length: encoded.length,
        error: `Value of type ${Object.prototype.toString.call(value).slice(8, -1)} is not a valid path parameter`
      });
    }
    return previousValue + currentValue + (index === params.length ? "" : encoded);
  }, "");
  const pathOnly = path.split(/[?#]/, 1)[0];
  const invalidSegmentPattern = /(?<=^|\/)(?:\.|%2e){1,2}(?=\/|$)/gi;
  let match2;
  while ((match2 = invalidSegmentPattern.exec(pathOnly)) !== null) {
    invalidSegments.push({
      start: match2.index,
      length: match2[0].length,
      error: `Value "${match2[0]}" can't be safely passed as a path parameter`
    });
  }
  invalidSegments.sort((a, b) => a.start - b.start);
  if (invalidSegments.length > 0) {
    let lastEnd = 0;
    const underline = invalidSegments.reduce((acc, segment) => {
      const spaces = " ".repeat(segment.start - lastEnd);
      const arrows = "^".repeat(segment.length);
      lastEnd = segment.start + segment.length;
      return acc + spaces + arrows;
    }, "");
    throw new OpenAIError(`Path parameters result in path with invalid segments:
${invalidSegments.map((e) => e.error).join(`
`)}
${path}
${underline}`);
  }
  return path;
};
var path = /* @__PURE__ */ createPathTagFunction(encodeURIPath);

// backend/node_modules/openai/resources/chat/completions/messages.mjs
class Messages extends APIResource {
  list(completionID, query = {}, options) {
    return this._client.getAPIList(path`/chat/completions/${completionID}/messages`, CursorPage, { query, ...options });
  }
}
// backend/node_modules/openai/lib/parser.mjs
function isChatCompletionFunctionTool(tool) {
  return tool !== undefined && "function" in tool && tool.function !== undefined;
}
function isAutoParsableResponseFormat(response_format) {
  return response_format?.["$brand"] === "auto-parseable-response-format";
}
function isAutoParsableTool(tool) {
  return tool?.["$brand"] === "auto-parseable-tool";
}
function maybeParseChatCompletion(completion, params) {
  if (!params || !hasAutoParseableInput(params)) {
    return {
      ...completion,
      choices: completion.choices.map((choice) => {
        assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);
        return {
          ...choice,
          message: {
            ...choice.message,
            parsed: null,
            ...choice.message.tool_calls ? {
              tool_calls: choice.message.tool_calls
            } : undefined
          }
        };
      })
    };
  }
  return parseChatCompletion(completion, params);
}
function parseChatCompletion(completion, params) {
  const choices = completion.choices.map((choice) => {
    if (choice.finish_reason === "length") {
      throw new LengthFinishReasonError;
    }
    if (choice.finish_reason === "content_filter") {
      throw new ContentFilterFinishReasonError;
    }
    assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);
    return {
      ...choice,
      message: {
        ...choice.message,
        ...choice.message.tool_calls ? {
          tool_calls: choice.message.tool_calls?.map((toolCall) => parseToolCall(params, toolCall)) ?? undefined
        } : undefined,
        parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat(params, choice.message.content) : null
      }
    };
  });
  return { ...completion, choices };
}
function parseResponseFormat(params, content) {
  if (params.response_format?.type !== "json_schema") {
    return null;
  }
  if (params.response_format?.type === "json_schema") {
    if ("$parseRaw" in params.response_format) {
      const response_format = params.response_format;
      return response_format.$parseRaw(content);
    }
    return JSON.parse(content);
  }
  return null;
}
function parseToolCall(params, toolCall) {
  const inputTool = params.tools?.find((inputTool2) => isChatCompletionFunctionTool(inputTool2) && inputTool2.function?.name === toolCall.function.name);
  return {
    ...toolCall,
    function: {
      ...toolCall.function,
      parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCall.function.arguments) : null
    }
  };
}
function shouldParseToolCall(params, toolCall) {
  if (!params || !("tools" in params) || !params.tools) {
    return false;
  }
  const inputTool = params.tools?.find((inputTool2) => isChatCompletionFunctionTool(inputTool2) && inputTool2.function?.name === toolCall.function.name);
  return isChatCompletionFunctionTool(inputTool) && (isAutoParsableTool(inputTool) || inputTool?.function.strict || false);
}
function hasAutoParseableInput(params) {
  if (isAutoParsableResponseFormat(params.response_format)) {
    return true;
  }
  return params.tools?.some((t) => isAutoParsableTool(t) || t.type === "function" && t.function.strict === true) ?? false;
}
function assertToolCallsAreChatCompletionFunctionToolCalls(toolCalls) {
  for (const toolCall of toolCalls || []) {
    if (toolCall.type !== "function") {
      throw new OpenAIError(`Currently only \`function\` tool calls are supported; Received \`${toolCall.type}\``);
    }
  }
}
function validateInputTools(tools) {
  for (const tool of tools ?? []) {
    if (tool.type !== "function") {
      throw new OpenAIError(`Currently only \`function\` tool types support auto-parsing; Received \`${tool.type}\``);
    }
    if (tool.function.strict !== true) {
      throw new OpenAIError(`The \`${tool.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
    }
  }
}

// backend/node_modules/openai/lib/chatCompletionUtils.mjs
var isAssistantMessage = (message) => {
  return message?.role === "assistant";
};
var isToolMessage = (message) => {
  return message?.role === "tool";
};

// backend/node_modules/openai/lib/EventStream.mjs
var _EventStream_instances;
var _EventStream_connectedPromise;
var _EventStream_resolveConnectedPromise;
var _EventStream_rejectConnectedPromise;
var _EventStream_endPromise;
var _EventStream_resolveEndPromise;
var _EventStream_rejectEndPromise;
var _EventStream_listeners;
var _EventStream_ended;
var _EventStream_errored;
var _EventStream_aborted;
var _EventStream_catchingPromiseCreated;
var _EventStream_handleError;

class EventStream {
  constructor() {
    _EventStream_instances.add(this);
    this.controller = new AbortController;
    _EventStream_connectedPromise.set(this, undefined);
    _EventStream_resolveConnectedPromise.set(this, () => {});
    _EventStream_rejectConnectedPromise.set(this, () => {});
    _EventStream_endPromise.set(this, undefined);
    _EventStream_resolveEndPromise.set(this, () => {});
    _EventStream_rejectEndPromise.set(this, () => {});
    _EventStream_listeners.set(this, {});
    _EventStream_ended.set(this, false);
    _EventStream_errored.set(this, false);
    _EventStream_aborted.set(this, false);
    _EventStream_catchingPromiseCreated.set(this, false);
    __classPrivateFieldSet(this, _EventStream_connectedPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet(this, _EventStream_resolveConnectedPromise, resolve, "f");
      __classPrivateFieldSet(this, _EventStream_rejectConnectedPromise, reject, "f");
    }), "f");
    __classPrivateFieldSet(this, _EventStream_endPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet(this, _EventStream_resolveEndPromise, resolve, "f");
      __classPrivateFieldSet(this, _EventStream_rejectEndPromise, reject, "f");
    }), "f");
    __classPrivateFieldGet(this, _EventStream_connectedPromise, "f").catch(() => {});
    __classPrivateFieldGet(this, _EventStream_endPromise, "f").catch(() => {});
  }
  _run(executor) {
    setTimeout(() => {
      executor().then(() => {
        this._emitFinal();
        this._emit("end");
      }, __classPrivateFieldGet(this, _EventStream_instances, "m", _EventStream_handleError).bind(this));
    }, 0);
  }
  _connected() {
    if (this.ended)
      return;
    __classPrivateFieldGet(this, _EventStream_resolveConnectedPromise, "f").call(this);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet(this, _EventStream_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet(this, _EventStream_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet(this, _EventStream_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  on(event, listener) {
    const listeners = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener });
    return this;
  }
  off(event, listener) {
    const listeners = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event];
    if (!listeners)
      return this;
    const index = listeners.findIndex((l) => l.listener === listener);
    if (index >= 0)
      listeners.splice(index, 1);
    return this;
  }
  once(event, listener) {
    const listeners = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  emitted(event) {
    return new Promise((resolve, reject) => {
      __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, "f");
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve);
    });
  }
  async done() {
    __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, "f");
    await __classPrivateFieldGet(this, _EventStream_endPromise, "f");
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet(this, _EventStream_ended, "f")) {
      return;
    }
    if (event === "end") {
      __classPrivateFieldSet(this, _EventStream_ended, true, "f");
      __classPrivateFieldGet(this, _EventStream_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet(this, _EventStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error2 = args[0];
      if (!__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error2);
      }
      __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, "f").call(this, error2);
      __classPrivateFieldGet(this, _EventStream_rejectEndPromise, "f").call(this, error2);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error2 = args[0];
      if (!__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error2);
      }
      __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, "f").call(this, error2);
      __classPrivateFieldGet(this, _EventStream_rejectEndPromise, "f").call(this, error2);
      this._emit("end");
    }
  }
  _emitFinal() {}
}
_EventStream_connectedPromise = new WeakMap, _EventStream_resolveConnectedPromise = new WeakMap, _EventStream_rejectConnectedPromise = new WeakMap, _EventStream_endPromise = new WeakMap, _EventStream_resolveEndPromise = new WeakMap, _EventStream_rejectEndPromise = new WeakMap, _EventStream_listeners = new WeakMap, _EventStream_ended = new WeakMap, _EventStream_errored = new WeakMap, _EventStream_aborted = new WeakMap, _EventStream_catchingPromiseCreated = new WeakMap, _EventStream_instances = new WeakSet, _EventStream_handleError = function _EventStream_handleError2(error2) {
  __classPrivateFieldSet(this, _EventStream_errored, true, "f");
  if (error2 instanceof Error && error2.name === "AbortError") {
    error2 = new APIUserAbortError;
  }
  if (error2 instanceof APIUserAbortError) {
    __classPrivateFieldSet(this, _EventStream_aborted, true, "f");
    return this._emit("abort", error2);
  }
  if (error2 instanceof OpenAIError) {
    return this._emit("error", error2);
  }
  if (error2 instanceof Error) {
    const openAIError = new OpenAIError(error2.message);
    openAIError.cause = error2;
    return this._emit("error", openAIError);
  }
  return this._emit("error", new OpenAIError(String(error2)));
};

// backend/node_modules/openai/lib/RunnableFunction.mjs
function isRunnableFunctionWithParse(fn) {
  return typeof fn.parse === "function";
}

// backend/node_modules/openai/lib/AbstractChatCompletionRunner.mjs
var _AbstractChatCompletionRunner_instances;
var _AbstractChatCompletionRunner_getFinalContent;
var _AbstractChatCompletionRunner_getFinalMessage;
var _AbstractChatCompletionRunner_getFinalFunctionToolCall;
var _AbstractChatCompletionRunner_getFinalFunctionToolCallResult;
var _AbstractChatCompletionRunner_calculateTotalUsage;
var _AbstractChatCompletionRunner_validateParams;
var _AbstractChatCompletionRunner_stringifyFunctionCallResult;
var DEFAULT_MAX_CHAT_COMPLETIONS = 10;

class AbstractChatCompletionRunner extends EventStream {
  constructor() {
    super(...arguments);
    _AbstractChatCompletionRunner_instances.add(this);
    this._chatCompletions = [];
    this.messages = [];
  }
  _addChatCompletion(chatCompletion) {
    this._chatCompletions.push(chatCompletion);
    this._emit("chatCompletion", chatCompletion);
    const message = chatCompletion.choices[0]?.message;
    if (message)
      this._addMessage(message);
    return chatCompletion;
  }
  _addMessage(message, emit = true) {
    if (!("content" in message))
      message.content = null;
    this.messages.push(message);
    if (emit) {
      this._emit("message", message);
      if (isToolMessage(message) && message.content) {
        this._emit("functionToolCallResult", message.content);
      } else if (isAssistantMessage(message) && message.tool_calls) {
        for (const tool_call of message.tool_calls) {
          if (tool_call.type === "function") {
            this._emit("functionToolCall", tool_call.function);
          }
        }
      }
    }
  }
  async finalChatCompletion() {
    await this.done();
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (!completion)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return completion;
  }
  async finalContent() {
    await this.done();
    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
  }
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
  }
  async finalFunctionToolCall() {
    await this.done();
    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCall).call(this);
  }
  async finalFunctionToolCallResult() {
    await this.done();
    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCallResult).call(this);
  }
  async totalUsage() {
    await this.done();
    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emitFinal() {
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (completion)
      this._emit("finalChatCompletion", completion);
    const finalMessage = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
    if (finalMessage)
      this._emit("finalMessage", finalMessage);
    const finalContent = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
    if (finalContent)
      this._emit("finalContent", finalContent);
    const finalFunctionCall = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCall).call(this);
    if (finalFunctionCall)
      this._emit("finalFunctionToolCall", finalFunctionCall);
    const finalFunctionCallResult = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCallResult).call(this);
    if (finalFunctionCallResult != null)
      this._emit("finalFunctionToolCallResult", finalFunctionCallResult);
    if (this._chatCompletions.some((c) => c.usage)) {
      this._emit("totalUsage", __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));
    }
  }
  async _createChatCompletion(client, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_validateParams).call(this, params);
    const chatCompletion = await client.chat.completions.create({ ...params, stream: false }, { ...options, signal: this.controller.signal });
    this._connected();
    return this._addChatCompletion(parseChatCompletion(chatCompletion, params));
  }
  async _runChatCompletion(client, params, options) {
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    return await this._createChatCompletion(client, params, options);
  }
  async _runTools(client, params, options) {
    const role = "tool";
    const { tool_choice = "auto", stream, ...restParams } = params;
    const singleFunctionToCall = typeof tool_choice !== "string" && tool_choice.type === "function" && tool_choice?.function?.name;
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const inputTools = params.tools.map((tool) => {
      if (isAutoParsableTool(tool)) {
        if (!tool.$callback) {
          throw new OpenAIError("Tool given to `.runTools()` that does not have an associated function");
        }
        return {
          type: "function",
          function: {
            function: tool.$callback,
            name: tool.function.name,
            description: tool.function.description || "",
            parameters: tool.function.parameters,
            parse: tool.$parseRaw,
            strict: true
          }
        };
      }
      return tool;
    });
    const functionsByName = {};
    for (const f of inputTools) {
      if (f.type === "function") {
        functionsByName[f.function.name || f.function.function.name] = f.function;
      }
    }
    const tools = "tools" in params ? inputTools.map((t) => t.type === "function" ? {
      type: "function",
      function: {
        name: t.function.name || t.function.function.name,
        parameters: t.function.parameters,
        description: t.function.description,
        strict: t.function.strict
      }
    } : t) : undefined;
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i = 0;i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(client, {
        ...restParams,
        tool_choice,
        tools,
        messages: [...this.messages]
      }, options);
      const message = chatCompletion.choices[0]?.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!message.tool_calls?.length) {
        return;
      }
      for (const tool_call of message.tool_calls) {
        if (tool_call.type !== "function")
          continue;
        const tool_call_id = tool_call.id;
        const { name, arguments: args } = tool_call.function;
        const fn = functionsByName[name];
        if (!fn) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName).map((name2) => JSON.stringify(name2)).join(", ")}. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        } else if (singleFunctionToCall && singleFunctionToCall !== name) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        let parsed;
        try {
          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
        } catch (error2) {
          const content2 = error2 instanceof Error ? error2.message : String(error2);
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        const rawContent = await fn.function(parsed, this);
        const content = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
        this._addMessage({ role, tool_call_id, content });
        if (singleFunctionToCall) {
          return;
        }
      }
    }
    return;
  }
}
_AbstractChatCompletionRunner_instances = new WeakSet, _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent2() {
  return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this).content ?? null;
}, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage2() {
  let i = this.messages.length;
  while (i-- > 0) {
    const message = this.messages[i];
    if (isAssistantMessage(message)) {
      const ret = {
        ...message,
        content: message.content ?? null,
        refusal: message.refusal ?? null
      };
      return ret;
    }
  }
  throw new OpenAIError("stream ended without producing a ChatCompletionMessage with role=assistant");
}, _AbstractChatCompletionRunner_getFinalFunctionToolCall = function _AbstractChatCompletionRunner_getFinalFunctionToolCall2() {
  for (let i = this.messages.length - 1;i >= 0; i--) {
    const message = this.messages[i];
    if (isAssistantMessage(message) && message?.tool_calls?.length) {
      return message.tool_calls.filter((x) => x.type === "function").at(-1)?.function;
    }
  }
  return;
}, _AbstractChatCompletionRunner_getFinalFunctionToolCallResult = function _AbstractChatCompletionRunner_getFinalFunctionToolCallResult2() {
  for (let i = this.messages.length - 1;i >= 0; i--) {
    const message = this.messages[i];
    if (isToolMessage(message) && message.content != null && typeof message.content === "string" && this.messages.some((x) => x.role === "assistant" && x.tool_calls?.some((y) => y.type === "function" && y.id === message.tool_call_id))) {
      return message.content;
    }
  }
  return;
}, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage2() {
  const total = {
    completion_tokens: 0,
    prompt_tokens: 0,
    total_tokens: 0
  };
  for (const { usage } of this._chatCompletions) {
    if (usage) {
      total.completion_tokens += usage.completion_tokens;
      total.prompt_tokens += usage.prompt_tokens;
      total.total_tokens += usage.total_tokens;
    }
  }
  return total;
}, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams2(params) {
  if (params.n != null && params.n > 1) {
    throw new OpenAIError("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
  }
}, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult2(rawContent) {
  return typeof rawContent === "string" ? rawContent : rawContent === undefined ? "undefined" : JSON.stringify(rawContent);
};

// backend/node_modules/openai/lib/ChatCompletionRunner.mjs
class ChatCompletionRunner extends AbstractChatCompletionRunner {
  static runTools(client, params, options) {
    const runner = new ChatCompletionRunner;
    const opts = {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client, params, opts));
    return runner;
  }
  _addMessage(message, emit = true) {
    super._addMessage(message, emit);
    if (isAssistantMessage(message) && message.content) {
      this._emit("content", message.content);
    }
  }
}

// backend/node_modules/openai/_vendor/partial-json-parser/parser.mjs
var STR = 1;
var NUM = 2;
var ARR = 4;
var OBJ = 8;
var NULL = 16;
var BOOL = 32;
var NAN = 64;
var INFINITY = 128;
var MINUS_INFINITY = 256;
var INF = INFINITY | MINUS_INFINITY;
var SPECIAL = NULL | BOOL | INF | NAN;
var ATOM = STR | NUM | SPECIAL;
var COLLECTION = ARR | OBJ;
var ALL = ATOM | COLLECTION;
var Allow = {
  STR,
  NUM,
  ARR,
  OBJ,
  NULL,
  BOOL,
  NAN,
  INFINITY,
  MINUS_INFINITY,
  INF,
  SPECIAL,
  ATOM,
  COLLECTION,
  ALL
};

class PartialJSON extends Error {
}

class MalformedJSON extends Error {
}
function parseJSON(jsonString, allowPartial = Allow.ALL) {
  if (typeof jsonString !== "string") {
    throw new TypeError(`expecting str, got ${typeof jsonString}`);
  }
  if (!jsonString.trim()) {
    throw new Error(`${jsonString} is empty`);
  }
  return _parseJSON(jsonString.trim(), allowPartial);
}
var _parseJSON = (jsonString, allow) => {
  const length = jsonString.length;
  let index = 0;
  const markPartialJSON = (msg) => {
    throw new PartialJSON(`${msg} at position ${index}`);
  };
  const throwMalformedError = (msg) => {
    throw new MalformedJSON(`${msg} at position ${index}`);
  };
  const parseAny = () => {
    skipBlank();
    if (index >= length)
      markPartialJSON("Unexpected end of input");
    if (jsonString[index] === '"')
      return parseStr();
    if (jsonString[index] === "{")
      return parseObj();
    if (jsonString[index] === "[")
      return parseArr();
    if (jsonString.substring(index, index + 4) === "null" || Allow.NULL & allow && length - index < 4 && "null".startsWith(jsonString.substring(index))) {
      index += 4;
      return null;
    }
    if (jsonString.substring(index, index + 4) === "true" || Allow.BOOL & allow && length - index < 4 && "true".startsWith(jsonString.substring(index))) {
      index += 4;
      return true;
    }
    if (jsonString.substring(index, index + 5) === "false" || Allow.BOOL & allow && length - index < 5 && "false".startsWith(jsonString.substring(index))) {
      index += 5;
      return false;
    }
    if (jsonString.substring(index, index + 8) === "Infinity" || Allow.INFINITY & allow && length - index < 8 && "Infinity".startsWith(jsonString.substring(index))) {
      index += 8;
      return Infinity;
    }
    if (jsonString.substring(index, index + 9) === "-Infinity" || Allow.MINUS_INFINITY & allow && 1 < length - index && length - index < 9 && "-Infinity".startsWith(jsonString.substring(index))) {
      index += 9;
      return -Infinity;
    }
    if (jsonString.substring(index, index + 3) === "NaN" || Allow.NAN & allow && length - index < 3 && "NaN".startsWith(jsonString.substring(index))) {
      index += 3;
      return NaN;
    }
    return parseNum();
  };
  const parseStr = () => {
    const start = index;
    let escape2 = false;
    index++;
    while (index < length && (jsonString[index] !== '"' || escape2 && jsonString[index - 1] === "\\")) {
      escape2 = jsonString[index] === "\\" ? !escape2 : false;
      index++;
    }
    if (jsonString.charAt(index) == '"') {
      try {
        return JSON.parse(jsonString.substring(start, ++index - Number(escape2)));
      } catch (e) {
        throwMalformedError(String(e));
      }
    } else if (Allow.STR & allow) {
      try {
        return JSON.parse(jsonString.substring(start, index - Number(escape2)) + '"');
      } catch (e) {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("\\")) + '"');
      }
    }
    markPartialJSON("Unterminated string literal");
  };
  const parseObj = () => {
    index++;
    skipBlank();
    const obj2 = {};
    try {
      while (jsonString[index] !== "}") {
        skipBlank();
        if (index >= length && Allow.OBJ & allow)
          return obj2;
        const key = parseStr();
        skipBlank();
        index++;
        try {
          const value = parseAny();
          Object.defineProperty(obj2, key, { value, writable: true, enumerable: true, configurable: true });
        } catch (e) {
          if (Allow.OBJ & allow)
            return obj2;
          else
            throw e;
        }
        skipBlank();
        if (jsonString[index] === ",")
          index++;
      }
    } catch (e) {
      if (Allow.OBJ & allow)
        return obj2;
      else
        markPartialJSON("Expected '}' at end of object");
    }
    index++;
    return obj2;
  };
  const parseArr = () => {
    index++;
    const arr = [];
    try {
      while (jsonString[index] !== "]") {
        arr.push(parseAny());
        skipBlank();
        if (jsonString[index] === ",") {
          index++;
        }
      }
    } catch (e) {
      if (Allow.ARR & allow) {
        return arr;
      }
      markPartialJSON("Expected ']' at end of array");
    }
    index++;
    return arr;
  };
  const parseNum = () => {
    if (index === 0) {
      if (jsonString === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString);
      } catch (e) {
        if (Allow.NUM & allow) {
          try {
            if (jsonString[jsonString.length - 1] === ".")
              return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf(".")));
            return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf("e")));
          } catch (e2) {}
        }
        throwMalformedError(String(e));
      }
    }
    const start = index;
    if (jsonString[index] === "-")
      index++;
    while (jsonString[index] && !",]}".includes(jsonString[index]))
      index++;
    if (index == length && !(Allow.NUM & allow))
      markPartialJSON("Unterminated number literal");
    try {
      return JSON.parse(jsonString.substring(start, index));
    } catch (e) {
      if (jsonString.substring(start, index) === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("e")));
      } catch (e2) {
        throwMalformedError(String(e2));
      }
    }
  };
  const skipBlank = () => {
    while (index < length && ` 
\r	`.includes(jsonString[index])) {
      index++;
    }
  };
  return parseAny();
};
var partialParse = (input) => parseJSON(input, Allow.ALL ^ Allow.NUM);
// backend/node_modules/openai/lib/ChatCompletionStream.mjs
var _ChatCompletionStream_instances;
var _ChatCompletionStream_params;
var _ChatCompletionStream_choiceEventStates;
var _ChatCompletionStream_currentChatCompletionSnapshot;
var _ChatCompletionStream_beginRequest;
var _ChatCompletionStream_getChoiceEventState;
var _ChatCompletionStream_addChunk;
var _ChatCompletionStream_emitToolCallDoneEvent;
var _ChatCompletionStream_emitContentDoneEvents;
var _ChatCompletionStream_endRequest;
var _ChatCompletionStream_getAutoParseableResponseFormat;
var _ChatCompletionStream_accumulateChatCompletion;

class ChatCompletionStream extends AbstractChatCompletionRunner {
  constructor(params) {
    super();
    _ChatCompletionStream_instances.add(this);
    _ChatCompletionStream_params.set(this, undefined);
    _ChatCompletionStream_choiceEventStates.set(this, undefined);
    _ChatCompletionStream_currentChatCompletionSnapshot.set(this, undefined);
    __classPrivateFieldSet(this, _ChatCompletionStream_params, params, "f");
    __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], "f");
  }
  get currentChatCompletionSnapshot() {
    return __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
  }
  static fromReadableStream(stream) {
    const runner = new ChatCompletionStream(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createChatCompletion(client, params, options) {
    const runner = new ChatCompletionStream(params);
    runner._run(() => runner._runChatCompletion(client, { ...params, stream: true }, { ...options, headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  async _createChatCompletion(client, params, options) {
    super._createChatCompletion;
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    const stream = await client.chat.completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const chunk of stream) {
      __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError;
    }
    return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  async _fromReadableStream(readableStream, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    this._connected();
    const stream = Stream.fromReadableStream(readableStream, this.controller);
    let chatId;
    for await (const chunk of stream) {
      if (chatId && chatId !== chunk.id) {
        this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
      }
      __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
      chatId = chunk.id;
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError;
    }
    return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  [(_ChatCompletionStream_params = new WeakMap, _ChatCompletionStream_choiceEventStates = new WeakMap, _ChatCompletionStream_currentChatCompletionSnapshot = new WeakMap, _ChatCompletionStream_instances = new WeakSet, _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest() {
    if (this.ended)
      return;
    __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, "f");
  }, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState(choice) {
    let state = __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index];
    if (state) {
      return state;
    }
    state = {
      content_done: false,
      refusal_done: false,
      logprobs_content_done: false,
      logprobs_refusal_done: false,
      done_tool_calls: new Set,
      current_tool_call_index: null
    };
    __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index] = state;
    return state;
  }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk(chunk) {
    if (this.ended)
      return;
    const completion = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);
    this._emit("chunk", chunk, completion);
    for (const choice of chunk.choices) {
      const choiceSnapshot = completion.choices[choice.index];
      if (choice.delta.content != null && choiceSnapshot.message?.role === "assistant" && choiceSnapshot.message?.content) {
        this._emit("content", choice.delta.content, choiceSnapshot.message.content);
        this._emit("content.delta", {
          delta: choice.delta.content,
          snapshot: choiceSnapshot.message.content,
          parsed: choiceSnapshot.message.parsed
        });
      }
      if (choice.delta.refusal != null && choiceSnapshot.message?.role === "assistant" && choiceSnapshot.message?.refusal) {
        this._emit("refusal.delta", {
          delta: choice.delta.refusal,
          snapshot: choiceSnapshot.message.refusal
        });
      }
      if (choice.logprobs?.content != null && choiceSnapshot.message?.role === "assistant") {
        this._emit("logprobs.content.delta", {
          content: choice.logprobs?.content,
          snapshot: choiceSnapshot.logprobs?.content ?? []
        });
      }
      if (choice.logprobs?.refusal != null && choiceSnapshot.message?.role === "assistant") {
        this._emit("logprobs.refusal.delta", {
          refusal: choice.logprobs?.refusal,
          snapshot: choiceSnapshot.logprobs?.refusal ?? []
        });
      }
      const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
      if (choiceSnapshot.finish_reason) {
        __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
        if (state.current_tool_call_index != null) {
          __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
        }
      }
      for (const toolCall of choice.delta.tool_calls ?? []) {
        if (state.current_tool_call_index !== toolCall.index) {
          __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
          if (state.current_tool_call_index != null) {
            __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
          }
        }
        state.current_tool_call_index = toolCall.index;
      }
      for (const toolCallDelta of choice.delta.tool_calls ?? []) {
        const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallDelta.index];
        if (!toolCallSnapshot?.type) {
          continue;
        }
        if (toolCallSnapshot?.type === "function") {
          this._emit("tool_calls.function.arguments.delta", {
            name: toolCallSnapshot.function?.name,
            index: toolCallDelta.index,
            arguments: toolCallSnapshot.function.arguments,
            parsed_arguments: toolCallSnapshot.function.parsed_arguments,
            arguments_delta: toolCallDelta.function?.arguments ?? ""
          });
        } else {
          assertNever(toolCallSnapshot?.type);
        }
      }
    }
  }, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent(choiceSnapshot, toolCallIndex) {
    const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (state.done_tool_calls.has(toolCallIndex)) {
      return;
    }
    const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallIndex];
    if (!toolCallSnapshot) {
      throw new Error("no tool call snapshot");
    }
    if (!toolCallSnapshot.type) {
      throw new Error("tool call snapshot missing `type`");
    }
    if (toolCallSnapshot.type === "function") {
      const inputTool = __classPrivateFieldGet(this, _ChatCompletionStream_params, "f")?.tools?.find((tool) => isChatCompletionFunctionTool(tool) && tool.function.name === toolCallSnapshot.function.name);
      this._emit("tool_calls.function.arguments.done", {
        name: toolCallSnapshot.function.name,
        index: toolCallIndex,
        arguments: toolCallSnapshot.function.arguments,
        parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCallSnapshot.function.arguments) : null
      });
    } else {
      assertNever(toolCallSnapshot.type);
    }
  }, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents(choiceSnapshot) {
    const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (choiceSnapshot.message.content && !state.content_done) {
      state.content_done = true;
      const responseFormat = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);
      this._emit("content.done", {
        content: choiceSnapshot.message.content,
        parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null
      });
    }
    if (choiceSnapshot.message.refusal && !state.refusal_done) {
      state.refusal_done = true;
      this._emit("refusal.done", { refusal: choiceSnapshot.message.refusal });
    }
    if (choiceSnapshot.logprobs?.content && !state.logprobs_content_done) {
      state.logprobs_content_done = true;
      this._emit("logprobs.content.done", { content: choiceSnapshot.logprobs.content });
    }
    if (choiceSnapshot.logprobs?.refusal && !state.logprobs_refusal_done) {
      state.logprobs_refusal_done = true;
      this._emit("logprobs.refusal.done", { refusal: choiceSnapshot.logprobs.refusal });
    }
  }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, "f");
    __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], "f");
    return finalizeChatCompletion(snapshot, __classPrivateFieldGet(this, _ChatCompletionStream_params, "f"));
  }, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat() {
    const responseFormat = __classPrivateFieldGet(this, _ChatCompletionStream_params, "f")?.response_format;
    if (isAutoParsableResponseFormat(responseFormat)) {
      return responseFormat;
    }
    return null;
  }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion(chunk) {
    var _a, _b, _c, _d;
    let snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    const { choices, ...rest } = chunk;
    if (!snapshot) {
      snapshot = __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, {
        ...rest,
        choices: []
      }, "f");
    } else {
      Object.assign(snapshot, rest);
    }
    for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices) {
      let choice = snapshot.choices[index];
      if (!choice) {
        choice = snapshot.choices[index] = { finish_reason, index, message: {}, logprobs, ...other };
      }
      if (logprobs) {
        if (!choice.logprobs) {
          choice.logprobs = Object.assign({}, logprobs);
        } else {
          const { content: content2, refusal: refusal2, ...rest3 } = logprobs;
          assertIsEmpty(rest3);
          Object.assign(choice.logprobs, rest3);
          if (content2) {
            (_a = choice.logprobs).content ?? (_a.content = []);
            choice.logprobs.content.push(...content2);
          }
          if (refusal2) {
            (_b = choice.logprobs).refusal ?? (_b.refusal = []);
            choice.logprobs.refusal.push(...refusal2);
          }
        }
      }
      if (finish_reason) {
        choice.finish_reason = finish_reason;
        if (__classPrivateFieldGet(this, _ChatCompletionStream_params, "f") && hasAutoParseableInput(__classPrivateFieldGet(this, _ChatCompletionStream_params, "f"))) {
          if (finish_reason === "length") {
            throw new LengthFinishReasonError;
          }
          if (finish_reason === "content_filter") {
            throw new ContentFilterFinishReasonError;
          }
        }
      }
      Object.assign(choice, other);
      if (!delta)
        continue;
      const { content, refusal, function_call, role, tool_calls, ...rest2 } = delta;
      assertIsEmpty(rest2);
      Object.assign(choice.message, rest2);
      if (refusal) {
        choice.message.refusal = (choice.message.refusal || "") + refusal;
      }
      if (role)
        choice.message.role = role;
      if (function_call) {
        if (!choice.message.function_call) {
          choice.message.function_call = function_call;
        } else {
          if (function_call.name)
            choice.message.function_call.name = function_call.name;
          if (function_call.arguments) {
            (_c = choice.message.function_call).arguments ?? (_c.arguments = "");
            choice.message.function_call.arguments += function_call.arguments;
          }
        }
      }
      if (content) {
        choice.message.content = (choice.message.content || "") + content;
        if (!choice.message.refusal && __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {
          choice.message.parsed = partialParse(choice.message.content);
        }
      }
      if (tool_calls) {
        if (!choice.message.tool_calls)
          choice.message.tool_calls = [];
        for (const { index: index2, id, type, function: fn, ...rest3 } of tool_calls) {
          const tool_call = (_d = choice.message.tool_calls)[index2] ?? (_d[index2] = {});
          Object.assign(tool_call, rest3);
          if (id)
            tool_call.id = id;
          if (type)
            tool_call.type = type;
          if (fn)
            tool_call.function ?? (tool_call.function = { name: fn.name ?? "", arguments: "" });
          if (fn?.name)
            tool_call.function.name = fn.name;
          if (fn?.arguments) {
            tool_call.function.arguments += fn.arguments;
            if (shouldParseToolCall(__classPrivateFieldGet(this, _ChatCompletionStream_params, "f"), tool_call)) {
              tool_call.function.parsed_arguments = partialParse(tool_call.function.arguments);
            }
          }
        }
      }
    }
    return snapshot;
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("chunk", (chunk) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(chunk);
      } else {
        pushQueue.push(chunk);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(undefined);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: undefined, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: undefined, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: undefined, done: true };
      }
    };
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
}
function finalizeChatCompletion(snapshot, params) {
  const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;
  const completion = {
    ...rest,
    id,
    choices: choices.map(({ message, finish_reason, index, logprobs, ...choiceRest }) => {
      if (!finish_reason) {
        throw new OpenAIError(`missing finish_reason for choice ${index}`);
      }
      const { content = null, function_call, tool_calls, ...messageRest } = message;
      const role = message.role;
      if (!role) {
        throw new OpenAIError(`missing role for choice ${index}`);
      }
      if (function_call) {
        const { arguments: args, name } = function_call;
        if (args == null) {
          throw new OpenAIError(`missing function_call.arguments for choice ${index}`);
        }
        if (!name) {
          throw new OpenAIError(`missing function_call.name for choice ${index}`);
        }
        return {
          ...choiceRest,
          message: {
            content,
            function_call: { arguments: args, name },
            role,
            refusal: message.refusal ?? null
          },
          finish_reason,
          index,
          logprobs
        };
      }
      if (tool_calls) {
        return {
          ...choiceRest,
          index,
          finish_reason,
          logprobs,
          message: {
            ...messageRest,
            role,
            content,
            refusal: message.refusal ?? null,
            tool_calls: tool_calls.map((tool_call, i) => {
              const { function: fn, type, id: id2, ...toolRest } = tool_call;
              const { arguments: args, name, ...fnRest } = fn || {};
              if (id2 == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].id
${str(snapshot)}`);
              }
              if (type == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].type
${str(snapshot)}`);
              }
              if (name == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.name
${str(snapshot)}`);
              }
              if (args == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.arguments
${str(snapshot)}`);
              }
              return { ...toolRest, id: id2, type, function: { ...fnRest, name, arguments: args } };
            })
          }
        };
      }
      return {
        ...choiceRest,
        message: { ...messageRest, content, role, refusal: message.refusal ?? null },
        finish_reason,
        index,
        logprobs
      };
    }),
    created,
    model,
    object: "chat.completion",
    ...system_fingerprint ? { system_fingerprint } : {}
  };
  return maybeParseChatCompletion(completion, params);
}
function str(x) {
  return JSON.stringify(x);
}
function assertIsEmpty(obj2) {
  return;
}
function assertNever(_x) {}

// backend/node_modules/openai/lib/ChatCompletionStreamingRunner.mjs
class ChatCompletionStreamingRunner extends ChatCompletionStream {
  static fromReadableStream(stream) {
    const runner = new ChatCompletionStreamingRunner(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static runTools(client, params, options) {
    const runner = new ChatCompletionStreamingRunner(params);
    const opts = {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client, params, opts));
    return runner;
  }
}

// backend/node_modules/openai/resources/chat/completions/completions.mjs
class Completions extends APIResource {
  constructor() {
    super(...arguments);
    this.messages = new Messages(this._client);
  }
  create(body, options) {
    return this._client.post("/chat/completions", { body, ...options, stream: body.stream ?? false });
  }
  retrieve(completionID, options) {
    return this._client.get(path`/chat/completions/${completionID}`, options);
  }
  update(completionID, body, options) {
    return this._client.post(path`/chat/completions/${completionID}`, { body, ...options });
  }
  list(query = {}, options) {
    return this._client.getAPIList("/chat/completions", CursorPage, { query, ...options });
  }
  delete(completionID, options) {
    return this._client.delete(path`/chat/completions/${completionID}`, options);
  }
  parse(body, options) {
    validateInputTools(body.tools);
    return this._client.chat.completions.create(body, {
      ...options,
      headers: {
        ...options?.headers,
        "X-Stainless-Helper-Method": "chat.completions.parse"
      }
    })._thenUnwrap((completion) => parseChatCompletion(completion, body));
  }
  runTools(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runTools(this._client, body, options);
    }
    return ChatCompletionRunner.runTools(this._client, body, options);
  }
  stream(body, options) {
    return ChatCompletionStream.createChatCompletion(this._client, body, options);
  }
}
Completions.Messages = Messages;

// backend/node_modules/openai/resources/chat/chat.mjs
class Chat extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions(this._client);
  }
}
Chat.Completions = Completions;
// backend/node_modules/openai/internal/headers.mjs
var brand_privateNullableHeaders = /* @__PURE__ */ Symbol("brand.privateNullableHeaders");
function* iterateHeaders(headers) {
  if (!headers)
    return;
  if (brand_privateNullableHeaders in headers) {
    const { values, nulls } = headers;
    yield* values.entries();
    for (const name of nulls) {
      yield [name, null];
    }
    return;
  }
  let shouldClear = false;
  let iter;
  if (headers instanceof Headers) {
    iter = headers.entries();
  } else if (isReadonlyArray(headers)) {
    iter = headers;
  } else {
    shouldClear = true;
    iter = Object.entries(headers ?? {});
  }
  for (let row of iter) {
    const name = row[0];
    if (typeof name !== "string")
      throw new TypeError("expected header name to be a string");
    const values = isReadonlyArray(row[1]) ? row[1] : [row[1]];
    let didClear = false;
    for (const value of values) {
      if (value === undefined)
        continue;
      if (shouldClear && !didClear) {
        didClear = true;
        yield [name, null];
      }
      yield [name, value];
    }
  }
}
var buildHeaders = (newHeaders) => {
  const targetHeaders = new Headers;
  const nullHeaders = new Set;
  for (const headers of newHeaders) {
    const seenHeaders = new Set;
    for (const [name, value] of iterateHeaders(headers)) {
      const lowerName = name.toLowerCase();
      if (!seenHeaders.has(lowerName)) {
        targetHeaders.delete(name);
        seenHeaders.add(lowerName);
      }
      if (value === null) {
        targetHeaders.delete(name);
        nullHeaders.add(lowerName);
      } else {
        targetHeaders.append(name, value);
        nullHeaders.delete(lowerName);
      }
    }
  }
  return { [brand_privateNullableHeaders]: true, values: targetHeaders, nulls: nullHeaders };
};

// backend/node_modules/openai/resources/audio/speech.mjs
class Speech extends APIResource {
  create(body, options) {
    return this._client.post("/audio/speech", {
      body,
      ...options,
      headers: buildHeaders([{ Accept: "application/octet-stream" }, options?.headers]),
      __binaryResponse: true
    });
  }
}

// backend/node_modules/openai/resources/audio/transcriptions.mjs
class Transcriptions extends APIResource {
  create(body, options) {
    return this._client.post("/audio/transcriptions", multipartFormRequestOptions({
      body,
      ...options,
      stream: body.stream ?? false,
      __metadata: { model: body.model }
    }, this._client));
  }
}

// backend/node_modules/openai/resources/audio/translations.mjs
class Translations extends APIResource {
  create(body, options) {
    return this._client.post("/audio/translations", multipartFormRequestOptions({ body, ...options, __metadata: { model: body.model } }, this._client));
  }
}

// backend/node_modules/openai/resources/audio/audio.mjs
class Audio extends APIResource {
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions(this._client);
    this.translations = new Translations(this._client);
    this.speech = new Speech(this._client);
  }
}
Audio.Transcriptions = Transcriptions;
Audio.Translations = Translations;
Audio.Speech = Speech;
// backend/node_modules/openai/resources/batches.mjs
class Batches extends APIResource {
  create(body, options) {
    return this._client.post("/batches", { body, ...options });
  }
  retrieve(batchID, options) {
    return this._client.get(path`/batches/${batchID}`, options);
  }
  list(query = {}, options) {
    return this._client.getAPIList("/batches", CursorPage, { query, ...options });
  }
  cancel(batchID, options) {
    return this._client.post(path`/batches/${batchID}/cancel`, options);
  }
}
// backend/node_modules/openai/resources/beta/assistants.mjs
class Assistants extends APIResource {
  create(body, options) {
    return this._client.post("/assistants", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  retrieve(assistantID, options) {
    return this._client.get(path`/assistants/${assistantID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  update(assistantID, body, options) {
    return this._client.post(path`/assistants/${assistantID}`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  list(query = {}, options) {
    return this._client.getAPIList("/assistants", CursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  delete(assistantID, options) {
    return this._client.delete(path`/assistants/${assistantID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
}

// backend/node_modules/openai/resources/beta/realtime/sessions.mjs
class Sessions extends APIResource {
  create(body, options) {
    return this._client.post("/realtime/sessions", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
}

// backend/node_modules/openai/resources/beta/realtime/transcription-sessions.mjs
class TranscriptionSessions extends APIResource {
  create(body, options) {
    return this._client.post("/realtime/transcription_sessions", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
}

// backend/node_modules/openai/resources/beta/realtime/realtime.mjs
class Realtime extends APIResource {
  constructor() {
    super(...arguments);
    this.sessions = new Sessions(this._client);
    this.transcriptionSessions = new TranscriptionSessions(this._client);
  }
}
Realtime.Sessions = Sessions;
Realtime.TranscriptionSessions = TranscriptionSessions;

// backend/node_modules/openai/resources/beta/chatkit/sessions.mjs
class Sessions2 extends APIResource {
  create(body, options) {
    return this._client.post("/chatkit/sessions", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
    });
  }
  cancel(sessionID, options) {
    return this._client.post(path`/chatkit/sessions/${sessionID}/cancel`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
    });
  }
}

// backend/node_modules/openai/resources/beta/chatkit/threads.mjs
class Threads extends APIResource {
  retrieve(threadID, options) {
    return this._client.get(path`/chatkit/threads/${threadID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
    });
  }
  list(query = {}, options) {
    return this._client.getAPIList("/chatkit/threads", ConversationCursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
    });
  }
  delete(threadID, options) {
    return this._client.delete(path`/chatkit/threads/${threadID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
    });
  }
  listItems(threadID, query = {}, options) {
    return this._client.getAPIList(path`/chatkit/threads/${threadID}/items`, ConversationCursorPage, { query, ...options, headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers]) });
  }
}

// backend/node_modules/openai/resources/beta/chatkit/chatkit.mjs
class ChatKit extends APIResource {
  constructor() {
    super(...arguments);
    this.sessions = new Sessions2(this._client);
    this.threads = new Threads(this._client);
  }
}
ChatKit.Sessions = Sessions2;
ChatKit.Threads = Threads;

// backend/node_modules/openai/resources/beta/threads/messages.mjs
class Messages2 extends APIResource {
  create(threadID, body, options) {
    return this._client.post(path`/threads/${threadID}/messages`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  retrieve(messageID, params, options) {
    const { thread_id } = params;
    return this._client.get(path`/threads/${thread_id}/messages/${messageID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  update(messageID, params, options) {
    const { thread_id, ...body } = params;
    return this._client.post(path`/threads/${thread_id}/messages/${messageID}`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  list(threadID, query = {}, options) {
    return this._client.getAPIList(path`/threads/${threadID}/messages`, CursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  delete(messageID, params, options) {
    const { thread_id } = params;
    return this._client.delete(path`/threads/${thread_id}/messages/${messageID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
}

// backend/node_modules/openai/resources/beta/threads/runs/steps.mjs
class Steps extends APIResource {
  retrieve(stepID, params, options) {
    const { thread_id, run_id, ...query } = params;
    return this._client.get(path`/threads/${thread_id}/runs/${run_id}/steps/${stepID}`, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  list(runID, params, options) {
    const { thread_id, ...query } = params;
    return this._client.getAPIList(path`/threads/${thread_id}/runs/${runID}/steps`, CursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
}
// backend/node_modules/openai/internal/utils/base64.mjs
var toFloat32Array = (base64Str) => {
  if (typeof Buffer !== "undefined") {
    const buf = Buffer.from(base64Str, "base64");
    return Array.from(new Float32Array(buf.buffer, buf.byteOffset, buf.length / Float32Array.BYTES_PER_ELEMENT));
  } else {
    const binaryStr = atob(base64Str);
    const len = binaryStr.length;
    const bytes = new Uint8Array(len);
    for (let i = 0;i < len; i++) {
      bytes[i] = binaryStr.charCodeAt(i);
    }
    return Array.from(new Float32Array(bytes.buffer));
  }
};
// backend/node_modules/openai/internal/utils/env.mjs
var readEnv = (env) => {
  if (typeof globalThis.process !== "undefined") {
    return globalThis.process.env?.[env]?.trim() ?? undefined;
  }
  if (typeof globalThis.Deno !== "undefined") {
    return globalThis.Deno.env?.get?.(env)?.trim();
  }
  return;
};
// backend/node_modules/openai/lib/AssistantStream.mjs
var _AssistantStream_instances;
var _a;
var _AssistantStream_events;
var _AssistantStream_runStepSnapshots;
var _AssistantStream_messageSnapshots;
var _AssistantStream_messageSnapshot;
var _AssistantStream_finalRun;
var _AssistantStream_currentContentIndex;
var _AssistantStream_currentContent;
var _AssistantStream_currentToolCallIndex;
var _AssistantStream_currentToolCall;
var _AssistantStream_currentEvent;
var _AssistantStream_currentRunSnapshot;
var _AssistantStream_currentRunStepSnapshot;
var _AssistantStream_addEvent;
var _AssistantStream_endRequest;
var _AssistantStream_handleMessage;
var _AssistantStream_handleRunStep;
var _AssistantStream_handleEvent;
var _AssistantStream_accumulateRunStep;
var _AssistantStream_accumulateMessage;
var _AssistantStream_accumulateContent;
var _AssistantStream_handleRun;

class AssistantStream extends EventStream {
  constructor() {
    super(...arguments);
    _AssistantStream_instances.add(this);
    _AssistantStream_events.set(this, []);
    _AssistantStream_runStepSnapshots.set(this, {});
    _AssistantStream_messageSnapshots.set(this, {});
    _AssistantStream_messageSnapshot.set(this, undefined);
    _AssistantStream_finalRun.set(this, undefined);
    _AssistantStream_currentContentIndex.set(this, undefined);
    _AssistantStream_currentContent.set(this, undefined);
    _AssistantStream_currentToolCallIndex.set(this, undefined);
    _AssistantStream_currentToolCall.set(this, undefined);
    _AssistantStream_currentEvent.set(this, undefined);
    _AssistantStream_currentRunSnapshot.set(this, undefined);
    _AssistantStream_currentRunStepSnapshot.set(this, undefined);
  }
  [(_AssistantStream_events = new WeakMap, _AssistantStream_runStepSnapshots = new WeakMap, _AssistantStream_messageSnapshots = new WeakMap, _AssistantStream_messageSnapshot = new WeakMap, _AssistantStream_finalRun = new WeakMap, _AssistantStream_currentContentIndex = new WeakMap, _AssistantStream_currentContent = new WeakMap, _AssistantStream_currentToolCallIndex = new WeakMap, _AssistantStream_currentToolCall = new WeakMap, _AssistantStream_currentEvent = new WeakMap, _AssistantStream_currentRunSnapshot = new WeakMap, _AssistantStream_currentRunStepSnapshot = new WeakMap, _AssistantStream_instances = new WeakSet, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("event", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(undefined);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: undefined, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: undefined, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: undefined, done: true };
      }
    };
  }
  static fromReadableStream(stream) {
    const runner = new _a;
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  async _fromReadableStream(readableStream, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    this._connected();
    const stream = Stream.fromReadableStream(readableStream, this.controller);
    for await (const event of stream) {
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError;
    }
    return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
  static createToolAssistantStream(runId, runs, params, options) {
    const runner = new _a;
    runner._run(() => runner._runToolAssistantStream(runId, runs, params, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  async _createToolAssistantStream(run, runId, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run.submitToolOutputs(runId, body, {
      ...options,
      signal: this.controller.signal
    });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError;
    }
    return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static createThreadAssistantStream(params, thread, options) {
    const runner = new _a;
    runner._run(() => runner._threadAssistantStream(params, thread, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  static createAssistantStream(threadId, runs, params, options) {
    const runner = new _a;
    runner._run(() => runner._runAssistantStream(threadId, runs, params, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  currentEvent() {
    return __classPrivateFieldGet(this, _AssistantStream_currentEvent, "f");
  }
  currentRun() {
    return __classPrivateFieldGet(this, _AssistantStream_currentRunSnapshot, "f");
  }
  currentMessageSnapshot() {
    return __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f");
  }
  currentRunStepSnapshot() {
    return __classPrivateFieldGet(this, _AssistantStream_currentRunStepSnapshot, "f");
  }
  async finalRunSteps() {
    await this.done();
    return Object.values(__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f"));
  }
  async finalMessages() {
    await this.done();
    return Object.values(__classPrivateFieldGet(this, _AssistantStream_messageSnapshots, "f"));
  }
  async finalRun() {
    await this.done();
    if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, "f"))
      throw Error("Final run was not received.");
    return __classPrivateFieldGet(this, _AssistantStream_finalRun, "f");
  }
  async _createThreadAssistantStream(thread, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await thread.createAndRun(body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError;
    }
    return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  async _createAssistantStream(run, threadId, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run.create(threadId, body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError;
    }
    return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static accumulateDelta(acc, delta) {
    for (const [key, deltaValue] of Object.entries(delta)) {
      if (!acc.hasOwnProperty(key)) {
        acc[key] = deltaValue;
        continue;
      }
      let accValue = acc[key];
      if (accValue === null || accValue === undefined) {
        acc[key] = deltaValue;
        continue;
      }
      if (key === "index" || key === "type") {
        acc[key] = deltaValue;
        continue;
      }
      if (typeof accValue === "string" && typeof deltaValue === "string") {
        accValue += deltaValue;
      } else if (typeof accValue === "number" && typeof deltaValue === "number") {
        accValue += deltaValue;
      } else if (isObj(accValue) && isObj(deltaValue)) {
        accValue = this.accumulateDelta(accValue, deltaValue);
      } else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {
        if (accValue.every((x) => typeof x === "string" || typeof x === "number")) {
          accValue.push(...deltaValue);
          continue;
        }
        for (const deltaEntry of deltaValue) {
          if (!isObj(deltaEntry)) {
            throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);
          }
          const index = deltaEntry["index"];
          if (index == null) {
            console.error(deltaEntry);
            throw new Error("Expected array delta entry to have an `index` property");
          }
          if (typeof index !== "number") {
            throw new Error(`Expected array delta entry \`index\` property to be a number but got ${index}`);
          }
          const accEntry = accValue[index];
          if (accEntry == null) {
            accValue.push(deltaEntry);
          } else {
            accValue[index] = this.accumulateDelta(accEntry, deltaEntry);
          }
        }
        continue;
      } else {
        throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);
      }
      acc[key] = accValue;
    }
    return acc;
  }
  _addRun(run) {
    return run;
  }
  async _threadAssistantStream(params, thread, options) {
    return await this._createThreadAssistantStream(thread, params, options);
  }
  async _runAssistantStream(threadId, runs, params, options) {
    return await this._createAssistantStream(runs, threadId, params, options);
  }
  async _runToolAssistantStream(runId, runs, params, options) {
    return await this._createToolAssistantStream(runs, runId, params, options);
  }
}
_a = AssistantStream, _AssistantStream_addEvent = function _AssistantStream_addEvent2(event) {
  if (this.ended)
    return;
  __classPrivateFieldSet(this, _AssistantStream_currentEvent, event, "f");
  __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleEvent).call(this, event);
  switch (event.event) {
    case "thread.created":
      break;
    case "thread.run.created":
    case "thread.run.queued":
    case "thread.run.in_progress":
    case "thread.run.requires_action":
    case "thread.run.completed":
    case "thread.run.incomplete":
    case "thread.run.failed":
    case "thread.run.cancelling":
    case "thread.run.cancelled":
    case "thread.run.expired":
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleRun).call(this, event);
      break;
    case "thread.run.step.created":
    case "thread.run.step.in_progress":
    case "thread.run.step.delta":
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleRunStep).call(this, event);
      break;
    case "thread.message.created":
    case "thread.message.in_progress":
    case "thread.message.delta":
    case "thread.message.completed":
    case "thread.message.incomplete":
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleMessage).call(this, event);
      break;
    case "error":
      throw new Error("Encountered an error event in event processing - errors should be processed earlier");
    default:
      assertNever2(event);
  }
}, _AssistantStream_endRequest = function _AssistantStream_endRequest2() {
  if (this.ended) {
    throw new OpenAIError(`stream has ended, this shouldn't happen`);
  }
  if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, "f"))
    throw Error("Final run has not been received");
  return __classPrivateFieldGet(this, _AssistantStream_finalRun, "f");
}, _AssistantStream_handleMessage = function _AssistantStream_handleMessage2(event) {
  const [accumulatedMessage, newContent] = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
  __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, accumulatedMessage, "f");
  __classPrivateFieldGet(this, _AssistantStream_messageSnapshots, "f")[accumulatedMessage.id] = accumulatedMessage;
  for (const content of newContent) {
    const snapshotContent = accumulatedMessage.content[content.index];
    if (snapshotContent?.type == "text") {
      this._emit("textCreated", snapshotContent.text);
    }
  }
  switch (event.event) {
    case "thread.message.created":
      this._emit("messageCreated", event.data);
      break;
    case "thread.message.in_progress":
      break;
    case "thread.message.delta":
      this._emit("messageDelta", event.data.delta, accumulatedMessage);
      if (event.data.delta.content) {
        for (const content of event.data.delta.content) {
          if (content.type == "text" && content.text) {
            let textDelta = content.text;
            let snapshot = accumulatedMessage.content[content.index];
            if (snapshot && snapshot.type == "text") {
              this._emit("textDelta", textDelta, snapshot.text);
            } else {
              throw Error("The snapshot associated with this text delta is not text or missing");
            }
          }
          if (content.index != __classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f")) {
            if (__classPrivateFieldGet(this, _AssistantStream_currentContent, "f")) {
              switch (__classPrivateFieldGet(this, _AssistantStream_currentContent, "f").type) {
                case "text":
                  this._emit("textDone", __classPrivateFieldGet(this, _AssistantStream_currentContent, "f").text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                  break;
                case "image_file":
                  this._emit("imageFileDone", __classPrivateFieldGet(this, _AssistantStream_currentContent, "f").image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                  break;
              }
            }
            __classPrivateFieldSet(this, _AssistantStream_currentContentIndex, content.index, "f");
          }
          __classPrivateFieldSet(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index], "f");
        }
      }
      break;
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f") !== undefined) {
        const currentContent = event.data.content[__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f")];
        if (currentContent) {
          switch (currentContent.type) {
            case "image_file":
              this._emit("imageFileDone", currentContent.image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
              break;
            case "text":
              this._emit("textDone", currentContent.text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
              break;
          }
        }
      }
      if (__classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f")) {
        this._emit("messageDone", event.data);
      }
      __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, undefined, "f");
  }
}, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep2(event) {
  const accumulatedRunStep = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateRunStep).call(this, event);
  __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep, "f");
  switch (event.event) {
    case "thread.run.step.created":
      this._emit("runStepCreated", event.data);
      break;
    case "thread.run.step.delta":
      const delta = event.data.delta;
      if (delta.step_details && delta.step_details.type == "tool_calls" && delta.step_details.tool_calls && accumulatedRunStep.step_details.type == "tool_calls") {
        for (const toolCall of delta.step_details.tool_calls) {
          if (toolCall.index == __classPrivateFieldGet(this, _AssistantStream_currentToolCallIndex, "f")) {
            this._emit("toolCallDelta", toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);
          } else {
            if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
              this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
            }
            __classPrivateFieldSet(this, _AssistantStream_currentToolCallIndex, toolCall.index, "f");
            __classPrivateFieldSet(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], "f");
            if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"))
              this._emit("toolCallCreated", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
          }
        }
      }
      this._emit("runStepDelta", event.data.delta, accumulatedRunStep);
      break;
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, undefined, "f");
      const details = event.data.step_details;
      if (details.type == "tool_calls") {
        if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
          this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
          __classPrivateFieldSet(this, _AssistantStream_currentToolCall, undefined, "f");
        }
      }
      this._emit("runStepDone", event.data, accumulatedRunStep);
      break;
    case "thread.run.step.in_progress":
      break;
  }
}, _AssistantStream_handleEvent = function _AssistantStream_handleEvent2(event) {
  __classPrivateFieldGet(this, _AssistantStream_events, "f").push(event);
  this._emit("event", event);
}, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep2(event) {
  switch (event.event) {
    case "thread.run.step.created":
      __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      return event.data;
    case "thread.run.step.delta":
      let snapshot = __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
      if (!snapshot) {
        throw Error("Received a RunStepDelta before creation of a snapshot");
      }
      let data = event.data;
      if (data.delta) {
        const accumulated = _a.accumulateDelta(snapshot, data.delta);
        __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = accumulated;
      }
      return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
    case "thread.run.step.in_progress":
      __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      break;
  }
  if (__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id])
    return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
  throw new Error("No snapshot available");
}, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage2(event, snapshot) {
  let newContent = [];
  switch (event.event) {
    case "thread.message.created":
      return [event.data, newContent];
    case "thread.message.delta":
      if (!snapshot) {
        throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
      }
      let data = event.data;
      if (data.delta.content) {
        for (const contentElement of data.delta.content) {
          if (contentElement.index in snapshot.content) {
            let currentContent = snapshot.content[contentElement.index];
            snapshot.content[contentElement.index] = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);
          } else {
            snapshot.content[contentElement.index] = contentElement;
            newContent.push(contentElement);
          }
        }
      }
      return [snapshot, newContent];
    case "thread.message.in_progress":
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (snapshot) {
        return [snapshot, newContent];
      } else {
        throw Error("Received thread message event with no existing snapshot");
      }
  }
  throw Error("Tried to accumulate a non-message event");
}, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent2(contentElement, currentContent) {
  return _a.accumulateDelta(currentContent, contentElement);
}, _AssistantStream_handleRun = function _AssistantStream_handleRun2(event) {
  __classPrivateFieldSet(this, _AssistantStream_currentRunSnapshot, event.data, "f");
  switch (event.event) {
    case "thread.run.created":
      break;
    case "thread.run.queued":
      break;
    case "thread.run.in_progress":
      break;
    case "thread.run.requires_action":
    case "thread.run.cancelled":
    case "thread.run.failed":
    case "thread.run.completed":
    case "thread.run.expired":
    case "thread.run.incomplete":
      __classPrivateFieldSet(this, _AssistantStream_finalRun, event.data, "f");
      if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
        this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
        __classPrivateFieldSet(this, _AssistantStream_currentToolCall, undefined, "f");
      }
      break;
    case "thread.run.cancelling":
      break;
  }
};
function assertNever2(_x) {}

// backend/node_modules/openai/resources/beta/threads/runs/runs.mjs
class Runs extends APIResource {
  constructor() {
    super(...arguments);
    this.steps = new Steps(this._client);
  }
  create(threadID, params, options) {
    const { include, ...body } = params;
    return this._client.post(path`/threads/${threadID}/runs`, {
      query: { include },
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]),
      stream: params.stream ?? false
    });
  }
  retrieve(runID, params, options) {
    const { thread_id } = params;
    return this._client.get(path`/threads/${thread_id}/runs/${runID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  update(runID, params, options) {
    const { thread_id, ...body } = params;
    return this._client.post(path`/threads/${thread_id}/runs/${runID}`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  list(threadID, query = {}, options) {
    return this._client.getAPIList(path`/threads/${threadID}/runs`, CursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  cancel(runID, params, options) {
    const { thread_id } = params;
    return this._client.post(path`/threads/${thread_id}/runs/${runID}/cancel`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  async createAndPoll(threadId, body, options) {
    const run = await this.create(threadId, body, options);
    return await this.poll(run.id, { thread_id: threadId }, options);
  }
  createAndStream(threadId, body, options) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
  }
  async poll(runId, params, options) {
    const headers = buildHeaders([
      options?.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": options?.pollIntervalMs?.toString() ?? undefined
      }
    ]);
    while (true) {
      const { data: run, response } = await this.retrieve(runId, params, {
        ...options,
        headers: { ...options?.headers, ...headers }
      }).withResponse();
      switch (run.status) {
        case "queued":
        case "in_progress":
        case "cancelling":
          let sleepInterval = 5000;
          if (options?.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep(sleepInterval);
          break;
        case "requires_action":
        case "incomplete":
        case "cancelled":
        case "completed":
        case "failed":
        case "expired":
          return run;
      }
    }
  }
  stream(threadId, body, options) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
  }
  submitToolOutputs(runID, params, options) {
    const { thread_id, ...body } = params;
    return this._client.post(path`/threads/${thread_id}/runs/${runID}/submit_tool_outputs`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]),
      stream: params.stream ?? false
    });
  }
  async submitToolOutputsAndPoll(runId, params, options) {
    const run = await this.submitToolOutputs(runId, params, options);
    return await this.poll(run.id, params, options);
  }
  submitToolOutputsStream(runId, params, options) {
    return AssistantStream.createToolAssistantStream(runId, this._client.beta.threads.runs, params, options);
  }
}
Runs.Steps = Steps;

// backend/node_modules/openai/resources/beta/threads/threads.mjs
class Threads2 extends APIResource {
  constructor() {
    super(...arguments);
    this.runs = new Runs(this._client);
    this.messages = new Messages2(this._client);
  }
  create(body = {}, options) {
    return this._client.post("/threads", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  retrieve(threadID, options) {
    return this._client.get(path`/threads/${threadID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  update(threadID, body, options) {
    return this._client.post(path`/threads/${threadID}`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  delete(threadID, options) {
    return this._client.delete(path`/threads/${threadID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  createAndRun(body, options) {
    return this._client.post("/threads/runs", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]),
      stream: body.stream ?? false
    });
  }
  async createAndRunPoll(body, options) {
    const run = await this.createAndRun(body, options);
    return await this.runs.poll(run.id, { thread_id: run.thread_id }, options);
  }
  createAndRunStream(body, options) {
    return AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);
  }
}
Threads2.Runs = Runs;
Threads2.Messages = Messages2;

// backend/node_modules/openai/resources/beta/beta.mjs
class Beta extends APIResource {
  constructor() {
    super(...arguments);
    this.realtime = new Realtime(this._client);
    this.chatkit = new ChatKit(this._client);
    this.assistants = new Assistants(this._client);
    this.threads = new Threads2(this._client);
  }
}
Beta.Realtime = Realtime;
Beta.ChatKit = ChatKit;
Beta.Assistants = Assistants;
Beta.Threads = Threads2;
// backend/node_modules/openai/resources/completions.mjs
class Completions2 extends APIResource {
  create(body, options) {
    return this._client.post("/completions", { body, ...options, stream: body.stream ?? false });
  }
}
// backend/node_modules/openai/resources/containers/files/content.mjs
class Content extends APIResource {
  retrieve(fileID, params, options) {
    const { container_id } = params;
    return this._client.get(path`/containers/${container_id}/files/${fileID}/content`, {
      ...options,
      headers: buildHeaders([{ Accept: "application/binary" }, options?.headers]),
      __binaryResponse: true
    });
  }
}

// backend/node_modules/openai/resources/containers/files/files.mjs
class Files extends APIResource {
  constructor() {
    super(...arguments);
    this.content = new Content(this._client);
  }
  create(containerID, body, options) {
    return this._client.post(path`/containers/${containerID}/files`, multipartFormRequestOptions({ body, ...options }, this._client));
  }
  retrieve(fileID, params, options) {
    const { container_id } = params;
    return this._client.get(path`/containers/${container_id}/files/${fileID}`, options);
  }
  list(containerID, query = {}, options) {
    return this._client.getAPIList(path`/containers/${containerID}/files`, CursorPage, {
      query,
      ...options
    });
  }
  delete(fileID, params, options) {
    const { container_id } = params;
    return this._client.delete(path`/containers/${container_id}/files/${fileID}`, {
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
}
Files.Content = Content;

// backend/node_modules/openai/resources/containers/containers.mjs
class Containers extends APIResource {
  constructor() {
    super(...arguments);
    this.files = new Files(this._client);
  }
  create(body, options) {
    return this._client.post("/containers", { body, ...options });
  }
  retrieve(containerID, options) {
    return this._client.get(path`/containers/${containerID}`, options);
  }
  list(query = {}, options) {
    return this._client.getAPIList("/containers", CursorPage, { query, ...options });
  }
  delete(containerID, options) {
    return this._client.delete(path`/containers/${containerID}`, {
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
}
Containers.Files = Files;
// backend/node_modules/openai/resources/conversations/items.mjs
class Items extends APIResource {
  create(conversationID, params, options) {
    const { include, ...body } = params;
    return this._client.post(path`/conversations/${conversationID}/items`, {
      query: { include },
      body,
      ...options
    });
  }
  retrieve(itemID, params, options) {
    const { conversation_id, ...query } = params;
    return this._client.get(path`/conversations/${conversation_id}/items/${itemID}`, { query, ...options });
  }
  list(conversationID, query = {}, options) {
    return this._client.getAPIList(path`/conversations/${conversationID}/items`, ConversationCursorPage, { query, ...options });
  }
  delete(itemID, params, options) {
    const { conversation_id } = params;
    return this._client.delete(path`/conversations/${conversation_id}/items/${itemID}`, options);
  }
}

// backend/node_modules/openai/resources/conversations/conversations.mjs
class Conversations extends APIResource {
  constructor() {
    super(...arguments);
    this.items = new Items(this._client);
  }
  create(body = {}, options) {
    return this._client.post("/conversations", { body, ...options });
  }
  retrieve(conversationID, options) {
    return this._client.get(path`/conversations/${conversationID}`, options);
  }
  update(conversationID, body, options) {
    return this._client.post(path`/conversations/${conversationID}`, { body, ...options });
  }
  delete(conversationID, options) {
    return this._client.delete(path`/conversations/${conversationID}`, options);
  }
}
Conversations.Items = Items;
// backend/node_modules/openai/resources/embeddings.mjs
class Embeddings extends APIResource {
  create(body, options) {
    const hasUserProvidedEncodingFormat = !!body.encoding_format;
    let encoding_format = hasUserProvidedEncodingFormat ? body.encoding_format : "base64";
    if (hasUserProvidedEncodingFormat) {
      loggerFor(this._client).debug("embeddings/user defined encoding_format:", body.encoding_format);
    }
    const response = this._client.post("/embeddings", {
      body: {
        ...body,
        encoding_format
      },
      ...options
    });
    if (hasUserProvidedEncodingFormat) {
      return response;
    }
    loggerFor(this._client).debug("embeddings/decoding base64 embeddings from base64");
    return response._thenUnwrap((response2) => {
      if (response2 && response2.data) {
        response2.data.forEach((embeddingBase64Obj) => {
          const embeddingBase64Str = embeddingBase64Obj.embedding;
          embeddingBase64Obj.embedding = toFloat32Array(embeddingBase64Str);
        });
      }
      return response2;
    });
  }
}
// backend/node_modules/openai/resources/evals/runs/output-items.mjs
class OutputItems extends APIResource {
  retrieve(outputItemID, params, options) {
    const { eval_id, run_id } = params;
    return this._client.get(path`/evals/${eval_id}/runs/${run_id}/output_items/${outputItemID}`, options);
  }
  list(runID, params, options) {
    const { eval_id, ...query } = params;
    return this._client.getAPIList(path`/evals/${eval_id}/runs/${runID}/output_items`, CursorPage, { query, ...options });
  }
}

// backend/node_modules/openai/resources/evals/runs/runs.mjs
class Runs2 extends APIResource {
  constructor() {
    super(...arguments);
    this.outputItems = new OutputItems(this._client);
  }
  create(evalID, body, options) {
    return this._client.post(path`/evals/${evalID}/runs`, { body, ...options });
  }
  retrieve(runID, params, options) {
    const { eval_id } = params;
    return this._client.get(path`/evals/${eval_id}/runs/${runID}`, options);
  }
  list(evalID, query = {}, options) {
    return this._client.getAPIList(path`/evals/${evalID}/runs`, CursorPage, {
      query,
      ...options
    });
  }
  delete(runID, params, options) {
    const { eval_id } = params;
    return this._client.delete(path`/evals/${eval_id}/runs/${runID}`, options);
  }
  cancel(runID, params, options) {
    const { eval_id } = params;
    return this._client.post(path`/evals/${eval_id}/runs/${runID}`, options);
  }
}
Runs2.OutputItems = OutputItems;

// backend/node_modules/openai/resources/evals/evals.mjs
class Evals extends APIResource {
  constructor() {
    super(...arguments);
    this.runs = new Runs2(this._client);
  }
  create(body, options) {
    return this._client.post("/evals", { body, ...options });
  }
  retrieve(evalID, options) {
    return this._client.get(path`/evals/${evalID}`, options);
  }
  update(evalID, body, options) {
    return this._client.post(path`/evals/${evalID}`, { body, ...options });
  }
  list(query = {}, options) {
    return this._client.getAPIList("/evals", CursorPage, { query, ...options });
  }
  delete(evalID, options) {
    return this._client.delete(path`/evals/${evalID}`, options);
  }
}
Evals.Runs = Runs2;
// backend/node_modules/openai/resources/files.mjs
class Files2 extends APIResource {
  create(body, options) {
    return this._client.post("/files", multipartFormRequestOptions({ body, ...options }, this._client));
  }
  retrieve(fileID, options) {
    return this._client.get(path`/files/${fileID}`, options);
  }
  list(query = {}, options) {
    return this._client.getAPIList("/files", CursorPage, { query, ...options });
  }
  delete(fileID, options) {
    return this._client.delete(path`/files/${fileID}`, options);
  }
  content(fileID, options) {
    return this._client.get(path`/files/${fileID}/content`, {
      ...options,
      headers: buildHeaders([{ Accept: "application/binary" }, options?.headers]),
      __binaryResponse: true
    });
  }
  async waitForProcessing(id, { pollInterval = 5000, maxWait = 30 * 60 * 1000 } = {}) {
    const TERMINAL_STATES = new Set(["processed", "error", "deleted"]);
    const start = Date.now();
    let file = await this.retrieve(id);
    while (!file.status || !TERMINAL_STATES.has(file.status)) {
      await sleep(pollInterval);
      file = await this.retrieve(id);
      if (Date.now() - start > maxWait) {
        throw new APIConnectionTimeoutError({
          message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
        });
      }
    }
    return file;
  }
}
// backend/node_modules/openai/resources/fine-tuning/methods.mjs
class Methods extends APIResource {
}

// backend/node_modules/openai/resources/fine-tuning/alpha/graders.mjs
class Graders extends APIResource {
  run(body, options) {
    return this._client.post("/fine_tuning/alpha/graders/run", { body, ...options });
  }
  validate(body, options) {
    return this._client.post("/fine_tuning/alpha/graders/validate", { body, ...options });
  }
}

// backend/node_modules/openai/resources/fine-tuning/alpha/alpha.mjs
class Alpha extends APIResource {
  constructor() {
    super(...arguments);
    this.graders = new Graders(this._client);
  }
}
Alpha.Graders = Graders;

// backend/node_modules/openai/resources/fine-tuning/checkpoints/permissions.mjs
class Permissions extends APIResource {
  create(fineTunedModelCheckpoint, body, options) {
    return this._client.getAPIList(path`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, Page, { body, method: "post", ...options });
  }
  retrieve(fineTunedModelCheckpoint, query = {}, options) {
    return this._client.get(path`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, {
      query,
      ...options
    });
  }
  delete(permissionID, params, options) {
    const { fine_tuned_model_checkpoint } = params;
    return this._client.delete(path`/fine_tuning/checkpoints/${fine_tuned_model_checkpoint}/permissions/${permissionID}`, options);
  }
}

// backend/node_modules/openai/resources/fine-tuning/checkpoints/checkpoints.mjs
class Checkpoints extends APIResource {
  constructor() {
    super(...arguments);
    this.permissions = new Permissions(this._client);
  }
}
Checkpoints.Permissions = Permissions;

// backend/node_modules/openai/resources/fine-tuning/jobs/checkpoints.mjs
class Checkpoints2 extends APIResource {
  list(fineTuningJobID, query = {}, options) {
    return this._client.getAPIList(path`/fine_tuning/jobs/${fineTuningJobID}/checkpoints`, CursorPage, { query, ...options });
  }
}

// backend/node_modules/openai/resources/fine-tuning/jobs/jobs.mjs
class Jobs extends APIResource {
  constructor() {
    super(...arguments);
    this.checkpoints = new Checkpoints2(this._client);
  }
  create(body, options) {
    return this._client.post("/fine_tuning/jobs", { body, ...options });
  }
  retrieve(fineTuningJobID, options) {
    return this._client.get(path`/fine_tuning/jobs/${fineTuningJobID}`, options);
  }
  list(query = {}, options) {
    return this._client.getAPIList("/fine_tuning/jobs", CursorPage, { query, ...options });
  }
  cancel(fineTuningJobID, options) {
    return this._client.post(path`/fine_tuning/jobs/${fineTuningJobID}/cancel`, options);
  }
  listEvents(fineTuningJobID, query = {}, options) {
    return this._client.getAPIList(path`/fine_tuning/jobs/${fineTuningJobID}/events`, CursorPage, { query, ...options });
  }
  pause(fineTuningJobID, options) {
    return this._client.post(path`/fine_tuning/jobs/${fineTuningJobID}/pause`, options);
  }
  resume(fineTuningJobID, options) {
    return this._client.post(path`/fine_tuning/jobs/${fineTuningJobID}/resume`, options);
  }
}
Jobs.Checkpoints = Checkpoints2;

// backend/node_modules/openai/resources/fine-tuning/fine-tuning.mjs
class FineTuning extends APIResource {
  constructor() {
    super(...arguments);
    this.methods = new Methods(this._client);
    this.jobs = new Jobs(this._client);
    this.checkpoints = new Checkpoints(this._client);
    this.alpha = new Alpha(this._client);
  }
}
FineTuning.Methods = Methods;
FineTuning.Jobs = Jobs;
FineTuning.Checkpoints = Checkpoints;
FineTuning.Alpha = Alpha;
// backend/node_modules/openai/resources/graders/grader-models.mjs
class GraderModels extends APIResource {
}

// backend/node_modules/openai/resources/graders/graders.mjs
class Graders2 extends APIResource {
  constructor() {
    super(...arguments);
    this.graderModels = new GraderModels(this._client);
  }
}
Graders2.GraderModels = GraderModels;
// backend/node_modules/openai/resources/images.mjs
class Images extends APIResource {
  createVariation(body, options) {
    return this._client.post("/images/variations", multipartFormRequestOptions({ body, ...options }, this._client));
  }
  edit(body, options) {
    return this._client.post("/images/edits", multipartFormRequestOptions({ body, ...options, stream: body.stream ?? false }, this._client));
  }
  generate(body, options) {
    return this._client.post("/images/generations", { body, ...options, stream: body.stream ?? false });
  }
}
// backend/node_modules/openai/resources/models.mjs
class Models extends APIResource {
  retrieve(model, options) {
    return this._client.get(path`/models/${model}`, options);
  }
  list(options) {
    return this._client.getAPIList("/models", Page, options);
  }
  delete(model, options) {
    return this._client.delete(path`/models/${model}`, options);
  }
}
// backend/node_modules/openai/resources/moderations.mjs
class Moderations extends APIResource {
  create(body, options) {
    return this._client.post("/moderations", { body, ...options });
  }
}
// backend/node_modules/openai/resources/realtime/calls.mjs
class Calls extends APIResource {
  accept(callID, body, options) {
    return this._client.post(path`/realtime/calls/${callID}/accept`, {
      body,
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
  hangup(callID, options) {
    return this._client.post(path`/realtime/calls/${callID}/hangup`, {
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
  refer(callID, body, options) {
    return this._client.post(path`/realtime/calls/${callID}/refer`, {
      body,
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
  reject(callID, body = {}, options) {
    return this._client.post(path`/realtime/calls/${callID}/reject`, {
      body,
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
}

// backend/node_modules/openai/resources/realtime/client-secrets.mjs
class ClientSecrets extends APIResource {
  create(body, options) {
    return this._client.post("/realtime/client_secrets", { body, ...options });
  }
}

// backend/node_modules/openai/resources/realtime/realtime.mjs
class Realtime2 extends APIResource {
  constructor() {
    super(...arguments);
    this.clientSecrets = new ClientSecrets(this._client);
    this.calls = new Calls(this._client);
  }
}
Realtime2.ClientSecrets = ClientSecrets;
Realtime2.Calls = Calls;
// backend/node_modules/openai/lib/ResponsesParser.mjs
function maybeParseResponse(response, params) {
  if (!params || !hasAutoParseableInput2(params)) {
    return {
      ...response,
      output_parsed: null,
      output: response.output.map((item) => {
        if (item.type === "function_call") {
          return {
            ...item,
            parsed_arguments: null
          };
        }
        if (item.type === "message") {
          return {
            ...item,
            content: item.content.map((content) => ({
              ...content,
              parsed: null
            }))
          };
        } else {
          return item;
        }
      })
    };
  }
  return parseResponse(response, params);
}
function parseResponse(response, params) {
  const output = response.output.map((item) => {
    if (item.type === "function_call") {
      return {
        ...item,
        parsed_arguments: parseToolCall2(params, item)
      };
    }
    if (item.type === "message") {
      const content = item.content.map((content2) => {
        if (content2.type === "output_text") {
          return {
            ...content2,
            parsed: parseTextFormat(params, content2.text)
          };
        }
        return content2;
      });
      return {
        ...item,
        content
      };
    }
    return item;
  });
  const parsed = Object.assign({}, response, { output });
  if (!Object.getOwnPropertyDescriptor(response, "output_text")) {
    addOutputText(parsed);
  }
  Object.defineProperty(parsed, "output_parsed", {
    enumerable: true,
    get() {
      for (const output2 of parsed.output) {
        if (output2.type !== "message") {
          continue;
        }
        for (const content of output2.content) {
          if (content.type === "output_text" && content.parsed !== null) {
            return content.parsed;
          }
        }
      }
      return null;
    }
  });
  return parsed;
}
function parseTextFormat(params, content) {
  if (params.text?.format?.type !== "json_schema") {
    return null;
  }
  if ("$parseRaw" in params.text?.format) {
    const text_format = params.text?.format;
    return text_format.$parseRaw(content);
  }
  return JSON.parse(content);
}
function hasAutoParseableInput2(params) {
  if (isAutoParsableResponseFormat(params.text?.format)) {
    return true;
  }
  return false;
}
function isAutoParsableTool2(tool) {
  return tool?.["$brand"] === "auto-parseable-tool";
}
function getInputToolByName(input_tools, name) {
  return input_tools.find((tool) => tool.type === "function" && tool.name === name);
}
function parseToolCall2(params, toolCall) {
  const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);
  return {
    ...toolCall,
    ...toolCall,
    parsed_arguments: isAutoParsableTool2(inputTool) ? inputTool.$parseRaw(toolCall.arguments) : inputTool?.strict ? JSON.parse(toolCall.arguments) : null
  };
}
function addOutputText(rsp) {
  const texts = [];
  for (const output of rsp.output) {
    if (output.type !== "message") {
      continue;
    }
    for (const content of output.content) {
      if (content.type === "output_text") {
        texts.push(content.text);
      }
    }
  }
  rsp.output_text = texts.join("");
}

// backend/node_modules/openai/lib/responses/ResponseStream.mjs
var _ResponseStream_instances;
var _ResponseStream_params;
var _ResponseStream_currentResponseSnapshot;
var _ResponseStream_finalResponse;
var _ResponseStream_beginRequest;
var _ResponseStream_addEvent;
var _ResponseStream_endRequest;
var _ResponseStream_accumulateResponse;

class ResponseStream extends EventStream {
  constructor(params) {
    super();
    _ResponseStream_instances.add(this);
    _ResponseStream_params.set(this, undefined);
    _ResponseStream_currentResponseSnapshot.set(this, undefined);
    _ResponseStream_finalResponse.set(this, undefined);
    __classPrivateFieldSet(this, _ResponseStream_params, params, "f");
  }
  static createResponse(client, params, options) {
    const runner = new ResponseStream(params);
    runner._run(() => runner._createOrRetrieveResponse(client, params, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  async _createOrRetrieveResponse(client, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_beginRequest).call(this);
    let stream;
    let starting_after = null;
    if ("response_id" in params) {
      stream = await client.responses.retrieve(params.response_id, { stream: true }, { ...options, signal: this.controller.signal, stream: true });
      starting_after = params.starting_after ?? null;
    } else {
      stream = await client.responses.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
    }
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_addEvent).call(this, event, starting_after);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError;
    }
    return __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_endRequest).call(this);
  }
  [(_ResponseStream_params = new WeakMap, _ResponseStream_currentResponseSnapshot = new WeakMap, _ResponseStream_finalResponse = new WeakMap, _ResponseStream_instances = new WeakSet, _ResponseStream_beginRequest = function _ResponseStream_beginRequest() {
    if (this.ended)
      return;
    __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, undefined, "f");
  }, _ResponseStream_addEvent = function _ResponseStream_addEvent(event, starting_after) {
    if (this.ended)
      return;
    const maybeEmit = (name, event2) => {
      if (starting_after == null || event2.sequence_number > starting_after) {
        this._emit(name, event2);
      }
    };
    const response = __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_accumulateResponse).call(this, event);
    maybeEmit("event", event);
    switch (event.type) {
      case "response.output_text.delta": {
        const output = response.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "message") {
          const content = output.content[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "output_text") {
            throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
          }
          maybeEmit("response.output_text.delta", {
            ...event,
            snapshot: content.text
          });
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const output = response.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "function_call") {
          maybeEmit("response.function_call_arguments.delta", {
            ...event,
            snapshot: output.arguments
          });
        }
        break;
      }
      default:
        maybeEmit(event.type, event);
        break;
    }
  }, _ResponseStream_endRequest = function _ResponseStream_endRequest() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any events`);
    }
    __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, undefined, "f");
    const parsedResponse = finalizeResponse(snapshot, __classPrivateFieldGet(this, _ResponseStream_params, "f"));
    __classPrivateFieldSet(this, _ResponseStream_finalResponse, parsedResponse, "f");
    return parsedResponse;
  }, _ResponseStream_accumulateResponse = function _ResponseStream_accumulateResponse(event) {
    let snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, "f");
    if (!snapshot) {
      if (event.type !== "response.created") {
        throw new OpenAIError(`When snapshot hasn't been set yet, expected 'response.created' event, got ${event.type}`);
      }
      snapshot = __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, "f");
      return snapshot;
    }
    switch (event.type) {
      case "response.output_item.added": {
        snapshot.output.push(event.item);
        break;
      }
      case "response.content_part.added": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        const type = output.type;
        const part = event.part;
        if (type === "message" && part.type !== "reasoning_text") {
          output.content.push(part);
        } else if (type === "reasoning" && part.type === "reasoning_text") {
          if (!output.content) {
            output.content = [];
          }
          output.content.push(part);
        }
        break;
      }
      case "response.output_text.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "message") {
          const content = output.content[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "output_text") {
            throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
          }
          content.text += event.delta;
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "function_call") {
          output.arguments += event.delta;
        }
        break;
      }
      case "response.reasoning_text.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "reasoning") {
          const content = output.content?.[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "reasoning_text") {
            throw new OpenAIError(`expected content to be 'reasoning_text', got ${content.type}`);
          }
          content.text += event.delta;
        }
        break;
      }
      case "response.completed": {
        __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, "f");
        break;
      }
    }
    return snapshot;
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("event", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(undefined);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: undefined, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((event2) => event2 ? { value: event2, done: false } : { value: undefined, done: true });
        }
        const event = pushQueue.shift();
        return { value: event, done: false };
      },
      return: async () => {
        this.abort();
        return { value: undefined, done: true };
      }
    };
  }
  async finalResponse() {
    await this.done();
    const response = __classPrivateFieldGet(this, _ResponseStream_finalResponse, "f");
    if (!response)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return response;
  }
}
function finalizeResponse(snapshot, params) {
  return maybeParseResponse(snapshot, params);
}

// backend/node_modules/openai/resources/responses/input-items.mjs
class InputItems extends APIResource {
  list(responseID, query = {}, options) {
    return this._client.getAPIList(path`/responses/${responseID}/input_items`, CursorPage, { query, ...options });
  }
}

// backend/node_modules/openai/resources/responses/input-tokens.mjs
class InputTokens extends APIResource {
  count(body = {}, options) {
    return this._client.post("/responses/input_tokens", { body, ...options });
  }
}

// backend/node_modules/openai/resources/responses/responses.mjs
class Responses extends APIResource {
  constructor() {
    super(...arguments);
    this.inputItems = new InputItems(this._client);
    this.inputTokens = new InputTokens(this._client);
  }
  create(body, options) {
    return this._client.post("/responses", { body, ...options, stream: body.stream ?? false })._thenUnwrap((rsp) => {
      if ("object" in rsp && rsp.object === "response") {
        addOutputText(rsp);
      }
      return rsp;
    });
  }
  retrieve(responseID, query = {}, options) {
    return this._client.get(path`/responses/${responseID}`, {
      query,
      ...options,
      stream: query?.stream ?? false
    })._thenUnwrap((rsp) => {
      if ("object" in rsp && rsp.object === "response") {
        addOutputText(rsp);
      }
      return rsp;
    });
  }
  delete(responseID, options) {
    return this._client.delete(path`/responses/${responseID}`, {
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options?.headers])
    });
  }
  parse(body, options) {
    return this._client.responses.create(body, options)._thenUnwrap((response) => parseResponse(response, body));
  }
  stream(body, options) {
    return ResponseStream.createResponse(this._client, body, options);
  }
  cancel(responseID, options) {
    return this._client.post(path`/responses/${responseID}/cancel`, options);
  }
}
Responses.InputItems = InputItems;
Responses.InputTokens = InputTokens;
// backend/node_modules/openai/resources/uploads/parts.mjs
class Parts extends APIResource {
  create(uploadID, body, options) {
    return this._client.post(path`/uploads/${uploadID}/parts`, multipartFormRequestOptions({ body, ...options }, this._client));
  }
}

// backend/node_modules/openai/resources/uploads/uploads.mjs
class Uploads extends APIResource {
  constructor() {
    super(...arguments);
    this.parts = new Parts(this._client);
  }
  create(body, options) {
    return this._client.post("/uploads", { body, ...options });
  }
  cancel(uploadID, options) {
    return this._client.post(path`/uploads/${uploadID}/cancel`, options);
  }
  complete(uploadID, body, options) {
    return this._client.post(path`/uploads/${uploadID}/complete`, { body, ...options });
  }
}
Uploads.Parts = Parts;
// backend/node_modules/openai/lib/Util.mjs
var allSettledWithThrow = async (promises) => {
  const results = await Promise.allSettled(promises);
  const rejected = results.filter((result) => result.status === "rejected");
  if (rejected.length) {
    for (const result of rejected) {
      console.error(result.reason);
    }
    throw new Error(`${rejected.length} promise(s) failed - see the above errors`);
  }
  const values2 = [];
  for (const result of results) {
    if (result.status === "fulfilled") {
      values2.push(result.value);
    }
  }
  return values2;
};

// backend/node_modules/openai/resources/vector-stores/file-batches.mjs
class FileBatches extends APIResource {
  create(vectorStoreID, body, options) {
    return this._client.post(path`/vector_stores/${vectorStoreID}/file_batches`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  retrieve(batchID, params, options) {
    const { vector_store_id } = params;
    return this._client.get(path`/vector_stores/${vector_store_id}/file_batches/${batchID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  cancel(batchID, params, options) {
    const { vector_store_id } = params;
    return this._client.post(path`/vector_stores/${vector_store_id}/file_batches/${batchID}/cancel`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  async createAndPoll(vectorStoreId, body, options) {
    const batch = await this.create(vectorStoreId, body);
    return await this.poll(vectorStoreId, batch.id, options);
  }
  listFiles(batchID, params, options) {
    const { vector_store_id, ...query } = params;
    return this._client.getAPIList(path`/vector_stores/${vector_store_id}/file_batches/${batchID}/files`, CursorPage, { query, ...options, headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]) });
  }
  async poll(vectorStoreID, batchID, options) {
    const headers = buildHeaders([
      options?.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": options?.pollIntervalMs?.toString() ?? undefined
      }
    ]);
    while (true) {
      const { data: batch, response } = await this.retrieve(batchID, { vector_store_id: vectorStoreID }, {
        ...options,
        headers
      }).withResponse();
      switch (batch.status) {
        case "in_progress":
          let sleepInterval = 5000;
          if (options?.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep(sleepInterval);
          break;
        case "failed":
        case "cancelled":
        case "completed":
          return batch;
      }
    }
  }
  async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options) {
    if (files == null || files.length == 0) {
      throw new Error(`No \`files\` provided to process. If you've already uploaded files you should use \`.createAndPoll()\` instead`);
    }
    const configuredConcurrency = options?.maxConcurrency ?? 5;
    const concurrencyLimit = Math.min(configuredConcurrency, files.length);
    const client = this._client;
    const fileIterator = files.values();
    const allFileIds = [...fileIds];
    async function processFiles(iterator) {
      for (let item of iterator) {
        const fileObj = await client.files.create({ file: item, purpose: "assistants" }, options);
        allFileIds.push(fileObj.id);
      }
    }
    const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);
    await allSettledWithThrow(workers);
    return await this.createAndPoll(vectorStoreId, {
      file_ids: allFileIds
    });
  }
}

// backend/node_modules/openai/resources/vector-stores/files.mjs
class Files3 extends APIResource {
  create(vectorStoreID, body, options) {
    return this._client.post(path`/vector_stores/${vectorStoreID}/files`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  retrieve(fileID, params, options) {
    const { vector_store_id } = params;
    return this._client.get(path`/vector_stores/${vector_store_id}/files/${fileID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  update(fileID, params, options) {
    const { vector_store_id, ...body } = params;
    return this._client.post(path`/vector_stores/${vector_store_id}/files/${fileID}`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  list(vectorStoreID, query = {}, options) {
    return this._client.getAPIList(path`/vector_stores/${vectorStoreID}/files`, CursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  delete(fileID, params, options) {
    const { vector_store_id } = params;
    return this._client.delete(path`/vector_stores/${vector_store_id}/files/${fileID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  async createAndPoll(vectorStoreId, body, options) {
    const file = await this.create(vectorStoreId, body, options);
    return await this.poll(vectorStoreId, file.id, options);
  }
  async poll(vectorStoreID, fileID, options) {
    const headers = buildHeaders([
      options?.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": options?.pollIntervalMs?.toString() ?? undefined
      }
    ]);
    while (true) {
      const fileResponse = await this.retrieve(fileID, {
        vector_store_id: vectorStoreID
      }, { ...options, headers }).withResponse();
      const file = fileResponse.data;
      switch (file.status) {
        case "in_progress":
          let sleepInterval = 5000;
          if (options?.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = fileResponse.response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep(sleepInterval);
          break;
        case "failed":
        case "completed":
          return file;
      }
    }
  }
  async upload(vectorStoreId, file, options) {
    const fileInfo = await this._client.files.create({ file, purpose: "assistants" }, options);
    return this.create(vectorStoreId, { file_id: fileInfo.id }, options);
  }
  async uploadAndPoll(vectorStoreId, file, options) {
    const fileInfo = await this.upload(vectorStoreId, file, options);
    return await this.poll(vectorStoreId, fileInfo.id, options);
  }
  content(fileID, params, options) {
    const { vector_store_id } = params;
    return this._client.getAPIList(path`/vector_stores/${vector_store_id}/files/${fileID}/content`, Page, { ...options, headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]) });
  }
}

// backend/node_modules/openai/resources/vector-stores/vector-stores.mjs
class VectorStores extends APIResource {
  constructor() {
    super(...arguments);
    this.files = new Files3(this._client);
    this.fileBatches = new FileBatches(this._client);
  }
  create(body, options) {
    return this._client.post("/vector_stores", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  retrieve(vectorStoreID, options) {
    return this._client.get(path`/vector_stores/${vectorStoreID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  update(vectorStoreID, body, options) {
    return this._client.post(path`/vector_stores/${vectorStoreID}`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  list(query = {}, options) {
    return this._client.getAPIList("/vector_stores", CursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  delete(vectorStoreID, options) {
    return this._client.delete(path`/vector_stores/${vectorStoreID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  search(vectorStoreID, body, options) {
    return this._client.getAPIList(path`/vector_stores/${vectorStoreID}/search`, Page, {
      body,
      method: "post",
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
}
VectorStores.Files = Files3;
VectorStores.FileBatches = FileBatches;
// backend/node_modules/openai/resources/videos.mjs
class Videos extends APIResource {
  create(body, options) {
    return this._client.post("/videos", maybeMultipartFormRequestOptions({ body, ...options }, this._client));
  }
  retrieve(videoID, options) {
    return this._client.get(path`/videos/${videoID}`, options);
  }
  list(query = {}, options) {
    return this._client.getAPIList("/videos", ConversationCursorPage, { query, ...options });
  }
  delete(videoID, options) {
    return this._client.delete(path`/videos/${videoID}`, options);
  }
  downloadContent(videoID, query = {}, options) {
    return this._client.get(path`/videos/${videoID}/content`, {
      query,
      ...options,
      headers: buildHeaders([{ Accept: "application/binary" }, options?.headers]),
      __binaryResponse: true
    });
  }
  remix(videoID, body, options) {
    return this._client.post(path`/videos/${videoID}/remix`, maybeMultipartFormRequestOptions({ body, ...options }, this._client));
  }
}
// backend/node_modules/openai/resources/webhooks.mjs
var _Webhooks_instances;
var _Webhooks_validateSecret;
var _Webhooks_getRequiredHeader;

class Webhooks extends APIResource {
  constructor() {
    super(...arguments);
    _Webhooks_instances.add(this);
  }
  async unwrap(payload, headers, secret = this._client.webhookSecret, tolerance = 300) {
    await this.verifySignature(payload, headers, secret, tolerance);
    return JSON.parse(payload);
  }
  async verifySignature(payload, headers, secret = this._client.webhookSecret, tolerance = 300) {
    if (typeof crypto === "undefined" || typeof crypto.subtle.importKey !== "function" || typeof crypto.subtle.verify !== "function") {
      throw new Error("Webhook signature verification is only supported when the `crypto` global is defined");
    }
    __classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_validateSecret).call(this, secret);
    const headersObj = buildHeaders([headers]).values;
    const signatureHeader = __classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-signature");
    const timestamp = __classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-timestamp");
    const webhookId = __classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-id");
    const timestampSeconds = parseInt(timestamp, 10);
    if (isNaN(timestampSeconds)) {
      throw new InvalidWebhookSignatureError("Invalid webhook timestamp format");
    }
    const nowSeconds = Math.floor(Date.now() / 1000);
    if (nowSeconds - timestampSeconds > tolerance) {
      throw new InvalidWebhookSignatureError("Webhook timestamp is too old");
    }
    if (timestampSeconds > nowSeconds + tolerance) {
      throw new InvalidWebhookSignatureError("Webhook timestamp is too new");
    }
    const signatures = signatureHeader.split(" ").map((part) => part.startsWith("v1,") ? part.substring(3) : part);
    const decodedSecret = secret.startsWith("whsec_") ? Buffer.from(secret.replace("whsec_", ""), "base64") : Buffer.from(secret, "utf-8");
    const signedPayload = webhookId ? `${webhookId}.${timestamp}.${payload}` : `${timestamp}.${payload}`;
    const key = await crypto.subtle.importKey("raw", decodedSecret, { name: "HMAC", hash: "SHA-256" }, false, ["verify"]);
    for (const signature of signatures) {
      try {
        const signatureBytes = Buffer.from(signature, "base64");
        const isValid = await crypto.subtle.verify("HMAC", key, signatureBytes, new TextEncoder().encode(signedPayload));
        if (isValid) {
          return;
        }
      } catch {
        continue;
      }
    }
    throw new InvalidWebhookSignatureError("The given webhook signature does not match the expected signature");
  }
}
_Webhooks_instances = new WeakSet, _Webhooks_validateSecret = function _Webhooks_validateSecret2(secret) {
  if (typeof secret !== "string" || secret.length === 0) {
    throw new Error(`The webhook secret must either be set using the env var, OPENAI_WEBHOOK_SECRET, on the client class, OpenAI({ webhookSecret: '123' }), or passed to this function`);
  }
}, _Webhooks_getRequiredHeader = function _Webhooks_getRequiredHeader2(headers, name) {
  if (!headers) {
    throw new Error(`Headers are required`);
  }
  const value = headers.get(name);
  if (value === null || value === undefined) {
    throw new Error(`Missing required header: ${name}`);
  }
  return value;
};
// backend/node_modules/openai/client.mjs
var _OpenAI_instances;
var _a2;
var _OpenAI_encoder;
var _OpenAI_baseURLOverridden;

class OpenAI {
  constructor({ baseURL = readEnv("OPENAI_BASE_URL"), apiKey = readEnv("OPENAI_API_KEY"), organization = readEnv("OPENAI_ORG_ID") ?? null, project = readEnv("OPENAI_PROJECT_ID") ?? null, webhookSecret = readEnv("OPENAI_WEBHOOK_SECRET") ?? null, ...opts } = {}) {
    _OpenAI_instances.add(this);
    _OpenAI_encoder.set(this, undefined);
    this.completions = new Completions2(this);
    this.chat = new Chat(this);
    this.embeddings = new Embeddings(this);
    this.files = new Files2(this);
    this.images = new Images(this);
    this.audio = new Audio(this);
    this.moderations = new Moderations(this);
    this.models = new Models(this);
    this.fineTuning = new FineTuning(this);
    this.graders = new Graders2(this);
    this.vectorStores = new VectorStores(this);
    this.webhooks = new Webhooks(this);
    this.beta = new Beta(this);
    this.batches = new Batches(this);
    this.uploads = new Uploads(this);
    this.responses = new Responses(this);
    this.realtime = new Realtime2(this);
    this.conversations = new Conversations(this);
    this.evals = new Evals(this);
    this.containers = new Containers(this);
    this.videos = new Videos(this);
    if (apiKey === undefined) {
      throw new OpenAIError("Missing credentials. Please pass an `apiKey`, or set the `OPENAI_API_KEY` environment variable.");
    }
    const options = {
      apiKey,
      organization,
      project,
      webhookSecret,
      ...opts,
      baseURL: baseURL || `https://api.openai.com/v1`
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new OpenAIError(`It looks like you're running in a browser-like environment.

This is disabled by default, as it risks exposing your secret API credentials to attackers.
If you understand the risks and have appropriate mitigations in place,
you can set the \`dangerouslyAllowBrowser\` option to \`true\`, e.g.,

new OpenAI({ apiKey, dangerouslyAllowBrowser: true });

https://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety
`);
    }
    this.baseURL = options.baseURL;
    this.timeout = options.timeout ?? _a2.DEFAULT_TIMEOUT;
    this.logger = options.logger ?? console;
    const defaultLogLevel = "warn";
    this.logLevel = defaultLogLevel;
    this.logLevel = parseLogLevel(options.logLevel, "ClientOptions.logLevel", this) ?? parseLogLevel(readEnv("OPENAI_LOG"), "process.env['OPENAI_LOG']", this) ?? defaultLogLevel;
    this.fetchOptions = options.fetchOptions;
    this.maxRetries = options.maxRetries ?? 2;
    this.fetch = options.fetch ?? getDefaultFetch();
    __classPrivateFieldSet(this, _OpenAI_encoder, FallbackEncoder, "f");
    this._options = options;
    this.apiKey = typeof apiKey === "string" ? apiKey : "Missing Key";
    this.organization = organization;
    this.project = project;
    this.webhookSecret = webhookSecret;
  }
  withOptions(options) {
    const client = new this.constructor({
      ...this._options,
      baseURL: this.baseURL,
      maxRetries: this.maxRetries,
      timeout: this.timeout,
      logger: this.logger,
      logLevel: this.logLevel,
      fetch: this.fetch,
      fetchOptions: this.fetchOptions,
      apiKey: this.apiKey,
      organization: this.organization,
      project: this.project,
      webhookSecret: this.webhookSecret,
      ...options
    });
    return client;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  validateHeaders({ values: values2, nulls }) {
    return;
  }
  async authHeaders(opts) {
    return buildHeaders([{ Authorization: `Bearer ${this.apiKey}` }]);
  }
  stringifyQuery(query) {
    return stringify(query, { arrayFormat: "brackets" });
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  makeStatusError(status, error2, message, headers) {
    return APIError.generate(status, error2, message, headers);
  }
  async _callApiKey() {
    const apiKey = this._options.apiKey;
    if (typeof apiKey !== "function")
      return false;
    let token;
    try {
      token = await apiKey();
    } catch (err) {
      if (err instanceof OpenAIError)
        throw err;
      throw new OpenAIError(`Failed to get token from 'apiKey' function: ${err.message}`, { cause: err });
    }
    if (typeof token !== "string" || !token) {
      throw new OpenAIError(`Expected 'apiKey' function argument to return a string but it returned ${token}`);
    }
    this.apiKey = token;
    return true;
  }
  buildURL(path2, query, defaultBaseURL) {
    const baseURL = !__classPrivateFieldGet(this, _OpenAI_instances, "m", _OpenAI_baseURLOverridden).call(this) && defaultBaseURL || this.baseURL;
    const url = isAbsoluteURL(path2) ? new URL(path2) : new URL(baseURL + (baseURL.endsWith("/") && path2.startsWith("/") ? path2.slice(1) : path2));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  async prepareOptions(options) {
    await this._callApiKey();
  }
  async prepareRequest(request, { url, options }) {}
  get(path2, opts) {
    return this.methodRequest("get", path2, opts);
  }
  post(path2, opts) {
    return this.methodRequest("post", path2, opts);
  }
  patch(path2, opts) {
    return this.methodRequest("patch", path2, opts);
  }
  put(path2, opts) {
    return this.methodRequest("put", path2, opts);
  }
  delete(path2, opts) {
    return this.methodRequest("delete", path2, opts);
  }
  methodRequest(method, path2, opts) {
    return this.request(Promise.resolve(opts).then((opts2) => {
      return { method, path: path2, ...opts2 };
    }));
  }
  request(options, remainingRetries = null) {
    return new APIPromise(this, this.makeRequest(options, remainingRetries, undefined));
  }
  async makeRequest(optionsInput, retriesRemaining, retryOfRequestLogID) {
    const options = await optionsInput;
    const maxRetries = options.maxRetries ?? this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url, timeout } = await this.buildRequest(options, {
      retryCount: maxRetries - retriesRemaining
    });
    await this.prepareRequest(req, { url, options });
    const requestLogID = "log_" + (Math.random() * (1 << 24) | 0).toString(16).padStart(6, "0");
    const retryLogStr = retryOfRequestLogID === undefined ? "" : `, retryOf: ${retryOfRequestLogID}`;
    const startTime = Date.now();
    loggerFor(this).debug(`[${requestLogID}] sending request`, formatRequestDetails({
      retryOfRequestLogID,
      method: options.method,
      url,
      options,
      headers: req.headers
    }));
    if (options.signal?.aborted) {
      throw new APIUserAbortError;
    }
    const controller = new AbortController;
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
    const headersTime = Date.now();
    if (response instanceof globalThis.Error) {
      const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;
      if (options.signal?.aborted) {
        throw new APIUserAbortError;
      }
      const isTimeout = isAbortError(response) || /timed? ?out/i.test(String(response) + ("cause" in response ? String(response.cause) : ""));
      if (retriesRemaining) {
        loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - ${retryMessage}`);
        loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (${retryMessage})`, formatRequestDetails({
          retryOfRequestLogID,
          url,
          durationMs: headersTime - startTime,
          message: response.message
        }));
        return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID);
      }
      loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - error; no more retries left`);
      loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (error; no more retries left)`, formatRequestDetails({
        retryOfRequestLogID,
        url,
        durationMs: headersTime - startTime,
        message: response.message
      }));
      if (isTimeout) {
        throw new APIConnectionTimeoutError;
      }
      throw new APIConnectionError({ cause: response });
    }
    const specialHeaders = [...response.headers.entries()].filter(([name]) => name === "x-request-id").map(([name, value]) => ", " + name + ": " + JSON.stringify(value)).join("");
    const responseInfo = `[${requestLogID}${retryLogStr}${specialHeaders}] ${req.method} ${url} ${response.ok ? "succeeded" : "failed"} with status ${response.status} in ${headersTime - startTime}ms`;
    if (!response.ok) {
      const shouldRetry = await this.shouldRetry(response);
      if (retriesRemaining && shouldRetry) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        await CancelReadableStream(response.body);
        loggerFor(this).info(`${responseInfo} - ${retryMessage2}`);
        loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage2})`, formatRequestDetails({
          retryOfRequestLogID,
          url: response.url,
          status: response.status,
          headers: response.headers,
          durationMs: headersTime - startTime
        }));
        return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID, response.headers);
      }
      const retryMessage = shouldRetry ? `error; no more retries left` : `error; not retryable`;
      loggerFor(this).info(`${responseInfo} - ${retryMessage}`);
      const errText = await response.text().catch((err2) => castToError(err2).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? undefined : errText;
      loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage})`, formatRequestDetails({
        retryOfRequestLogID,
        url: response.url,
        status: response.status,
        headers: response.headers,
        message: errMessage,
        durationMs: Date.now() - startTime
      }));
      const err = this.makeStatusError(response.status, errJSON, errMessage, response.headers);
      throw err;
    }
    loggerFor(this).info(responseInfo);
    loggerFor(this).debug(`[${requestLogID}] response start`, formatRequestDetails({
      retryOfRequestLogID,
      url: response.url,
      status: response.status,
      headers: response.headers,
      durationMs: headersTime - startTime
    }));
    return { response, options, controller, requestLogID, retryOfRequestLogID, startTime };
  }
  getAPIList(path2, Page2, opts) {
    return this.requestAPIList(Page2, { method: "get", path: path2, ...opts });
  }
  requestAPIList(Page2, options) {
    const request = this.makeRequest(options, null, undefined);
    return new PagePromise(this, request, Page2);
  }
  async fetchWithTimeout(url, init, ms, controller) {
    const { signal, method, ...options } = init || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    const isReadableBody = globalThis.ReadableStream && options.body instanceof globalThis.ReadableStream || typeof options.body === "object" && options.body !== null && Symbol.asyncIterator in options.body;
    const fetchOptions = {
      signal: controller.signal,
      ...isReadableBody ? { duplex: "half" } : {},
      method: "GET",
      ...options
    };
    if (method) {
      fetchOptions.method = method.toUpperCase();
    }
    try {
      return await this.fetch.call(undefined, url, fetchOptions);
    } finally {
      clearTimeout(timeout);
    }
  }
  async shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, requestLogID, responseHeaders) {
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders?.get("retry-after-ms");
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders?.get("retry-after");
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1000;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1000)) {
      const maxRetries = options.maxRetries ?? this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1, requestLogID);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1000;
  }
  async buildRequest(inputOptions, { retryCount = 0 } = {}) {
    const options = { ...inputOptions };
    const { method, path: path2, query, defaultBaseURL } = options;
    const url = this.buildURL(path2, query, defaultBaseURL);
    if ("timeout" in options)
      validatePositiveInteger("timeout", options.timeout);
    options.timeout = options.timeout ?? this.timeout;
    const { bodyHeaders, body } = this.buildBody({ options });
    const reqHeaders = await this.buildHeaders({ options: inputOptions, method, bodyHeaders, retryCount });
    const req = {
      method,
      headers: reqHeaders,
      ...options.signal && { signal: options.signal },
      ...globalThis.ReadableStream && body instanceof globalThis.ReadableStream && { duplex: "half" },
      ...body && { body },
      ...this.fetchOptions ?? {},
      ...options.fetchOptions ?? {}
    };
    return { req, url, timeout: options.timeout };
  }
  async buildHeaders({ options, method, bodyHeaders, retryCount }) {
    let idempotencyHeaders = {};
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      idempotencyHeaders[this.idempotencyHeader] = options.idempotencyKey;
    }
    const headers = buildHeaders([
      idempotencyHeaders,
      {
        Accept: "application/json",
        "User-Agent": this.getUserAgent(),
        "X-Stainless-Retry-Count": String(retryCount),
        ...options.timeout ? { "X-Stainless-Timeout": String(Math.trunc(options.timeout / 1000)) } : {},
        ...getPlatformHeaders(),
        "OpenAI-Organization": this.organization,
        "OpenAI-Project": this.project
      },
      await this.authHeaders(options),
      this._options.defaultHeaders,
      bodyHeaders,
      options.headers
    ]);
    this.validateHeaders(headers);
    return headers.values;
  }
  buildBody({ options: { body, headers: rawHeaders } }) {
    if (!body) {
      return { bodyHeaders: undefined, body: undefined };
    }
    const headers = buildHeaders([rawHeaders]);
    if (ArrayBuffer.isView(body) || body instanceof ArrayBuffer || body instanceof DataView || typeof body === "string" && headers.values.has("content-type") || globalThis.Blob && body instanceof globalThis.Blob || body instanceof FormData || body instanceof URLSearchParams || globalThis.ReadableStream && body instanceof globalThis.ReadableStream) {
      return { bodyHeaders: undefined, body };
    } else if (typeof body === "object" && ((Symbol.asyncIterator in body) || (Symbol.iterator in body) && ("next" in body) && typeof body.next === "function")) {
      return { bodyHeaders: undefined, body: ReadableStreamFrom(body) };
    } else {
      return __classPrivateFieldGet(this, _OpenAI_encoder, "f").call(this, { body, headers });
    }
  }
}
_a2 = OpenAI, _OpenAI_encoder = new WeakMap, _OpenAI_instances = new WeakSet, _OpenAI_baseURLOverridden = function _OpenAI_baseURLOverridden2() {
  return this.baseURL !== "https://api.openai.com/v1";
};
OpenAI.OpenAI = _a2;
OpenAI.DEFAULT_TIMEOUT = 600000;
OpenAI.OpenAIError = OpenAIError;
OpenAI.APIError = APIError;
OpenAI.APIConnectionError = APIConnectionError;
OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
OpenAI.APIUserAbortError = APIUserAbortError;
OpenAI.NotFoundError = NotFoundError;
OpenAI.ConflictError = ConflictError;
OpenAI.RateLimitError = RateLimitError;
OpenAI.BadRequestError = BadRequestError;
OpenAI.AuthenticationError = AuthenticationError;
OpenAI.InternalServerError = InternalServerError;
OpenAI.PermissionDeniedError = PermissionDeniedError;
OpenAI.UnprocessableEntityError = UnprocessableEntityError;
OpenAI.InvalidWebhookSignatureError = InvalidWebhookSignatureError;
OpenAI.toFile = toFile;
OpenAI.Completions = Completions2;
OpenAI.Chat = Chat;
OpenAI.Embeddings = Embeddings;
OpenAI.Files = Files2;
OpenAI.Images = Images;
OpenAI.Audio = Audio;
OpenAI.Moderations = Moderations;
OpenAI.Models = Models;
OpenAI.FineTuning = FineTuning;
OpenAI.Graders = Graders2;
OpenAI.VectorStores = VectorStores;
OpenAI.Webhooks = Webhooks;
OpenAI.Beta = Beta;
OpenAI.Batches = Batches;
OpenAI.Uploads = Uploads;
OpenAI.Responses = Responses;
OpenAI.Realtime = Realtime2;
OpenAI.Conversations = Conversations;
OpenAI.Evals = Evals;
OpenAI.Containers = Containers;
OpenAI.Videos = Videos;
// backend/node_modules/openai/azure.mjs
var _deployments_endpoints = new Set([
  "/completions",
  "/chat/completions",
  "/embeddings",
  "/audio/transcriptions",
  "/audio/translations",
  "/audio/speech",
  "/images/generations",
  "/batches",
  "/images/edits"
]);
// backend/src/kolosalai.ts
var KOLOSAL_API_KEY = process.env.KOLOSAL_API_KEY;
var USE_MOCK = process.env.USE_MOCK_AI === "true";
var client = new OpenAI({
  apiKey: KOLOSAL_API_KEY,
  baseURL: "https://api.kolosal.ai/v1"
});
if (!KOLOSAL_API_KEY || KOLOSAL_API_KEY === "your_kolosal_api_key_here") {
  console.error("  KOLOSAL_API_KEY tidak diset!");
}
console.log("\uD83D\uDD27 Kolosal AI Config:");
console.log("   Model: Llama 4 Maverick");
console.log("   API Key:", KOLOSAL_API_KEY ? " Set" : " Not set");
console.log("   Mock Mode:", USE_MOCK ? " Enabled" : " Disabled");
async function generateCopywriting(request) {
  if (USE_MOCK) {
    console.log("\uD83E\uDDEA Using MOCK mode - generating dynamic copywriting...");
    return generateDynamicMockCopywriting(request);
  }
  try {
    const prompt = buildPrompt(request);
    console.log("\uD83E\uDD16 Generating with Llama 4 Maverick...");
    const completion = await client.chat.completions.create({
      model: "Llama 4 Maverick",
      messages: [
        {
          role: "system",
          content: "Kamu adalah AI copywriter ahli yang membantu UMKM kuliner di Makassar membuat konten marketing yang menarik. Kamu bisa menulis dalam berbagai gaya bahasa termasuk bahasa Makassar."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.8,
      max_tokens: 500
    });
    console.log(" AI response received");
    const mainText = completion.choices[0].message.content?.trim() || "";
    const alternatives = await generateAlternatives(request, 3);
    return { mainText, alternatives };
  } catch (error2) {
    console.error(" Error:", error2.message);
    throw new Error(error2.message || "Gagal generate copywriting");
  }
}
function buildPrompt(request) {
  const { namaProduk, jenisKonten, gayaBahasa, tujuanKonten } = request;
  let styleInstruction = "";
  switch (gayaBahasa.toLowerCase()) {
    case "makassar halus":
      styleInstruction = 'Gunakan bahasa Makassar yang halus dan sopan dengan campuran Indonesia. Contoh: "Enak sekali mi", "Jangan lupa mampir ki ya".';
      break;
    case "daeng friendly":
      styleInstruction = 'Gunakan gaya ramah khas Makassar dengan panggilan "Daeng". Hangat dan akrab. Contoh: "Halo Daeng! Cobai mi menu baru ta".';
      break;
    case "formal":
      styleInstruction = "Gunakan bahasa Indonesia formal yang profesional dan sopan.";
      break;
    case "gen z tiktok":
      styleInstruction = 'Gunakan bahasa Gen Z yang catchy dengan emoji dan istilah viral TikTok. Contoh: "Ga nyobain? Rugi banget sih \uD83D\uDE2D".';
      break;
    default:
      styleInstruction = `Gunakan gaya bahasa ${gayaBahasa}.`;
  }
  return `Buatkan ${jenisKonten} untuk produk "${namaProduk}":

Gaya: ${styleInstruction}
Tujuan: ${tujuanKonten}

Buatkan copywriting yang menarik, sesuai gaya, cocok untuk ${jenisKonten}, singkat dan mengajak action.`;
}
async function generateAlternatives(request, count = 3) {
  try {
    const prompt = buildPrompt(request) + `

Berikan ${count} variasi berbeda. Pisahkan dengan "---".`;
    const completion = await client.chat.completions.create({
      model: "Llama 4 Maverick",
      messages: [
        { role: "system", content: "Kamu AI copywriter Makassar. Berikan variasi berbeda." },
        { role: "user", content: prompt }
      ],
      temperature: 0.9,
      max_tokens: 800
    });
    const content = completion.choices[0].message.content?.trim() || "";
    return content.split("---").map((v) => v.trim()).filter((v) => v.length > 0).slice(0, count);
  } catch (error2) {
    return [];
  }
}
function generateDynamicMockCopywriting(request) {
  const { namaProduk, jenisKonten, gayaBahasa } = request;
  const templates = getMockTemplates(gayaBahasa, jenisKonten);
  const mainTemplate = templates.main[Math.floor(Math.random() * templates.main.length)];
  const mainText = mainTemplate.replace(/{produk}/g, namaProduk);
  const alternatives = templates.alternatives.map((t) => t.replace(/{produk}/g, namaProduk));
  console.log(" Dynamic mock generated:", namaProduk, "-", gayaBahasa);
  return { mainText, alternatives };
}
function getMockTemplates(gayaBahasa, jenisKonten) {
  const style = gayaBahasa.toLowerCase();
  const type = jenisKonten.toLowerCase();
  if (style.includes("makassar")) {
    if (type === "caption" || type === "post") {
      return {
        main: [
          `Assalamualaikum Saudaraku! \uD83D\uDE4F

Enak sekali mi {produk} kami ini! Rasanya istimewa, bikin nagih terus ji. Dibuat dengan resep turun-temurun dan bahan pilihan.

Jangan lupa mampir ki ya! \uD83D\uDE0A

\uD83D\uDCCD Lokasi mudah ditemukan kok
 0821-xxxx-xxxx

#{produk}Makassar #KulinerMakassar`,
          `Salam sejahtera Saudaraku! 

{produk} kita sudah buka mi hari ini! Segar, enak, dan porsinya melimpah. Harga terjangkau, rasa tak terlupakan!

Mari singgah ki, banyak promo menarik! \uD83C\uDF89

#{produk}Enak #MakassarBanget`,
          `Selamat pagi Saudaraku! \uD83C\uDF05

Sudah coba belum {produk} istimewa kami? Bumbu meresap sempurna, tekstur mantap, bikin kenyang dan puas!

Buruan sebelum kehabisan ya! \uD83C\uDFC3

#{produk}Makassar #Recommend`
        ],
        alternatives: [
          `Hai Saudaraku! \uD83D\uDC4B

{produk} kita luar biasa. Setiap gigitan penuh kelezatan, setiap suapan bikin bahagia!

Dicoba mi, tidak mengecewakan! 

#{produk} #Yummy #Makassar`,
          `Bismillah! \uD83D\uDD4C

{produk} kami dibuat dengan penuh cinta dan kehati-hatian. Higienis, halal, dan tentunya enak parah!

Tunggu kedatangan mu ya Saudaraku! \uD83E\uDD17

#{produk}Halal #BersihSehat`,
          `Kabar gembira Saudaraku! \uD83C\uDF8A

{produk} terlaris kami hari ini masih tersedia! Rasa original khas Makassar yang autentik. Ga pake MSG, semua natural!

Pesan sekarang ji sebelum kehabisan! \uD83D\uDCF1

#{produk}Asli #Natural`,
          `Siang-siang begini cocok sekali mi makan {produk}! \uD83C\uDF72

Hangat, gurih, bikin kenyang. Sempurna untuk makan siang bersama keluarga!

Yuk mampir, tempat nya nyaman kok! \uD83C\uDFE0

#{produk}LunchTime #KeluargaBahagia`,
          `Mau berbagi cerita nih Saudaraku! \uD83D\uDCAC

{produk} kami sudah dipercaya pelanggan selama bertahun-tahun. Resep rahasia yang tak pernah berubah!

Silakan dicoba, pasti jatuh cinta! \uD83D\uDE0D

#{produk}Legendary #RahasisKeluarga`
        ]
      };
    } else if (type === "story") {
      return {
        main: [
          `*Swipe up untuk lokasi*

{produk} kita lagi ramai nih! \uD83D\uDE0D

Banyak yang bilang enak sekali mi!

Mampir ki ya! `,
          `Pagi-pagi sudah antre mi! \uD83C\uDF05

{produk} fresh hari ini!
Porsi jumbo 
Harga OK 
Rasa juara 

Yuk buruan! \uD83C\uDFC3`
        ],
        alternatives: [
          `UPDATE: Tinggal 10 porsi! 

{produk} hari ini hampir habis mi!

Siapa cepat dia dapat \uD83C\uDFC3`,
          `PROMO HARI INI! \uD83C\uDF89

Beli 2 {produk} dapat 1 gratis minuman!

Sampai jam 12 siang ya! `
        ]
      };
    }
  } else if (style.includes("daeng")) {
    if (type === "caption" || type === "post") {
      return {
        main: [
          `Halo Daeng-daeng! \uD83D\uDC4B

Ada kabar gembira! {produk} kesukaan Daeng sudah ready loh! Enak parah, bikin nagih terus! \uD83E\uDD24

Yuk mampir Daeng! Kita tunggu! \uD83C\uDFE0

#{produk}DaengKu #MakassarFoodies`,
          `Daengg, udah cobain belum {produk} terbaru ta? \uD83C\uDD95

Rasanya juara, harganya bersahabat sama kantong Daeng! \uD83D\uDCB8

Langsung meluncur aja Daeng! \uD83E\uDE91

#{produk}Mantap`
        ],
        alternatives: [
          `Good morning Daeng! 

{produk} pagi-pagi hangat nih! Cocok banget ditemani kopi atau teh favoritDaeng! 

Ayo Daeng, jangan malas-malas! Sudah buka dari jam 7 pagi loh! \uD83D\uDE01

#{produk}Pagi #SarapanDaeng`,
          `Daeng kesayangan \uD83D\uDC96

{produk} nya masih anget-anget nih! Baru keluar dari oven! \uD83D\uDD25

Ditunggu kedatangannya ya Daeng! Ada promo spesial hari ini! \uD83C\uDF89

#{produk}LunchTime #PromoSpesial`,
          `Psssttt Daeng... \uD83E\uDD2B

Mau tahu rahasia {produk} kita yang enak banget? Rahasianya adalah CINTA dan KESABARAN dalam setiap proses!

DM aja ya Daeng kalau mau order! \uD83D\uDCF1

#{produk}Rahasia #MadeWithLove`,
          `Breaking news Daeng! \uD83D\uDCE2

{produk} lagi promo buy 2 get 1 hari ini aja! Limited time offer Daeng!

Buruan sebelum nyesel! Tag teman Daeng sekarang! \uD83D\uDC65

#{produk}Promo #BOGOF`,
          `Daengg, sudah makan siang belum? \uD83E\uDD14

Kalau belum, yuk ke tempat kita! {produk} nya lezat banget, porsinya juga banyak loh!

Ada tempat duduk nyaman, WiFi gratis pula! \uD83E\uDE91\uD83D\uDCF6

#{produk}NyamanBanget #DaengFriendly`
        ]
      };
    }
  } else if (style.includes("gen z") || style.includes("tiktok")) {
    if (type === "caption" || type === "post" || type === "reel" || type === "short") {
      return {
        main: [
          `POV: Kamu lagi scrolling sambil laper parah \uD83E\uDD7A\uD83D\uDE2D

{produk} HITS BANGET SIH!! Ini tuh BUSSIN fr fr! \uD83D\uDD25

Harga? AFFORDABLE banget! No debat! \uD83D\uDC85

Yg belum nyobain, are we even friends? \uD83E\uDD28

Tag temen! \uD83D\uDC47
#{produk} #FYP #ViralTikTok`,
          ` WARNING: Jangan scroll kalau lagi diet! 

{produk} = COMFORT FOOD tingkat DEWA! \uD83E\uDD29\uD83D\uDE4F

Yang belum cobain, kalian ketinggalan ZAMAN! \uD83D\uDE24

Double tap! 
#{produk} #Viral`,
          `Tell me you're from Makassar without telling me you're from Makassar \uD83D\uDDFA\uD83D\uDE0E

Me: *shows {produk}* \uD83E\uDD24

This is THE moment! Share ke story kamu! \uD83D\uDCF1

#{produk} #MakassarVibes #Foodies`,
          `No cuz why is {produk} so GOOD?! \uD83D\uDE29\uD83D\uDCAF

Literally the best thing I've ever tasted! NO CAP! \uD83E\uDDE2\uD83D\uDE45

Go viral bestie! \uD83D\uDE80

#{produk}Obsessed #MakassarFood #Foodgasm`
        ],
        alternatives: [
          `Alexa, cariin {produk} terdekat! \uD83E\uDD16\uD83D\uDC9A

Bro sis, ini LEGEND! Ga nyobain? RUGI SEUMUR HIDUP! \uD83D\uDE2D

#{produk}Legend`,
          `Not me eating {produk} at 3AM \uD83D\uDD50\uD83D\uDE43

It's giving main character vibes \uD83D\uDC85

Comment "NEED"! \uD83D\uDCDD

#{produk}Mood`,
          `Understanding the assignment 

{produk}? CHECKED! SLAYED! DEVOURED! \uD83D\uDC51\uD83D\uDD25

Save this post NOW! \uD83D\uDD16

#{produk}Goals #Slay`,
          `The way I GASPED when I tried {produk}! \uD83D\uDE32\uD83E\uDD2F

It's giving everything! Everything! \uD83D\uDC85

Who's with me?? \uD83D\uDE4B\uD83D\uDE4B

#{produk}Moment #Stunner`,
          `This is your sign to try {produk} \uD83E\uDEA7

Seriously, I'm obsessed! It's chef's kiss \uD83D\uDC68\uD83C\uDF73\uD83D\uDC8B

Tag someone who needs this! \uD83D\uDCAC\uD83D\uDC47

#{produk}Divine #FoodieLife #MustTry`
        ]
      };
    }
  }
  return {
    main: [
      `{produk} - Cita Rasa Autentik untuk Anda

Kami dengan bangga mempersembahkan {produk} berkualitas premium yang diolah dengan resep tradisional turun-temurun. Setiap sajian menggunakan bahan pilihan terbaik dan melalui standar kebersihan yang ketat.

Nikmati pengalaman kuliner yang memorable bersama keluarga dan rekan bisnis Anda.

Reservasi: 0821-xxxx-xxxx
Alamat: Makassar, Sulawesi Selatan

#{produk} #KulinerIndonesia #HalalFood`,
      `Selamat Datang di {produk}

Menghadirkan keaslian cita rasa kuliner Nusantara dengan sentuhan modern. Kami berkomitmen untuk menyajikan hidangan berkualitas tinggi dengan pelayanan yang profesional dan ramah.

Kunjungi outlet kami atau pesan melalui layanan delivery yang tersedia.

Follow Instagram: @{produk}official
Telepon: 0821-xxxx-xxxx

#{produk} #KualitasTerjamin #PelayananProfesional`,
      `{produk} - Warisan Kuliner yang Terpercaya

Telah melayani ribuan pelanggan dengan tingkat kepuasan maksimal. Setiap hidangan dibuat fresh daily dengan standar food safety internasional.

Tersedia paket untuk berbagai kebutuhan acara Anda.

Operasional: 08.00 - 21.00 WITA
Hubungi: 0821-xxxx-xxxx

#{produk}Makassar #Terpercaya #SejaktahunLalu`,
      `Nikmati Kelezatan {produk} Premium

Diproduksi dengan teknologi modern namun tetap mempertahankan cita rasa tradisional yang autentik. Bahan baku dipilih langsung dari supplier terpercaya.

Dapatkan diskon 10% untuk pemesanan pertama!

Info & Pemesanan:
WhatsApp: 0821-xxxx-xxxx
Delivery Area: Seluruh Makassar

#{produk}Premium #Diskon #DeliveryAvailable`
    ],
    alternatives: [
      `{produk} - Pilihan Tepat untuk Setiap Momen

Menu variatif dengan cita rasa yang konsisten. Harga kompetitif tanpa mengurangi kualitas.

Fasilitas:
 Ruang ber-AC
 WiFi gratis
 Parkir luas
 Musholla

Informasi lengkap: WA 0821-xxxx-xxxx

#{produk}Recommended #FasilitasLengkap`,
      `Promo Special {produk}

Dapatkan paket hemat untuk keluarga dengan harga yang sangat terjangkau. Kualitas tetap terjaga, rasa tetap istimewa!

Paket tersedia:
 Paket Keluarga (4-6 orang)
 Paket Meeting (10 orang)
 Paket Acara (custom)

Pesan sekarang: 0821-xxxx-xxxx

#{produk}Promo #PaketHemat`,
      `{produk} Terpercaya Sejak 1990

Pengalaman lebih dari 30 tahun melayani masyarakat Makassar. Kualitas konsisten, pelayanan memuaskan.

Testimoni pelanggan:
"Rasa yang tak pernah berubah!" 
"Tempat favorit keluarga" 

Kontak: 0821-xxxx-xxxx

#{produk}LegendaryTaste #PelangganSetia`,
      `Mencari Tempat Makan Berkualitas?

{produk} adalah solusi tepat untuk Anda. Kami menyediakan berbagai pilihan menu dengan standar hygiene tinggi.

Layanan:
 Dine-in
 Take away
 Delivery
 Catering untuk acara

Reservasi & Info: 0821-xxxx-xxxx

#{produk}Service #MultiLayanan`,
      `{produk} - Experience the Difference

Perpaduan sempurna antara tradisi dan inovasi. Setiap hidangan diciptakan untuk memberikan pengalaman kuliner yang tak terlupakan.

Buka setiap hari pukul 08.00 - 22.00 WITA

Kunjungi kami di:
Jl. [Alamat], Makassar
Telp: 0821-xxxx-xxxx

#{produk}Experience #Innovation`
    ]
  };
}

// backend/src/ai-content-studio.ts
var KOLOSAL_API_KEY2 = process.env.KOLOSAL_API_KEY;
var USE_MOCK2 = process.env.USE_MOCK_AI === "true";
var client2 = new OpenAI({
  apiKey: KOLOSAL_API_KEY2,
  baseURL: "https://api.kolosal.ai/v1"
});
console.log("\uD83C\uDFA8 AI Content Studio Config:");
console.log("   Model: Llama 4 Maverick");
console.log("   API Key:", KOLOSAL_API_KEY2 ? " Set" : " Not set");
console.log("   Mock Mode:", USE_MOCK2 ? " Enabled" : " Disabled");
async function generateAIContent(request) {
  if (USE_MOCK2) {
    console.log(`\uD83E\uDDEA MOCK: Generating ${request.type}...`);
    return generateMockContent(request);
  }
  try {
    const prompt = buildPromptByType(request);
    console.log(`\uD83E\uDD16 Generating ${request.type} with Llama 4 Maverick...`);
    const completion = await client2.chat.completions.create({
      model: "Llama 4 Maverick",
      messages: [
        {
          role: "system",
          content: getSystemPrompt(request.type)
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: getTemperatureByType(request.type),
      max_tokens: 1500,
      top_p: 0.95,
      frequency_penalty: 0.3,
      presence_penalty: 0.3
    });
    const outputText = completion.choices[0].message.content?.trim() || "";
    console.log(` ${request.type} generated successfully`);
    return {
      type: request.type,
      inputText: request.inputText,
      outputText,
      metadata: request.metadata || {}
    };
  } catch (error2) {
    console.error(` Error generating ${request.type}:`, error2.message);
    throw new Error(`Gagal generate ${request.type}: ${error2.message}`);
  }
}
function getSystemPrompt(type) {
  const prompts = {
    caption: "Kamu adalah AI copywriter expert untuk UMKM kuliner Makassar. Kamu SANGAT kreatif dan selalu menghasilkan caption yang BERBEDA setiap kali. Kamu memahami psikologi konsumen lokal, tren viral TikTok/Instagram, dan budaya Makassar. Gunakan storytelling yang emotional, data lokal yang spesifik, dan call-to-action yang kuat. JANGAN gunakan template generik - setiap caption harus UNIK dan FRESH!",
    promo: "Kamu adalah AI marketing strategist dengan pengalaman 10+ tahun di UMKM kuliner. Kamu expert dalam consumer psychology, scarcity principle, social proof, dan viral marketing. Setiap promo yang kamu buat HARUS berbeda dan menggunakan strategi unik seperti: limited-time offers, bundle deals, loyalty programs, flash sales, kolaborasi influencer lokal, atau gamification. Fokus pada behavior triggers yang membuat orang ACTION sekarang!",
    branding: "Kamu adalah AI brand strategist tingkat expert yang memahami positioning strategy, brand archetype, value proposition, dan competitive differentiation. Kamu bisa menganalisis pasar Makassar, kompetitor lokal, dan cultural insights untuk menciptakan brand identity yang UNIK dan MEMORABLE. Berikan analisa mendalam dengan contoh konkrit, referensi brand sukses, dan actionable steps. Fokus pada emotional branding dan local pride!",
    planner: "Kamu adalah AI content strategist expert dengan deep understanding tentang content pillars, customer journey mapping, engagement metrics, dan platform algorithms (Instagram, TikTok, Facebook). Buat content calendar yang strategic dengan variasi format (Reels, Carousel, Story, Live), timing optimal berdasarkan behavior audience Makassar, dan content mix yang balance (educational, entertaining, promotional, UGC). Setiap plan harus include KPIs dan reasoning!",
    copywriting: "Kamu adalah AI master copywriter dengan expertise dalam persuasive writing frameworks: AIDA, PAS (Problem-Agitate-Solve), FAB (Features-Advantages-Benefits), storytelling hooks, dan neuro-linguistic programming. Kamu bisa menulis dalam bahasa Makassar autentik (bukan template), bahasa gaul Makassar Gen Z, dan formal sesuai konteks. Setiap copywriting HARUS menggunakan sensory words, social proof, dan urgency triggers yang spesifik untuk kultur lokal!",
    pricing: "Kamu adalah AI financial strategist dan pricing expert untuk UMKM. Kamu memahami: cost-plus pricing, value-based pricing, competitive pricing, psychological pricing (charm pricing, prestige pricing), dan dynamic pricing. Analisa break-even point, profit margins, price elasticity, dan positioning strategy. Berikan rekomendasi pricing dengan justifikasi detail, perbandingan kompetitor Makassar, dan strategi penetrasi pasar yang actionable!",
    reply: "Kamu adalah AI customer service excellence trainer dengan expertise dalam empathetic communication, de-escalation techniques, solution-focused responses, dan relationship building. Setiap reply harus: (1) Acknowledge perasaan customer, (2) Provide solution/info yang jelas, (3) Add personal touch khas Makassar, (4) End with positive note. Sesuaikan tone: ramah untuk inquiry, empati untuk komplain, profesional untuk bisnis. Hindari template robot - be HUMAN!",
    comment: "Kamu adalah AI data analyst expert dalam sentiment analysis, text mining, customer insights extraction, dan trend prediction. Analisa DEEP: sentiment score (1-10), emotion detection (happy/angry/sad/excited), pain points, buying intent, customer personas, dan action items. Berikan: (1) Summary ringkas, (2) Key insights dengan quote spesifik, (3) Prioritized action steps, (4) Suggested reply template, (5) Business improvement recommendations. Think like a business consultant!"
  };
  return prompts[type];
}
function buildPromptByType(request) {
  const { type, inputText, metadata } = request;
  switch (type) {
    case "caption":
      return buildCaptionPrompt(inputText, metadata);
    case "promo":
      return buildPromoPrompt(inputText, metadata);
    case "branding":
      return buildBrandingPrompt(inputText, metadata);
    case "planner":
      return buildPlannerPrompt(inputText, metadata);
    case "copywriting":
      return buildCopywritingPrompt(inputText, metadata);
    case "pricing":
      return buildPricingPrompt(inputText, metadata);
    case "reply":
      return buildReplyPrompt(inputText, metadata);
    case "comment":
      return buildCommentPrompt(inputText, metadata);
    default:
      return inputText;
  }
}
function buildCaptionPrompt(inputText, metadata) {
  const topik = metadata?.topik || inputText;
  const tone = metadata?.tone || "Santai";
  const platform = metadata?.platform || "Instagram";
  const includeHashtags = metadata?.includeHashtags !== false;
  const frameworks = [
    "Hook + Story + CTA",
    "Problem + Agitate + Solution",
    "Question + Answer + Action",
    "FOMO + Social Proof + Urgency",
    "Behind the Scenes + Value + Invitation"
  ];
  const randomFramework = frameworks[Math.floor(Math.random() * frameworks.length)];
  return `Buat caption UNIK untuk ${platform} tentang: "${topik}"

KONTEKS PENTING:
- Target: UMKM kuliner Makassar
- Tone: ${tone}
- Platform: ${platform}
- Framework: Gunakan pendekatan "${randomFramework}"

INSTRUKSI KREATIF:
1. Opening HOOK yang bikin berhenti scroll (jangan generic!)
2. Ceritakan dengan storytelling yang emotional & relatable
3. Gunakan sensory words (rasa, aroma, tekstur) yang spesifik
4. Include social proof atau testimoni singkat jika relevan
5. Closing dengan CTA yang kuat (comment/share/visit)
6. Sesuaikan bahasa dengan kultur Makassar (bisa campur lokal words)
7. ${includeHashtags ? "Tambahkan 8-12 hashtag strategi: mix populer + niche + branded" : "Tanpa hashtag"}

CONTOH VARIASI OPENING HOOKS:
- "Pagi ini kami hampir kehabisan stok..." (Scarcity)
- "Ada yang tanya kenapa ${topik} kami beda..." (Curiosity)  
- "3 tahun lalu, kami mulai dari..." (Story)
- "Pelanggan: 'Ini enak banget!'" (Social proof)

OUTPUT: Buat caption yang BENAR-BENAR BERBEDA dari biasanya!

Format:
\uD83D\uDD25 CAPTION ${platform.toUpperCase()}

[Caption siap post - 150-250 kata]

${includeHashtags ? `
\uD83D\uDCCC HASHTAGS:
[Hashtag strategy dengan reasoning]` : ""}`;
}
function buildPromoPrompt(inputText, metadata) {
  const namaProduk = metadata?.namaProduk || inputText;
  const discount = metadata?.discount || "20%";
  const targetAudience = metadata?.targetAudience || "Umum";
  const strategies = [
    "Flash Sale + Countdown Timer",
    "Buy 1 Get 1 + Limited Stock",
    "Bundle Deal + Free Shipping",
    "Loyalty Reward + Gamification",
    "Kolaborasi Influencer Lokal + Giveaway",
    "Payday Special + Cashback"
  ];
  const randomStrategy = strategies[Math.floor(Math.random() * strategies.length)];
  return `Buat KONSEP PROMO KREATIF untuk: "${namaProduk}"

BRIEF:
- Diskon/Promo: ${discount}
- Target: ${targetAudience}
- Lokasi: Makassar
- Strategi Unik: ${randomStrategy}

CHALLENGE: Buat promo yang VIRAL & MENGHASILKAN PENJUALAN!

REQUIREMENTS:
1. **JUDUL PROMO** yang bikin FOMO (Fear of Missing Out)
   - Gunakan power words: GRATIS, EKSKLUSIF, HARI INI, TERBATAS
   - Angka spesifik (Diskon 47% lebih menarik dari 50%)

2. **CAPTION PROMO** (200-300 kata) yang include:
   - Opening hook yang shocking/surprising
   - Benefit jelas untuk customer
   - Social proof (testimoni/sold out history)
   - Urgency triggers (limited time/stock)
   - Clear instructions cara ikutan promo
   - Multiple CTAs (Order/Share/Tag)

3. **STRATEGI EKSEKUSI** yang actionable:
   - Timing optimal post (hari + jam)
   - Platform prioritas (IG/FB/TikTok/WA)
   - Content format (carousel/video/story)
   - Kolaborasi potential (influencer/komunitas Makassar)

4. **PROMO MECHANICS** yang clear:
   - Syarat & ketentuan simple
   - Cara claim/redeem
   - Duration specific

5. **SUCCESS METRICS** untuk track:
   - Target sales/orders
   - Engagement expected

PENTING: Jangan buat promo generik! Sesuaikan dengan culture & behavior audience Makassar!

Format output:
\uD83D\uDCE2 KONSEP PROMO VIRAL

\uD83D\uDD25 [JUDUL PROMO]

\uD83D\uDCDD CAPTION:
[Full caption siap post]

 STRATEGI EKSEKUSI:
[Step-by-step implementation]

\uD83D\uDCCA SUCCESS METRICS:
[KPIs to track]`;
}
function buildBrandingPrompt(inputText, metadata) {
  const sloganSekarang = metadata?.sloganSekarang || "";
  const brandPersona = metadata?.brandPersona || inputText;
  const toneOfVoice = metadata?.toneOfVoice || "Makassar Friendly";
  return `Bantu analisis dan kembangkan branding untuk UMKM dengan detail:

${sloganSekarang ? `Slogan Sekarang: ${sloganSekarang}` : "Belum punya slogan"}
Brand Persona: ${brandPersona}
Tone of Voice: ${toneOfVoice}

Buatkan rekomendasi branding yang meliputi:

Format output:
\uD83C\uDFA8 HASIL ANALISA BRANDING:

 SLOGAN UNIK:
[3 pilihan slogan yang memorable dan sesuai persona]

\uD83C\uDFA8 REKOMENDASI WARNA:
[3 warna dengan kode hex dan psikologi warnanya]

\uD83D\uDCD6 STORYTELLING BRAND:
[Cerita brand yang emotional dan relatable untuk Makassar]

\uD83D\uDC64 KARAKTER BRAND PERSONA:
[Deskripsi karakter brand yang konsisten]`;
}
function buildPlannerPrompt(inputText, metadata) {
  const temaMingguan = metadata?.temaMingguan || inputText;
  const durasi = metadata?.durasi || "7";
  return `Buatkan content planner untuk social media dengan:

Tema: ${temaMingguan}
Durasi: ${durasi} hari

Buatkan jadwal konten yang:
- Seimbang antara konten edukasi, hiburan, dan promosi (80:20 ratio)
- Berdasarkan best practice posting time untuk audience Makassar
- Mencakup berbagai format (foto, video, story, carousel, reels)
- Mengikuti prinsip content marketing yang efektif

Format output:
\uD83D\uDCC5 JADWAL KONTEN (${durasi} HARI)
Tema: ${temaMingguan}

[Untuk setiap hari, tulis:]
 Hari [X] ([Format Konten]): [Judul/Ide konten singkat]
    Waktu posting terbaik: [Jam WITA]
   \uD83C\uDFAF Tujuan: [Engagement/Edukasi/Selling]

\uD83D\uDCA1 TIPS EKSEKUSI:
[Strategi tambahan untuk memaksimalkan engagement]`;
}
function buildCopywritingPrompt(inputText, metadata) {
  const namaProduk = metadata?.namaProduk || inputText;
  const jenisKonten = metadata?.jenisKonten || "Caption";
  const tujuanKonten = metadata?.tujuanKonten || "Jualan";
  const gayaBahasa = metadata?.gayaBahasa || "Makassar Halus";
  let styleInstruction = "";
  switch (gayaBahasa.toLowerCase()) {
    case "makassar halus":
      styleInstruction = 'Gunakan bahasa Makassar yang halus dan sopan dengan campuran Indonesia. Contoh: "Enak sekali mi", "Jangan lupa mampir ki ya".';
      break;
    case "daeng friendly":
      styleInstruction = 'Gunakan gaya ramah khas Makassar dengan panggilan "Daeng". Hangat dan akrab. Contoh: "Halo Daeng! Cobai mi menu baru ta".';
      break;
    case "formal":
      styleInstruction = "Gunakan bahasa Indonesia formal yang profesional dan sopan.";
      break;
    case "gen z tiktok":
      styleInstruction = 'Gunakan bahasa Gen Z yang catchy dengan emoji dan istilah viral TikTok. Contoh: "Ga nyobain? Rugi banget sih \uD83D\uDE2D".';
      break;
    default:
      styleInstruction = `Gunakan gaya bahasa ${gayaBahasa}.`;
  }
  return `Buatkan ${jenisKonten} untuk produk "${namaProduk}":

Gaya: ${styleInstruction}
Tujuan: ${tujuanKonten}

Buatkan copywriting yang:
- Menarik dan sesuai gaya
- Cocok untuk ${jenisKonten}
- Singkat, padat, dan mengajak action
- Sesuai dengan tujuan ${tujuanKonten}

Format output:
\uD83D\uDCDD COPYWRITING (Tujuan: ${tujuanKonten})

[Copywriting lengkap siap pakai dengan emoji yang sesuai]

 ALTERNATIF:
[Berikan 2 variasi berbeda dengan gaya yang sama]`;
}
function buildPricingPrompt(inputText, metadata) {
  const namaProduk = metadata?.namaProduk || inputText;
  const cost = metadata?.cost || metadata?.modalHPP || 0;
  const targetProfit = metadata?.targetProfit || metadata?.targetUntung || 30;
  const competitorPrice = metadata?.competitorPrice || metadata?.hargaKompetitor || 0;
  const methods = [
    "Cost-Plus + Psychological Pricing",
    "Value-Based + Competitive Analysis",
    "Penetration Strategy + Market Share Focus",
    "Premium Positioning + Brand Value",
    "Dynamic Pricing + Demand-Based"
  ];
  const selectedMethod = methods[Math.floor(Math.random() * methods.length)];
  return `Lakukan ANALISA PRICING STRATEGY MENDALAM untuk: "${namaProduk}"

\uD83D\uDCCA DATA FINANSIAL:
- HPP/Cost: Rp ${cost.toLocaleString("id-ID")}
- Target Profit Margin: ${targetProfit}%
${competitorPrice > 0 ? `- Harga Kompetitor: Rp ${competitorPrice.toLocaleString("id-ID")}` : "- Data kompetitor: Perlu research"}
- Market: UMKM Kuliner Makassar
- Metode Analisa: ${selectedMethod}

TUGAS ANALISA LENGKAP:

1. **KALKULASI DETAIL** (Harus accurate!)
   - Break-even price (HPP + 0% margin)
   - Cost-plus target (HPP + ${targetProfit}% margin)
   - Harga psikologis optimal (charm pricing: 9.900 vs 10.000)
   - Bundling price suggestions
   - Volume discount structure

2. **COMPETITIVE INTELLIGENCE**
   ${competitorPrice > 0 ? `
   - Gap analysis vs kompetitor (Rp ${competitorPrice.toLocaleString("id-ID")})
   - Positioning: Above/At/Below kompetitor?
   - Value differentiation yang justify price difference` : `
   - Research kompetitor Makassar serupa
   - Estimasi range harga market
   - Sweet spot positioning`}

3. **MARKET CONTEXT MAKASSAR**
   - Daya beli segmen target (mahasiswa/pekerja/keluarga)
   - Price sensitivity untuk produk ini
   - Cultural pricing (angka favorit: 8, 9, 88, 99)
   - Seasonal pricing opportunities (Ramadhan, weekends, payday)

4. **STRATEGI MAKSIMALKAN REVENUE**
   - Paket bundling (1+1, family pack, catering)
   - Upselling strategy (add-ons, premium version)
   - Cross-selling items
   - Loyalty program pricing tier
   - Early bird / happy hour pricing

5. **IMPLEMENTATION PLAN**
   - Phase 1: Launch pricing (penetration/premium?)
   - Phase 2: Regular pricing
   - Phase 3: Promotional pricing calendar
   - A/B testing suggestions (test 2-3 price points)

6. **RISK & OPPORTUNITY ANALYSIS**
   - Risk pricing terlalu tinggi
   - Risk pricing terlalu rendah (devaluasi brand)
   - Sweet spot range dengan reasoning
   - Contingency plan jika harga tidak work

Output dalam format:
\uD83D\uDCB0 PRICING STRATEGY ANALYSIS

\uD83D\uDCCA REKOMENDASI HARGA (3 Skenario):
[Berikan 3 opsi: Aggressive/Standard/Premium dengan pros-cons]

\uD83D\uDCC8 BREAKDOWN FINANSIAL:
[Tabel detail kalkulasi]

\uD83C\uDFAF POSITIONING STRATEGY:
[Strategic reasoning + competitive advantage]

\uD83D\uDE80 IMPLEMENTATION ROADMAP:
[Timeline eksekusi 3 bulan]

\uD83D\uDCA1 PRO TIPS PRICING MAKASSAR:
[Insights spesifik lokal yang actionable]`;
}
function buildReplyPrompt(inputText, metadata) {
  const pesanPelanggan = metadata?.pesanPelanggan || inputText;
  const nadaBalasan = metadata?.nadaBalasan || "Ramah & Membantu";
  return `Buatkan balasan customer service untuk pesan pelanggan berikut:

PESAN PELANGGAN:
"${pesanPelanggan}"

NADA BALASAN: ${nadaBalasan}

Buatkan balasan yang:
- Sesuai dengan nada "${nadaBalasan}"
- Empati dan solutif
- Profesional namun tetap friendly
- Mengandung action/solusi konkret
- Mempertahankan customer relationship

Format output:
\uD83D\uDCAC REKOMENDASI BALASAN:

[Balasan lengkap siap kirim dengan emoji yang sesuai]

\uD83D\uDCA1 ANALISIS SITUASI:
[Penjelasan singkat situasi dan mengapa balasan ini efektif]`;
}
function buildCommentPrompt(inputText, metadata) {
  const comment = metadata?.komentarPelanggan || inputText;
  return `Lakukan ANALISA MENDALAM terhadap komentar customer ini:

\uD83D\uDCAC KOMENTAR:
"${comment}"

TUGAS: Analisa seperti seorang BUSINESS ANALYST & CUSTOMER SUCCESS MANAGER!

ANALISA YANG HARUS DILAKUKAN:

1. **SENTIMENT ANALYSIS** (Detailed!)
   - Overall sentiment: Positif/Netral/Negatif (dengan score 1-10)
   - Emotion detected: Happy/Angry/Disappointed/Excited/Confused
   - Urgency level: Low/Medium/High/Critical
   - Customer lifecycle stage: New/Regular/Loyal/Churning

2. **DEEP INSIGHTS EXTRACTION**
   - Pain points mentioned (spesifik!)
   - Expectations vs reality gap
   - Buying intent signals
   - Recommendation likelihood
   - Competitor mentions
   - Cultural/local context (Makassar specific)

3. **KEY QUOTES & THEMES**
   - Quote 2-3 kalimat penting dari comment
   - Main themes/topics
   - Keywords yang sering muncul

4. **BUSINESS IMPLICATIONS**
   - Impact ke brand reputation (positive/negative/neutral)
   - Revenue opportunity (upsell/cross-sell potential)
   - Churn risk assessment
   - Product/service improvement insights
   - Competitive advantage/disadvantage revealed

5. **PRIORITIZED ACTION ITEMS**
   - Immediate actions (24 hours)
   - Short-term actions (1 week)
   - Long-term improvements (1 month+)
   - Who should handle this? (owner/CS/chef/marketing)

6. **RESPONSE STRATEGY**
   - Recommended tone: Empathetic/Professional/Friendly/Apologetic
   - Key points to address dalam reply
   - Do's and Don'ts
   - 2 alternative reply drafts (formal & casual Makassar style)

7. **SIMILAR PATTERN DETECTION**
   - Apakah ini one-off issue atau pattern?
   - Red flags untuk monitor
   - Opportunities untuk leverage (jika positif)

Format output:
\uD83D\uDD0D COMPREHENSIVE COMMENT ANALYSIS

\uD83D\uDCCA SENTIMENT BREAKDOWN:
[Detail scoring + reasoning]

\uD83C\uDFAF KEY INSIGHTS:
[Bullet points penting dengan quotes]

 PRIORITY ACTIONS:
[Ranked by urgency + impact]

\uD83D\uDCAC RESPONSE TEMPLATES:

**Option 1 (Formal):**
[Balasan profesional]

**Option 2 (Makassar Friendly):**
[Balasan hangat khas Makassar]

\uD83D\uDCA1 BUSINESS RECOMMENDATIONS:
[Strategic suggestions untuk prevent/leverage]`;
}
function getTemperatureByType(type) {
  const temperatures = {
    caption: 0.95,
    promo: 0.9,
    branding: 0.85,
    planner: 0.75,
    copywriting: 0.95,
    pricing: 0.7,
    reply: 0.8,
    comment: 0.75
  };
  return temperatures[type];
}
function generateMockContent(request) {
  const { type, inputText, metadata } = request;
  const mockOutputs = {
    caption: `\uD83D\uDD25 CAPTION INSTAGRAM SIAP PAKAI \uD83D\uDD25

Halo Daeng! \uD83D\uDC4B Sudah coba menu baru kami? Rasanya bikin nagih! \uD83E\uDD24
Cocok banget buat makan siang bareng teman kantor.

\uD83D\uDCCD Lokasi: Jl. Pettarani No. 10
\uD83D\uDEF5 Tersedia di GrabFood & GoFood

Yuk buruan mampir sebelum kehabisan! 

#KulinerMakassar #MakassarDagang #Ewako #CotoMakassar #JajananMakassar`,
    promo: `\uD83D\uDCE2 KONSEP PROMO SIAP POST!

\uD83D\uDD25 JUDUL PROMO: GAJIAN TIBA? WAKTUNYA MAKAN ENAK TANPA PUSING!

\uD83D\uDCDD CAPTION:
Habis gajian jangan langsung habis cika'! \uD83D\uDE02
Mending ke sini, makan kenyang hati senang.

Khusus buat Pegawai Kantor & Mahasiswa, tunjukkan ID Card kalian dan dapatkan DISKON 20% untuk semua menu Paket!

Buruan nah, cuma berlaku 3 hari! \uD83C\uDFC3\uD83D\uDCA8

 WAKTU TERBAIK POST: Pukul 11:30 WITA (sebelum jam makan siang)

\uD83D\uDCA1 TIPS TAMBAHAN: 
- Posting di story IG jam 8 pagi untuk reminder
- Share di grup WA kantor/kampus
- Buat countdown timer untuk urgency`,
    branding: `\uD83C\uDFA8 HASIL ANALISA BRANDING:

 SLOGAN UNIK:
1. "Rasa Sultan, Harga Teman - Ewako!"
2. "Dari Hati Makassar, Untuk Perut Indonesia"
3. "Authentik. Enak. Terjangkau."

\uD83C\uDFA8 REKOMENDASI WARNA:
- Merah Marun (#800000)  Berani, nafsu makan, tradisional
- Kuning Emas (#FFD700)  Mewah tapi ceria, optimis
- Hitam (#000000)  Elegan, premium, modern

\uD83D\uDCD6 STORYTELLING BRAND:
"Berawal dari resep rahasia Nenek di lorong sempit Makassar tahun 1990, kami membawa cita rasa otentik yang tidak pernah berubah. Setiap suapan adalah perjalanan ke masa lalu, ke kehangatan keluarga Makassar."

\uD83D\uDC64 KARAKTER BRAND PERSONA:
"Si Daeng yang Ramah, Humoris, tapi Sangat Menghargai Tradisi. Bicara santai tapi tahu sopan santun. Seperti tetangga yang selalu siap berbagi cerita sambil makan bersama."`,
    planner: `\uD83D\uDCC5 JADWAL KONTEN (7 HARI)
Tema: Kuliner Makassar

 Hari 1 (Video Reel): 'Behind The Scene' proses pembuatan bumbu rahasia
    Waktu posting: 18:00 WITA
   \uD83C\uDFAF Tujuan: Edukasi & Trust Building

 Hari 2 (Carousel): Repost testimoni pelanggan yang paling lucu
    Waktu posting: 12:00 WITA
   \uD83C\uDFAF Tujuan: Social Proof

 Hari 3 (Story + Post): Tebak-tebakan bahasa Makassar berhadiah voucher
    Waktu posting: 15:00 WITA
   \uD83C\uDFAF Tujuan: Engagement

 Hari 4 (Foto HD): Produk close-up yang bikin ngiler
    Waktu posting: 11:00 WITA
   \uD83C\uDFAF Tujuan: Soft Selling

 Hari 5 (Story + Post): Promo 'Jumat Berkah' diskon khusus
    Waktu posting: 08:00 WITA
   \uD83C\uDFAF Tujuan: Hard Selling

 Hari 6 (Carousel Edukasi): Tips makan Coto biar makin enak ala Daeng
    Waktu posting: 16:00 WITA
   \uD83C\uDFAF Tujuan: Value Content

 Hari 7 (Quote Card): Motivasi usaha anak muda Makassar
    Waktu posting: 09:00 WITA
   \uD83C\uDFAF Tujuan: Inspirasi & Community

\uD83D\uDCA1 TIPS EKSEKUSI:
- Gunakan Reels untuk konten edukatif (algoritma prioritas)
- Selalu reply komentar dalam 1 jam pertama
- Cross-posting ke TikTok & Facebook untuk jangkauan lebih luas`,
    copywriting: `\uD83D\uDCDD COPYWRITING (Tujuan: Jualan)

POV: Kamu nemu produk lokal yang kualitasnya impor! \uD83D\uDE31

Sumpah ini barang mantap sekali cika'. ${metadata?.namaProduk || inputText} ini solusinya buat kamu yang mau tampil beda.

Keunggulannya:
 Kualitas Premium
 Harga Terjangkau
 Asli Anak Makassar

Order sekarang sebelum kehabisan stok! Klik link di bio nah. \uD83D\uDC47

 ALTERNATIF:

VARIASI 1:
Eh Daeng! Tau nda' kalo ${metadata?.namaProduk || inputText} kita ini sudah jadi favorit pelanggan setia? \uD83D\uDD25

Rahasianya? Simple ji:
- Bahan berkualitas
- Harga bersahabat
- Pelayanan cepat

Yuk cobai sebelum terlambat! DM aja langsung \uD83D\uDCF1

VARIASI 2:
Breaking News! \uD83D\uDCE2

${metadata?.namaProduk || inputText} yang viral di TikTok sekarang bisa dibeli di Makassar! 

Limited stock, siapa cepat dia dapat!
Grab yours NOW! \uD83C\uDFC3\uD83D\uDCA8

#MakassarLokalPride`,
    pricing: `\uD83D\uDCCA ANALISIS HARGA:

\uD83D\uDCB0 Modal (HPP): Rp ${metadata?.modalHPP?.toLocaleString("id-ID") || "15.000"}
\uD83D\uDCC8 Rekomendasi Harga Jual: Rp 25.000 - Rp 28.000
 Margin Keuntungan: 40% - 46%

\uD83D\uDCA1 STRATEGI PRICING:
1. **Harga Psikologis**: Gunakan Rp 24.999 atau Rp 27.999 (terlihat lebih murah)
2. **Tier Pricing**: 
   - Regular: Rp 25.000
   - Jumbo: Rp 35.000 (margin lebih besar)
3. **Bundle Deal**: Beli 3 hanya Rp 70.000 (dari Rp 75.000)

 CATATAN:
- Harga ini sudah kompetitif untuk market Makassar
- Pastikan packaging mendukung perceived value
- Monitor biaya operasional (listrik, gas, gaji) setiap bulan
- Evaluasi harga setiap 3 bulan mengikuti inflasi bahan baku`,
    reply: `\uD83D\uDCAC REKOMENDASI BALASAN:

"Halo Kak, terima kasih sudah menghubungi kami! \uD83D\uDE4F

Mohon maaf atas ketidaknyamanannya. Boleh kami tahu detail masalahnya atau nomor pesanan Kakak supaya kami bantu cek statusnya segera? 

Kami pastikan masalah ini akan ditangani dengan cepat. Terima kasih atas kesabarannya ya Kak \uD83D\uDE0A

Salam hangat,
Tim [Nama Bisnis]"

\uD83D\uDCA1 ANALISIS SITUASI:
Pesan ini efektif karena:
- Menunjukkan empati langsung
- Menawarkan solusi konkret (cek nomor pesanan)
- Menggunakan bahasa yang ramah namun profesional
- Menutup dengan harapan positif
- Mencantumkan signature untuk personal touch`,
    comment: `\uD83D\uDD0D ANALISA KOMENTAR:

\uD83D\uDCCA SENTIMEN: NEGATIF \uD83D\uDD34

 MASALAH UTAMA: 
- Pelayanan lambat (respon customer service)
- Pesanan salah/tidak sesuai ekspektasi
- Kemungkinan kecewa dengan kualitas vs harga

\uD83D\uDCA1 REKOMENDASI TINDAKAN:
1. **SEGERA** reply komentar secara personal (jangan generic)
2. **Minta maaf** dengan tulus dan akui kesalahan
3. **Tawarkan kompensasi** (voucher/diskon/refund)
4. **Follow up via DM** untuk privasi
5. **Internal review** proses yang bermasalah

\uD83D\uDCAC AUTO-REPLY SUGGESTION:
"Tabe' Kak, mohon maaf sekali atas ketidaknyamanannya \uD83D\uDE4F 

Ini bukan standar pelayanan kami dan kami sangat menyesal. Boleh kami DM untuk ganti rugi dan pastikan hal ini tidak terulang lagi? 

Terima kasih masukannya, ini sangat membantu kami berkembang.

Hormat kami,
[Nama Bisnis]"

 URGENCY LEVEL: TINGGI - Handle dalam 1 jam!`
  };
  return {
    type,
    inputText,
    outputText: mockOutputs[type],
    metadata: metadata || {}
  };
}

// backend/src/visual-studio.ts
var import_sharp2 = __toESM(require_lib(), 1);

// backend/src/external-apis.ts
init_axios2();
var import_form_data2 = __toESM(require_form_data(), 1);
var import_sharp = __toESM(require_lib(), 1);
var HUGGINGFACE_API_KEY2 = process.env.HUGGINGFACE_API_KEY || "";
var REMOVEBG_API_KEY = process.env.REMOVEBG_API_KEY || "";
var STABILITY_API_KEY2 = process.env.STABILITY_API_KEY || "";
console.log("\uD83D\uDD0C External APIs Config (FREE Tier):");
console.log("   Hugging Face:", HUGGINGFACE_API_KEY2 ? " Configured" : " Not set (Unlimited FREE)");
console.log("   Remove.bg:", REMOVEBG_API_KEY ? " Configured" : " Not set (50 free/month)");
console.log("   Stability AI:", STABILITY_API_KEY2 ? " Configured" : " Not set (25 free/month)");
async function analyzeImageWithSightengine(imageBase64) {
  try {
    console.log("\uD83D\uDD0D Analyzing image quality with Sharp.js...");
    return fallbackImageAnalysis(imageBase64);
  } catch (error2) {
    console.error(" Error analyzing image:", error2.message);
    return fallbackImageAnalysis(imageBase64);
  }
}
async function removeBackgroundWithRemoveBg(imageBase64) {
  try {
    console.log(" Removing background with Remove.bg...");
    if (!REMOVEBG_API_KEY) {
      console.warn(" Remove.bg API key not configured - using simulation mode");
      return {
        success: false,
        error: "Remove.bg API key not configured. Get 50 free images/month at https://remove.bg/api"
      };
    }
    const imageBuffer = Buffer.from(imageBase64.replace(/^data:image\/\w+;base64,/, ""), "base64");
    const formData = new import_form_data2.default;
    formData.append("image_file_b64", imageBase64.replace(/^data:image\/\w+;base64,/, ""));
    formData.append("size", "auto");
    const response = await axios_default.post("https://api.remove.bg/v1.0/removebg", formData, {
      headers: {
        ...formData.getHeaders(),
        "X-Api-Key": REMOVEBG_API_KEY
      },
      responseType: "arraybuffer",
      timeout: 30000
    });
    console.log(" Background removed successfully with Remove.bg");
    const resultBase64 = `data:image/png;base64,${Buffer.from(response.data).toString("base64")}`;
    return {
      success: true,
      imageBase64: resultBase64
    };
  } catch (error2) {
    console.error(" Remove.bg API Error:", error2.message);
    return {
      success: false,
      error: error2.response?.data?.errors?.[0]?.title || error2.message
    };
  }
}
async function generateTemplateWithHuggingFace(prompt, style = "instagram-feed") {
  try {
    const { generateWithHuggingFace: generateWithHuggingFace2 } = await Promise.resolve().then(() => (init_huggingface_client(), exports_huggingface_client));
    const { generateWithStabilityAI: generateWithStabilityAI2 } = await Promise.resolve().then(() => (init_stability_client(), exports_stability_client));
    const result = await generateWithHuggingFace2(prompt);
    if (result.success) {
      return { success: true, imageBase64: result.imageBase64 };
    }
    if (STABILITY_API_KEY2) {
      const stabilityResult = await generateWithStabilityAI2(prompt);
      if (stabilityResult.success) {
        return { success: true, imageBase64: stabilityResult.imageBase64 };
      }
    }
    return { success: false, error: "All AI models failed" };
  } catch (error2) {
    return { success: false, error: error2.message };
  }
}
function generateFallbackTemplate(prompt, style, productImage, theme = "minimalist", brandColor = "#FF6347", productName) {
  console.log(`\uD83C\uDFA8 Generating creative ${theme} template with fallback`);
  const dimensions = style === "story" ? { width: 1080, height: 1920 } : { width: 1080, height: 1080 };
  const adjustBrightness = (hex, percent) => {
    const num = parseInt(hex.replace("#", ""), 16);
    const r = Math.max(0, Math.min(255, (num >> 16) + percent));
    const g = Math.max(0, Math.min(255, (num >> 8 & 255) + percent));
    const b = Math.max(0, Math.min(255, (num & 255) + percent));
    return `#${(r << 16 | g << 8 | b).toString(16).padStart(6, "0")}`;
  };
  const brandLight = adjustBrightness(brandColor, 40);
  const brandDark = adjustBrightness(brandColor, -30);
  const seed = Date.now() % 1000;
  const randomRotation = seed % 30 - 15;
  const randomScale = 0.9 + seed % 20 / 100;
  const randomX = seed % 10 - 5;
  const randomY = seed % 10 - 5;
  let templateSvg = "";
  if (theme === "cute-pastel" || theme.includes("pastel")) {
    templateSvg = `
      <svg width="${dimensions.width}" height="${dimensions.height}" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient id="bg" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stop-color="#FFE5EC"/>
            <stop offset="50%" stop-color="#FFF0F5"/>
            <stop offset="100%" stop-color="#E5F5FF"/>
          </linearGradient>
          <filter id="shadow"><feDropShadow dx="0" dy="8" stdDeviation="12" flood-color="#FFB6C1" flood-opacity="0.3"/></filter>
        </defs>
        <rect width="100%" height="100%" fill="url(#bg)"/>
        <ellipse cx="20%" cy="15%" rx="80" ry="50" fill="white" opacity="0.7"/>
        <ellipse cx="80%" cy="20%" rx="70" ry="45" fill="white" opacity="0.7"/>
        <text x="10%" y="85%" font-size="40" opacity="0.6">\uD83D\uDC95</text>
        <text x="88%" y="88%" font-size="40" opacity="0.6">\uD83D\uDC95</text>
        <rect x="10%" y="25%" width="80%" height="60%" fill="white" rx="40" filter="url(#shadow)"/>
        ${productImage ? `<image href="${productImage}" x="15%" y="30%" width="70%" height="45%" preserveAspectRatio="xMidYMid slice" clip-path="inset(0 round 30px)"/>` : `<text x="50%" y="53%" font-size="80" text-anchor="middle">\uD83C\uDF38</text>`}
        <rect x="15%" y="78%" width="70%" height="12%" fill="#FFB6C1" rx="25"/>
        <text x="50%" y="84.5%" font-family="Comic Sans MS" font-size="32" font-weight="bold" fill="white" text-anchor="middle" dominant-baseline="middle">${productName || "Kawaii"} </text>
      </svg>`;
  } else if (theme === "elegant" || theme.includes("luxury")) {
    templateSvg = `
      <svg width="${dimensions.width}" height="${dimensions.height}" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient id="bg" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stop-color="#1a1a1a"/>
            <stop offset="100%" stop-color="#2d2d2d"/>
          </linearGradient>
          <linearGradient id="gold" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" stop-color="#FFD700"/>
            <stop offset="50%" stop-color="#FFA500"/>
            <stop offset="100%" stop-color="#FFD700"/>
          </linearGradient>
        </defs>
        <rect width="100%" height="100%" fill="url(#bg)"/>
        <rect x="5%" y="5%" width="90%" height="2" fill="url(#gold)"/>
        <rect x="5%" y="95%" width="90%" height="2" fill="url(#gold)"/>
        ${productImage ? `<circle cx="50%" cy="45%" r="255" fill="url(#gold)"/><image href="${productImage}" x="27%" y="22%" width="46%" height="46%" preserveAspectRatio="xMidYMid slice" clip-path="circle(250px at 50% 50%)"/>` : `<circle cx="50%" cy="45%" r="250" fill="${brandColor}" opacity="0.2"/><text x="50%" y="47%" font-size="100" text-anchor="middle" fill="url(#gold)"></text>`}
        <text x="50%" y="82%" font-family="Georgia" font-size="48" font-weight="bold" fill="url(#gold)" text-anchor="middle">${productName || "Luxury"}</text>
        <text x="50%" y="88%" font-family="Georgia" font-size="24" fill="#999" text-anchor="middle">PREMIUM QUALITY</text>
      </svg>`;
  } else if (theme === "bold-modern" || theme.includes("bold")) {
    templateSvg = `
      <svg width="${dimensions.width}" height="${dimensions.height}" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient id="bg" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stop-color="${brandColor}"/>
            <stop offset="100%" stop-color="${brandDark}"/>
          </linearGradient>
          <filter id="shadow"><feDropShadow dx="0" dy="10" stdDeviation="15" flood-opacity="0.3"/></filter>
        </defs>
        <rect width="100%" height="100%" fill="url(#bg)"/>
        <polygon points="0,0 ${dimensions.width},0 ${dimensions.width},200" fill="black" opacity="0.1"/>
        <polygon points="0,${dimensions.height} ${dimensions.width},${dimensions.height} 0,${dimensions.height - 200}" fill="white" opacity="0.1"/>
        <rect x="10%" y="20%" width="80%" height="65%" fill="white" rx="20" filter="url(#shadow)"/>
        ${productImage ? `<image href="${productImage}" x="15%" y="25%" width="70%" height="50%" preserveAspectRatio="xMidYMid slice" clip-path="inset(0 round 15px)"/>` : `<text x="50%" y="50%" font-size="100" font-weight="900" text-anchor="middle" fill="${brandColor}"></text>`}
        <rect x="5%" y="88%" width="90%" height="10%" fill="black"/>
        <text x="50%" y="93.5%" font-family="Impact" font-size="42" font-weight="900" fill="white" text-anchor="middle" dominant-baseline="middle">${(productName || "BOLD").toUpperCase()}</text>
      </svg>`;
  } else if (theme === "playful") {
    templateSvg = `
      <svg width="${dimensions.width}" height="${dimensions.height}" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient id="bg" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stop-color="#FF6B9D"/>
            <stop offset="50%" stop-color="#FEC163"/>
            <stop offset="100%" stop-color="#C3F0FF"/>
          </linearGradient>
          <filter id="shadow"><feDropShadow dx="4" dy="8" stdDeviation="10" flood-color="${brandColor}" flood-opacity="0.4"/></filter>
        </defs>
        <rect width="100%" height="100%" fill="url(#bg)"/>
        <circle cx="15%" cy="12%" r="40" fill="#FFD93D" opacity="0.6"/>
        <circle cx="88%" cy="18%" r="50" fill="#6BCB77" opacity="0.6"/>
        <circle cx="10%" cy="85%" r="45" fill="#4D96FF" opacity="0.6"/>
        <text x="20%" y="25%" font-size="35" transform="rotate(-15 216 270)"></text>
        <text x="82%" y="30%" font-size="40" transform="rotate(20 886 324)"></text>
        <rect x="12%" y="28%" width="76%" height="58%" fill="white" rx="35" filter="url(#shadow)" transform="rotate(-2 ${dimensions.width / 2} ${dimensions.height / 2})"/>
        ${productImage ? `<image href="${productImage}" x="18%" y="33%" width="64%" height="43%" preserveAspectRatio="xMidYMid slice" clip-path="inset(0 round 25px)"/>` : `<text x="50%" y="56%" font-size="90" text-anchor="middle" fill="${brandColor}">\uD83C\uDF89</text>`}
        <ellipse cx="50%" cy="82%" rx="38%" ry="8%" fill="${brandColor}"/>
        <text x="50%" y="83.5%" font-family="Comic Sans MS" font-size="38" font-weight="bold" fill="white" text-anchor="middle" dominant-baseline="middle">${productName || "Fun"} \uD83C\uDF8A</text>
      </svg>`;
  } else if (theme === "premium") {
    templateSvg = `
      <svg width="${dimensions.width}" height="${dimensions.height}" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient id="bg"><stop offset="0%" stop-color="#0a0a0a"/><stop offset="100%" stop-color="#1a1a1a"/></linearGradient>
          <linearGradient id="accent" x1="0%" x2="100%"><stop offset="0%" stop-color="${brandColor}"/><stop offset="100%" stop-color="${brandDark}"/></linearGradient>
        </defs>
        <rect width="100%" height="100%" fill="url(#bg)"/>
        <rect x="3%" y="3%" width="94%" height="94%" fill="none" stroke="url(#accent)" stroke-width="3" rx="15"/>
        <rect x="5%" y="5%" width="90%" height="90%" fill="none" stroke="url(#accent)" stroke-width="1" rx="12"/>
        <text x="8%" y="10%" font-size="30" fill="${brandColor}"></text>
        <text x="92%" y="10%" font-size="30" fill="${brandColor}"></text>
        ${productImage ? `<rect x="18%" y="20%" width="64%" height="50%" fill="url(#accent)" rx="10"/><image href="${productImage}" x="20%" y="22%" width="60%" height="46%" preserveAspectRatio="xMidYMid slice" clip-path="inset(0 round 8px)"/>` : `<text x="50%" y="47%" font-size="120" text-anchor="middle" fill="url(#accent)">\uD83D\uDC51</text>`}
        <line x1="20%" y1="78%" x2="80%" y2="78%" stroke="url(#accent)" stroke-width="2"/>
        <text x="50%" y="85%" font-family="Georgia" font-size="40" font-weight="bold" fill="${brandColor}" text-anchor="middle">${productName || "Premium"}</text>
        <text x="50%" y="91%" font-family="Georgia" font-size="20" fill="#888" text-anchor="middle" letter-spacing="3">EXCLUSIVE</text>
      </svg>`;
  } else {
    templateSvg = `
      <svg width="${dimensions.width}" height="${dimensions.height}" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient id="bg" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stop-color="#FAFAFA"/>
            <stop offset="100%" stop-color="#F0F0F0"/>
          </linearGradient>
          <filter id="shadow"><feDropShadow dx="0" dy="4" stdDeviation="8" flood-opacity="0.1"/></filter>
        </defs>
        <rect width="100%" height="100%" fill="url(#bg)"/>
        <circle cx="15%" cy="15%" r="120" fill="${brandLight}" opacity="0.3"/>
        <circle cx="85%" cy="85%" r="150" fill="${brandColor}" opacity="0.2"/>
        <rect x="8%" y="8%" width="84%" height="84%" fill="white" rx="30" filter="url(#shadow)"/>
        ${productImage ? `<image href="${productImage}" x="15%" y="15%" width="70%" height="55%" preserveAspectRatio="xMidYMid slice" clip-path="inset(0 round 20px)"/>` : `<text x="50%" y="42%" font-size="80" text-anchor="middle" fill="${brandColor}">\uD83C\uDFA8</text>`}
        <rect x="12%" y="75%" width="76%" height="15%" fill="${brandColor}" rx="15"/>
        <text x="50%" y="82.5%" font-family="Arial" font-size="36" font-weight="bold" fill="white" text-anchor="middle" dominant-baseline="middle">${productName || "Product"}</text>
      </svg>`;
  }
  const templateBase64 = `data:image/svg+xml;base64,${Buffer.from(templateSvg.trim()).toString("base64")}`;
  return {
    success: true,
    imageBase64: templateBase64
  };
}
async function calculateSharpness(imageBuffer) {
  try {
    const { data, info } = await import_sharp.default(imageBuffer).greyscale().convolve({
      width: 3,
      height: 3,
      kernel: [0, -1, 0, -1, 4, -1, 0, -1, 0]
    }).raw().toBuffer({ resolveWithObject: true });
    let sum = 0;
    let sumSq = 0;
    const pixels = data.length;
    for (let i = 0;i < pixels; i++) {
      sum += data[i];
      sumSq += data[i] * data[i];
    }
    const mean = sum / pixels;
    const variance = sumSq / pixels - mean * mean;
    let sharpnessScore;
    if (variance < 50)
      sharpnessScore = 1;
    else if (variance < 100)
      sharpnessScore = 2;
    else if (variance < 200)
      sharpnessScore = 3;
    else if (variance < 300)
      sharpnessScore = 4;
    else if (variance < 500)
      sharpnessScore = 5;
    else if (variance < 700)
      sharpnessScore = 6;
    else if (variance < 1000)
      sharpnessScore = 7;
    else if (variance < 1500)
      sharpnessScore = 8;
    else if (variance < 2000)
      sharpnessScore = 9;
    else
      sharpnessScore = 10;
    console.log(`   \uD83D\uDCCA Sharpness variance: ${variance.toFixed(2)}  Score: ${sharpnessScore}/10`);
    return sharpnessScore;
  } catch (error2) {
    console.warn(" Sharpness calculation error:", error2);
    return 3;
  }
}
function calculateContrast(stats) {
  try {
    const channels = stats.channels;
    let avgStdDev = 0;
    channels.forEach((channel) => {
      avgStdDev += channel.stdev || 0;
    });
    avgStdDev = avgStdDev / channels.length;
    let contrastScore;
    if (avgStdDev < 10)
      contrastScore = 1;
    else if (avgStdDev < 20)
      contrastScore = 3;
    else if (avgStdDev < 30)
      contrastScore = 5;
    else if (avgStdDev < 45)
      contrastScore = 7;
    else if (avgStdDev < 60)
      contrastScore = 9;
    else
      contrastScore = 10;
    console.log(`   \uD83D\uDCCA Contrast stddev: ${avgStdDev.toFixed(2)}  Score: ${contrastScore}/10`);
    return contrastScore;
  } catch (error2) {
    return 3;
  }
}
function calculateBrightness(stats) {
  try {
    const channels = stats.channels;
    let avgMean = 0;
    channels.forEach((channel) => {
      avgMean += channel.mean || 0;
    });
    avgMean = avgMean / channels.length;
    let brightnessScore;
    if (avgMean < 30)
      brightnessScore = 1;
    else if (avgMean < 50)
      brightnessScore = 2;
    else if (avgMean < 80)
      brightnessScore = 4;
    else if (avgMean < 100)
      brightnessScore = 6;
    else if (avgMean >= 100 && avgMean <= 150)
      brightnessScore = 9;
    else if (avgMean <= 180)
      brightnessScore = 7;
    else if (avgMean <= 200)
      brightnessScore = 5;
    else if (avgMean <= 220)
      brightnessScore = 3;
    else
      brightnessScore = 1;
    console.log(`   \uD83D\uDCCA Brightness mean: ${avgMean.toFixed(2)}  Score: ${brightnessScore}/10`);
    return brightnessScore;
  } catch (error2) {
    return 3;
  }
}
function calculateColorScore(stats) {
  try {
    const channels = stats.channels;
    if (channels.length < 3) {
      return 3;
    }
    let totalStdDev = 0;
    let totalRange = 0;
    channels.forEach((channel) => {
      totalStdDev += channel.stdev || 0;
      totalRange += channel.max - channel.min || 0;
    });
    const avgStdDev = totalStdDev / channels.length;
    const avgRange = totalRange / channels.length;
    let colorScore;
    if (avgRange < 50)
      colorScore = 1;
    else if (avgRange < 100)
      colorScore = 3;
    else if (avgRange < 150)
      colorScore = 5;
    else if (avgRange < 200)
      colorScore = 7;
    else if (avgRange < 230)
      colorScore = 9;
    else
      colorScore = 10;
    console.log(`   \uD83D\uDCCA Color range: ${avgRange.toFixed(2)}  Score: ${colorScore}/10`);
    return colorScore;
  } catch (error2) {
    return 3;
  }
}
function calculateCompositionScore(metadata) {
  try {
    const width = metadata.width || 1;
    const height = metadata.height || 1;
    const aspectRatio = width / height;
    const idealRatios = [1, 0.8, 1.78];
    let closestDiff = 999;
    idealRatios.forEach((ratio) => {
      const diff = Math.abs(aspectRatio - ratio);
      if (diff < closestDiff)
        closestDiff = diff;
    });
    const compositionScore = Math.min(10, Math.max(1, Math.round(10 - closestDiff * 5)));
    return compositionScore;
  } catch (error2) {
    return 6;
  }
}
function generateAnalysisText(params) {
  const { qualityScore, viralScore, sharpness, contrast, brightness, colors, composition, needsRetake, issues, suggestions } = params;
  return `\uD83D\uDD0D ANALISIS VISUAL COMPREHENSIVE (Powered by Sightengine AI)


\uD83D\uDCCA QUALITY SCORE: ${qualityScore}/10 ${needsRetake ? " NEEDS RETAKE" : " APPROVED"}
\uD83D\uDD25 VIRAL POTENTIAL: ${viralScore}/10


${needsRetake ? ` REKOMENDASI: RETAKE FOTO

Foto ini memiliki kualitas di bawah standar profesional. Pertimbangkan untuk foto ulang dengan pencahayaan lebih baik, fokus lebih tajam, dan komposisi yang lebih optimal.
` : ` REKOMENDASI: FOTO SIAP DIGUNAKAN!

Foto ini memiliki kualitas yang baik dan siap untuk konten marketing. Anda bisa langsung lanjut ke tahap design.
`}

1. DETAIL PENILAIAN TEKNIS

   \uD83D\uDD0D Sharpness/Focus: ${sharpness}/10 ${sharpness >= 8 ? "- Crystal Sharp " : sharpness >= 6 ? "- Acceptable" : "- Blur/Soft "}
   ${sharpness >= 8 ? "    Fokus tack sharp, detail sangat jelas" : sharpness >= 6 ? "   ~ Fokus decent tapi bisa lebih tajam" : "    BLUR - fokus tidak tajam, gambar soft/kabur"}
   
    Contrast: ${contrast}/10 ${contrast >= 8 ? "- Excellent " : contrast >= 6 ? "- Good" : "- Flat "}
   ${contrast >= 8 ? "    Contrast optimal, depth bagus" : contrast >= 6 ? "   ~ Contrast cukup, bisa ditingkatkan" : "    Gambar flat, perlu boost contrast"}
   
   \uD83D\uDCA1 Brightness/Exposure: ${brightness}/10 ${brightness >= 8 ? "- Perfect " : brightness >= 6 ? "- Acceptable" : "- Poor "}
   ${brightness >= 8 ? "    Exposure ideal, tidak ada blown highlights" : brightness >= 6 ? "   ~ Exposure cukup tapi bisa lebih optimal" : "    Exposure buruk - terlalu gelap/terang"}
   
   \uD83C\uDFA8 Colors/Vibrancy: ${colors}/10 ${colors >= 8 ? "- Vibrant " : colors >= 6 ? "- Decent" : "- Dull "}
   ${colors >= 8 ? "    Warna vibrant dan appealing" : colors >= 6 ? "   ~ Warna decent tapi kurang pop" : "    Warna kusam/pudar, tidak menarik"}
   
   \uD83D\uDCD0 Composition: ${composition}/10 ${composition >= 8 ? "- Excellent " : composition >= 6 ? "- Good" : "- Poor "}
   ${composition >= 8 ? "    Komposisi profesional, well-framed" : composition >= 6 ? "   ~ Komposisi acceptable" : "    Komposisi lemah, framing kurang optimal"}

${issues.length > 0 ? `
2. MASALAH TERDETEKSI
${issues.map((issue) => `   ${issue}`).join(`
`)}
` : ""}

3. REKOMENDASI PERBAIKAN
${suggestions.length > 0 ? suggestions.map((s) => `   ${s}`).join(`
`) : "    Foto sudah bagus, lanjut ke editing & design!"}

4. MARKETING STRATEGY
   \uD83D\uDCF1 Platform: Instagram Feed & Story (optimal)
   \uD83C\uDFAF Target: Foodies 25-40 tahun, mahasiswa
    Best time: 11:00-13:00 & 18:00-20:00 WIB
   \uD83D\uDCC8 Engagement potential: ${viralScore >= 8 ? "HIGH" : viralScore >= 6 ? "MEDIUM" : "LOW"}


\uD83D\uDCA1 FINAL VERDICT: ${needsRetake ? " Retake disarankan untuk hasil maksimal" : " Ready for design & posting!"}
`;
}
async function fallbackImageAnalysis(imageBase64) {
  console.log("\uD83D\uDD04 Using fallback image analysis with Sharp...");
  try {
    const imageBuffer = Buffer.from(imageBase64.replace(/^data:image\/\w+;base64,/, ""), "base64");
    const metadata = await import_sharp.default(imageBuffer).metadata();
    const stats = await import_sharp.default(imageBuffer).stats();
    const sharpness = await calculateSharpness(imageBuffer);
    const contrast = calculateContrast(stats);
    const brightness = calculateBrightness(stats);
    const colors = calculateColorScore(stats);
    const composition = calculateCompositionScore(metadata);
    const qualityScore = Math.round(sharpness * 0.3 + contrast * 0.2 + brightness * 0.2 + colors * 0.15 + composition * 0.15);
    const viralScore = Math.round(qualityScore * 0.5 + colors * 0.3 + composition * 0.2);
    const needsRetake = qualityScore < 7 || sharpness < 6;
    const issues = [];
    if (sharpness < 6)
      issues.push(" Gambar BLUR - fokus tidak tajam");
    if (contrast < 5)
      issues.push(" Contrast rendah");
    if (brightness < 4 || brightness > 9)
      issues.push(" Exposure tidak optimal");
    if (colors < 6)
      issues.push(" Warna kusam");
    const suggestions = [];
    if (sharpness < 7)
      suggestions.push("\uD83D\uDCF8 Gunakan tripod untuk foto lebih tajam");
    if (contrast < 6)
      suggestions.push("\uD83C\uDFA8 Tingkatkan contrast saat editing");
    if (brightness < 5)
      suggestions.push("\uD83D\uDCA1 Tambah pencahayaan");
    if (colors < 7)
      suggestions.push("\uD83C\uDF08 Tingkatkan saturation");
    const analysis = generateAnalysisText({
      qualityScore,
      viralScore,
      sharpness,
      contrast,
      brightness,
      colors,
      composition,
      needsRetake,
      issues,
      suggestions
    });
    return {
      qualityScore,
      viralScore,
      needsRetake,
      analysis,
      detailedScores: { sharpness, contrast, brightness, colors, composition },
      issues,
      suggestions
    };
  } catch (error2) {
    console.error(" Fallback analysis error:", error2);
    throw error2;
  }
}

// backend/src/services/templatePrompt.ts
function buildUMKMPrompt(productName, businessType, theme, brandColor, targetMarket, format, additionalInfo) {
  const themeMap = {
    elegant: "elegant luxury with gold accents, sophisticated presentation, premium quality",
    "cute-pastel": "cute kawaii style with pastel colors, soft lighting, playful aesthetic",
    "bold-modern": "bold vibrant colors, strong contrast, modern dynamic composition",
    minimalist: "clean minimal design, white background, simple elegant presentation",
    premium: "premium luxury branding, dark moody background, sophisticated lighting",
    playful: "fun playful composition, bright cheerful colors, energetic vibe"
  };
  const businessMap = {
    makanan: "delicious Indonesian food dish, appetizing presentation, steam rising, professional food photography",
    fashion: "fashionable clothing item, stylish presentation, studio lighting, model or mannequin",
    kosmetik: "beauty cosmetic product, clean elegant display, soft feminine lighting",
    kerajinan: "handmade craft product, artisanal authentic look, cultural elements",
    cafe: "cozy cafe beverage or food, lifestyle photography, warm inviting atmosphere",
    kuliner: "gourmet culinary creation, restaurant quality plating, professional food photography",
    lainnya: "professional product photography, clean studio setup"
  };
  return `High quality commercial product photography of ${productName}, ${businessMap[businessType]}, ${themeMap[theme]}, professional studio lighting, shallow depth of field, centered composition, clean neutral background, vibrant appetizing colors, Instagram-worthy, marketing material quality, 4K sharp details, no text, no watermark. ${additionalInfo || ""}`;
}

// backend/src/visual-studio.ts
var KOLOSAL_API_KEY3 = process.env.KOLOSAL_API_KEY;
var USE_MOCK3 = process.env.USE_MOCK_AI === "true";
var client3 = new OpenAI({
  apiKey: KOLOSAL_API_KEY3,
  baseURL: "https://api.kolosal.ai/v1"
});
console.log("\uD83C\uDFA8 Visual Studio Config:");
console.log("   Image Analysis: Sharp.js (FREE)");
console.log("   Background Removal: Remove.bg (50/month)");
console.log("   Template Gen: FLUX.1-schnell  FLUX.1-dev  SDXL-Lightning (FREE)");
console.log("   Fallback: Stability AI Core  Creative SVG");
console.log("   Mock Mode:", USE_MOCK3 ? " Enabled" : " Disabled");
async function compositeProductWithTemplate(productImage, templateImage, format) {
  try {
    const dims = getFormatDimensions(format);
    const productBuffer = Buffer.from(productImage.replace(/^data:image\/\w+;base64,/, ""), "base64");
    const templateBuffer = Buffer.from(templateImage.replace(/^data:image\/\w+;base64,/, ""), "base64");
    const productMeta = await import_sharp2.default(productBuffer).metadata();
    const productAspect = (productMeta.width || 1) / (productMeta.height || 1);
    const maxSize = Math.round(Math.min(dims.width, dims.height) * 0.7);
    let productWidth = maxSize;
    let productHeight = maxSize;
    if (productAspect > 1) {
      productHeight = Math.round(maxSize / productAspect);
    } else {
      productWidth = Math.round(maxSize * productAspect);
    }
    const productResized = await import_sharp2.default(productBuffer).resize(productWidth, productHeight, {
      fit: "contain",
      background: { r: 0, g: 0, b: 0, alpha: 0 }
    }).png().toBuffer();
    const xOffset = Math.round((dims.width - productWidth) / 2);
    const yOffset = Math.round((dims.height - productHeight) / 2.2);
    const composited = await import_sharp2.default(templateBuffer).resize(dims.width, dims.height, { fit: "cover" }).composite([{
      input: productResized,
      top: yOffset,
      left: xOffset,
      blend: "over"
    }]).jpeg({ quality: 95 }).toBuffer();
    console.log(`    Composited ${productWidth}x${productHeight} product onto ${dims.width}x${dims.height} template`);
    return `data:image/jpeg;base64,${composited.toString("base64")}`;
  } catch (error2) {
    console.error(" Composite error:", error2.message);
    return templateImage;
  }
}
async function generateUMKMBranding(request) {
  const startTime = Date.now();
  try {
    console.log("\uD83C\uDFA8 Starting UMKM Branding Generation...");
    console.log("   Product:", request.productName);
    console.log("   Business:", request.businessType);
    console.log("   Theme:", request.theme);
    console.log("   Format:", request.format);
    let imageAnalysis = undefined;
    let processedImage = request.productImage;
    if (request.productImage) {
      console.log("\uD83D\uDCF8 Step 1: Analyzing product image quality...");
      const analysis = await analyzeImageWithSightengine(request.productImage);
      imageAnalysis = {
        qualityScore: analysis.qualityScore,
        isGoodQuality: analysis.qualityScore >= 7,
        issues: analysis.issues,
        recommendations: analysis.suggestions
      };
      console.log(`   Quality Score: ${analysis.qualityScore}/10`);
      if (analysis.qualityScore >= 6) {
        console.log(" Step 2: Removing background...");
        const bgRemovalResult = await removeBackgroundWithRemoveBg(request.productImage);
        if (bgRemovalResult.success && bgRemovalResult.imageBase64) {
          processedImage = bgRemovalResult.imageBase64;
          console.log("    Background removed successfully");
        }
      }
    }
    console.log("\uD83C\uDFA8 Step 3: Generating branded design template...");
    const prompt = buildUMKMPrompt(request.productName, request.businessType, request.theme, request.brandColor, request.targetMarket, request.format, request.additionalInfo);
    const templateResult = await generateTemplateWithHuggingFace(prompt, request.format);
    let finalDesign;
    if (!templateResult.success || !templateResult.imageBase64) {
      console.warn(" Template generation failed, using enhanced fallback with product image");
      const fallback = generateFallbackTemplate(prompt, request.format, processedImage || undefined, request.theme, request.brandColor, request.productName);
      finalDesign = fallback.imageBase64;
    } else {
      if (processedImage) {
        console.log("\uD83D\uDDBC Step 4: Compositing product image with AI template...");
        try {
          const composited = await compositeProductWithTemplate(processedImage, templateResult.imageBase64, request.format);
          finalDesign = composited;
        } catch (error2) {
          console.warn(" Composite failed, using fallback with product image");
          const fallback = generateFallbackTemplate(prompt, request.format, processedImage, request.theme, request.brandColor, request.productName);
          finalDesign = fallback.imageBase64;
        }
      } else {
        finalDesign = templateResult.imageBase64;
      }
    }
    console.log("\uD83D\uDCDD Step 5: Generating marketing suggestions...");
    const marketingSuggestions = generateMarketingSuggestions(request);
    const processingTime = Date.now() - startTime;
    console.log(` UMKM Branding completed in ${processingTime}ms`);
    return {
      success: true,
      imageAnalysis,
      designResult: {
        imageBase64: finalDesign,
        format: request.format,
        dimensions: getFormatDimensions(request.format)
      },
      marketingSuggestions,
      metadata: {
        generatedAt: new Date().toISOString(),
        processingTime
      }
    };
  } catch (error2) {
    console.error(" Error in UMKM Branding:", error2.message);
    throw new Error(`Gagal generate branding: ${error2.message}`);
  }
}
function generateMarketingSuggestions(request) {
  const captionTemplates = {
    makanan: ` ${request.productName} - Lezat & Berkualitas!

\uD83C\uDF7D Dibuat dengan bahan pilihan terbaik
\uD83D\uDCCD Tersedia sekarang untuk ${request.targetMarket}
\uD83D\uDCAC DM untuk order!`,
    fashion: ` ${request.productName} - Style Meets Comfort

\uD83D\uDC57 Perfect untuk ${request.targetMarket}
\uD83C\uDFA8 Desain eksklusif & berkualitas
\uD83D\uDCE6 Ready stock - Order sekarang!`,
    kosmetik: ` ${request.productName} - Your Beauty Secret

\uD83D\uDC84 Aman & teruji untuk ${request.targetMarket}
\uD83C\uDF1F Hasil maksimal, harga terjangkau
\uD83D\uDCAC Tanya-tanya? DM aja!`,
    default: ` ${request.productName}

 Kualitas terjamin
\uD83C\uDFAF Cocok untuk ${request.targetMarket}
\uD83D\uDCF2 Order via DM atau WhatsApp!`
  };
  const caption = captionTemplates[request.businessType] || captionTemplates.default;
  const hashtags = [
    "#UMKM",
    "#UMKMIndonesia",
    `#${request.productName.replace(/\s+/g, "")}`,
    "#ProdukLokal",
    "#SupportLokal",
    request.businessType === "makanan" ? "#KulinerNusantara" : `#${request.businessType}`,
    "#BisnisOnline",
    "#Jualan",
    "#OpenOrder"
  ];
  const themeStrategies = {
    elegant: "Gunakan font serif, spacing luas, foto high-end quality",
    "cute-pastel": "Warna soft pastel, elemen playful, font rounded",
    "bold-modern": "Kontras tinggi, geometric shapes, font bold sans-serif",
    minimalist: "White space maksimal, clean lines, typography focus",
    premium: "Dark background, gold accents, luxury feel",
    playful: "Bright colors, dynamic elements, fun typography"
  };
  return {
    caption,
    hashtags,
    bestPostingTime: [
      "\uD83D\uDCF1 Instagram: 11:00-13:00 & 19:00-21:00 WIB",
      "\uD83D\uDCF1 TikTok: 12:00-14:00 & 18:00-22:00 WIB",
      "\uD83D\uDCF1 Facebook: 10:00-12:00 & 19:00-20:00 WIB"
    ],
    targetPlatform: ["Instagram", "TikTok", "Facebook", "WhatsApp Business"],
    designDirection: themeStrategies[request.theme],
    colorStrategy: `Primary: ${request.brandColor}, gunakan complementary colors untuk balance visual`
  };
}
function getFormatDimensions(format) {
  const dimensions = {
    "instagram-square": { width: 1080, height: 1080 },
    "instagram-story": { width: 1080, height: 1920 },
    tiktok: { width: 1080, height: 1920 },
    facebook: { width: 1200, height: 630 }
  };
  return dimensions[format] || { width: 1080, height: 1080 };
}
async function analyzeImageWithAI(request) {
  try {
    console.log("\uD83D\uDD0D Analyzing image with Sightengine AI...");
    if (!request.imageBase64) {
      throw new Error("Image base64 required for analysis");
    }
    const sightengineResult = await analyzeImageWithSightengine(request.imageBase64);
    console.log(" Image analysis complete:", {
      qualityScore: sightengineResult.qualityScore,
      viralScore: sightengineResult.viralScore,
      needsRetake: sightengineResult.needsRetake
    });
    return {
      analysis: sightengineResult.analysis,
      suggestions: sightengineResult.suggestions,
      marketingTips: [
        "Post di jam makan (11-13 & 18-20 WIB) untuk maximize engagement",
        "Tag lokasi Makassar untuk local discovery",
        "Gunakan Story polls & questions untuk boost interaction",
        "Collaborate dengan food blogger lokal"
      ],
      bestTimeToPost: [
        "Senin-Jumat: 11:00-13:00 WIB (Lunch peak)",
        "Sabtu-Minggu: 18:00-20:00 WIB (Dinner time)",
        "Story: 07:00-09:00 WIB (Morning commute)"
      ],
      hashtags: [
        "#KulinerMakassar",
        "#MakananMakassar",
        "#FoodGram",
        "#UMKMMakassar",
        "#InstaFoodMakassar",
        "#MakassarFoodies",
        "#Enak",
        "#FoodPhotography",
        "#SulawesiSelatan",
        "#ExploreIndonesia"
      ],
      colorPalette: ["#FF6B4A", "#FFB84D", "#FFF5E1", "#8B4513", "#CD853F"],
      metadata: {
        analyzedAt: new Date().toISOString(),
        engine: "Sightengine AI + Sharp.js",
        qualityScore: sightengineResult.qualityScore,
        viralScore: sightengineResult.viralScore,
        needsRetake: sightengineResult.needsRetake,
        detailedScores: sightengineResult.detailedScores
      }
    };
  } catch (error2) {
    console.error(" Error analyzing image:", error2.message);
    throw new Error(`Gagal menganalisa gambar: ${error2.message}`);
  }
}
async function generateTemplateDesign(request) {
  if (USE_MOCK3) {
    console.log("\uD83E\uDDEA MOCK: Generating template design...");
    return generateMockTemplateDesign(request);
  }
  try {
    console.log(`\uD83E\uDD16 Generating ${request.templateType} template with AI...`);
    const prompt = buildTemplatePrompt(request);
    const completion = await client3.chat.completions.create({
      model: "Llama 4 Maverick",
      messages: [
        {
          role: "system",
          content: "Kamu adalah AI graphic designer expert specializing dalam social media design, layout composition, typography, color theory, dan visual hierarchy. Kamu memahami platform algorithms, engagement triggers, dan best practices untuk UMKM di Indonesia."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.9,
      max_tokens: 1500,
      frequency_penalty: 0.3,
      presence_penalty: 0.3
    });
    const designText = completion.choices[0].message.content?.trim() || "";
    return {
      designSuggestions: designText,
      layoutRecommendations: extractLayoutRecommendations(designText),
      textOverlaySuggestions: extractTextOverlay(designText),
      colorScheme: extractColorScheme(designText),
      fontRecommendations: extractFonts(designText),
      ctaSuggestions: extractCTAs(designText),
      metadata: {
        generatedAt: new Date().toISOString(),
        templateType: request.templateType
      }
    };
  } catch (error2) {
    console.error(" Error generating template:", error2.message);
    throw new Error(`Gagal generate template: ${error2.message}`);
  }
}
async function generateSchedulePlanner(request) {
  if (USE_MOCK3) {
    console.log("\uD83E\uDDEA MOCK: Generating schedule planner...");
    return generateMockSchedulePlanner(request);
  }
  try {
    console.log("\uD83E\uDD16 Generating content schedule with AI...");
    const prompt = buildSchedulePrompt(request);
    const completion = await client3.chat.completions.create({
      model: "Llama 4 Maverick",
      messages: [
        {
          role: "system",
          content: "Kamu adalah AI content strategist expert dengan deep knowledge tentang social media algorithms, audience behavior patterns, engagement optimization, dan content calendar planning. Kamu memahami best practice posting schedule untuk UMKM kuliner di Makassar, termasuk local peak times, cultural events, dan seasonal trends."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.75,
      max_tokens: 2000
    });
    const scheduleText = completion.choices[0].message.content?.trim() || "";
    return {
      schedule: parseScheduleFromText(scheduleText, request.duration),
      overallStrategy: extractStrategy(scheduleText),
      kpiTargets: extractKPIs(scheduleText),
      tips: extractTips(scheduleText),
      metadata: {
        generatedAt: new Date().toISOString(),
        duration: request.duration,
        businessGoal: request.businessGoal
      }
    };
  } catch (error2) {
    console.error(" Error generating schedule:", error2.message);
    throw new Error(`Gagal generate schedule: ${error2.message}`);
  }
}
function buildTemplatePrompt(request) {
  const { templateType, theme, brandColor, targetAudience } = request;
  const templates = {
    promo: "Promo/Sale announcement",
    story: "Instagram/Facebook Story",
    feed: "Instagram Feed Post",
    reels: "Instagram Reels/TikTok",
    carousel: "Carousel/Multi-slide post"
  };
  return `Buatkan DESIGN CONCEPT untuk template ${templates[templateType]}

PROJECT BRIEF:
- Format: ${templates[templateType]}
- Theme: ${theme}
- Brand Color: ${brandColor || "Belum ditentukan (suggest optimal colors)"}
- Target Audience: ${targetAudience}
- Platform: Instagram, Facebook, TikTok
- Business: UMKM Kuliner Makassar

DELIVERABLES:

1. **LAYOUT RECOMMENDATIONS** (3 variations)
   - Layout A: [Describe composition, grid system, visual hierarchy]
   - Layout B: [Alternative approach with reasoning]
   - Layout C: [Creative bold option]
   
2. **TEXT OVERLAY STRATEGY**
   - Headline placement & sizing
   - Subheadline treatment
   - Body text positioning
   - Price/discount display (if promo)
   - Typography hierarchy
   
3. **COLOR SCHEME** (Psychology-based)
   - Primary color (with hex code)
   - Secondary color (with hex code)
   - Accent color (with hex code)
   - Background options
   - Color psychology reasoning
   
4. **FONT PAIRING RECOMMENDATIONS**
   - Headline font (with alternatives)
   - Body font (with alternatives)
   - Accent font for emphasis
   - Font pairing reasoning
   
5. **VISUAL ELEMENTS**
   - Icons/illustrations suggestions
   - Shapes/patterns to include
   - Photo treatment (filters, overlays)
   - Negative space usage
   
6. **CTA (Call-to-Action) SUGGESTIONS**
   - CTA text variations (5 options)
   - CTA button styling
   - Placement strategy
   - Urgency elements
   
7. **PLATFORM OPTIMIZATION**
   - Dimensions (pixel perfect)
   - Safe zones (text visibility)
   - Swipe/tap areas
   - Algorithm-friendly elements
   
8. **DESIGN TRENDS 2025**
   - Current trending styles
   - What works for ${targetAudience}
   - Local Makassar preferences
   - Viral potential elements

OUTPUT: Berikan design brief yang DETAIL dan IMPLEMENTABLE!`;
}
function buildSchedulePrompt(request) {
  const { contentType, targetAudience, businessGoal, duration } = request;
  const goals = {
    awareness: "Brand Awareness & Reach",
    engagement: "Engagement & Community Building",
    sales: "Sales & Conversion",
    traffic: "Website/Store Traffic"
  };
  return `Buatkan CONTENT POSTING SCHEDULE untuk ${duration} hari kedepan

PROJECT BRIEF:
- Content Type: ${contentType}
- Target Audience: ${targetAudience}
- Business Goal: ${goals[businessGoal]}
- Location: Makassar, Indonesia
- Business: UMKM Kuliner

CONTEXT ANALYSIS:
- Hari ini: ${new Date().toLocaleDateString("id-ID", { weekday: "long", year: "numeric", month: "long", day: "numeric" })}
- Target duration: ${duration} hari
- Platform: Instagram, Facebook, TikTok, WhatsApp Status

DELIVERABLES:

1. **DAILY POSTING SCHEDULE** (${duration} hari)
   Untuk setiap hari include:
   - Day number & date
   - Best posting time (jam + menit) with reasoning
   - Platform prioritas (IG/FB/TikTok/WA)
   - Content idea/theme
   - Caption suggestion (50-100 kata)
   - Hashtag strategy (10-15 hashtags)
   - Why this timing? (algorithm + behavior insights)

2. **CONTENT MIX STRATEGY**
   - Educational content: X%
   - Entertainment content: X%
   - Promotional content: X%
   - UGC/Testimonial content: X%
   - Behind-the-scenes: X%
   - Reasoning untuk ratio ini

3. **PLATFORM-SPECIFIC TIMING**
   - Instagram: Best times (3-5 time slots)
   - Facebook: Best times (3-5 time slots)
   - TikTok: Best times (3-5 time slots)
   - Why these times work untuk Makassar audience?

4. **KPI TARGETS & METRICS**
   - Expected reach
   - Expected engagement rate
   - Expected conversions
   - How to track success?

5. **TREND INTEGRATION**
   - Trending topics untuk integrate
   - Seasonal opportunities (if any)
   - Local events Makassar (if any)
   - Viral challenges to leverage

6. **OPTIMIZATION TIPS**
   - A/B testing suggestions
   - Content repurposing strategy
   - Engagement boosting tactics
   - Crisis management plan

7. **MAKASSAR-SPECIFIC INSIGHTS**
   - Peak online hours lokal
   - Cultural considerations
   - Local holidays/events
   - Community behavior patterns

OUTPUT FORMAT:
\uD83D\uDCC5 CONTENT POSTING SCHEDULE (${duration} Hari)

[For each day, provide structured schedule]

Berikan schedule yang STRATEGIC, DATA-DRIVEN, dan ACTIONABLE!`;
}
function extractLayoutRecommendations(text) {
  return [
    "Layout A: Centered composition with bold headline",
    "Layout B: Asymmetric grid with dynamic spacing",
    "Layout C: Minimal design with focus on product"
  ];
}
function extractTextOverlay(text) {
  return [
    "Headline: Top 1/3, Bold, White with shadow",
    "Subheadline: Below headline, Secondary font",
    "CTA: Bottom right, High contrast button"
  ];
}
function extractColorScheme(text) {
  return ["#FF6347", "#FFD700", "#FFFFFF", "#2C3E50"];
}
function extractFonts(text) {
  return [
    "Headline: Poppins Bold / Montserrat ExtraBold",
    "Body: Open Sans / Roboto",
    "Accent: Playfair Display / Bebas Neue"
  ];
}
function extractCTAs(text) {
  return [
    "Pesan Sekarang!",
    "Order via WhatsApp",
    "Klik Link di Bio",
    "Swipe Up untuk Info",
    "Limited Time - Grab Yours!"
  ];
}
function parseScheduleFromText(text, duration) {
  const schedule = [];
  const today = new Date;
  for (let i = 0;i < duration; i++) {
    const date = new Date(today);
    date.setDate(today.getDate() + i);
    schedule.push({
      day: i + 1,
      date: date.toLocaleDateString("id-ID"),
      time: i % 2 === 0 ? "11:00" : "18:00",
      platform: ["Instagram", "Facebook"],
      contentIdea: `Content idea untuk hari ke-${i + 1}`,
      caption: `Caption suggestion untuk hari ke-${i + 1}`,
      hashtags: ["#KulinerMakassar", "#UMKM", "#FoodLovers"],
      reasoning: "Optimal timing untuk audience engagement"
    });
  }
  return schedule;
}
function extractStrategy(text) {
  return "Fokus pada engagement di jam-jam peak, mix konten edukasi dan promosi dengan ratio 70:30";
}
function extractKPIs(text) {
  return [
    "Target reach: 10,000 per post",
    "Target engagement rate: 5-8%",
    "Target conversions: 50 orders/week"
  ];
}
function extractTips(text) {
  return [
    "Konsisten posting di jam yang sama",
    "Respond cepat ke comments dalam 1 jam",
    "Gunakan Story polls untuk boost engagement"
  ];
}
function generateMockTemplateDesign(request) {
  return {
    designSuggestions: `\uD83C\uDFA8 DESIGN CONCEPT - ${request.templateType.toUpperCase()}

1. LAYOUT RECOMMENDATIONS
   Layout A (Centered Hero):
   - Product image: 60% ruang, centered
   - Headline: Top 20%, bold impact
   - CTA: Bottom 10%, high contrast
   
   Layout B (Split Screen):
   - Left: Product image (50%)
   - Right: Text content (50%)
   - Modern, clean, professional
   
   Layout C (Overlay Gradient):
   - Fullscreen image
   - Gradient overlay (bottom to top)
   - Text on gradient area

2. COLOR PSYCHOLOGY
   - Primary: ${request.brandColor || "#FF6347"} (Urgency, appetite)
   - Secondary: #FFD700 (Premium, value)
   - Accent: #FFFFFF (Clean, clear)
   - Background: #2C3E50 (Contrast)

3. TYPOGRAPHY HIERARCHY
   - Headline: 72pt, Poppins ExtraBold
   - Subheadline: 36pt, Montserrat SemiBold
   - Body: 18pt, Open Sans Regular
   - CTA: 24pt, Poppins Bold

4. VISUAL ELEMENTS
    Add subtle pattern texture
   \uD83C\uDFAF Icon badges untuk "Fresh", "Halal", "Best Seller"
   \uD83D\uDCD0 Geometric shapes untuk frame
   \uD83D\uDD25 Flame icons untuk "Hot Deal"`,
    layoutRecommendations: [
      "Layout A: Centered hero composition (60-30-10 rule)",
      "Layout B: Split screen modern (50-50 balance)",
      "Layout C: Fullscreen overlay gradient (dramatic impact)"
    ],
    textOverlaySuggestions: [
      "Headline: Top 1/3, White + Drop Shadow",
      "Price: Large, bold, bottom right corner",
      "CTA Button: Bottom center, rounded, high contrast"
    ],
    colorScheme: ["#FF6347", "#FFD700", "#FFFFFF", "#2C3E50", "#95E1D3"],
    fontRecommendations: [
      "Headline: Poppins ExtraBold / Montserrat Black",
      "Body: Open Sans Regular / Roboto",
      "Accent: Bebas Neue / Playfair Display"
    ],
    ctaSuggestions: [
      "ORDER SEKARANG!",
      "Pesan via WhatsApp",
      "Klik Link Bio",
      "PROMO TERBATAS!",
      "Grab Yours Now!"
    ],
    metadata: {
      generatedAt: new Date().toISOString(),
      templateType: request.templateType,
      theme: request.theme
    }
  };
}
function generateMockSchedulePlanner(request) {
  const schedule = [];
  const today = new Date;
  const contentIdeas = [
    "Behind the scenes - proses masak",
    "Customer testimonial video",
    "Menu highlight dengan close-up",
    "Promo special hari ini",
    "Tips memasak / food hack",
    "Staff introduction",
    "Product comparison / before-after"
  ];
  for (let i = 0;i < request.duration; i++) {
    const date = new Date(today);
    date.setDate(today.getDate() + i);
    const dayOfWeek = date.getDay();
    const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
    schedule.push({
      day: i + 1,
      date: date.toLocaleDateString("id-ID", { weekday: "long", day: "numeric", month: "long" }),
      time: isWeekend ? "18:00 WITA" : "11:30 WITA",
      platform: ["Instagram", "Facebook", "TikTok"],
      contentIdea: contentIdeas[i % contentIdeas.length],
      caption: `Caption hari ke-${i + 1}: Share value, engage audience, dan call-to-action yang jelas.`,
      hashtags: ["#KulinerMakassar", "#UMKM", "#FoodLovers", "#MakassarFoodies"],
      reasoning: isWeekend ? "Weekend dinner time - audience lebih santai browsing" : "Weekday lunch time - peak hunger moment untuk kuliner"
    });
  }
  return {
    schedule,
    overallStrategy: `\uD83D\uDCCA STRATEGI KONTEN ${request.duration} HARI

\uD83C\uDFAF Content Mix:
- Educational: 40% (tips, behind scenes, knowledge)
- Entertainment: 30% (engaging, fun, relatable)
- Promotional: 30% (offers, products, CTA)

\uD83D\uDCF1 Platform Strategy:
- Instagram: Daily feed post + 3-5 stories
- Facebook: Share dari Instagram + local group posting
- TikTok: 3x per week (trending audio + challenges)

 Timing Strategy:
- Weekday: Focus on lunch (11:00-13:00) & dinner (18:00-20:00)
- Weekend: Evening posts untuk family dining decision
- Story: Morning (07:00-09:00) untuk reach

\uD83C\uDFA8 Content Variety:
- Mix foto & video (60:40 ratio)
- Use carousel untuk storytelling
- Go Live 1x per week untuk engagement boost`,
    kpiTargets: [
      "\uD83D\uDCC8 Reach target: 15,000-20,000 per post",
      "\uD83D\uDCAC Engagement rate: 6-10% (likes + comments + shares)",
      "\uD83D\uDED2 Conversion: 5-8% dari engagement ke inquiry",
      "\uD83D\uDC65 Follower growth: +500-1000 per bulan",
      " Save rate: 3-5% (content value indicator)"
    ],
    tips: [
      " Respond to DM & comments dalam 1 jam (golden hour)",
      " Gunakan Story polls, quiz, Q&A untuk boost engagement",
      " Repost customer content (UGC) untuk social proof",
      " Collaborate dengan micro-influencer Makassar (5-50K followers)",
      " Track analytics weekly dan adjust strategy",
      " Prepare content batch (3-5 post) untuk konsistensi",
      " Join & engage di Facebook Groups lokal Makassar",
      " Use trending audio di TikTok untuk FYP potential"
    ],
    metadata: {
      generatedAt: new Date().toISOString(),
      duration: request.duration,
      businessGoal: request.businessGoal,
      targetAudience: request.targetAudience
    }
  };
}

// backend/src/dapur-umkm.ts
var kolosalLlama = new OpenAI({
  apiKey: process.env.KOLOSAL_API_KEY,
  baseURL: "https://api.kolosal.ai/v1"
});
var LLAMA_MODEL = "Llama 4 Maverick";
var UMKM_EXPERT_PROMPT = `Kamu adalah konsultan bisnis UMKM profesional dari Indonesia dengan keahlian:
- Strategi pemasaran untuk UMKM lokal (terutama Makassar & Indonesia Timur)
- Analisis harga dan margin keuntungan
- Manajemen stok dan inventory
- Pengelolaan keuangan usaha kecil
- Digital marketing untuk UMKM

Gaya komunikasi:
- Ramah, praktis, dan actionable
- Gunakan bahasa Indonesia yang santai tapi profesional
- Berikan contoh nyata dan tips konkret
- Fokus pada solusi sederhana yang bisa langsung diterapkan
- Pahami kondisi UMKM Indonesia (modal terbatas, pasar lokal, kompetisi ketat)

Selalu berikan rekomendasi yang:
1. Spesifik dan terukur
2. Realistis untuk UMKM kecil
3. Bisa dieksekusi dengan budget minimal
4. Sesuai dengan konteks pasar Indonesia`;
async function calculateBusinessMetrics(profileId) {
  try {
    const { data: transactions, error: txError } = await supabase.from("umkm_transactions").select("*").eq("profile_id", profileId);
    if (txError)
      throw txError;
    const { data: products, error: prodError } = await supabase.from("umkm_products").select("*").eq("profile_id", profileId);
    if (prodError)
      throw prodError;
    const totalIncome = transactions?.filter((t) => t.type === "in").reduce((sum, t) => sum + Number(t.amount), 0) || 0;
    const totalExpense = transactions?.filter((t) => t.type === "out").reduce((sum, t) => sum + Number(t.amount), 0) || 0;
    const balance = totalIncome - totalExpense;
    const lowStockProducts = products?.filter((p) => Number(p.stock) > 0 && Number(p.stock) < 10) || [];
    const averageTransactionValue = transactions?.length ? totalIncome / transactions.filter((t) => t.type === "in").length : 0;
    return {
      totalIncome,
      totalExpense,
      balance,
      productCount: products?.length || 0,
      lowStockProducts,
      averageTransactionValue
    };
  } catch (error2) {
    console.error("Error calculating metrics:", error2);
    throw error2;
  }
}
async function getAIRecommendation(request) {
  try {
    const { profileId, insightType, question, context } = request;
    const { data: profile, error: profileError } = await supabase.from("umkm_profiles").select("*").eq("id", profileId).single();
    if (profileError)
      throw profileError;
    const businessContext = context || await calculateBusinessMetrics(profileId);
    let specificPrompt = "";
    switch (insightType) {
      case "pricing":
        specificPrompt = `Analisis harga dan strategi pricing untuk bisnis ${profile.business_name} (${profile.category}).
        
Data bisnis:
- Total Pemasukan: Rp ${businessContext.totalIncome.toLocaleString("id-ID")}
- Total Pengeluaran: Rp ${businessContext.totalExpense.toLocaleString("id-ID")}
- Saldo: Rp ${businessContext.balance.toLocaleString("id-ID")}
- Jumlah Produk: ${businessContext.productCount}

Pertanyaan: ${question}

Berikan rekomendasi pricing yang:
1. Kompetitif di pasar lokal
2. Mempertimbangkan margin keuntungan sehat (minimal 30%)
3. Sesuai dengan target pasar UMKM
4. Disertai contoh perhitungan konkret`;
        break;
      case "inventory":
        specificPrompt = `Analisis dan rekomendasi manajemen stok untuk ${profile.business_name}.
        
Data stok:
- Total Produk: ${businessContext.productCount}
- Produk Stok Rendah: ${businessContext.lowStockProducts.length}
${businessContext.lowStockProducts.map((p) => `   ${p.name}: ${p.stock} unit`).join(`
`)}

Pertanyaan: ${question}

Berikan tips inventory management yang praktis dan realistis untuk UMKM.`;
        break;
      case "strategy":
        specificPrompt = `Konsultasi strategi bisnis untuk ${profile.business_name} (${profile.category}).
        
Performa bisnis:
- Omzet: Rp ${businessContext.totalIncome.toLocaleString("id-ID")}
- Pengeluaran: Rp ${businessContext.totalExpense.toLocaleString("id-ID")}
- Net Profit: Rp ${businessContext.balance.toLocaleString("id-ID")}
- Rata-rata Transaksi: Rp ${businessContext.averageTransactionValue.toLocaleString("id-ID")}

Pertanyaan: ${question}

Berikan strategi bisnis yang actionable dan bisa langsung dieksekusi.`;
        break;
      case "marketing":
        specificPrompt = `Strategi marketing digital untuk ${profile.business_name}.
        
Bisnis: ${profile.category}
Budget: Minimal (UMKM kecil)

Pertanyaan: ${question}

Rekomendasikan strategi marketing yang:
1. Low-cost / no-cost
2. Fokus digital (Instagram, Facebook, TikTok, WhatsApp Business)
3. Sesuai target pasar lokal Indonesia
4. Mudah dieksekusi tanpa tim marketing`;
        break;
      case "finance":
        specificPrompt = `Analisis kesehatan keuangan ${profile.business_name}.
        
Laporan Keuangan:
- Pemasukan: Rp ${businessContext.totalIncome.toLocaleString("id-ID")}
- Pengeluaran: Rp ${businessContext.totalExpense.toLocaleString("id-ID")}
- Saldo: Rp ${businessContext.balance.toLocaleString("id-ID")}
- Profit Margin: ${businessContext.totalIncome > 0 ? (businessContext.balance / businessContext.totalIncome * 100).toFixed(1) : 0}%

Pertanyaan: ${question}

Berikan analisis dan saran pengelolaan keuangan yang sehat untuk UMKM.`;
        break;
    }
    const completion = await kolosalLlama.chat.completions.create({
      model: LLAMA_MODEL,
      messages: [
        {
          role: "system",
          content: UMKM_EXPERT_PROMPT
        },
        {
          role: "user",
          content: specificPrompt
        }
      ],
      temperature: 0.7,
      max_tokens: 1500,
      top_p: 0.9
    });
    const recommendation = completion.choices[0].message.content;
    const { data: insight, error: insertError } = await supabase.from("umkm_ai_insights").insert({
      profile_id: profileId,
      insight_type: insightType,
      question,
      recommendation,
      context_data: businessContext
    }).select().single();
    if (insertError) {
      console.error("Error saving AI insight:", insertError);
    }
    return {
      success: true,
      data: {
        recommendation,
        insightType,
        context: businessContext,
        savedInsight: insight
      }
    };
  } catch (error2) {
    console.error("AI Recommendation Error:", error2);
    return {
      success: false,
      message: error2.message || "Gagal mendapatkan rekomendasi AI",
      error: error2.response?.data || error2
    };
  }
}
var QUICK_INSIGHTS = [
  {
    id: "pricing-strategy",
    title: "Strategi Harga Optimal",
    question: "Bagaimana cara menentukan harga jual yang kompetitif tapi tetap untung?",
    type: "pricing",
    icon: "\uD83D\uDCB0"
  },
  {
    id: "increase-sales",
    title: "Cara Ningkatin Penjualan",
    question: "Tips praktis untuk meningkatkan penjualan dengan budget terbatas?",
    type: "strategy",
    icon: "\uD83D\uDCC8"
  },
  {
    id: "social-media",
    title: "Strategi Medsos",
    question: "Platform medsos apa yang paling efektif untuk UMKM kuliner dan cara optimasinya?",
    type: "marketing",
    icon: "\uD83D\uDCF1"
  },
  {
    id: "inventory-management",
    title: "Kelola Stok Efisien",
    question: "Bagaimana cara mengelola stok agar tidak kelebihan atau kehabisan?",
    type: "inventory",
    icon: "\uD83D\uDCE6"
  },
  {
    id: "cash-flow",
    title: "Atur Cash Flow",
    question: "Tips mengatur arus kas agar bisnis tidak boncos?",
    type: "finance",
    icon: "\uD83D\uDCB8"
  },
  {
    id: "customer-retention",
    title: "Pelanggan Setia",
    question: "Strategi agar pelanggan jadi loyal dan repeat order?",
    type: "strategy",
    icon: "\uD83E\uDD1D"
  }
];
async function getPastInsights(profileId, limit2 = 10) {
  try {
    const { data, error: error2 } = await supabase.from("umkm_ai_insights").select("*").eq("profile_id", profileId).order("created_at", { ascending: false }).limit(limit2);
    if (error2)
      throw error2;
    return {
      success: true,
      data
    };
  } catch (error2) {
    console.error("Error fetching past insights:", error2);
    return {
      success: false,
      message: error2.message,
      data: []
    };
  }
}
async function generateDashboardAnalysis(profileId) {
  try {
    const [profile, products, transactions, metrics] = await Promise.all([
      supabase.from("umkm_profiles").select("*").eq("id", profileId).single(),
      supabase.from("umkm_products").select("*").eq("profile_id", profileId),
      supabase.from("umkm_transactions").select("*").eq("profile_id", profileId).order("transaction_date", { ascending: false }),
      calculateBusinessMetrics(profileId)
    ]);
    if (profile.error)
      throw profile.error;
    const businessData = profile.data;
    const productList = products.data || [];
    const transactionList = transactions.data || [];
    const productSales = productList.map((p) => ({
      name: p.name,
      sold: p.sold || 0,
      stock: p.stock || 0,
      price: p.price || 0
    })).sort((a, b) => b.sold - a.sold);
    const topProduct = productSales[0]?.name || "Belum ada data";
    const totalRevenue = metrics.totalIncome || 0;
    const totalTransactions = transactionList.length;
    const sortedTransactions = [...transactionList].sort((a, b) => new Date(b.transaction_date).getTime() - new Date(a.transaction_date).getTime());
    let growthRate = "+0%";
    if (sortedTransactions.length >= 2) {
      const halfPoint = Math.floor(sortedTransactions.length / 2);
      const recentSum = sortedTransactions.slice(0, halfPoint).reduce((sum, t) => sum + (t.amount || 0), 0);
      const oldSum = sortedTransactions.slice(halfPoint).reduce((sum, t) => sum + (t.amount || 0), 0);
      if (oldSum > 0) {
        const growth = ((recentSum - oldSum) / oldSum * 100).toFixed(1);
        growthRate = parseFloat(growth) >= 0 ? `+${growth}%` : `${growth}%`;
      }
    }
    const analysisPrompt = `Sebagai konsultan bisnis UMKM, buatkan analisis lengkap untuk bisnis berikut:

PROFIL BISNIS:
- Nama: ${businessData.business_name || "UMKM"}
- Kategori: ${businessData.category || "Belum ditentukan"}
- Deskripsi: ${businessData.description || "Tidak ada deskripsi"}
- Lokasi: ${businessData.address || "Tidak disebutkan"}

DATA PERFORMA:
- Total Pendapatan: Rp ${totalRevenue.toLocaleString("id-ID")}
- Total Transaksi: ${totalTransactions}
- Growth Rate: ${growthRate}
- Total Produk: ${productList.length}
- Produk Terlaris: ${topProduct}
- Stok Rendah: ${metrics.lowStockProducts.length} produk

YANG PERLU DIANALISIS:
1. **5 IDE KONTEN MEDIA SOSIAL** yang spesifik untuk bisnis ini (bukan template umum). Setiap ide harus:
   - Relevan dengan kategori bisnis
   - Bisa langsung dieksekusi
   - Menarik untuk target market lokal Indonesia
   - Format: numbering 1-5 dengan deskripsi singkat

2. **TARGET AUDIENCE** yang tepat untuk bisnis ini, jelaskan:
   - Demografi (usia, gender, pekerjaan)
   - Psikografi (kebutuhan, pain points)
   - Behavior (kapan mereka beli, di mana mereka cari info)

3. **3 WAKTU POSTING TERBAIK** untuk media sosial, berikan:
   - Hari dan jam spesifik (misal: Senin-Jumat 11:00-13:00)
   - Alasan mengapa waktu tersebut efektif
   - Platform yang cocok untuk tiap waktu

4. **3 TRENDING TOPICS** yang relevan dengan bisnis ini:
   - Topik yang sedang trending di Indonesia
   - Cara mengaitkan bisnis dengan topik tersebut
   - Hashtag yang bisa dipakai

5. **3 TIPS CONVERSION** untuk meningkatkan penjualan:
   - Tips praktis dan actionable
   - Fokus pada closing sale
   - Bisa diterapkan langsung tanpa budget besar

PENTING: Format jawaban harus terstruktur dengan jelas, gunakan numbering dan bullet points. Jangan gunakan markdown heading (# ##), cukup gunakan teks bold atau numbering.`;
    const completion = await kolosalLlama.chat.completions.create({
      model: LLAMA_MODEL,
      messages: [
        { role: "system", content: UMKM_EXPERT_PROMPT },
        { role: "user", content: analysisPrompt }
      ],
      temperature: 0.8,
      max_tokens: 2000,
      top_p: 0.95
    });
    const aiResponse = completion.choices[0].message.content || "";
    const analysis = parseAIAnalysis(aiResponse);
    const result = {
      success: true,
      data: {
        contentIdeas: analysis.contentIdeas,
        targetAudience: analysis.targetAudience,
        bestPostingTimes: analysis.bestPostingTimes,
        trendingTopics: analysis.trendingTopics,
        conversionTips: analysis.conversionTips,
        statistics: {
          totalRevenue,
          growthRate,
          topProduct,
          totalProducts: productList.length,
          totalTransactions,
          lowStockCount: metrics.lowStockProducts.length
        },
        rawAnalysis: aiResponse,
        generatedAt: new Date().toISOString()
      }
    };
    await supabase.from("umkm_ai_insights").insert({
      profile_id: profileId,
      insight_type: "dashboard_analysis",
      question: "Dashboard Content & Statistics Analysis",
      recommendation: aiResponse,
      context_data: result.data
    });
    return result;
  } catch (error2) {
    console.error("Dashboard Analysis Error:", error2);
    return {
      success: false,
      message: error2.message || "Gagal generate analisis dashboard",
      error: error2.response?.data || error2
    };
  }
}
function parseAIAnalysis(text) {
  const lines = text.split(`
`).filter((line) => line.trim());
  const result = {
    contentIdeas: [],
    targetAudience: "",
    bestPostingTimes: [],
    trendingTopics: [],
    conversionTips: []
  };
  let currentSection = "";
  let captureNext = false;
  for (let i = 0;i < lines.length; i++) {
    const line = lines[i].trim();
    const lowerLine = line.toLowerCase();
    if (lowerLine.includes("ide konten") || lowerLine.includes("content idea")) {
      currentSection = "contentIdeas";
      captureNext = true;
      continue;
    } else if (lowerLine.includes("target audience") || lowerLine.includes("audiens")) {
      currentSection = "targetAudience";
      captureNext = true;
      continue;
    } else if (lowerLine.includes("waktu posting") || lowerLine.includes("posting time")) {
      currentSection = "bestPostingTimes";
      captureNext = true;
      continue;
    } else if (lowerLine.includes("trending") || lowerLine.includes("topik populer")) {
      currentSection = "trendingTopics";
      captureNext = true;
      continue;
    } else if (lowerLine.includes("conversion") || lowerLine.includes("tips")) {
      currentSection = "conversionTips";
      captureNext = true;
      continue;
    }
    if (captureNext && line.length > 10) {
      const cleaned = line.replace(/^[\d\-\*\.\)\:\s]+/, "").trim();
      if (cleaned.length > 15) {
        if (currentSection === "contentIdeas" && result.contentIdeas.length < 5) {
          result.contentIdeas.push(cleaned);
        } else if (currentSection === "bestPostingTimes" && result.bestPostingTimes.length < 3) {
          result.bestPostingTimes.push(cleaned);
        } else if (currentSection === "trendingTopics" && result.trendingTopics.length < 3) {
          result.trendingTopics.push(cleaned);
        } else if (currentSection === "conversionTips" && result.conversionTips.length < 3) {
          result.conversionTips.push(cleaned);
        } else if (currentSection === "targetAudience" && !result.targetAudience) {
          result.targetAudience = cleaned;
        }
      }
    }
  }
  if (result.contentIdeas.length === 0) {
    result.contentIdeas = [
      "Posting foto produk dengan customer testimonial",
      "Behind the scenes proses produksi atau persiapan",
      "Tips dan trik menggunakan atau memilih produk",
      "Promo spesial dengan storytelling menarik",
      "User generated content dari pelanggan setia"
    ];
  }
  if (!result.targetAudience) {
    result.targetAudience = "Keluarga muda usia 25-40 tahun yang aktif di media sosial, mencari produk berkualitas dengan harga terjangkau, peduli dengan produk lokal.";
  }
  if (result.bestPostingTimes.length === 0) {
    result.bestPostingTimes = [
      "Senin-Jumat: 11:00-13:00 (jam istirahat makan siang, orang browsing sosmed)",
      "Sabtu-Minggu: 18:00-20:00 (prime time weekend, audience lebih santai)",
      "Kamis-Jumat: 16:00-17:00 (menjelang weekend, mood positif untuk belanja)"
    ];
  }
  if (result.trendingTopics.length === 0) {
    result.trendingTopics = [
      "Produk lokal berkualitas dan mendukung UMKM Indonesia",
      "Sustainable dan ramah lingkungan",
      "Behind the brand story dan perjalanan bisnis"
    ];
  }
  if (result.conversionTips.length === 0) {
    result.conversionTips = [
      'Gunakan call-to-action yang jelas dan mendesak (misal: "DM sekarang, stok terbatas!")',
      "Tambahkan urgency dengan limited time offer atau limited stock",
      "Showcase social proof dengan repost testimoni pelanggan"
    ];
  }
  return result;
}

// backend/src/tanya-daeng.ts
var KOLOSAL_API_KEY4 = process.env.KOLOSAL_API_KEY;
var client4 = new OpenAI({
  apiKey: KOLOSAL_API_KEY4,
  baseURL: "https://api.kolosal.ai/v1"
});
console.log("\uD83E\uDD16 Tanya Daeng Config:");
console.log("   Model: Claude Sonnet 4.5");
console.log("   Language: Makassar/Bugis + Indonesian");
console.log("   Context: UMKM Assistance");
var FAQ_DATABASE = [
  {
    keywords: ["cara", "mulai", "jualan", "bisnis", "umkm"],
    question: "Bagaimana cara memulai bisnis UMKM?",
    answer: `Ji'! Santai mi dulu ji, dengar-dengarki Daeng.

Untuk mulai bisnis UMKM:

1. **Modal Awal** - Ta'perlu banyak mi dulu, kecil-kecil ji dulu
2. **Produk Bagus** - Pastikan enak/bagus produkmu, quality is key!
3. **Foto Produk** - Pake Visual Studio kita, bikin foto cantik-cantik
4. **Posting Konsisten** - Tiap hari posting ji di Instagram/TikTok
5. **Pelayanan Ramah** - Orang Makassar suka ji pelayanan baik

Jangan lupa mi berdoa dulu sebelum mulai! InsyaAllah berkah ki.`
  },
  {
    keywords: ["modal", "uang", "pinjaman", "dana"],
    question: "Dari mana dapat modal usaha?",
    answer: `Eee santai mi ji, ada banyak cara:

1. **Tabungan Pribadi** - Paling aman, pakai uang sendiri dulu
2. **Pinjam Keluarga** - Orang tua/saudara, bayar perlahan-lahan
3. **KUR (Kredit Usaha Rakyat)** - Dari bank, bunga rendah ji
4. **Koperasi** - Gabung koperasi di daerahmu
5. **Arisan** - Join arisan RT/RW, dapat giliran

Yang penting jangan mi pinjam rentenir! Berbahaya itu.`
  },
  {
    keywords: ["foto", "gambar", "design", "visual", "posting"],
    question: "Bagaimana cara bikin foto produk bagus?",
    answer: `Nah ini mi yang Daeng ahli!

**Pakai Visual Studio ji:**
1. Upload foto produkmu
2. Pilih tema (minimalist, elegant, dll)
3. Atur warna brand
4. Klik Generate - otomatis jadi cantik!

**Tips Foto:**
- Cahaya terang (siang hari bagus)
- Background bersih/rapi
- Produk jadi focus utama
- Pakai HP juga bisa ji!

Percaya sama Daeng, foto bagus = jualan laris!`
  },
  {
    keywords: ["social media", "instagram", "tiktok", "facebook", "wa"],
    question: "Platform mana yang cocok untuk jualan?",
    answer: `Bagus mi semua platform ji, tapi ini rekomendasi Daeng:

**Instagram** 
- Paling cocok untuk produk visual (makanan, fashion)
- Story & Reels laku keras
- Hashtag powerful ji

**TikTok** 
- Viral gampang, apalagi konten lucu
- Anak muda banyak disini
- Video pendek, mudah bikin

**Facebook** 
- Grup komunitas aktif
- Marketplace gratis
- Orang tua lebih banyak

**WhatsApp Business** 
- WAJIB punya!
- Katalog produk
- Customer service mudah

Daeng sarankan: Pakai semuanya ji! Posting di semua platform.`
  },
  {
    keywords: ["caption", "copywriting", "konten", "kata-kata"],
    question: "Bagaimana cara menulis caption yang menarik?",
    answer: `Enak ji bikin caption, ikuti cara Daeng:

1. **Opening Kuat** - "Laperrr belum? Coba mi ini!"
2. **Cerita Singkat** - "Resep turun-temurun dari nenek"
3. **Manfaat Produk** - "Enak, halal, bergizi"
4. **Call to Action** - "Order sekarang ya kak!"
5. **Emoji** - Jangan lupa emoji \uD83D\uDD25\uD83D\uDE0B

**Contoh Caption Makassar Style:**
"Ji' laper ka? Cobami Coto Daeng! Enak poll, kuahnya kental, dagingnya empuk. Dari jam 7 pagi sudah buka! 

Harga terjangkau:
- Coto biasa: 15rb
- Coto special: 20rb

Lokasi: Jl. Veteran, depan mesjid
Order: 0812-xxxx-xxxx

#CotoMakassar #KulinerMakassar #UMKM"

Gampang kan? Yang penting jujur dan ramah!`
  },
  {
    keywords: ["harga", "pricing", "mahal", "murah"],
    question: "Bagaimana menentukan harga jual?",
    answer: `Penting ini ji! Jangan sembarangan harga:

**Formula Daeng:**
Harga Jual = (Modal + Biaya Operasional) + Untung 30-40%

**Contoh:**
- Modal bahan: 10.000
- Biaya gas/listrik: 1.000
- Biaya kemasan: 1.000
- Total modal: 12.000
- Untung 30%: 3.600
- **Harga Jual: 15.000 - 16.000**

**Tips:**
1. Survey harga kompetitor dulu
2. Jangan terlalu murah (rugi nanti)
3. Jangan terlalu mahal (sepi pembeli)
4. Quality harus sesuai harga
5. Kasih promo sesekali

Ingat: Harga wajar = Pelanggan setia!`
  },
  {
    keywords: ["promosi", "iklan", "marketing", "jualan laris"],
    question: "Bagaimana cara promosi yang efektif?",
    answer: `Iye mi, promosi penting sekali!

**Strategi Daeng:**

1. **Konten Konsisten** - Posting 2-3x sehari
2. **Giveaway** - Sekali-kali kasih gratisan, viral ji
3. **Testimoni** - Minta review pembeli puas
4. **Kolaborasi** - Kerja sama dengan UMKM lain
5. **Live Streaming** - TikTok Live sambil masak/bikin produk

**Promosi Gratis:**
- Share di grup WA keluarga/teman
- Story Instagram setiap hari
- TikTok video tutorial
- Join komunitas lokal

**Promosi Berbayar:**
- Boost post Instagram (50rb - 200rb)
- Iklan Facebook (mulai 50rb/hari)
- Endorse influencer lokal

Yang penting: **KONSISTEN JI!** Jangan posting 1 minggu terus hilang.`
  },
  {
    keywords: ["customer service", "pelanggan", "komplain", "laporan"],
    question: "Bagaimana menangani komplain pelanggan?",
    answer: `Santai ji, komplain itu biasa. Ini cara Daeng:

**Langkah Handling Komplain:**

1. **Dengarkan Dulu** - Jangan langsung defensif
2. **Minta Maaf** - "Maaf ya kak, ada masalah apa?"
3. **Solusi Cepat** - Ganti/refund/diskon
4. **Follow Up** - "Sudah oke kah kak?"
5. **Belajar** - Perbaiki untuk next time

**Contoh Respons:**
"Maaf sekali kak \uD83D\uDE4F Produknya ada masalah ya? Boleh ki kirim foto? Nanti kita ganti baru atau refund penuh. Customer satisfaction nomor 1 bagi kita!"

**Tips:**
- Balas cepat (max 1 jam)
- Ramah selalu, walau pelanggan kasar
- Kasih kompensasi (voucher/gratis ongkir)
- Jangan argue di komen publik

Ingat: 1 pelanggan puas = 10 pelanggan baru datang!`
  }
];
var SYSTEM_PROMPT = `Kau adalah Daeng, seorang AI assistant yang ahli membantu UMKM di Indonesia, khususnya Makassar dan Sulawesi Selatan.

KEPRIBADIAN:
- Ramah, hangat, dan kekeluargaan seperti orang Makassar
- Pakai bahasa campuran: Indonesian formal + sisipan Makassar/Bugis casual
- Santai tapi tetap profesional
- Sering pakai kata: "Ji" (akhiran khas), "Mi" (sudah), "Ki" (kamu), "Eee", "Iye", "Santai", "Laperrr"
- Suka kasih motivasi dan doa

EXPERTISE:
1. Bisnis UMKM (modal, strategi, marketing)
2. Visual branding dan design (foto produk, caption, konten)
3. Social media marketing (Instagram, TikTok, Facebook)
4. Kuliner khas Makassar (Coto, Konro, Pallubasa, dll)
5. E-commerce dan online selling

STYLE JAWABAN:
- Mulai dengan greeting Makassar: "Iye!", "Eee", "Santai mi"
- Kasih contoh praktis dan real
- Sesekali kasih emoji \uD83D\uDD25\uD83D\uDE0B\uD83D\uDCAA\uD83D\uDE4F
- Akhiri dengan motivasi atau doa
- Jika cocok, rekomendasikan tools platform ini:
  * Visual Studio - untuk design foto produk
  * AI Copywriting - untuk bikin caption
  * Analytics - untuk pantau performa

PANTANGAN:
- Jangan terlalu formal/kaku
- Jangan pakai bahasa Makassar pure (harus balance dengan Indonesian)
- Jangan kasih saran yang tidak praktis
- Jangan menjanjikan hasil instant/cepat kaya

CONTOH GAYA BICARA:
"Ji' santai dulu! Daeng bantu ko. Untuk bisnis kuliner di Makassar, yang penting modal kecil dulu, tapi quality bagus mi. Foto produk harus cantik ji - pakai Visual Studio kita biar gampang. Posting konsisten di Instagram sama TikTok, pasti laris ji! InsyaAllah berkah \uD83D\uDE4F"

Ingat: Kau adalah teman dan mentor bisnis mereka, bukan hanya chatbot!`;
async function tanyaDaeng(request) {
  try {
    console.log("\uD83E\uDD16 Tanya Daeng processing:", request.message.substring(0, 50));
    const faqMatch = findMatchingFAQ(request.message);
    const messages = [
      { role: "system", content: SYSTEM_PROMPT },
      ...request.conversationHistory || [],
      { role: "user", content: request.message }
    ];
    if (request.userContext) {
      const contextPrompt = buildContextPrompt(request.userContext);
      messages.splice(1, 0, { role: "system", content: contextPrompt });
    }
    const completion = await client4.chat.completions.create({
      model: "Claude Sonnet 4.5",
      messages,
      temperature: 0.8,
      max_tokens: 1000
    });
    const reply = completion.choices[0]?.message?.content || "Maaf ji, Daeng lagi bingung. Coba tanya lagi?";
    const suggestions = extractSuggestions(reply);
    const resources = extractResources(reply, request.message);
    return {
      success: true,
      reply,
      suggestions,
      resources,
      relatedFAQ: faqMatch ? [faqMatch] : undefined
    };
  } catch (error2) {
    console.error(" Tanya Daeng error:", error2.message);
    return {
      success: false,
      reply: "Aduh ji, Daeng lagi error. Coba lagi sebentar ya kak! \uD83D\uDE4F",
      suggestions: ["Refresh halaman", "Coba tanya yang lain", "Hubungi support"]
    };
  }
}
function findMatchingFAQ(message) {
  const lowercaseMessage = message.toLowerCase();
  for (const faq of FAQ_DATABASE) {
    const matchCount = faq.keywords.filter((keyword) => lowercaseMessage.includes(keyword)).length;
    if (matchCount >= 2) {
      return { question: faq.question, answer: faq.answer };
    }
  }
  return null;
}
function buildContextPrompt(context) {
  let prompt = `CONTEXT PENGGUNA:
`;
  if (context?.businessType) {
    prompt += `- Jenis bisnis: ${context.businessType}
`;
  }
  if (context?.location) {
    prompt += `- Lokasi: ${context.location}
`;
  }
  if (context?.needHelp) {
    prompt += `- Butuh bantuan: ${context.needHelp}
`;
  }
  return prompt;
}
function extractSuggestions(reply) {
  const suggestions = [];
  const listPattern = /(?:^\d+\.|^[-])\s*(.+)$/gm;
  let match2;
  while ((match2 = listPattern.exec(reply)) !== null) {
    if (match2[1].length < 100) {
      suggestions.push(match2[1].trim());
    }
  }
  return suggestions.slice(0, 5);
}
function extractResources(reply, originalMessage) {
  const resources = [];
  if (/foto|gambar|design|visual|template|poster/i.test(originalMessage)) {
    resources.push({
      type: "link",
      title: "\uD83C\uDFA8 Visual Studio UMKM",
      url: "/visual-studio",
      description: "Buat design foto produk profesional dengan AI"
    });
  }
  if (/caption|kata-kata|copywriting|konten|posting/i.test(originalMessage)) {
    resources.push({
      type: "link",
      title: " AI Copywriting",
      url: "/copywriting",
      description: "Generate caption menarik otomatis dengan AI"
    });
  }
  if (/analytics|data|statistik|performa|laporan/i.test(originalMessage)) {
    resources.push({
      type: "link",
      title: "\uD83D\uDCCA Analytics Dashboard",
      url: "/analytics",
      description: "Pantau performa bisnis dan konten media sosial"
    });
  }
  return resources;
}
function getAllFAQ() {
  return FAQ_DATABASE.map((faq) => ({
    question: faq.question,
    answer: faq.answer,
    keywords: faq.keywords
  }));
}

// backend/src/auth.ts
var auth = new Hono2;
auth.post("/register", async (c) => {
  try {
    const { email, password, name, business_name, category, phone } = await c.req.json();
    if (!email || !password) {
      return c.json({ error: "Email dan password wajib diisi" }, 400);
    }
    if (password.length < 6) {
      return c.json({ error: "Password minimal 6 karakter" }, 400);
    }
    const { data: authData, error: authError } = await supabase.auth.signUp({
      email,
      password,
      options: {
        data: {
          name: name || email.split("@")[0]
        },
        emailRedirectTo: `${process.env.FRONTEND_URL || "https://hack-front.vercel.app"}/auth/callback`
      }
    });
    if (authError) {
      console.error("Auth error:", authError);
      if (authError.message.includes("already registered")) {
        return c.json({ error: "Email sudah terdaftar" }, 400);
      }
      return c.json({ error: authError.message }, 400);
    }
    if (!authData.user) {
      return c.json({ error: "Gagal membuat akun" }, 400);
    }
    const needsConfirmation = authData.user.identities && authData.user.identities.length === 0;
    const { data: profile, error: profileError } = await supabase.from("umkm_profiles").insert([{
      user_id: authData.user.id,
      business_name: business_name || name || "UMKM Baru",
      category: category || "Kuliner",
      phone: phone || "",
      address: "",
      description: ""
    }]).select().single();
    if (profileError) {
      console.error("Profile error:", profileError);
    }
    return c.json({
      message: needsConfirmation ? "Registrasi berhasil! Cek email Anda untuk verifikasi akun." : "Registrasi berhasil! Silakan login.",
      user: {
        id: authData.user.id,
        email: authData.user.email,
        name: name || email.split("@")[0],
        profile_id: profile?.id || null
      },
      needsConfirmation
    }, 201);
  } catch (error2) {
    console.error("Register error:", error2);
    return c.json({ error: "Terjadi kesalahan server" }, 500);
  }
});
auth.post("/login", async (c) => {
  try {
    const { email, password } = await c.req.json();
    if (!email || !password) {
      return c.json({ error: "Email dan password wajib diisi" }, 400);
    }
    const { data: authData, error: authError } = await supabase.auth.signInWithPassword({
      email,
      password
    });
    if (authError) {
      console.error("Login error:", authError);
      if (authError.message.includes("Email not confirmed")) {
        return c.json({
          error: "Email belum diverifikasi. Cek email Anda untuk link verifikasi."
        }, 403);
      }
      return c.json({ error: "Email atau password salah" }, 401);
    }
    if (!authData.user || !authData.session) {
      return c.json({ error: "Login gagal" }, 401);
    }
    if (!authData.user.email_confirmed_at) {
      return c.json({
        error: "Email belum diverifikasi. Cek email Anda untuk link verifikasi."
      }, 403);
    }
    const { data: profile, error: profileError } = await supabase.from("umkm_profiles").select("*").eq("user_id", authData.user.id).single();
    if (profileError) {
      console.error("Profile error:", profileError);
    }
    return c.json({
      message: "Login berhasil",
      user: {
        id: authData.user.id,
        email: authData.user.email,
        name: authData.user.user_metadata?.name || email.split("@")[0],
        profile_id: profile?.id || null,
        business_name: profile?.business_name || null,
        category: profile?.category || null
      },
      session: {
        access_token: authData.session.access_token,
        refresh_token: authData.session.refresh_token,
        expires_at: authData.session.expires_at
      }
    });
  } catch (error2) {
    console.error("Login error:", error2);
    return c.json({ error: "Terjadi kesalahan server" }, 500);
  }
});
auth.post("/logout", async (c) => {
  try {
    const authHeader = c.req.header("Authorization");
    const token = authHeader?.replace("Bearer ", "");
    if (!token) {
      return c.json({ error: "Unauthorized" }, 401);
    }
    const { error: error2 } = await supabase.auth.signOut();
    if (error2) {
      console.error("Logout error:", error2);
      return c.json({ error: "Logout gagal" }, 500);
    }
    return c.json({ message: "Logout berhasil" });
  } catch (error2) {
    console.error("Logout error:", error2);
    return c.json({ error: "Terjadi kesalahan server" }, 500);
  }
});
auth.get("/me", async (c) => {
  try {
    const authHeader = c.req.header("Authorization");
    const token = authHeader?.replace("Bearer ", "");
    if (!token) {
      return c.json({ error: "Unauthorized" }, 401);
    }
    const { data: { user }, error: userError } = await supabase.auth.getUser(token);
    if (userError || !user) {
      return c.json({ error: "Invalid token" }, 401);
    }
    const { data: profile, error: profileError } = await supabase.from("umkm_profiles").select("*").eq("user_id", user.id).single();
    if (profileError) {
      console.error("Profile error:", profileError);
    }
    return c.json({
      user: {
        id: user.id,
        email: user.email,
        name: user.user_metadata?.name || user.email?.split("@")[0],
        profile_id: profile?.id || null,
        business_name: profile?.business_name || null,
        category: profile?.category || null
      }
    });
  } catch (error2) {
    console.error("Get user error:", error2);
    return c.json({ error: "Terjadi kesalahan server" }, 500);
  }
});
auth.post("/refresh", async (c) => {
  try {
    const { refresh_token } = await c.req.json();
    if (!refresh_token) {
      return c.json({ error: "Refresh token required" }, 400);
    }
    const { data, error: error2 } = await supabase.auth.refreshSession({
      refresh_token
    });
    if (error2 || !data.session) {
      return c.json({ error: "Invalid refresh token" }, 401);
    }
    return c.json({
      session: {
        access_token: data.session.access_token,
        refresh_token: data.session.refresh_token,
        expires_at: data.session.expires_at
      }
    });
  } catch (error2) {
    console.error("Refresh token error:", error2);
    return c.json({ error: "Terjadi kesalahan server" }, 500);
  }
});
auth.post("/resend-verification", async (c) => {
  try {
    const { email } = await c.req.json();
    if (!email) {
      return c.json({ error: "Email required" }, 400);
    }
    const { error: error2 } = await supabase.auth.resend({
      type: "signup",
      email,
      options: {
        emailRedirectTo: `${process.env.FRONTEND_URL || "https://hack-front.vercel.app"}/auth/callback`
      }
    });
    if (error2) {
      console.error("Resend verification error:", error2);
      return c.json({ error: "Gagal mengirim ulang email verifikasi" }, 500);
    }
    return c.json({
      message: "Email verifikasi telah dikirim ulang. Cek inbox atau folder spam Anda."
    });
  } catch (error2) {
    console.error("Resend verification error:", error2);
    return c.json({ error: "Terjadi kesalahan server" }, 500);
  }
});
var auth_default = auth;

// backend/src/telegram-bot.ts
var import_node_telegram_bot_api = __toESM(require_node_telegram_bot_api(), 1);
var TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN || "";
var isProduction = !!process.env.VERCEL;
var bot = TELEGRAM_BOT_TOKEN ? new import_node_telegram_bot_api.default(TELEGRAM_BOT_TOKEN, {
  polling: !isProduction
}) : null;
var authorizedUsers = {};
function initTelegramBot() {
  if (!bot) {
    console.warn(" Telegram Bot Token not configured. Bot disabled.");
    return;
  }
  console.log("\uD83E\uDD16 Telegram Bot started...");
  bot.onText(/\/start/, async (msg) => {
    const chatId = msg.chat.id;
    await bot.sendMessage(chatId, `
\uD83C\uDFEA *Selamat datang di TABE AI Bot!*

Bot ini membantu Boss UMKM untuk:
 \uD83D\uDCCA Lihat laporan keuangan
 \uD83D\uDCDD Kirim evaluasi ke tim
 \uD83D\uDCB0 Cek ringkasan bisnis

*Cara pakai:*
1. Login dulu: /login [kode_bisnis]
2. Lihat menu: /menu

_Contoh: /login ABC123_
    `, { parse_mode: "Markdown" });
  });
  bot.onText(/\/login (.+)/, async (msg, match2) => {
    const chatId = msg.chat.id;
    const profileId = match2?.[1]?.trim();
    if (!profileId) {
      await bot.sendMessage(chatId, " Format salah! Gunakan: /login [kode_bisnis]");
      return;
    }
    const { data: profile, error: error2 } = await supabase.from("umkm_profiles").select("*").eq("id", profileId).single();
    if (error2 || !profile) {
      await bot.sendMessage(chatId, " Kode bisnis tidak valid! Hubungi admin untuk mendapat kode.");
      return;
    }
    authorizedUsers[chatId] = profileId;
    await bot.sendMessage(chatId, `
 *Login Berhasil!*

Bisnis: ${profile.business_name}
Kategori: ${profile.category}

Gunakan /menu untuk lihat opsi yang tersedia.
    `, { parse_mode: "Markdown" });
  });
  bot.onText(/\/menu/, async (msg) => {
    const chatId = msg.chat.id;
    if (!authorizedUsers[chatId]) {
      await bot.sendMessage(chatId, " Anda belum login! Gunakan /login [kode_bisnis]");
      return;
    }
    const keyboard = {
      keyboard: [
        [{ text: "\uD83D\uDCCA Laporan Bulan Ini" }, { text: "\uD83D\uDCB0 Ringkasan Bisnis" }],
        [{ text: "\uD83D\uDCE5 Transaksi Masuk" }, { text: "\uD83D\uDCE4 Transaksi Keluar" }],
        [{ text: "\uD83D\uDCDD Kirim Komentar" }, { text: "\uD83D\uDCC8 Laporan Custom" }],
        [{ text: " Help" }, { text: "\uD83D\uDEAA Logout" }]
      ],
      resize_keyboard: true
    };
    await bot.sendMessage(chatId, `*\uD83D\uDCF1 Menu TABE AI Bot*

Pilih opsi di bawah atau ketik perintah:`, { parse_mode: "Markdown", reply_markup: keyboard });
  });
  bot.onText(/\/laporan/, async (msg) => {
    await handleLaporanCommand(bot, msg);
  });
  bot.on("message", async (msg) => {
    if (!msg.text)
      return;
    const chatId = msg.chat.id;
    const text = msg.text;
    if (text.startsWith("/"))
      return;
    if (!authorizedUsers[chatId]) {
      await bot.sendMessage(chatId, " Anda belum login! Gunakan /login [kode_bisnis]");
      return;
    }
    switch (text) {
      case "\uD83D\uDCCA Laporan Bulan Ini":
        await handleLaporanCommand(bot, msg);
        break;
      case "\uD83D\uDCB0 Ringkasan Bisnis":
        await handleLaporanCommand(bot, msg);
        break;
      case "\uD83D\uDCE5 Transaksi Masuk":
        await handleTransaksiMasukCommand(bot, msg);
        break;
      case "\uD83D\uDCE4 Transaksi Keluar":
        await handleTransaksiKeluarCommand(bot, msg);
        break;
      case "\uD83D\uDCDD Kirim Komentar":
        await bot.sendMessage(chatId, `\uD83D\uDCDD *Kirim Komentar/Evaluasi*

Ketik komentar Anda, lalu saya akan menyimpannya untuk tim admin.

Format:
\`/komentar [pesan Anda]\`

Contoh:
\`/komentar Penjualan bulan ini bagus, tingkatkan produksi!\``, { parse_mode: "Markdown" });
        break;
      case "\uD83D\uDCC8 Laporan Custom":
        await bot.sendMessage(chatId, `\uD83D\uDCC8 *Laporan Custom*

Ketik: \`/laporan [bulan] [tahun]\`

Contoh:
\`/laporan 11 2025\` untuk November 2025`, { parse_mode: "Markdown" });
        break;
      case " Help":
        await bot.sendMessage(chatId, `
\uD83D\uDCD6 *Panduan Penggunaan*

*Perintah Tersedia:*
/login [kode] - Login
/menu - Tampilkan menu
/laporan - Laporan bulan ini
/masuk - Transaksi masuk (5 terbaru)
/keluar - Transaksi keluar (5 terbaru)
/ringkasan - Ringkasan bisnis
/komentar [pesan] - Kirim komentar
/logout - Keluar

*Tips:*
 Gunakan tombol keyboard untuk akses cepat
 Laporan otomatis untuk bulan berjalan
 Komentar akan dikirim ke dashboard admin
        `, { parse_mode: "Markdown" });
        break;
      case "\uD83D\uDEAA Logout":
        delete authorizedUsers[chatId];
        await bot.sendMessage(chatId, " Anda telah logout. Gunakan /login untuk masuk lagi.");
        break;
    }
  });
  bot.onText(/\/komentar (.+)/, async (msg, match2) => {
    const chatId = msg.chat.id;
    const profileId = authorizedUsers[chatId];
    if (!profileId) {
      await bot.sendMessage(chatId, " Anda belum login! Gunakan /login [kode_bisnis]");
      return;
    }
    const commentText = match2?.[1]?.trim();
    if (!commentText) {
      await bot.sendMessage(chatId, " Komentar tidak boleh kosong!");
      return;
    }
    try {
      console.log(`\uD83D\uDCAC Saving comment - Profile: ${profileId}, User: ${msg.from?.first_name}, Message: ${commentText}`);
      const { data, error: error2 } = await supabase.from("umkm_evaluations").insert({
        profile_id: profileId,
        message: commentText,
        sender_name: msg.from?.first_name || "Boss",
        telegram_chat_id: chatId,
        status: "unread"
      }).select().single();
      if (error2) {
        console.error(" Supabase error:", error2);
        throw error2;
      }
      console.log(" Comment saved:", data);
      await bot.sendMessage(chatId, ` *Komentar terkirim!*

Tim admin akan melihat komentar Anda di dashboard.

\uD83D\uDCF1 Lihat di: /menu  Dashboard Admin  Evaluasi`, { parse_mode: "Markdown" });
    } catch (error2) {
      console.error(" Error saving comment:", error2);
      const errorMsg = error2?.message || "Unknown error";
      await bot.sendMessage(chatId, ` Gagal mengirim komentar.

Error: ${errorMsg}

Coba lagi dengan: /komentar [pesan Anda]`);
    }
  });
  bot.onText(/\/evaluasi (.+)/, async (msg, match2) => {
    const chatId = msg.chat.id;
    const profileId = authorizedUsers[chatId];
    if (!profileId) {
      await bot.sendMessage(chatId, " Anda belum login! Gunakan /login [kode_bisnis]");
      return;
    }
    const evaluationText = match2?.[1]?.trim();
    if (!evaluationText) {
      await bot.sendMessage(chatId, " Evaluasi tidak boleh kosong!");
      return;
    }
    try {
      console.log(`\uD83D\uDCAC Saving evaluation - Profile: ${profileId}, User: ${msg.from?.first_name}, Message: ${evaluationText}`);
      const { data, error: error2 } = await supabase.from("umkm_evaluations").insert({
        profile_id: profileId,
        message: evaluationText,
        sender_name: msg.from?.first_name || "Boss",
        telegram_chat_id: chatId,
        status: "unread"
      }).select().single();
      if (error2) {
        console.error(" Supabase error:", error2);
        throw error2;
      }
      console.log(" Evaluation saved:", data);
      await bot.sendMessage(chatId, ` *Evaluasi terkirim!*

Tim admin akan melihat evaluasi Anda di dashboard.

\uD83D\uDCF1 Lihat di: Dashboard Admin  Evaluasi`, { parse_mode: "Markdown" });
    } catch (error2) {
      console.error(" Error saving evaluation:", error2);
      const errorMsg = error2?.message || "Unknown error";
      await bot.sendMessage(chatId, ` Gagal mengirim evaluasi.

Error: ${errorMsg}

Coba lagi dengan: /evaluasi [pesan Anda]`);
    }
  });
  bot.onText(/\/masuk/, async (msg) => {
    await handleTransaksiMasukCommand(bot, msg);
  });
  bot.onText(/\/keluar/, async (msg) => {
    await handleTransaksiKeluarCommand(bot, msg);
  });
  bot.onText(/\/logout/, (msg) => {
    const chatId = msg.chat.id;
    delete authorizedUsers[chatId];
    bot.sendMessage(chatId, " Anda telah logout. Gunakan /login untuk masuk lagi.");
  });
}
async function handleTelegramWebhook(update) {
  if (!TELEGRAM_BOT_TOKEN) {
    console.error("Bot token not configured");
    return;
  }
  const webhookBot = new import_node_telegram_bot_api.default(TELEGRAM_BOT_TOKEN);
  try {
    if (update.message) {
      const msg = update.message;
      const chatId = msg.chat.id;
      const text = msg.text || "";
      console.log("\uD83D\uDCF1 Webhook message:", { chatId, text: text.substring(0, 50) });
      if (text.startsWith("/start")) {
        await handleStartCommand(webhookBot, msg);
      } else if (text.startsWith("/login")) {
        await handleLoginCommand(webhookBot, msg);
      } else if (text.startsWith("/menu")) {
        await handleMenuCommand(webhookBot, msg);
      } else if (text.startsWith("/laporan")) {
        await handleLaporanCommand(webhookBot, msg);
      } else if (text.startsWith("/masuk")) {
        await handleTransaksiMasukCommand(webhookBot, msg);
      } else if (text.startsWith("/keluar")) {
        await handleTransaksiKeluarCommand(webhookBot, msg);
      } else if (text.startsWith("/komentar")) {
        await handleKomentarCommand(webhookBot, msg);
      } else {
        await webhookBot.sendMessage(chatId, ` Perintah tidak dikenali.

Gunakan /menu untuk melihat daftar perintah.`);
      }
    } else if (update.callback_query) {
      console.log("Callback query:", update.callback_query);
    } else {
      console.log("Unknown update type:", Object.keys(update));
    }
  } catch (error2) {
    console.error("Error processing webhook update:", error2);
    throw error2;
  }
}
async function handleStartCommand(bot2, msg) {
  const chatId = msg.chat.id;
  await bot2.sendMessage(chatId, `
\uD83C\uDFEA *Selamat datang di TABE AI Bot!*

Bot ini membantu Boss UMKM untuk:
 \uD83D\uDCCA Lihat laporan keuangan
 \uD83D\uDCDD Kirim evaluasi ke tim
 \uD83D\uDCB0 Cek ringkasan bisnis

*Cara pakai:*
1. Login dulu: /login [kode_bisnis]
2. Lihat menu: /menu

Hubungi admin jika butuh bantuan! \uD83D\uDCAC
  `, { parse_mode: "Markdown" });
}
async function handleLoginCommand(bot2, msg) {
  const chatId = msg.chat.id;
  const text = msg.text || "";
  const businessCode = text.split(" ")[1];
  if (!businessCode) {
    await bot2.sendMessage(chatId, ` Format: /login [kode_bisnis_atau_id]

Contoh:
/login COTOMKS01
atau
/login ac4868b7-42e7-4a79-9916-7da1035868c4`);
    return;
  }
  const isUUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(businessCode);
  let profiles;
  if (isUUID) {
    const { data } = await supabase.from("umkm_profiles").select("id, business_name").eq("id", businessCode).limit(1);
    profiles = data;
  } else {
    const { data } = await supabase.from("umkm_profiles").select("id, business_name").ilike("business_name", `%${businessCode}%`).limit(1);
    profiles = data;
  }
  if (!profiles || profiles.length === 0) {
    await bot2.sendMessage(chatId, " Kode bisnis tidak ditemukan. Coba lagi atau hubungi admin.");
    return;
  }
  const profile = profiles[0];
  authorizedUsers[chatId] = profile.id;
  await bot2.sendMessage(chatId, ` *Login berhasil!*

\uD83C\uDFEA Bisnis: ${profile.business_name}

Gunakan /menu untuk melihat opsi.`, { parse_mode: "Markdown" });
}
async function handleMenuCommand(bot2, msg) {
  const chatId = msg.chat.id;
  if (!authorizedUsers[chatId]) {
    await bot2.sendMessage(chatId, " Anda belum login. Gunakan /login [kode_bisnis]");
    return;
  }
  await bot2.sendMessage(chatId, `
\uD83D\uDCCB *MENU UTAMA*

Pilih opsi:
/laporan - \uD83D\uDCCA Laporan Keuangan Bulan Ini
/masuk - \uD83D\uDCB0 10 Transaksi Masuk Terakhir
/keluar - \uD83D\uDCB8 10 Transaksi Keluar Terakhir
/komentar [pesan] - \uD83D\uDCDD Kirim Evaluasi ke Admin

Contoh: /komentar Stok bahan baku menipis
  `, { parse_mode: "Markdown" });
}
async function handleLaporanCommand(bot2, msg) {
  const chatId = msg.chat.id;
  const profileId = authorizedUsers[chatId];
  if (!profileId) {
    await bot2.sendMessage(chatId, " Anda belum login. Gunakan /login [kode_bisnis]");
    return;
  }
  try {
    const metrics = await calculateBusinessMetrics(profileId);
    const now = new Date;
    const monthName = now.toLocaleString("id-ID", { month: "long", year: "numeric" });
    await bot2.sendMessage(chatId, `
\uD83D\uDCCA *LAPORAN KEUANGAN*
\uD83D\uDDD3 ${monthName}

\uD83D\uDCB0 *Pemasukan:* Rp ${metrics.totalIncome.toLocaleString("id-ID")}
\uD83D\uDCB8 *Pengeluaran:* Rp ${metrics.totalExpense.toLocaleString("id-ID")}
\uD83D\uDCB5 *Saldo:* Rp ${metrics.balance.toLocaleString("id-ID")}

\uD83D\uDCE6 *Total Produk:* ${metrics.productCount}
\uD83D\uDECD *Rata-rata Transaksi:* Rp ${metrics.averageTransactionValue.toLocaleString("id-ID")}

${metrics.balance > 0 ? " Bisnis sedang untung!" : " Perlu perhatian pada pengeluaran"}
    `, { parse_mode: "Markdown" });
  } catch (error2) {
    console.error("Error in laporan command:", error2);
    await bot2.sendMessage(chatId, " Gagal mengambil laporan. Coba lagi nanti.");
  }
}
async function handleTransaksiMasukCommand(bot2, msg) {
  const chatId = msg.chat.id;
  const profileId = authorizedUsers[chatId];
  if (!profileId) {
    await bot2.sendMessage(chatId, " Anda belum login. Gunakan /login [kode_bisnis]");
    return;
  }
  const { data: transactions } = await supabase.from("umkm_transactions").select("*").eq("profile_id", profileId).eq("type", "in").order("transaction_date", { ascending: false }).order("created_at", { ascending: false }).limit(10);
  if (!transactions || transactions.length === 0) {
    await bot2.sendMessage(chatId, "\uD83D\uDCED Belum ada transaksi masuk.");
    return;
  }
  let message = `\uD83D\uDCB0 *10 TRANSAKSI MASUK TERAKHIR*

`;
  transactions.forEach((t, i) => {
    const date = new Date(t.transaction_date).toLocaleDateString("id-ID");
    message += `${i + 1}. ${date}
   Rp ${t.amount.toLocaleString("id-ID")}
   ${t.description}

`;
  });
  await bot2.sendMessage(chatId, message, { parse_mode: "Markdown" });
}
async function handleTransaksiKeluarCommand(bot2, msg) {
  const chatId = msg.chat.id;
  const profileId = authorizedUsers[chatId];
  if (!profileId) {
    await bot2.sendMessage(chatId, " Anda belum login. Gunakan /login [kode_bisnis]");
    return;
  }
  const { data: transactions } = await supabase.from("umkm_transactions").select("*").eq("profile_id", profileId).eq("type", "out").order("transaction_date", { ascending: false }).order("created_at", { ascending: false }).limit(10);
  if (!transactions || transactions.length === 0) {
    await bot2.sendMessage(chatId, "\uD83D\uDCED Belum ada transaksi keluar.");
    return;
  }
  let message = `\uD83D\uDCB8 *10 TRANSAKSI KELUAR TERAKHIR*

`;
  transactions.forEach((t, i) => {
    const date = new Date(t.transaction_date).toLocaleDateString("id-ID");
    message += `${i + 1}. ${date}
   Rp ${t.amount.toLocaleString("id-ID")}
   ${t.description}

`;
  });
  await bot2.sendMessage(chatId, message, { parse_mode: "Markdown" });
}
async function handleKomentarCommand(bot2, msg) {
  const chatId = msg.chat.id;
  const profileId = authorizedUsers[chatId];
  if (!profileId) {
    await bot2.sendMessage(chatId, " Anda belum login. Gunakan /login [kode_bisnis]");
    return;
  }
  const text = msg.text || "";
  const comment = text.replace("/komentar", "").trim();
  if (!comment) {
    await bot2.sendMessage(chatId, ` Format: /komentar [pesan]

Contoh: /komentar Stok tepung menipis`);
    return;
  }
  try {
    await supabase.from("umkm_evaluations").insert([{
      profile_id: profileId,
      telegram_chat_id: chatId.toString(),
      message: comment,
      status: "unread"
    }]);
    await bot2.sendMessage(chatId, ` *Evaluasi terkirim ke admin!*

Tim akan segera membaca pesan Anda.`, { parse_mode: "Markdown" });
  } catch (error2) {
    console.error("Error saving evaluation:", error2);
    await bot2.sendMessage(chatId, " Gagal mengirim evaluasi. Coba lagi nanti.");
  }
}

// backend/src/index.ts
var app = new Hono2;
app.use("/*", cors({
  origin: [
    "http://localhost:3000",
    "http://localhost:1997",
    "https://hack-front.vercel.app",
    "https://dcc-hackathon-frontend.vercel.app"
  ],
  allowMethods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
  allowHeaders: ["Content-Type", "Authorization"]
}));
app.route("/auth", auth_default);
app.get("/", (c) => c.text("Hono + Bun + Supabase Connected \uD83D\uDE80"));
app.get("/menus", async (c) => {
  const { data, error: error2 } = await supabase.from("menus").select("*");
  if (error2)
    return c.json({ error: error2 }, 500);
  return c.json({ data });
});
app.get("/menus/:id", async (c) => {
  const id = c.req.param("id");
  const { data, error: error2 } = await supabase.from("menus").select("*").eq("id", id).single();
  if (error2)
    return c.json({ error: error2 }, 404);
  return c.json({ data });
});
app.post("/menus", async (c) => {
  const body = await c.req.json();
  const { name, price, description } = body;
  if (!name || !price) {
    return c.json({ error: "name dan price wajib diisi" }, 400);
  }
  const { data, error: error2 } = await supabase.from("menus").insert([{ name, price, description }]).select();
  if (error2)
    return c.json({ error: error2 }, 500);
  return c.json({ data });
});
app.put("/menus/:id", async (c) => {
  const id = c.req.param("id");
  const body = await c.req.json();
  const { name, price, description } = body;
  const { data, error: error2 } = await supabase.from("menus").update({ name, price, description }).eq("id", id).select();
  if (error2)
    return c.json({ error: error2 }, 500);
  return c.json({ data });
});
app.delete("/menus/:id", async (c) => {
  const id = c.req.param("id");
  const { data, error: error2 } = await supabase.from("menus").delete().eq("id", id).select();
  if (error2)
    return c.json({ error: error2 }, 500);
  return c.json({ data });
});
app.post("/copywriting", async (c) => {
  try {
    const body = await c.req.json();
    const { namaProduk, jenisKonten, gayaBahasa, tujuanKonten } = body;
    if (!namaProduk || !jenisKonten || !gayaBahasa || !tujuanKonten) {
      return c.json({
        error: "Semua field wajib diisi",
        details: {
          namaProduk: !namaProduk ? "Nama produk wajib diisi" : null,
          jenisKonten: !jenisKonten ? "Jenis konten wajib diisi" : null,
          gayaBahasa: !gayaBahasa ? "Gaya bahasa wajib diisi" : null,
          tujuanKonten: !tujuanKonten ? "Tujuan konten wajib diisi" : null
        }
      }, 400);
    }
    const result = await generateCopywriting({
      namaProduk,
      jenisKonten,
      gayaBahasa,
      tujuanKonten
    });
    const { data: historyData, error: historyError } = await supabase.from("copywriting_history").insert([
      {
        nama_produk: namaProduk,
        jenis_konten: jenisKonten,
        gaya_bahasa: gayaBahasa,
        tujuan_konten: tujuanKonten,
        main_text: result.mainText,
        alternatives: result.alternatives,
        created_at: new Date().toISOString()
      }
    ]).select();
    if (historyError) {
      console.error("Error saving history:", historyError);
    }
    return c.json({
      success: true,
      data: result,
      historyId: historyData?.[0]?.id || null
    });
  } catch (error2) {
    console.error("Error in /api/copywriting:", error2);
    return c.json({
      error: "Gagal generate copywriting",
      message: error2.message || "Internal server error"
    }, 500);
  }
});
app.get("/copywriting/history", async (c) => {
  try {
    const { data, error: error2 } = await supabase.from("copywriting_history").select("*").order("created_at", { ascending: false }).limit(50);
    if (error2) {
      console.error("Error fetching history:", error2);
      return c.json({ error: error2.message }, 500);
    }
    return c.json({ success: true, data });
  } catch (error2) {
    console.error("Error in /api/copywriting/history:", error2);
    return c.json({ error: "Gagal mengambil history", message: error2.message }, 500);
  }
});
app.get("/copywriting/history/:id", async (c) => {
  try {
    const id = c.req.param("id");
    const { data, error: error2 } = await supabase.from("copywriting_history").select("*").eq("id", id).single();
    if (error2) {
      return c.json({ error: "History tidak ditemukan" }, 404);
    }
    return c.json({ success: true, data });
  } catch (error2) {
    console.error("Error in /api/copywriting/history/:id:", error2);
    return c.json({ error: "Gagal mengambil history", message: error2.message }, 500);
  }
});
app.post("/ai-content", async (c) => {
  try {
    const body = await c.req.json();
    const { type, inputText, metadata, userId } = body;
    if (!type || !inputText) {
      return c.json({
        error: "Validation error",
        message: "type dan inputText wajib diisi"
      }, 400);
    }
    const validTypes = ["caption", "promo", "branding", "planner", "copywriting", "pricing", "reply", "comment"];
    if (!validTypes.includes(type)) {
      return c.json({
        error: "Invalid type",
        message: `Type harus salah satu dari: ${validTypes.join(", ")}`
      }, 400);
    }
    const request = {
      type,
      inputText,
      metadata: metadata || {}
    };
    const result = await generateAIContent(request);
    const { data: savedData, error: dbError } = await supabase.from("ai_content_activity").insert([{
      user_id: userId || null,
      type: result.type,
      input_text: result.inputText,
      output_text: result.outputText,
      metadata: result.metadata
    }]).select().single();
    if (dbError) {
      console.error("Error saving to database:", dbError);
      return c.json({
        success: true,
        data: result,
        warning: "Berhasil generate tapi gagal menyimpan ke history"
      });
    }
    return c.json({
      success: true,
      data: {
        id: savedData.id,
        ...result,
        createdAt: savedData.created_at
      }
    });
  } catch (error2) {
    console.error("Error in /api/ai-content:", error2);
    return c.json({
      error: "Gagal generate content",
      message: error2.message
    }, 500);
  }
});
app.get("/ai-content/history", async (c) => {
  try {
    const userId = c.req.query("userId");
    const type = c.req.query("type");
    const limit2 = parseInt(c.req.query("limit") || "50");
    const offset = parseInt(c.req.query("offset") || "0");
    let query = supabase.from("ai_content_activity").select("*").order("created_at", { ascending: false }).range(offset, offset + limit2 - 1);
    if (userId) {
      query = query.eq("user_id", userId);
    }
    if (type) {
      query = query.eq("type", type);
    }
    const { data, error: error2, count } = await query;
    if (error2) {
      console.error("Error fetching history:", error2);
      return c.json({ error: "Gagal mengambil history" }, 500);
    }
    return c.json({
      success: true,
      data: data || [],
      pagination: {
        limit: limit2,
        offset,
        total: count || data?.length || 0
      }
    });
  } catch (error2) {
    console.error("Error in /api/ai-content/history:", error2);
    return c.json({
      error: "Gagal mengambil history",
      message: error2.message
    }, 500);
  }
});
app.get("/ai-content/history/:id", async (c) => {
  try {
    const id = c.req.param("id");
    const { data, error: error2 } = await supabase.from("ai_content_activity").select("*").eq("id", id).single();
    if (error2) {
      return c.json({ error: "History tidak ditemukan" }, 404);
    }
    return c.json({ success: true, data });
  } catch (error2) {
    console.error("Error in /api/ai-content/history/:id:", error2);
    return c.json({
      error: "Gagal mengambil history",
      message: error2.message
    }, 500);
  }
});
app.delete("/ai-content/history/:id", async (c) => {
  try {
    const id = c.req.param("id");
    const { error: error2 } = await supabase.from("ai_content_activity").delete().eq("id", id);
    if (error2) {
      console.error("Error deleting history:", error2);
      return c.json({ error: "Gagal menghapus history" }, 500);
    }
    return c.json({
      success: true,
      message: "History berhasil dihapus"
    });
  } catch (error2) {
    console.error("Error in DELETE /api/ai-content/history/:id:", error2);
    return c.json({
      error: "Gagal menghapus history",
      message: error2.message
    }, 500);
  }
});
app.get("/ai-content/stats", async (c) => {
  try {
    const userId = c.req.query("userId");
    let query = supabase.from("ai_content_activity").select("type, created_at");
    if (userId) {
      query = query.eq("user_id", userId);
    }
    const { data, error: error2 } = await query;
    if (error2) {
      console.error("Error fetching stats:", error2);
      return c.json({ error: "Gagal mengambil statistik" }, 500);
    }
    const stats = {
      total: data?.length || 0,
      byType: {
        caption: 0,
        promo: 0,
        branding: 0,
        planner: 0,
        copywriting: 0,
        pricing: 0,
        reply: 0,
        comment: 0
      },
      recentActivity: data?.slice(0, 10) || []
    };
    data?.forEach((item) => {
      if (item.type in stats.byType) {
        stats.byType[item.type]++;
      }
    });
    return c.json({ success: true, data: stats });
  } catch (error2) {
    console.error("Error in /api/ai-content/stats:", error2);
    return c.json({
      error: "Gagal mengambil statistik",
      message: error2.message
    }, 500);
  }
});
app.post("/visual-studio/generate-umkm-branding", async (c) => {
  try {
    const body = await c.req.json();
    const {
      productImage,
      productName,
      businessType,
      theme,
      brandColor,
      targetMarket,
      format,
      additionalInfo,
      userId
    } = body;
    if (!productName || !businessType || !theme || !brandColor || !targetMarket || !format) {
      return c.json({
        error: "Validation error",
        message: "productName, businessType, theme, brandColor, targetMarket, dan format wajib diisi"
      }, 400);
    }
    const request = {
      productImage,
      productName,
      businessType,
      theme,
      brandColor,
      targetMarket,
      format,
      additionalInfo
    };
    console.log("\uD83C\uDFA8 Processing UMKM Branding request:", {
      productName,
      businessType,
      theme,
      format,
      hasImage: !!productImage
    });
    const result = await generateUMKMBranding(request);
    const { error: dbError } = await supabase.from("visual_studio_activity").insert([{
      user_id: userId || null,
      activity_type: "umkm_branding",
      input_data: {
        productName,
        businessType,
        theme,
        format,
        hasProductImage: !!productImage
      },
      output_data: {
        success: result.success,
        imageAnalysis: result.imageAnalysis,
        processingTime: result.metadata.processingTime
      },
      created_at: new Date().toISOString()
    }]);
    if (dbError) {
      console.warn("Warning: Failed to save to DB:", dbError.message);
    }
    return c.json({
      success: true,
      data: result
    });
  } catch (error2) {
    console.error("Error in /api/visual-studio/generate-umkm-branding:", error2);
    return c.json({
      error: "Gagal generate branding UMKM",
      message: error2.message
    }, 500);
  }
});
app.post("/visual-studio/analyze-image", async (c) => {
  try {
    const body = await c.req.json();
    const { imageUrl, imageBase64, context, userId } = body;
    if (!imageUrl && !imageBase64) {
      return c.json({
        error: "Validation error",
        message: "imageUrl atau imageBase64 wajib diisi"
      }, 400);
    }
    const request = {
      imageUrl,
      imageBase64,
      context: context || "UMKM kuliner Makassar"
    };
    const result = await analyzeImageWithAI(request);
    const { error: dbError } = await supabase.from("visual_studio_activity").insert([{
      user_id: userId || null,
      activity_type: "image_analysis",
      input_data: { imageUrl, context },
      output_data: result,
      created_at: new Date().toISOString()
    }]);
    if (dbError) {
      console.warn("Warning: Failed to save to DB:", dbError.message);
    }
    return c.json({
      success: true,
      data: result
    });
  } catch (error2) {
    console.error("Error in /api/visual-studio/analyze-image:", error2);
    return c.json({
      error: "Gagal menganalisa gambar",
      message: error2.message
    }, 500);
  }
});
app.post("/visual-studio/generate-template", async (c) => {
  try {
    const body = await c.req.json();
    const { imageUrl, imageBase64, templateType, theme, brandColor, targetAudience, userId } = body;
    if (!templateType || !theme || !targetAudience) {
      return c.json({
        error: "Validation error",
        message: "templateType, theme, dan targetAudience wajib diisi"
      }, 400);
    }
    const validTypes = ["promo", "story", "feed", "reels", "carousel"];
    if (!validTypes.includes(templateType)) {
      return c.json({
        error: "Invalid templateType",
        message: `templateType harus salah satu dari: ${validTypes.join(", ")}`
      }, 400);
    }
    const request = {
      imageUrl,
      imageBase64,
      templateType,
      theme,
      brandColor,
      targetAudience
    };
    const result = await generateTemplateDesign(request);
    const { error: dbError } = await supabase.from("visual_studio_activity").insert([{
      user_id: userId || null,
      activity_type: "template_generation",
      input_data: { templateType, theme, targetAudience },
      output_data: result,
      created_at: new Date().toISOString()
    }]);
    if (dbError) {
      console.warn("Warning: Failed to save to DB:", dbError.message);
    }
    return c.json({
      success: true,
      data: result
    });
  } catch (error2) {
    console.error("Error in /api/visual-studio/generate-template:", error2);
    return c.json({
      error: "Gagal generate template",
      message: error2.message
    }, 500);
  }
});
app.post("/visual-studio/remove-background", async (c) => {
  try {
    const body = await c.req.json();
    const { imageBase64, userId } = body;
    if (!imageBase64) {
      return c.json({
        error: "Validation error",
        message: "imageBase64 wajib diisi"
      }, 400);
    }
    const result = await removeBackgroundWithRemoveBg(imageBase64);
    if (!result.success) {
      return c.json({
        error: "Background removal failed",
        message: result.error
      }, 500);
    }
    const { error: dbError } = await supabase.from("visual_studio_activity").insert([{
      user_id: userId || null,
      activity_type: "background_removal",
      input_data: { action: "remove_background" },
      output_data: { success: true },
      created_at: new Date().toISOString()
    }]);
    if (dbError) {
      console.warn("Warning: Failed to save to DB:", dbError.message);
    }
    return c.json({
      success: true,
      data: {
        imageBase64: result.imageBase64
      }
    });
  } catch (error2) {
    console.error("Error in /api/visual-studio/remove-background:", error2);
    return c.json({
      error: "Gagal menghapus background",
      message: error2.message
    }, 500);
  }
});
app.post("/visual-studio/generate-design", async (c) => {
  try {
    const body = await c.req.json();
    const { prompt, style, userId } = body;
    if (!prompt) {
      return c.json({
        error: "Validation error",
        message: "prompt wajib diisi"
      }, 400);
    }
    const result = await generateTemplateWithHuggingFace(prompt, style || "instagram-feed");
    if (!result.success) {
      return c.json({
        error: "Design generation failed",
        message: result.error
      }, 500);
    }
    const { error: dbError } = await supabase.from("visual_studio_activity").insert([{
      user_id: userId || null,
      activity_type: "design_generation",
      input_data: { prompt, style },
      output_data: result,
      created_at: new Date().toISOString()
    }]);
    if (dbError) {
      console.warn("Warning: Failed to save to DB:", dbError.message);
    }
    return c.json({
      success: true,
      data: result
    });
  } catch (error2) {
    console.error("Error in /api/visual-studio/generate-design:", error2);
    return c.json({
      error: "Gagal generate design",
      message: error2.message
    }, 500);
  }
});
app.post("/visual-studio/schedule-planner", async (c) => {
  try {
    const body = await c.req.json();
    const { imageUrl, contentType, targetAudience, businessGoal, duration, userId } = body;
    if (!contentType || !targetAudience || !businessGoal || !duration) {
      return c.json({
        error: "Validation error",
        message: "contentType, targetAudience, businessGoal, dan duration wajib diisi"
      }, 400);
    }
    const validGoals = ["awareness", "engagement", "sales", "traffic"];
    if (!validGoals.includes(businessGoal)) {
      return c.json({
        error: "Invalid businessGoal",
        message: `businessGoal harus salah satu dari: ${validGoals.join(", ")}`
      }, 400);
    }
    const request = {
      imageUrl,
      contentType,
      targetAudience,
      businessGoal,
      duration: parseInt(duration)
    };
    const result = await generateSchedulePlanner(request);
    const { error: dbError } = await supabase.from("visual_studio_activity").insert([{
      user_id: userId || null,
      activity_type: "schedule_planner",
      input_data: { contentType, targetAudience, businessGoal, duration },
      output_data: result,
      created_at: new Date().toISOString()
    }]);
    if (dbError) {
      console.warn("Warning: Failed to save to DB:", dbError.message);
    }
    return c.json({
      success: true,
      data: result
    });
  } catch (error2) {
    console.error("Error in /api/visual-studio/schedule-planner:", error2);
    return c.json({
      error: "Gagal generate schedule",
      message: error2.message
    }, 500);
  }
});
app.get("/visual-studio/history", async (c) => {
  try {
    const userId = c.req.query("userId");
    const activityType = c.req.query("type");
    let query = supabase.from("visual_studio_activity").select("*").order("created_at", { ascending: false });
    if (userId) {
      query = query.eq("user_id", userId);
    }
    if (activityType) {
      query = query.eq("activity_type", activityType);
    }
    const { data, error: error2 } = await query;
    if (error2) {
      throw error2;
    }
    return c.json({ success: true, data });
  } catch (error2) {
    console.error("Error in /api/visual-studio/history:", error2);
    return c.json({
      error: "Gagal mengambil history",
      message: error2.message
    }, 500);
  }
});
app.post("/tanya-daeng/chat", async (c) => {
  try {
    const body = await c.req.json();
    const { message, conversationHistory, userContext, userId } = body;
    if (!message) {
      return c.json({
        error: "Validation error",
        message: "Message wajib diisi"
      }, 400);
    }
    console.log("\uD83D\uDCAC Tanya Daeng request:", { message: message.substring(0, 50), userId });
    const result = await tanyaDaeng({
      message,
      conversationHistory,
      userContext
    });
    if (userId) {
      await supabase.from("tanya_daeng_conversations").insert([{
        user_id: userId,
        message,
        reply: result.reply,
        created_at: new Date().toISOString()
      }]).select();
    }
    return c.json({
      success: true,
      data: result
    });
  } catch (error2) {
    console.error("Error in /api/tanya-daeng/chat:", error2);
    return c.json({
      error: "Gagal memproses chat",
      message: error2.message
    }, 500);
  }
});
app.get("/tanya-daeng/faq", async (c) => {
  try {
    const faqs = getAllFAQ();
    return c.json({
      success: true,
      data: faqs
    });
  } catch (error2) {
    console.error("Error in /api/tanya-daeng/faq:", error2);
    return c.json({
      error: "Gagal mengambil FAQ",
      message: error2.message
    }, 500);
  }
});
app.get("/dapur-umkm/profile", async (c) => {
  try {
    const userId = c.req.header("X-User-ID");
    const { data, error: error2 } = await supabase.from("umkm_profiles").select("*").limit(1).single();
    if (error2 && error2.code !== "PGRST116")
      throw error2;
    return c.json({
      success: true,
      data: data || null
    });
  } catch (error2) {
    console.error("Error fetching profile:", error2);
    return c.json({
      success: false,
      message: error2.message
    }, 500);
  }
});
app.post("/dapur-umkm/profile", async (c) => {
  try {
    const body = await c.req.json();
    const { id, business_name, category, address, phone, email, logo_url, description } = body;
    if (!business_name || !category) {
      return c.json({
        success: false,
        message: "Nama usaha dan kategori wajib diisi"
      }, 400);
    }
    let result;
    if (id) {
      const { data, error: error2 } = await supabase.from("umkm_profiles").update({
        business_name,
        category,
        address,
        phone,
        email,
        logo_url,
        description
      }).eq("id", id).select().single();
      if (error2)
        throw error2;
      result = data;
    } else {
      const { data, error: error2 } = await supabase.from("umkm_profiles").insert({
        business_name,
        category,
        address,
        phone,
        email,
        logo_url,
        description
      }).select().single();
      if (error2)
        throw error2;
      result = data;
    }
    return c.json({
      success: true,
      data: result
    });
  } catch (error2) {
    console.error("Error saving profile:", error2);
    return c.json({
      success: false,
      message: error2.message
    }, 500);
  }
});
app.post("/dapur-umkm/upload-logo", async (c) => {
  try {
    const formData = await c.req.formData();
    const file = formData.get("logo");
    const profileId = formData.get("profile_id");
    if (!file) {
      return c.json({
        success: false,
        message: "File logo wajib diupload"
      }, 400);
    }
    if (!profileId) {
      return c.json({
        success: false,
        message: "Profile ID diperlukan"
      }, 400);
    }
    const allowedTypes = ["image/jpeg", "image/jpg", "image/png", "image/webp", "image/gif"];
    if (!allowedTypes.includes(file.type)) {
      return c.json({
        success: false,
        message: "Format file harus JPEG, PNG, WebP, atau GIF"
      }, 400);
    }
    if (file.size > 5 * 1024 * 1024) {
      return c.json({
        success: false,
        message: "Ukuran file maksimal 5MB"
      }, 400);
    }
    const fileExt = file.name.split(".").pop();
    const fileName = `${profileId}-${Date.now()}.${fileExt}`;
    const filePath = `logos/${fileName}`;
    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);
    const { data: uploadData, error: uploadError } = await supabase.storage.from("umkm-logos").upload(filePath, buffer, {
      contentType: file.type,
      upsert: true
    });
    if (uploadError)
      throw uploadError;
    const { data: { publicUrl } } = supabase.storage.from("umkm-logos").getPublicUrl(filePath);
    const { data: profile, error: updateError } = await supabase.from("umkm_profiles").update({ logo_url: publicUrl }).eq("id", profileId).select().single();
    if (updateError)
      throw updateError;
    return c.json({
      success: true,
      data: {
        logo_url: publicUrl,
        profile
      }
    });
  } catch (error2) {
    console.error("Error uploading logo:", error2);
    return c.json({
      success: false,
      message: error2.message || "Gagal upload logo"
    }, 500);
  }
});
app.get("/dapur-umkm/public/profile", async (c) => {
  try {
    const { data, error: error2 } = await supabase.from("umkm_profiles").select("id, business_name, category, address, logo_url, description").limit(1).single();
    if (error2 && error2.code !== "PGRST116")
      throw error2;
    return c.json({
      success: true,
      data: data || null
    });
  } catch (error2) {
    console.error("Error fetching public profile:", error2);
    return c.json({
      success: false,
      message: error2.message
    }, 500);
  }
});
app.get("/dapur-umkm/products", async (c) => {
  try {
    const profileId = c.req.query("profile_id");
    let query = supabase.from("umkm_products").select("*").order("created_at", { ascending: false });
    if (profileId) {
      query = query.eq("profile_id", profileId);
    }
    const { data, error: error2 } = await query;
    if (error2)
      throw error2;
    return c.json({
      success: true,
      data: data || []
    });
  } catch (error2) {
    console.error("Error fetching products:", error2);
    return c.json({
      success: false,
      message: error2.message
    }, 500);
  }
});
app.post("/dapur-umkm/products", async (c) => {
  try {
    const body = await c.req.json();
    const { profile_id, name, price, stock, image_url, category, description, cost_price } = body;
    if (!name || !price) {
      return c.json({
        success: false,
        message: "Nama dan harga produk wajib diisi"
      }, 400);
    }
    const { data, error: error2 } = await supabase.from("umkm_products").insert({
      profile_id,
      name,
      price,
      stock: stock || 0,
      image_url,
      category,
      description,
      cost_price: cost_price || 0,
      is_available: true
    }).select().single();
    if (error2)
      throw error2;
    return c.json({
      success: true,
      data
    });
  } catch (error2) {
    console.error("Error adding product:", error2);
    return c.json({
      success: false,
      message: error2.message
    }, 500);
  }
});
app.put("/dapur-umkm/products/:id", async (c) => {
  try {
    const id = c.req.param("id");
    const body = await c.req.json();
    const { name, price, stock, image_url, category, description, cost_price, is_available } = body;
    const { data, error: error2 } = await supabase.from("umkm_products").update({
      name,
      price,
      stock,
      image_url,
      category,
      description,
      cost_price,
      is_available
    }).eq("id", id).select().single();
    if (error2)
      throw error2;
    return c.json({
      success: true,
      data
    });
  } catch (error2) {
    console.error("Error updating product:", error2);
    return c.json({
      success: false,
      message: error2.message
    }, 500);
  }
});
app.delete("/dapur-umkm/products/:id", async (c) => {
  try {
    const id = c.req.param("id");
    const { error: error2 } = await supabase.from("umkm_products").delete().eq("id", id);
    if (error2)
      throw error2;
    return c.json({
      success: true,
      message: "Produk berhasil dihapus"
    });
  } catch (error2) {
    console.error("Error deleting product:", error2);
    return c.json({
      success: false,
      message: error2.message
    }, 500);
  }
});
app.get("/dapur-umkm/transactions", async (c) => {
  try {
    const profileId = c.req.query("profile_id");
    const type = c.req.query("type");
    let query = supabase.from("umkm_transactions").select("*").order("transaction_date", { ascending: false }).order("created_at", { ascending: false });
    if (profileId) {
      query = query.eq("profile_id", profileId);
    }
    if (type) {
      query = query.eq("type", type);
    }
    const { data, error: error2 } = await query;
    if (error2)
      throw error2;
    return c.json({
      success: true,
      data: data || []
    });
  } catch (error2) {
    console.error("Error fetching transactions:", error2);
    return c.json({
      success: false,
      message: error2.message
    }, 500);
  }
});
app.post("/dapur-umkm/transactions", async (c) => {
  try {
    const body = await c.req.json();
    const { profile_id, transaction_date, description, amount, type, category, product_id, notes } = body;
    if (!description || !amount || !type) {
      return c.json({
        success: false,
        message: "Keterangan, jumlah, dan jenis transaksi wajib diisi"
      }, 400);
    }
    if (!["in", "out"].includes(type)) {
      return c.json({
        success: false,
        message: 'Jenis transaksi harus "in" atau "out"'
      }, 400);
    }
    const { data, error: error2 } = await supabase.from("umkm_transactions").insert({
      profile_id,
      transaction_date: transaction_date || new Date().toISOString().split("T")[0],
      description,
      amount,
      type,
      category,
      product_id,
      notes
    }).select().single();
    if (error2)
      throw error2;
    return c.json({
      success: true,
      data
    });
  } catch (error2) {
    console.error("Error adding transaction:", error2);
    return c.json({
      success: false,
      message: error2.message
    }, 500);
  }
});
app.get("/dapur-umkm/summary", async (c) => {
  try {
    const profileId = c.req.query("profile_id");
    if (!profileId) {
      return c.json({
        success: false,
        message: "profile_id diperlukan"
      }, 400);
    }
    const metrics = await calculateBusinessMetrics(profileId);
    return c.json({
      success: true,
      data: metrics
    });
  } catch (error2) {
    console.error("Error calculating summary:", error2);
    return c.json({
      success: false,
      message: error2.message
    }, 500);
  }
});
app.post("/dapur-umkm/ai-advice", async (c) => {
  try {
    const body = await c.req.json();
    const { profile_id, insight_type, question } = body;
    if (!profile_id || !insight_type || !question) {
      return c.json({
        success: false,
        message: "profile_id, insight_type, dan question wajib diisi"
      }, 400);
    }
    const validTypes = ["pricing", "inventory", "strategy", "marketing", "finance"];
    if (!validTypes.includes(insight_type)) {
      return c.json({
        success: false,
        message: `insight_type harus salah satu dari: ${validTypes.join(", ")}`
      }, 400);
    }
    const result = await getAIRecommendation({
      profileId: profile_id,
      insightType: insight_type,
      question
    });
    return c.json(result);
  } catch (error2) {
    console.error("Error getting AI advice:", error2);
    return c.json({
      success: false,
      message: error2.message
    }, 500);
  }
});
app.get("/dapur-umkm/quick-insights", async (c) => {
  try {
    return c.json({
      success: true,
      data: QUICK_INSIGHTS
    });
  } catch (error2) {
    console.error("Error fetching quick insights:", error2);
    return c.json({
      success: false,
      message: error2.message
    }, 500);
  }
});
app.get("/dapur-umkm/insights-history", async (c) => {
  try {
    const profileId = c.req.query("profile_id");
    const limit2 = parseInt(c.req.query("limit") || "10");
    if (!profileId) {
      return c.json({
        success: false,
        message: "profile_id diperlukan"
      }, 400);
    }
    const result = await getPastInsights(profileId, limit2);
    return c.json(result);
  } catch (error2) {
    console.error("Error fetching insights history:", error2);
    return c.json({
      success: false,
      message: error2.message
    }, 500);
  }
});
app.post("/dapur-umkm/dashboard-analysis", async (c) => {
  try {
    const body = await c.req.json();
    const { profile_id } = body;
    if (!profile_id) {
      return c.json({
        success: false,
        message: "profile_id diperlukan"
      }, 400);
    }
    const result = await generateDashboardAnalysis(profile_id);
    return c.json(result);
  } catch (error2) {
    console.error("Error generating dashboard analysis:", error2);
    return c.json({
      success: false,
      message: error2.message || "Gagal generate analisis dashboard",
      error: error2.toString()
    }, 500);
  }
});
app.get("/dapur-umkm/dashboard-overview", async (c) => {
  try {
    const profileId = c.req.query("profile_id");
    if (!profileId) {
      return c.json({
        success: false,
        message: "profile_id diperlukan"
      }, 400);
    }
    const [profile, products, transactions, insights, summary] = await Promise.all([
      supabase.from("umkm_profiles").select("*").eq("id", profileId).single(),
      supabase.from("umkm_products").select("*").eq("profile_id", profileId),
      supabase.from("umkm_transactions").select("*").eq("profile_id", profileId).order("transaction_date", { ascending: false }).limit(50),
      supabase.from("umkm_ai_insights").select("*").eq("profile_id", profileId).order("created_at", { ascending: false }).limit(10),
      supabase.from("umkm_financial_summary").select("*").eq("profile_id", profileId).single()
    ]);
    const metrics = await calculateBusinessMetrics(profileId);
    return c.json({
      success: true,
      data: {
        profile: profile.data,
        products: products.data || [],
        transactions: transactions.data || [],
        insights: insights.data || [],
        summary: summary.data,
        metrics
      }
    });
  } catch (error2) {
    console.error("Error fetching dashboard overview:", error2);
    return c.json({
      success: false,
      message: error2.message
    }, 500);
  }
});
app.get("/dapur-umkm/report", async (c) => {
  try {
    const profileId = c.req.query("profile_id");
    const month = parseInt(c.req.query("month") || "0");
    const year = parseInt(c.req.query("year") || new Date().getFullYear().toString());
    if (!profileId) {
      return c.json({
        success: false,
        message: "profile_id diperlukan"
      }, 400);
    }
    if (month < 1 || month > 12) {
      return c.json({
        success: false,
        message: "month harus antara 1-12"
      }, 400);
    }
    const startDate = new Date(year, month - 1, 1);
    const endDate = new Date(year, month, 0, 23, 59, 59);
    console.log("Fetching report for:", { profileId, startDate, endDate });
    const { data: transactions, error: error2 } = await supabase.from("umkm_transactions").select("*").eq("profile_id", profileId).gte("transaction_date", startDate.toISOString()).lte("transaction_date", endDate.toISOString()).order("transaction_date", { ascending: false });
    if (error2) {
      console.error("Supabase error:", error2);
      throw error2;
    }
    const totalIncome = transactions?.filter((t) => t.type === "in").reduce((sum, t) => sum + Number(t.amount), 0) || 0;
    const totalExpense = transactions?.filter((t) => t.type === "out").reduce((sum, t) => sum + Number(t.amount), 0) || 0;
    const balance = totalIncome - totalExpense;
    const monthNames = [
      "Januari",
      "Februari",
      "Maret",
      "April",
      "Mei",
      "Juni",
      "Juli",
      "Agustus",
      "September",
      "Oktober",
      "November",
      "Desember"
    ];
    return c.json({
      success: true,
      data: {
        month: monthNames[month - 1],
        year,
        totalIncome,
        totalExpense,
        balance,
        transactionCount: transactions?.length || 0,
        transactions: transactions || []
      }
    });
  } catch (error2) {
    console.error("Error fetching monthly report:", error2);
    return c.json({
      success: false,
      message: error2.message || "Gagal mengambil laporan bulanan"
    }, 500);
  }
});
app.get("/evaluations", async (c) => {
  try {
    const profileId = c.req.query("profile_id");
    const status = c.req.query("status");
    let query = supabase.from("umkm_evaluations").select("*").order("created_at", { ascending: false });
    if (profileId) {
      query = query.eq("profile_id", profileId);
    }
    if (status) {
      query = query.eq("status", status);
    }
    const { data, error: error2 } = await query;
    if (error2)
      throw error2;
    return c.json({
      success: true,
      data: data || []
    });
  } catch (error2) {
    console.error("Error fetching evaluations:", error2);
    return c.json({
      success: false,
      message: error2.message
    }, 500);
  }
});
app.put("/evaluations/:id/read", async (c) => {
  try {
    const id = c.req.param("id");
    const { data, error: error2 } = await supabase.from("umkm_evaluations").update({
      status: "read",
      read_at: new Date().toISOString()
    }).eq("id", id).select().single();
    if (error2)
      throw error2;
    return c.json({
      success: true,
      data
    });
  } catch (error2) {
    console.error("Error marking evaluation as read:", error2);
    return c.json({
      success: false,
      message: error2.message
    }, 500);
  }
});
app.put("/evaluations/:id/notes", async (c) => {
  try {
    const id = c.req.param("id");
    const body = await c.req.json();
    const { notes } = body;
    const { data, error: error2 } = await supabase.from("umkm_evaluations").update({ admin_notes: notes }).eq("id", id).select().single();
    if (error2)
      throw error2;
    return c.json({
      success: true,
      data
    });
  } catch (error2) {
    console.error("Error adding notes:", error2);
    return c.json({
      success: false,
      message: error2.message
    }, 500);
  }
});
app.delete("/evaluations/:id", async (c) => {
  try {
    const id = c.req.param("id");
    const { error: error2 } = await supabase.from("umkm_evaluations").delete().eq("id", id);
    if (error2)
      throw error2;
    return c.json({
      success: true,
      message: "Evaluation deleted successfully"
    });
  } catch (error2) {
    console.error("Error deleting evaluation:", error2);
    return c.json({
      success: false,
      message: error2.message
    }, 500);
  }
});
app.post("/telegram/webhook", async (c) => {
  try {
    const update = await c.req.json();
    await handleTelegramWebhook(update);
    return c.json({ ok: true });
  } catch (error2) {
    console.error("Telegram webhook error:", error2);
    return c.json({ ok: false, error: error2.message }, 500);
  }
});
app.get("/telegram/info", async (c) => {
  const TELEGRAM_BOT_TOKEN2 = process.env.TELEGRAM_BOT_TOKEN;
  if (!TELEGRAM_BOT_TOKEN2) {
    return c.json({ error: "Bot token not configured" }, 500);
  }
  try {
    const response = await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN2}/getWebhookInfo`);
    const data = await response.json();
    return c.json(data);
  } catch (error2) {
    return c.json({ error: error2.message }, 500);
  }
});
var isVercel = !!process.env.VERCEL || false;
if (process.env.TELEGRAM_BOT_TOKEN && !isVercel) {
  console.log("\uD83E\uDD16 Initializing Telegram Bot in polling mode (development)...");
  initTelegramBot();
} else if (isVercel) {
  console.log("\uD83E\uDD16 Telegram Bot using webhook mode (production)");
  console.log("   Webhook endpoint: /telegram/webhook");
} else {
  console.warn(" TELEGRAM_BOT_TOKEN not set. Bot features disabled.");
}
var src_default = app;
